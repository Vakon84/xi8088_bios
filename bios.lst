     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 - 2014 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.07, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
   108                                  %include "config.inc"
   109                              <1> ;=========================================================================
   110                              <1> ; config.inc - Compilation time settings and settings
   111                              <1> ;-------------------------------------------------------------------------
   112                              <1> ;
   113                              <1> ; Compiles with NASM 2.07, might work with other versions
   114                              <1> ;
   115                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   116                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   117                              <1> ;
   118                              <1> ; This program is free software: you can redistribute it and/or modify
   119                              <1> ; it under the terms of the GNU General Public License as published by
   120                              <1> ; the Free Software Foundation, either version 3 of the License, or
   121                              <1> ; (at your option) any later version.
   122                              <1> ;
   123                              <1> ; This program is distributed in the hope that it will be useful,
   124                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   125                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   126                              <1> ; GNU General Public License for more details.
   127                              <1> ;
   128                              <1> ; You should have received a copy of the GNU General Public License
   129                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   130                              <1> ;
   131                              <1> ;=========================================================================
   132                              <1> 
   133                              <1> %define DATE		'05/28/14'	; BIOS release date MM/DD/YY
   134                              <1> %define VERSION		'0.9.0'		; BIOS version
   135                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   136                              <1> 
   137                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
   138                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   139                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   140                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   141                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   142                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   143                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   144                              <1> 					; EBDA is required for PS/2 aux support
   145                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   146                                  %include "errno.inc"
   147                              <1> ;=========================================================================
   148                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> ;
   151                              <1> ; Compiles with NASM 2.07, might work with other versions
   152                              <1> ;
   153                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   154                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   155                              <1> ;
   156                              <1> ; This program is free software: you can redistribute it and/or modify
   157                              <1> ; it under the terms of the GNU General Public License as published by
   158                              <1> ; the Free Software Foundation, either version 3 of the License, or
   159                              <1> ; (at your option) any later version.
   160                              <1> ;
   161                              <1> ; This program is distributed in the hope that it will be useful,
   162                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   163                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   164                              <1> ; GNU General Public License for more details.
   165                              <1> ;
   166                              <1> ; You should have received a copy of the GNU General Public License
   167                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   168                              <1> ;
   169                              <1> ;=========================================================================
   170                              <1> 
   171                              <1> e_boot		equ	00h		; Boot the OS
   172                              <1> e_start		equ	01h		; BIOS POST started
   173                              <1> e_cpu_ok	equ	02h		; CPU test passed
   174                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   175                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   176                              <1> e_int_ok	equ	05h		; interrupt table initialized
   177                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   178                              <1> e_pic_ok	equ	08h		; PIC initialized
   179                              <1> e_kbd_ok	equ	10h		; KBD test passed
   180                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   181                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   182                              <1> e_rtc_init_ok	equ	20h		; RTC initialized
   183                              <1> e_cpu_detect_ok	equ	21h		; CPU type detected
   184                              <1> e_fpu_detect_ok	equ	22h		; FPU type detected
   185                              <1> e_serial_ok	equ	24h		; Serial port scan finished
   186                              <1> e_parallel_ok	equ	25h		; Parallel port scan finished
   187                              <1> e_ram_start	equ	30h		; RAM test start
   188                              <1> e_ram_complete	equ	31h		; RAM test completed
   189                              <1> e_ram_esc	equ	32h		; RAM test canceled
   190                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   191                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found
   192                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   193                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   194                              <1> e_cpu_fail	equ	52h		; CPU test failed
   195                              <1> e_low_ram_fail	equ	54h		; low RAM test failed
   196                              <1> e_kbd_ctrl_fail	equ	60h		; KBD test - controller selftest failed
   197                              <1> e_kbd_key_fail	equ	61h		; KBD test - echo test failed
   198                              <1> e_kbd_timeout	equ	62h		; KBD timeout
   199                              <1> e_kbd_int_fail	equ	63h		; KBD test - interface test failed
   200                              <1> e_ram_fail	equ	80h		; RAM test failed
   201                                  
   202                                  bioscseg	equ	0F000h
   203                                  biosdseg	equ	0040h
   204                                  
   205                                  pic1_reg0	equ	20h
   206                                  pic1_reg1	equ	21h
   207                                  pit_ch0_reg	equ	40h
   208                                  pit_ch1_reg	equ	41h
   209                                  pit_ch2_reg	equ	42h
   210                                  pit_ctl_reg	equ	43h
   211                                  port_b_reg	equ	61h
   212                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   213                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   214                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   215                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   216                                  post_reg	equ	80h	; POST status output port
   217                                  pic2_reg0	equ	0A0h
   218                                  pic2_reg1	equ	0A1h
   219                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   220                                  cga_mode_reg	equ	3D8h
   221                                  mda_mode_reg	equ	3B8h
   222                                  
   223                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   224                                  
   225                                  ;========================================================================
   226                                  ; BIOS data area variables
   227                                  ;------------------------------------------------------------------------
   228                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   229                                  				; or 0 if port doesn't exist
   230                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   231                                  				; or 0 if port doesn't exist
   232                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   233                                  equipment_list	equ	10h	; word - equpment list
   234                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   235                                  equip_fpu	equ	0000000000000010b	; FPU installed
   236                                  equip_mouse	equ	0000000000000100b
   237                                  equip_video	equ	0000000000110000b	; video type bit mask
   238                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   239                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   240                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   241                                  ;			|||||||||||||||`-- floppy drives installed
   242                                  ;			||||||||||||||`-- FPU installed
   243                                  ;			|||||||||||||`-- PS/2 mouse installed
   244                                  ;			||||||||||||`-- reserved
   245                                  ;			||||||||||`--- initial video mode
   246                                  ;			||||||||`---- number of floppy drives - 1
   247                                  ;			|||||||`---- O = DMA installed
   248                                  ;			||||`------ number of serial ports
   249                                  ;			|||`------ game adapter installed
   250                                  ;			||`------ internal modem?!
   251                                  ;			`------- number of parallel ports
   252                                  
   253                                  post_flags	equ	12h	; byte - post flags
   254                                  post_setup	equ	01h	; run NVRAM setup
   255                                  memory_size	equ	13h	; word - memory size in KiB
   256                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   257                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   258                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   259                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   260                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   261                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   262                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   263                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   264                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   265                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   266                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   267                                  video_mode	equ	49h	; byte - active video mode number
   268                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   269                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   270                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   271                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   272                                  video_cur_shape	equ	60h	; word - cursor shape
   273                                  video_page	equ	62h	; byte - active video page
   274                                  video_port	equ	63h	; word - I/O port for the display adapter
   275                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   276                                  video_palet_reg	equ	66h	; byte - color palette
   277                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   278                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   279                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   280                                  new_day		equ	70h	; byte - 1 = new day flag
   281                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   282                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   283                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   284                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   285                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   286                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   287                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   288                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   289                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   290                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   291                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   292                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   293                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   294                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   295                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   296                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   297                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   298                                  
   299                                  ;=========================================================================
   300                                  ; Extended BIOS data area variables
   301                                  ;-------------------------------------------------------------------------
   302                                  ebda_size	equ	0h
   303                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   304                                  mouse_flags_1	equ	26h
   305                                  mouse_flags_2	equ	27h
   306                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   307                                  
   308                                  	org	START		; Use only upper 32 KiB of ROM
   309                                  
   310                                  ;=========================================================================
   311                                  ; Includes
   312                                  ;-------------------------------------------------------------------------
   313                                  %include	"messages.inc"		; POST messages
   314                              <1> ;=========================================================================
   315                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> ;
   318                              <1> ; Compiles with NASM 2.07, might work with other versions
   319                              <1> ;
   320                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   321                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   322                              <1> ;
   323                              <1> ; This program is free software: you can redistribute it and/or modify
   324                              <1> ; it under the terms of the GNU General Public License as published by
   325                              <1> ; the Free Software Foundation, either version 3 of the License, or
   326                              <1> ; (at your option) any later version.
   327                              <1> ;
   328                              <1> ; This program is distributed in the hope that it will be useful,
   329                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   330                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   331                              <1> ; GNU General Public License for more details.
   332                              <1> ;
   333                              <1> ; You should have received a copy of the GNU General Public License
   334                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   335                              <1> ;
   336                              <1> ;=========================================================================
   337                              <1> 
   338 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   339 00000002 586920383038382042- <1> 		db	"Xi 8088 BIOS, Version "
   340 0000000B 494F532C2056657273- <1>
   341 00000014 696F6E20            <1>
   342 00000018 302E392E30          <1> 		db	VERSION
   343 0000001D 2E20                <1> 		db	". "
   344 0000001F 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2014 Sergey Kiselev", 0Dh, 0Ah
   345 00000028 202843292032303130- <1>
   346 00000031 202D20323031342053- <1>
   347 0000003A 6572676579204B6973- <1>
   348 00000043 656C65760D0A        <1>
   349 00000049 446973747269627574- <1> 		db	"Distributed under the terms of "
   350 00000052 656420756E64657220- <1>
   351 0000005B 746865207465726D73- <1>
   352 00000064 206F6620            <1>
   353 00000068 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   354 00000071 656E6572616C205075- <1>
   355 0000007A 626C6963204C696365- <1>
   356 00000083 6E73650D0A          <1>
   357 00000088 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   358 0000008B 6E6F6E6500          <1> msg_none	db	'none', 00h
   359 00000090 3A2000              <1> msg_colon	db	': ', 00h
   360 00000093 3B2000              <1> msg_semicolon	db	'; ', 00h
   361 00000096 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   362 0000009F 6573736F723A202020- <1>
   363 000000A8 202020202020202020- <1>
   364 000000B1 2000                <1>
   365 000000B3 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   366 000000BC 637320436F2D70726F- <1>
   367 000000C5 636573736F723A2020- <1>
   368 000000CE 2000                <1>
   369 000000D0 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 0Dh, 0Ah
   370 000000D9 38202737380D0A      <1>
   371 000000E0 5741524E494E473A20- <1> 		db      'WARNING: This CPU does not disable interrupts '
   372 000000E9 546869732043505520- <1>
   373 000000F2 646F6573206E6F7420- <1>
   374 000000FB 64697361626C652069- <1>
   375 00000104 6E7465727275707473- <1>
   376 0000010D 20                  <1>
   377 0000010E 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   378 00000117 64696E67207365676D- <1>
   379 00000120 656E74207265676973- <1>
   380 00000129 74657273210D0A00    <1>
   381 00000131 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   382 0000013A 3820273831206F7220- <1>
   383 00000143 6C617465722C20      <1>
   384 0000014A 6F72204F4B492D6465- <1> 		db      'or OKI-designed 80C88', 0Dh, 0Ah, 00h
   385 00000153 7369676E6564203830- <1>
   386 0000015C 4338380D0A00        <1>
   387 00000162 4861727269732D6465- <1> msg_cpu_harris  db      'Harris-designed 80C88', 0Dh, 0Ah, 00h
   388 0000016B 7369676E6564203830- <1>
   389 00000174 4338380D0A00        <1>
   390 0000017A 4E4543205632300D0A- <1> msg_cpu_nec_v20 db      'NEC V20', 0Dh, 0Ah, 00h
   391 00000183 00                  <1>
   392 00000184 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   393 0000018D 370D0A00            <1>
   394 00000191 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   395 0000019A 646170746572205479- <1>
   396 000001A3 70653A202020202020- <1>
   397 000001AC 2000                <1>
   398 000001AE 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   399 000001B7 566964656F2042494F- <1>
   400 000001C0 532050726573656E74- <1>
   401 000001C9 290D0A00            <1>
   402 000001CD 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   403 000001D3 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   404 000001DC 7263756C65730D0A00  <1>
   405 000001E5 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock) time: ', 00h
   406 000001EE 2054696D6520436C6F- <1>
   407 000001F7 636B292074696D653A- <1>
   408 00000200 2000                <1>
   409 00000202 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   410 0000020B 736B20647269766573- <1>
   411 00000214 3A2020202020202020- <1>
   412 0000021D 20447269766520303A- <1>
   413 00000226 2000                <1>
   414 00000228 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   415 00000231 3A2000              <1>
   416 00000234 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   417 0000023D 2E32352200          <1>
   418 00000242 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   419 0000024B 2E32352200          <1>
   420 00000250 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   421 00000259 2E352200            <1>
   422 0000025D 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   423 00000266 332E352200          <1>
   424 0000026B 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   425 00000274 332E352200          <1>
   426 00000279 50532F322041757820- <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   427 00000282 44657669636520284D- <1>
   428 0000028B 6F757365293A202020- <1>
   429 00000294 2000                <1>
   430 00000296 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   431 0000029F 00                  <1>
   432 000002A0 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   433 000002A9 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   434 000002B2 7274733A2020202020- <1>
   435 000002BB 202020202020202020- <1>
   436 000002C4 2000                <1>
   437 000002C6 434F4D00            <1> msg_serial_com	db	'COM', 00h
   438 000002CA 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   439 000002D3 506F7274733A202020- <1>
   440 000002DC 202020202020202020- <1>
   441 000002E5 2000                <1>
   442 000002E7 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   443 000002EB 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   444 000002F4 414D20284553432074- <1>
   445 000002FD 6F20736B6970293A20- <1>
   446 00000306 2000                <1>
   447 00000308 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   448 00000311 4661756C7479206D65- <1>
   449 0000031A 6D6F72792064657465- <1>
   450 00000323 637465642061742000  <1>
   451 0000032C 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   452 00000335 6E76656E74696F6E61- <1>
   453 0000033E 6C2052414D3A202020- <1>
   454 00000347 202000              <1>
   455 0000034A 526573657276656420- <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   456 00000353 666F7220454244413A- <1>
   457 0000035C 202020202020202020- <1>
   458 00000365 2000                <1>
   459 00000367 417661696C61626C65- <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   460 00000370 20436F6E76656E7469- <1>
   461 00000379 6F6E616C2052414D3A- <1>
   462 00000382 2000                <1>
   463 00000384 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   464 0000038B 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   465 00000394 65642C207072657373- <1>
   466 0000039D 20616E79206B657920- <1>
   467 000003A6 746F20747279206167- <1>
   468 000003AF 61696E2E2E2E0D0A00  <1>
   469 000003B8 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   470 000003C1 5349430D0A00        <1>
   471 000003C7 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   472 000003D0 5320657874656E7369- <1>
   473 000003D9 6F6E20524F4D206174- <1>
   474 000003E2 2000                <1>
   475 000003E4 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   476 000003ED 6C697A696E672E2E2E- <1>
   477 000003F6 0D0A00              <1>
   478 000003F9 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   479 00000402 532E2E2E0D0A00      <1>
   480 00000409 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   481 00000412 432062617474657279- <1>
   482 0000041B 206973206261640D0A- <1>
   483 00000424 00                  <1>
   484 00000425 4552524F523A204E56- <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   485 0000042E 52414D20636865636B- <1>
   486 00000437 73756D20697320696E- <1>
   487 00000440 76616C69642C20      <1>
   488 00000447 6C6F6164696E672064- <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   489 00000450 656661756C74207661- <1>
   490 00000459 6C75657320746F204E- <1>
   491 00000462 5652414D0D0A00      <1>
   492 00000469 507265737320463120- <1> msg_setup	db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   493 00000472 746F2072756E204E56- <1>
   494 0000047B 52414D207365747570- <1>
   495 00000484 2E2E2E0D0A0D0A00    <1>
   496 0000048C 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the NVRAM setup utility', 00h
   497 00000495 20746F20746865204E- <1>
   498 0000049E 5652414D2073657475- <1>
   499 000004A7 70207574696C697479- <1>
   500 000004B0 00                  <1>
   501 000004B1 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   502 000004B3 4E5652414D20736574- <1> 		db	'NVRAM setup commands:', 0Dh, 0Ah
   503 000004BC 757020636F6D6D616E- <1>
   504 000004C5 64733A0D0A          <1>
   505 000004CA 74202D205365742074- <1> 		db	't - Set time', 0Dh, 0Ah
   506 000004D3 696D650D0A          <1>
   507 000004D8 64202D205365742064- <1> 		db	'd - Set date', 0Dh, 0Ah
   508 000004E1 6174650D0A          <1>
   509 000004E6 66202D204368616E67- <1> 		db	'f - Change first floppy drive type', 0Dh, 0Ah
   510 000004EF 652066697273742066- <1>
   511 000004F8 6C6F70707920647269- <1>
   512 00000501 766520747970650D0A  <1>
   513 0000050A 67202D204368616E67- <1> 		db	'g - Change second floppy drive type', 0Dh, 0Ah
   514 00000513 65207365636F6E6420- <1>
   515 0000051C 666C6F707079206472- <1>
   516 00000525 69766520747970650D- <1>
   517 0000052E 0A                  <1>
   518 0000052F 70202D205072696E74- <1> 		db	'p - Print current settings', 0Dh, 0Ah
   519 00000538 2063757272656E7420- <1>
   520 00000541 73657474696E67730D- <1>
   521 0000054A 0A                  <1>
   522 0000054B 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   523 00000554 6368616E6765732061- <1>
   524 0000055D 6E6420657869740D0A  <1>
   525 00000566 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   526 0000056F 776974686F75742073- <1>
   527 00000578 6176696E6720636861- <1>
   528 00000581 6E6765730D0A        <1>
   529 00000587 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   530 00000590 746869732068656C70- <1>
   531 00000599 0D0A00              <1>
   532 0000059C 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   533 000005A5 6F6D6D616E64202868- <1>
   534 000005AE 20666F722068656C70- <1>
   535 000005B7 293A2000            <1>
   536 000005BB 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   537 000005C4 65202868683A6D6D3A- <1>
   538 000005CD 7373293A2000        <1>
   539 000005D3 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   540 000005DC 652028595959592D4D- <1>
   541 000005E5 4D2D4444293A2000    <1>
   542 000005ED 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   543 000005F6 76616C69642074696D- <1>
   544 000005FF 652E0D0A00          <1>
   545 00000604 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   546 0000060D 76616C696420646174- <1>
   547 00000616 652E0D0A00          <1>
   548 0000061B 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   549 0000061D 466C6F707079206472- <1> 		db	'Floppy drive types:', 0Dh, 0Ah
   550 00000626 697665207479706573- <1>
   551 0000062F 3A0D0A              <1>
   552 00000632 30202D204E6F742069- <1> 		db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   553 0000063B 6E7374616C6C656420- <1>
   554 00000644 202033202D20373230- <1>
   555 0000064D 204B422C20332E3522- <1>
   556 00000656 0D0A                <1>
   557 00000658 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   558 00000661 422C20352E32352220- <1>
   559 0000066A 202034202D20312E34- <1>
   560 00000673 34204D422C20332E35- <1>
   561 0000067C 220D0A              <1>
   562 0000067F 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   563 00000688 422C20352E32352220- <1>
   564 00000691 202036202D20322E38- <1>
   565 0000069A 38204D422C20332E35- <1>
   566 000006A3 220D0A              <1>
   567 000006A6 536574757020636F6D- <1> 		db	'Setup commands:', 0Dh, 0Ah
   568 000006AF 6D616E64733A0D0A    <1>
   569 000006B7 72202D205265747572- <1> 		db	'r - Return to the main menu', 0Dh, 0Ah
   570 000006C0 6E20746F2074686520- <1>
   571 000006C9 6D61696E206D656E75- <1>
   572 000006D2 0D0A                <1>
   573 000006D4 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   574 000006DD 746869732068656C70- <1>
   575 000006E6 0D0A00              <1>
   576 000006E9 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   577 000006F2 6C6F70707920647269- <1>
   578 000006FB 766520747970652028- <1>
   579 00000704 6820666F722068656C- <1>
   580 0000070D 70293A20            <1>
   581 00000711 00                  <1> 		db	00h
   582 00000712 [8B00]              <1> tbl_floppy	dw	msg_none
   583 00000714 [3402]              <1> 		dw	msg_floppy_360
   584 00000716 [4202]              <1> 		dw	msg_floppy_1200
   585 00000718 [5002]              <1> 		dw	msg_floppy_720
   586 0000071A [5D02]              <1> 		dw	msg_floppy_1440
   587 0000071C [8B00]              <1> 		dw	msg_none
   588 0000071E [6B02]              <1> 		dw	msg_floppy_2880
   589 00000720 [8B00]              <1> 		dw	msg_none
   590                                  %include	"fnt80-FF.inc"		; font for graphics modes
   591                              <1> ;=========================================================================
   592                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   593                              <1> ;       Characters from 80h to 0FFh
   594                              <1> ;-------------------------------------------------------------------------
   595                              <1> ;
   596                              <1> ; Compiles with NASM 2.07, might work with other versions
   597                              <1> ;
   598                              <1> ; This font is borrowed from kbd package (alt-8x8)
   599                              <1> ;
   600                              <1> ; This program is free software: you can redistribute it and/or modify
   601                              <1> ; it under the terms of the GNU General Public License as published by
   602                              <1> ; the Free Software Foundation, either version 3 of the License, or
   603                              <1> ; (at your option) any later version.
   604                              <1> ;
   605                              <1> ; This program is distributed in the hope that it will be useful,
   606                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   607                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   608                              <1> ; GNU General Public License for more details.
   609                              <1> ;
   610                              <1> ; You should have received a copy of the GNU General Public License
   611                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   612                              <1> ;
   613                              <1> ;=========================================================================
   614                              <1> int_1F:
   615 00000722 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   616 0000072A 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   617 00000732 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   618 0000073A 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   619 00000742 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   620 0000074A 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   621 00000752 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   622 0000075A 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   623 00000762 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   624 0000076A 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   625 00000772 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   626 0000077A 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   627 00000782 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   628 0000078A 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   629 00000792 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   630 0000079A 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   631 000007A2 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   632 000007AA 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   633 000007B2 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   634 000007BA 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   635 000007C2 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   636 000007CA 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   637 000007D2 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   638 000007DA 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   639 000007E2 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   640 000007EA DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   641 000007F2 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   642 000007FA C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   643 00000802 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   644 0000080A 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   645 00000812 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   646 0000081A 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   647 00000822 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   648 0000082A 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   649 00000832 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   650 0000083A 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   651 00000842 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   652 0000084A 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   653 00000852 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   654 0000085A 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   655 00000862 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   656 0000086A 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   657 00000872 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   658 0000087A 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   659 00000882 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   660 0000088A 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   661 00000892 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   662 0000089A 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   663 000008A2 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   664 000008AA 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   665 000008B2 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   666 000008BA 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   667 000008C2 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   668 000008CA 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   669 000008D2 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   670 000008DA 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   671 000008E2 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   672 000008EA 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   673 000008F2 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   674 000008FA 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   675 00000902 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   676 0000090A 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   677 00000912 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   678 0000091A 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   679 00000922 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   680 0000092A 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   681 00000932 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   682 0000093A 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   683 00000942 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   684 0000094A 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   685 00000952 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   686 0000095A 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   687 00000962 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   688 0000096A 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   689 00000972 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   690 0000097A 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   691 00000982 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   692 0000098A 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   693 00000992 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   694 0000099A 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   695 000009A2 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   696 000009AA 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   697 000009B2 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   698 000009BA 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   699 000009C2 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   700 000009CA 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   701 000009D2 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   702 000009DA 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   703 000009E2 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   704 000009EA 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   705 000009F2 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   706 000009FA FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   707 00000A02 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   708 00000A0A F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   709 00000A12 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   710 00000A1A FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   711 00000A22 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   712 00000A2A 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   713 00000A32 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   714 00000A3A 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   715 00000A42 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   716 00000A4A 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   717 00000A52 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   718 00000A5A 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   719 00000A62 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   720 00000A6A 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   721 00000A72 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   722 00000A7A 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   723 00000A82 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   724 00000A8A 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   725 00000A92 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   726 00000A9A 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   727 00000AA2 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   728 00000AAA 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   729 00000AB2 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   730 00000ABA 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   731 00000AC2 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   732 00000ACA 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   733 00000AD2 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   734 00000ADA 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   735 00000AE2 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   736 00000AEA 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   737 00000AF2 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   738 00000AFA 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   739 00000B02 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   740 00000B0A 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   741 00000B12 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   742 00000B1A 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   743                                  ;%include	"inttrace.inc"		; XXX
   744                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   745                              <1> ;=========================================================================
   746                              <1> ; rtc.inc - RTC/CMOS read and write functions
   747                              <1> ;-------------------------------------------------------------------------
   748                              <1> ;
   749                              <1> ; Compiles with NASM 2.07, might work with other versions
   750                              <1> ;
   751                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   752                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   753                              <1> ;
   754                              <1> ; This program is free software: you can redistribute it and/or modify
   755                              <1> ; it under the terms of the GNU General Public License as published by
   756                              <1> ; the Free Software Foundation, either version 3 of the License, or
   757                              <1> ; (at your option) any later version.
   758                              <1> ;
   759                              <1> ; This program is distributed in the hope that it will be useful,
   760                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   761                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   762                              <1> ; GNU General Public License for more details.
   763                              <1> ;
   764                              <1> ; You should have received a copy of the GNU General Public License
   765                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   766                              <1> ;
   767                              <1> ;=========================================================================
   768                              <1> 
   769                              <1> ;-------------------------------------------------------------------------
   770                              <1> ; RTC ports
   771                              <1> rtc_addr_reg	equ	70h	; RTC address port
   772                              <1> rtc_data_reg	equ	71h	; RTC data port
   773                              <1> 
   774                              <1> ;-------------------------------------------------------------------------
   775                              <1> ; locations in RTC and NVRAM
   776                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   777                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   778                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   779                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   780                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   781                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   782                              <1> cmos_day	equ	06h	; day location in RTC
   783                              <1> cmos_date	equ	07h	; date location in RTC
   784                              <1> cmos_month	equ	08h	; month location in RTC
   785                              <1> cmos_year	equ	09h	; year location in RTC
   786                              <1> cmos_floppy	equ	10h	; floppy type byte
   787                              <1> cmos_equip	equ	14h	; equipment byte
   788                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   789                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   790                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   791                              <1> 
   792                              <1> ;-------------------------------------------------------------------------
   793                              <1> ; RTC control register and their bits
   794                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   795                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   796                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   797                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   798                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   799                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   800                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   801                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   802                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   803                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   804                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   805                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   806                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   807                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   808                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   809                              <1> 
   810                              <1> ;-------------------------------------------------------------------------
   811                              <1> ; NMI flag
   812                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   813                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   814                              <1> 
   815                              <1> ;=========================================================================
   816                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   817                              <1> ; Input:
   818                              <1> ;	AL - address and NMI enable bit
   819                              <1> ;		bits 6-0 - address of byte to read
   820                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   821                              <1> ; Output:
   822                              <1> ;	AL = byte from RTC
   823                              <1> ;-------------------------------------------------------------------------
   824                              <1> rtc_read:
   825 00000B22 FA                  <1> 	cli
   826 00000B23 E670                <1> 	out	rtc_addr_reg,al
   827 00000B25 EB00                <1> 	jmp	$+2
   828 00000B27 EB00                <1> 	jmp	$+2
   829 00000B29 E471                <1> 	in	al,rtc_data_reg
   830 00000B2B FB                  <1> 	sti
   831 00000B2C C3                  <1> 	ret
   832                              <1> 
   833                              <1> ;=========================================================================
   834                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   835                              <1> ; Input:
   836                              <1> ;	AL - address and NMI enable bit
   837                              <1> ;		bits 6-0 - address of byte to read
   838                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   839                              <1> ;	AH = byte to write to RTC
   840                              <1> ;-------------------------------------------------------------------------
   841                              <1> rtc_write:
   842 00000B2D FA                  <1> 	cli
   843 00000B2E E670                <1> 	out	rtc_addr_reg,al
   844 00000B30 EB00                <1> 	jmp	$+2
   845 00000B32 EB00                <1> 	jmp	$+2
   846 00000B34 86E0                <1> 	xchg	ah,al
   847 00000B36 E671                <1> 	out	rtc_data_reg,al
   848 00000B38 86E0                <1> 	xchg	ah,al
   849 00000B3A FB                  <1> 	sti
   850 00000B3B C3                  <1> 	ret
   851                              <1> 
   852                              <1> ;=========================================================================
   853                              <1> ; rtc_init - Initialize RTC
   854                              <1> ; Notes:
   855                              <1> ;	- makes sure RTC battery is OK, resets time if not
   856                              <1> ;	- disables RTC interrupts
   857                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   858                              <1> ;-------------------------------------------------------------------------
   859                              <1> rtc_init:
   860 00000B3C 50                  <1> 	push	ax
   861 00000B3D 53                  <1> 	push	bx
   862 00000B3E 51                  <1> 	push	cx
   863 00000B3F 52                  <1> 	push	dx
   864 00000B40 56                  <1> 	push	si
   865 00000B41 57                  <1> 	push	di
   866 00000B42 B00A                <1> 	mov	al,cmos_control_a	; select control A register
   867 00000B44 B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   868                              <1> 					; set SQW frequency to 1.024 KHz
   869 00000B46 E8E4FF              <1> 	call	rtc_write		; write control register A
   870                              <1> 
   871 00000B49 B00B                <1> 	mov	al,cmos_control_b
   872 00000B4B B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   873                              <1> 					; interrupts disabled
   874 00000B4D E8DDFF              <1> 	call	rtc_write		; write control register B
   875                              <1> 
   876 00000B50 B00C                <1> 	mov	al,cmos_control_c
   877 00000B52 E8CDFF              <1> 	call	rtc_read		; read control register C - reset
   878                              <1> 					; interrupt flags
   879                              <1> 
   880 00000B55 B00D                <1> 	mov	al,cmos_control_d
   881 00000B57 E8C8FF              <1> 	call	rtc_read		; read control register D
   882 00000B5A A880                <1> 	test	al,cmos_vrt
   883 00000B5C 7518                <1> 	jnz	.1			; RTC battery is OK
   884 00000B5E BE[0904]            <1> 	mov	si,msg_rtc_bad
   885 00000B61 E8701A              <1> 	call	print
   886                              <1> ; RTC is bad, set initial time
   887 00000B64 B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   888 00000B66 31C9                <1> 	xor	cx,cx
   889 00000B68 31D2                <1> 	xor	dx,dx
   890 00000B6A CD1A                <1> 	int	1Ah
   891 00000B6C B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   892 00000B6E B91020              <1> 	mov	cx,2010h		; year 2010
   893 00000B71 BA0101              <1> 	mov	dx,0101h		; January 1st
   894 00000B74 CD1A                <1> 	int	1Ah
   895                              <1> 
   896                              <1> .1:
   897                              <1> ; set timer variables to RTC time
   898 00000B76 B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   899 00000B78 CD1A                <1> 	int	1Ah
   900                              <1> 
   901                              <1> ; convert time to ticks * 2^11
   902                              <1> 
   903                              <1> ; ticks = seconds * 37287
   904 00000B7A 88F0                <1> 	mov	al,dh
   905 00000B7C E8AE00              <1> 	call	bcd_to_binary		; convert seconds to binary
   906                              <1> 
   907 00000B7F BAA791              <1> 	mov	dx,37287
   908 00000B82 F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   909                              <1> 
   910 00000B84 89C6                <1> 	mov	si,ax
   911 00000B86 89D7                <1> 	mov	di,dx
   912                              <1> 
   913                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   914 00000B88 88C8                <1> 	mov	al,cl
   915 00000B8A E8A000              <1> 	call	bcd_to_binary		; convert minutes to binary
   916                              <1> 
   917 00000B8D 89C3                <1> 	mov	bx,ax
   918 00000B8F BA2023              <1> 	mov	dx,8992
   919 00000B92 F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   920                              <1> 
   921 00000B94 01C6                <1> 	add	si,ax
   922 00000B96 11D7                <1> 	adc	di,dx
   923                              <1> 
   924 00000B98 89D8                <1> 	mov	ax,bx
   925 00000B9A BA2200              <1> 	mov	dx,34
   926 00000B9D F7E2                <1> 	mul	dx
   927                              <1> 
   928 00000B9F 01C7                <1> 	add	di,ax
   929                              <1> 
   930                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   931 00000BA1 88E8                <1> 	mov	al,ch
   932 00000BA3 E88700              <1> 	call	bcd_to_binary		; convert hours to binary
   933                              <1> 
   934 00000BA6 89C3                <1> 	mov	bx,ax
   935 00000BA8 BA6A3B              <1> 	mov	dx,15210
   936 00000BAB F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   937                              <1> 
   938 00000BAD 01C6                <1> 	add	si,ax
   939 00000BAF 11D7                <1> 	adc	di,dx
   940                              <1> 
   941 00000BB1 89D8                <1> 	mov	ax,bx
   942 00000BB3 BA0008              <1> 	mov	dx,2048
   943 00000BB6 F7E2                <1> 	mul	dx			; AX = hours * 2048
   944                              <1> 
   945 00000BB8 01C7                <1> 	add	di,ax
   946                              <1> 
   947                              <1> ; CX:DX = DI:SI / 2048
   948 00000BBA B10B                <1> 	mov	cl,11
   949 00000BBC D3EE                <1> 	shr	si,cl
   950 00000BBE 89FA                <1> 	mov	dx,di
   951 00000BC0 B105                <1> 	mov	cl,5
   952 00000BC2 D3E2                <1> 	shl	dx,cl
   953 00000BC4 09F2                <1> 	or	dx,si
   954                              <1> 
   955 00000BC6 B10B                <1> 	mov	cl,11
   956 00000BC8 D3EF                <1> 	shr	di,cl
   957 00000BCA 89F9                <1> 	mov	cx,di
   958                              <1> 
   959                              <1> 					; CX = high word of tick count
   960                              <1> 					; DX = low word of tick count
   961                              <1> 	
   962 00000BCC B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   963 00000BCE CD1A                <1> 	int	1Ah	
   964                              <1> 
   965                              <1> 
   966                              <1> ; compare NVRAM checksum with stored value
   967                              <1> 
   968 00000BD0 E86C00              <1> 	call	rtc_checksum
   969                              <1> 
   970 00000BD3 B02E                <1> 	mov	al,cmos_sum_hi
   971 00000BD5 E84AFF              <1> 	call	rtc_read
   972 00000BD8 88C4                <1> 	mov	ah,al
   973 00000BDA B02F                <1> 	mov	al,cmos_sum_lo
   974 00000BDC E843FF              <1> 	call	rtc_read
   975 00000BDF 39C3                <1> 	cmp	bx,ax
   976 00000BE1 742F                <1> 	je	.update_equipment
   977                              <1> 
   978 00000BE3 BE[2504]            <1> 	mov	si,msg_rtc_sum
   979 00000BE6 E8EB19              <1> 	call	print
   980                              <1> 
   981                              <1> ; clear NVRAM
   982                              <1> 
   983 00000BE9 B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   984                              <1> 
   985                              <1> .nvram_clear_loop:
   986 00000BEC E83EFF              <1> 	call	rtc_write
   987 00000BEF FEC0                <1> 	inc	al
   988 00000BF1 3C20                <1> 	cmp	al,20h			; last address is 20h
   989 00000BF3 76F7                <1> 	jbe	.nvram_clear_loop
   990                              <1> 
   991 00000BF5 B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   992 00000BF8 E832FF              <1> 	call	rtc_write
   993                              <1> 
   994 00000BFB B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
   995 00000BFE E82CFF              <1> 	call	rtc_write
   996                              <1> 
   997                              <1> ; update checksum
   998                              <1> 
   999 00000C01 E83B00              <1> 	call	rtc_checksum
  1000                              <1> 
  1001 00000C04 B02E                <1> 	mov	al,cmos_sum_hi
  1002 00000C06 88FC                <1> 	mov	ah,bh
  1003 00000C08 E822FF              <1> 	call	rtc_write
  1004                              <1> 
  1005 00000C0B FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1006 00000C0D 88DC                <1> 	mov	ah,bl
  1007 00000C0F E81BFF              <1> 	call	rtc_write
  1008                              <1> 
  1009                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
  1010                              <1> 
  1011                              <1> .update_equipment:
  1012 00000C12 B014                <1> 	mov	al,cmos_equip
  1013 00000C14 E80BFF              <1> 	call	rtc_read
  1014 00000C17 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
  1015 00000C19 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
  1016 00000C1E 08061000            <1> 	or	byte [equipment_list],al
  1017                              <1> 
  1018 00000C22 B020                <1> 	mov	al,e_rtc_init_ok	; RTC initialzied successfully
  1019 00000C24 E680                <1> 	out	post_reg,al
  1020                              <1> 
  1021 00000C26 5F                  <1> 	pop	di
  1022 00000C27 5E                  <1> 	pop	si
  1023 00000C28 5A                  <1> 	pop	dx
  1024 00000C29 59                  <1> 	pop	cx
  1025 00000C2A 5B                  <1> 	pop	bx
  1026 00000C2B 58                  <1> 	pop	ax
  1027 00000C2C C3                  <1> 	ret
  1028                              <1> 
  1029                              <1> bcd_to_binary:
  1030 00000C2D 51                  <1> 	push	cx
  1031 00000C2E 88C5                <1> 	mov	ch,al
  1032 00000C30 80E50F              <1> 	and	ch,0Fh
  1033 00000C33 B104                <1> 	mov	cl,4
  1034 00000C35 D2E8                <1> 	shr	al,cl
  1035 00000C37 B10A                <1> 	mov	cl,10
  1036 00000C39 F6E1                <1> 	mul	cl
  1037 00000C3B 00E8                <1> 	add	al,ch
  1038 00000C3D 59                  <1> 	pop	cx
  1039 00000C3E C3                  <1> 	ret
  1040                              <1> 
  1041                              <1> ;=========================================================================
  1042                              <1> ; rtc_checksum - calculate NVRAM checksum
  1043                              <1> ; Input:
  1044                              <1> ;	none
  1045                              <1> ; Output:
  1046                              <1> ;	BX = NVRAM checksum
  1047                              <1> ;-------------------------------------------------------------------------
  1048                              <1> rtc_checksum:
  1049 00000C3F 50                  <1> 	push	ax
  1050 00000C40 31DB                <1> 	xor	bx,bx
  1051 00000C42 B410                <1> 	mov	ah,10h			; start from 10h
  1052                              <1> 
  1053                              <1> .checksum_loop:
  1054 00000C44 88E0                <1> 	mov	al,ah
  1055 00000C46 E8D9FE              <1> 	call	rtc_read
  1056 00000C49 00C3                <1> 	add	bl,al			; BX += AL
  1057 00000C4B 80D700              <1> 	adc	bh,0
  1058 00000C4E FEC4                <1> 	inc	ah
  1059 00000C50 80FC20              <1> 	cmp	ah,20h			; last address is 20h
  1060 00000C53 76EF                <1> 	jbe	.checksum_loop
  1061 00000C55 58                  <1> 	pop	ax
  1062 00000C56 C3                  <1> 	ret
  1063                              <1> 
  1064                              <1> ;=========================================================================
  1065                              <1> ; rtc_setup - NVRAM configuration utility
  1066                              <1> ; Input:
  1067                              <1> ;	none
  1068                              <1> ; Output:
  1069                              <1> ;	none
  1070                              <1> ;-------------------------------------------------------------------------
  1071                              <1> rtc_setup:
  1072 00000C57 50                  <1> 	push	ax
  1073 00000C58 53                  <1> 	push	bx
  1074 00000C59 51                  <1> 	push	cx
  1075 00000C5A 52                  <1> 	push	dx
  1076 00000C5B 56                  <1> 	push	si
  1077                              <1> 
  1078 00000C5C B010                <1> 	mov	al,cmos_floppy
  1079 00000C5E E8C1FE              <1> 	call	rtc_read		; read currently configured floppies
  1080 00000C61 88C1                <1> 	mov	cl,al			; save it to CL
  1081 00000C63 BE[8C04]            <1> 	mov	si,msg_set_welcome
  1082 00000C66 E86B19              <1> 	call	print
  1083                              <1> 
  1084                              <1> .menu_loop:
  1085 00000C69 BE[9C05]            <1> 	mov	si,msg_set_prompt
  1086 00000C6C E86519              <1> 	call	print
  1087                              <1> 
  1088                              <1> .menu_input:
  1089 00000C6F B400                <1> 	mov	ah,00h
  1090 00000C71 CD16                <1> 	int	16h
  1091 00000C73 0C20                <1> 	or	al,20h			; convert to lower case
  1092 00000C75 B200                <1> 	mov	dl,0			; floppy 0
  1093 00000C77 3C66                <1> 	cmp	al,'f'
  1094 00000C79 743E                <1> 	je	.set_floppy
  1095 00000C7B FEC2                <1> 	inc	dl			; floppy 1
  1096 00000C7D 3C67                <1> 	cmp	al,'g'
  1097 00000C7F 7438                <1> 	je	.set_floppy
  1098 00000C81 3C70                <1> 	cmp	al,'p'
  1099 00000C83 7503E99100          <1> 	je	.print_settings
  1100 00000C88 3C74                <1> 	cmp	al,'t'
  1101 00000C8A 7503E9A200          <1> 	je	.set_time
  1102 00000C8F 3C64                <1> 	cmp	al,'d'
  1103 00000C91 7503E91301          <1> 	je	.set_date
  1104 00000C96 3C77                <1> 	cmp	al,'w'
  1105 00000C98 7503E9D401          <1> 	je	.save
  1106 00000C9D 3C71                <1> 	cmp	al,'q'
  1107 00000C9F 7503E90702          <1> 	je	.exit
  1108 00000CA4 3C68                <1> 	cmp	al,'h'
  1109 00000CA6 7402                <1> 	je	.help
  1110 00000CA8 EBC5                <1> 	jmp	.menu_input
  1111                              <1> 
  1112                              <1> .help:
  1113 00000CAA B40E                <1> 	mov	ah,0Eh			; echo
  1114 00000CAC BB0700              <1> 	mov	bx,0007h
  1115 00000CAF CD10                <1> 	int	10h
  1116 00000CB1 BE[B104]            <1> 	mov	si,msg_set_help
  1117 00000CB4 E81D19              <1> 	call	print
  1118 00000CB7 EBB0                <1> 	jmp	.menu_loop
  1119                              <1> 
  1120                              <1> .set_floppy:
  1121 00000CB9 B40E                <1> 	mov	ah,0Eh			; echo
  1122 00000CBB BB0700              <1> 	mov	bx,0007h
  1123 00000CBE CD10                <1> 	int	10h
  1124                              <1> 
  1125                              <1> .set_floppy_prompt:
  1126 00000CC0 BE[E906]            <1> 	mov	si,msg_set_fd_prmt
  1127 00000CC3 E80E19              <1> 	call	print
  1128                              <1> 
  1129                              <1> .floppy_input:
  1130 00000CC6 B400                <1> 	mov	ah,00h
  1131 00000CC8 CD16                <1> 	int	16h
  1132 00000CCA 0C20                <1> 	or	al,20h			; convert to lower case
  1133 00000CCC 3C72                <1> 	cmp	al,'r'
  1134 00000CCE 7430                <1> 	je	.floppy_exit
  1135 00000CD0 3C68                <1> 	cmp	al,'h'
  1136 00000CD2 7436                <1> 	je	.floppy_help
  1137 00000CD4 3C30                <1> 	cmp	al,'0'
  1138 00000CD6 72EE                <1> 	jb	.floppy_input
  1139 00000CD8 3C36                <1> 	cmp	al,'6'
  1140 00000CDA 77EA                <1> 	ja	.floppy_input
  1141 00000CDC 3C35                <1> 	cmp	al,'5'
  1142 00000CDE 74E6                <1> 	je	.floppy_input
  1143 00000CE0 B40E                <1> 	mov	ah,0Eh			; echo
  1144 00000CE2 BB0700              <1> 	mov	bx,0007h
  1145 00000CE5 CD10                <1> 	int	10h
  1146 00000CE7 2C30                <1> 	sub	al,'0'
  1147 00000CE9 B6F0                <1> 	mov	dh,0F0h
  1148 00000CEB 08D2                <1> 	or	dl,dl			; drive	0?
  1149 00000CED 750A                <1> 	jnz	.drive_1
  1150 00000CEF D0E0                <1> 	shl	al,1
  1151 00000CF1 D0E0                <1> 	shl	al,1
  1152 00000CF3 D0E0                <1> 	shl	al,1
  1153 00000CF5 D0E0                <1> 	shl	al,1
  1154 00000CF7 B60F                <1> 	mov	dh,0Fh
  1155                              <1> .drive_1:
  1156 00000CF9 20F1                <1> 	and	cl,dh
  1157 00000CFB 08C1                <1> 	or	cl,al
  1158 00000CFD E969FF              <1> 	jmp	.menu_loop
  1159                              <1> 
  1160                              <1> .floppy_exit:
  1161 00000D00 B40E                <1> 	mov	ah,0Eh			; echo
  1162 00000D02 BB0700              <1> 	mov	bx,0007h
  1163 00000D05 CD10                <1> 	int	10h
  1164 00000D07 E95FFF              <1> 	jmp	.menu_loop
  1165                              <1> 
  1166                              <1> .floppy_help:
  1167 00000D0A B40E                <1> 	mov	ah,0Eh			; echo
  1168 00000D0C BB0700              <1> 	mov	bx,0007h
  1169 00000D0F CD10                <1> 	int	10h
  1170 00000D11 BE[1B06]            <1> 	mov	si,msg_set_fd_help
  1171 00000D14 E8BD18              <1> 	call	print
  1172 00000D17 EBA7                <1> 	jmp	.set_floppy_prompt
  1173                              <1> 
  1174                              <1> .print_settings:
  1175 00000D19 B40E                <1> 	mov	ah,0Eh			; echo
  1176 00000D1B BB0700              <1> 	mov	bx,0007h
  1177 00000D1E CD10                <1> 	int	10h
  1178 00000D20 BE[8800]            <1> 	mov	si,msg_crlf
  1179 00000D23 E8AE18              <1> 	call	print
  1180 00000D26 E89501              <1> 	call	print_rtc		; print current RTC time
  1181 00000D29 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1182 00000D2B E8580B              <1> 	call	print_floppy
  1183 00000D2E E938FF              <1> 	jmp	.menu_loop
  1184                              <1> 
  1185                              <1> .set_time:
  1186 00000D31 51                  <1> 	push	cx
  1187 00000D32 57                  <1> 	push	di
  1188 00000D33 06                  <1> 	push	es
  1189 00000D34 B40E                <1> 	mov	ah,0Eh			; echo
  1190 00000D36 BB0700              <1> 	mov	bx,0007h
  1191 00000D39 CD10                <1> 	int	10h
  1192 00000D3B BE[8800]            <1> 	mov	si,msg_crlf
  1193 00000D3E E89318              <1> 	call	print
  1194                              <1> 
  1195 00000D41 BE[BB05]            <1> 	mov	si,msg_set_time
  1196 00000D44 E88D18              <1> 	call	print
  1197                              <1> 
  1198 00000D47 B402                <1> 	mov	ah,02h
  1199 00000D49 CD1A                <1> 	int	1Ah			; get current time
  1200                              <1> 
  1201 00000D4B B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1202 00000D4E 8EC0                <1> 	mov	es,ax
  1203 00000D50 31FF                <1> 	xor	di,di
  1204 00000D52 B80800              <1> 	mov	ax,8			; length of the time string
  1205                              <1> 
  1206 00000D55 E8C417              <1> 	call	get_line
  1207                              <1> 
  1208 00000D58 09C0                <1> 	or	ax,ax			; empty string?
  1209 00000D5A 743F                <1> 	jz	.set_time_exit
  1210                              <1> 
  1211 00000D5C E82F18              <1> 	call	atoi
  1212                              <1> 
  1213 00000D5F 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
  1214 00000D62 773D                <1> 	ja	.set_time_invalid
  1215                              <1> 
  1216 00000D64 E84C18              <1> 	call	bin_to_bcd		; convert to BCD
  1217                              <1> 
  1218 00000D67 88C5                <1> 	mov	ch,al			; CH = hours
  1219                              <1> 
  1220 00000D69 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1221 00000D6D 7532                <1> 	jne	.set_time_invalid
  1222                              <1> 
  1223 00000D6F 47                  <1> 	inc	di
  1224                              <1> 
  1225 00000D70 E81B18              <1> 	call	atoi
  1226                              <1> 
  1227 00000D73 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
  1228 00000D76 7729                <1> 	ja	.set_time_invalid
  1229                              <1> 
  1230 00000D78 E83818              <1> 	call	bin_to_bcd
  1231                              <1> 
  1232 00000D7B 88C1                <1> 	mov	cl,al			; CL = minutes
  1233                              <1> 
  1234 00000D7D 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1235 00000D81 751E                <1> 	jne	.set_time_invalid
  1236                              <1> 
  1237 00000D83 47                  <1> 	inc	di
  1238                              <1> 
  1239 00000D84 E80718              <1> 	call	atoi
  1240                              <1> 
  1241 00000D87 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
  1242 00000D8A 7715                <1> 	ja	.set_time_invalid
  1243                              <1> 
  1244 00000D8C E82418              <1> 	call	bin_to_bcd
  1245                              <1> 
  1246 00000D8F 88C6                <1> 	mov	dh,al			; DH = seconds
  1247                              <1> 
  1248 00000D91 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1249 00000D95 750A                <1> 	jne	.set_time_invalid
  1250                              <1> 
  1251 00000D97 B403                <1> 	mov	ah,03h			; set RTC time
  1252 00000D99 CD1A                <1> 	int	1Ah
  1253                              <1> 
  1254                              <1> .set_time_exit:
  1255 00000D9B 07                  <1> 	pop	es
  1256 00000D9C 5F                  <1> 	pop	di
  1257 00000D9D 59                  <1> 	pop	cx
  1258 00000D9E E9C8FE              <1> 	jmp	.menu_loop
  1259                              <1> 
  1260                              <1> .set_time_invalid:
  1261 00000DA1 BE[ED05]            <1> 	mov	si,msg_time_inval
  1262 00000DA4 E82D18              <1> 	call	print
  1263 00000DA7 EBF2                <1> 	jmp	.set_time_exit
  1264                              <1> 
  1265                              <1> .set_date:
  1266 00000DA9 51                  <1> 	push	cx
  1267 00000DAA 57                  <1> 	push	di
  1268 00000DAB 06                  <1> 	push	es
  1269 00000DAC B40E                <1> 	mov	ah,0Eh			; echo
  1270 00000DAE BB0700              <1> 	mov	bx,0007h
  1271 00000DB1 CD10                <1> 	int	10h
  1272 00000DB3 BE[8800]            <1> 	mov	si,msg_crlf
  1273 00000DB6 E81B18              <1> 	call	print
  1274 00000DB9 BE[D305]            <1> 	mov	si,msg_set_date
  1275 00000DBC E81518              <1> 	call	print
  1276                              <1> 
  1277 00000DBF B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1278 00000DC2 8EC0                <1> 	mov	es,ax
  1279 00000DC4 31FF                <1> 	xor	di,di
  1280 00000DC6 B80A00              <1> 	mov	ax,10			; length of the date string
  1281                              <1> 
  1282 00000DC9 E85017              <1> 	call	get_line
  1283                              <1> 
  1284 00000DCC 09C0                <1> 	or	ax,ax			; empty string?
  1285 00000DCE 7503E99000          <1> 	jz	.set_date_exit
  1286                              <1> 
  1287 00000DD3 E8B817              <1> 	call	atoi
  1288                              <1> 
  1289 00000DD6 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
  1290 00000DD9 7603E98B00          <1> 	ja	.set_date_invalid
  1291                              <1> 
  1292 00000DDE 89C3                <1> 	mov	bx,ax			; store binary year in BX
  1293                              <1> 
  1294 00000DE0 E8D017              <1> 	call	bin_to_bcd		; convert to BCD
  1295                              <1> 
  1296 00000DE3 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
  1297                              <1> 	
  1298 00000DE5 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1299 00000DE9 757E                <1> 	jne	.set_date_invalid
  1300                              <1> 
  1301 00000DEB 47                  <1> 	inc	di
  1302                              <1> 
  1303 00000DEC E89F17              <1> 	call	atoi
  1304                              <1> 
  1305 00000DEF 83F801              <1> 	cmp	ax,1			; month is lower than 1?
  1306 00000DF2 7275                <1> 	jb	.set_date_invalid
  1307                              <1> 
  1308 00000DF4 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
  1309 00000DF7 7770                <1> 	ja	.set_date_invalid
  1310                              <1> 
  1311 00000DF9 E8B717              <1> 	call	bin_to_bcd
  1312                              <1> 
  1313 00000DFC 88C6                <1> 	mov	dh,al			; DH = month
  1314                              <1> 
  1315 00000DFE 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1316 00000E02 7565                <1> 	jne	.set_date_invalid
  1317                              <1> 
  1318 00000E04 47                  <1> 	inc	di
  1319                              <1> 
  1320 00000E05 E88617              <1> 	call	atoi
  1321                              <1> 
  1322 00000E08 83F801              <1> 	cmp	ax,1			; day is lower than 1?
  1323 00000E0B 725C                <1> 	jb	.set_date_invalid
  1324                              <1> 
  1325 00000E0D 80FE02              <1> 	cmp	dh,02h			; February
  1326 00000E10 7430                <1> 	je	.set_date_february
  1327                              <1> 
  1328 00000E12 80FE04              <1> 	cmp	dh,04h			; April
  1329 00000E15 7416                <1> 	je	.set_date_30_days
  1330                              <1> 
  1331 00000E17 80FE06              <1> 	cmp	dh,06h			; July
  1332 00000E1A 7411                <1> 	je	.set_date_30_days
  1333                              <1> 
  1334 00000E1C 80FE09              <1> 	cmp	dh,09h			; September
  1335 00000E1F 740C                <1> 	je	.set_date_30_days
  1336                              <1> 
  1337 00000E21 80FE11              <1> 	cmp	dh,11h			; November
  1338 00000E24 7407                <1> 	je	.set_date_30_days
  1339                              <1> 
  1340                              <1> .set_date_31_days:
  1341 00000E26 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
  1342 00000E29 773E                <1> 	ja	.set_date_invalid
  1343 00000E2B EB27                <1> 	jmp	.set_date_set_day
  1344                              <1> 
  1345                              <1> .set_date_30_days:
  1346 00000E2D 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
  1347 00000E30 7737                <1> 	ja	.set_date_invalid
  1348 00000E32 EB20                <1> 	jmp	.set_date_set_day
  1349                              <1> 
  1350                              <1> .set_date_29_days:
  1351 00000E34 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
  1352 00000E37 7730                <1> 	ja	.set_date_invalid
  1353 00000E39 EB19                <1> 	jmp	.set_date_set_day
  1354                              <1> 
  1355                              <1> .set_date_28_days:
  1356 00000E3B 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
  1357 00000E3E 7729                <1> 	ja	.set_date_invalid
  1358 00000E40 EB12                <1> 	jmp	.set_date_set_day
  1359                              <1> 
  1360                              <1> .set_date_february:
  1361 00000E42 F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
  1362 00000E46 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
  1363                              <1> 
  1364 00000E48 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
  1365 00000E4B 75E7                <1> 	jne	.set_date_29_days	; a leap year
  1366                              <1> 
  1367 00000E4D F6C503              <1> 	test	ch,03h			; check if century divides by 4
  1368 00000E50 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
  1369 00000E52 EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
  1370                              <1> 
  1371                              <1> .set_date_set_day:
  1372 00000E54 E85C17              <1> 	call	bin_to_bcd
  1373                              <1> 
  1374 00000E57 88C2                <1> 	mov	dl,al			; DL = date (day of month)
  1375                              <1> 
  1376 00000E59 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1377 00000E5D 750A                <1> 	jne	.set_date_invalid
  1378                              <1> 
  1379 00000E5F B405                <1> 	mov	ah,05h			; set RTC date
  1380 00000E61 CD1A                <1> 	int	1Ah
  1381                              <1> 
  1382                              <1> .set_date_exit:
  1383 00000E63 07                  <1> 	pop	es
  1384 00000E64 5F                  <1> 	pop	di
  1385 00000E65 59                  <1> 	pop	cx
  1386 00000E66 E900FE              <1> 	jmp	.menu_loop
  1387                              <1> 
  1388                              <1> .set_date_invalid:
  1389 00000E69 BE[0406]            <1> 	mov	si,msg_date_inval
  1390 00000E6C E86517              <1> 	call	print
  1391 00000E6F EBF2                <1> 	jmp	.set_date_exit
  1392                              <1> 
  1393                              <1> .save:
  1394 00000E71 50                  <1> 	push	ax
  1395                              <1> 
  1396 00000E72 B010                <1> 	mov	al,cmos_floppy
  1397 00000E74 88CC                <1> 	mov	ah,cl
  1398 00000E76 E8B4FC              <1> 	call	rtc_write
  1399                              <1> 
  1400 00000E79 8A261000            <1> 	mov	ah,byte [equipment_list]
  1401 00000E7D 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1402                              <1> 
  1403 00000E80 F6C170              <1> 	test	cl,70h
  1404 00000E83 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1405 00000E85 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1406                              <1> 
  1407                              <1> .second_floppy:
  1408 00000E88 F6C107              <1> 	test	cl,07h
  1409 00000E8B 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1410 00000E8D 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1411                              <1> 					; (even if the first one is missing)
  1412                              <1> 
  1413                              <1> .save_equipment:
  1414 00000E90 88261000            <1> 	mov	byte [equipment_list],ah
  1415 00000E94 B014                <1> 	mov	al,cmos_equip
  1416 00000E96 E894FC              <1> 	call	rtc_write
  1417                              <1> 
  1418 00000E99 E8A3FD              <1> 	call	rtc_checksum
  1419                              <1> 
  1420 00000E9C B02E                <1> 	mov	al,cmos_sum_hi
  1421 00000E9E 88FC                <1> 	mov	ah,bh
  1422 00000EA0 E88AFC              <1> 	call	rtc_write
  1423                              <1> 
  1424 00000EA3 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1425 00000EA5 88DC                <1> 	mov	ah,bl
  1426 00000EA7 E883FC              <1> 	call	rtc_write
  1427                              <1> 	
  1428 00000EAA 58                  <1> 	pop	ax
  1429                              <1> 
  1430                              <1> .exit:
  1431 00000EAB B40E                <1> 	mov	ah,0Eh			; echo
  1432 00000EAD BB0700              <1> 	mov	bx,0007h
  1433 00000EB0 CD10                <1> 	int	10h
  1434 00000EB2 BE[8800]            <1> 	mov	si,msg_crlf
  1435 00000EB5 E81C17              <1> 	call	print
  1436 00000EB8 5E                  <1> 	pop	si
  1437 00000EB9 5A                  <1> 	pop	dx
  1438 00000EBA 59                  <1> 	pop	cx
  1439 00000EBB 5B                  <1> 	pop	bx
  1440 00000EBC 58                  <1> 	pop	ax
  1441 00000EBD C3                  <1> 	ret
  1442                              <1> 
  1443                              <1> ;=========================================================================
  1444                              <1> ; print_rtc - print current RTC date and time
  1445                              <1> ; Input:
  1446                              <1> ;	none
  1447                              <1> ; Output:
  1448                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
  1449                              <1> ; Notes:
  1450                              <1> ;	There is a slight probability of getting inconsistent printout.
  1451                              <1> ;	In case the function is called just before midnight, it could
  1452                              <1> ;	print the previos day's date and next day's time.
  1453                              <1> ;-------------------------------------------------------------------------
  1454                              <1> print_rtc:
  1455 00000EBE 50                  <1> 	push	ax
  1456 00000EBF 53                  <1> 	push	bx
  1457 00000EC0 51                  <1> 	push	cx
  1458 00000EC1 52                  <1> 	push	dx
  1459 00000EC2 56                  <1> 	push	si
  1460 00000EC3 BE[E501]            <1> 	mov	si,msg_rtc
  1461 00000EC6 E80B17              <1> 	call	print
  1462                              <1> 
  1463                              <1> ; print date
  1464 00000EC9 B404                <1> 	mov	ah,04h
  1465 00000ECB CD1A                <1> 	int	1Ah			; read RTC date
  1466                              <1> 					; CH = BCD century
  1467                              <1> 					; CL = BCD year
  1468                              <1> 					; DH = BCD month
  1469                              <1> 					; DL = BCD date (day of month)
  1470 00000ECD 89C8                <1> 	mov	ax,cx
  1471 00000ECF E81D17              <1> 	call	print_hex		; print 4-digit year
  1472 00000ED2 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1473 00000ED5 BB0700              <1> 	mov	bx,0007h
  1474 00000ED8 CD10                <1> 	int	10h			; print dash (-)
  1475                              <1> 
  1476 00000EDA 88F0                <1> 	mov	al,dh
  1477 00000EDC E81B17              <1> 	call	print_byte		; print 2-digit month
  1478 00000EDF B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1479 00000EE2 BB0700              <1> 	mov	bx,0007h
  1480 00000EE5 CD10                <1> 	int	10h			; print dash (-)
  1481                              <1> 
  1482 00000EE7 88D0                <1> 	mov	al,dl
  1483 00000EE9 E80E17              <1> 	call	print_byte		; print 2-digit date (day of month)
  1484                              <1> 
  1485 00000EEC B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
  1486 00000EEF BB0700              <1> 	mov	bx,0007h
  1487 00000EF2 CD10                <1> 	int	10h			; print space ( )
  1488                              <1> 
  1489                              <1> ; print time
  1490 00000EF4 B402                <1> 	mov	ah,02h
  1491 00000EF6 CD1A                <1> 	int	1Ah			; read RTC time
  1492                              <1> 					; CH = BCD hours
  1493                              <1> 					; CL = BCD minutes
  1494                              <1> 					; DH = BCD seconds
  1495                              <1> 					; DL = daylight saving flag (ignored)
  1496 00000EF8 88E8                <1> 	mov	al,ch
  1497 00000EFA E8FD16              <1> 	call	print_byte		; print 2-digit hours
  1498                              <1> 	
  1499 00000EFD B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1500 00000F00 BB0700              <1> 	mov	bx,0007h
  1501 00000F03 CD10                <1> 	int	10h			; print colon (:)
  1502                              <1> 
  1503 00000F05 88C8                <1> 	mov	al,cl
  1504 00000F07 E8F016              <1> 	call	print_byte		; print 2-digit minutes
  1505                              <1> 	
  1506 00000F0A B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1507 00000F0D BB0700              <1> 	mov	bx,0007h
  1508 00000F10 CD10                <1> 	int	10h			; print colon (:)
  1509                              <1> 
  1510 00000F12 88F0                <1> 	mov	al,dh
  1511 00000F14 E8E316              <1> 	call	print_byte		; print 2-digit seconds
  1512                              <1> 
  1513 00000F17 BE[8800]            <1> 	mov	si,msg_crlf
  1514 00000F1A E8B716              <1> 	call	print
  1515 00000F1D 5E                  <1> 	pop	si
  1516 00000F1E 5A                  <1> 	pop	dx
  1517 00000F1F 59                  <1> 	pop	cx
  1518 00000F20 5B                  <1> 	pop	bx
  1519 00000F21 58                  <1> 	pop	ax
  1520 00000F22 C3                  <1> 	ret
  1521                              <1> 
  1522                              <1> ;=========================================================================
  1523                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1524                              <1> ; Input:
  1525                              <1> ;	CX = time to delay (in 15 microsecond units)
  1526                              <1> ; Notes:
  1527                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1528                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1529                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1530                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1531                              <1> ;-------------------------------------------------------------------------
  1532                              <1> delay_15us:
  1533 00000F23 50                  <1> 	push	ax
  1534 00000F24 51                  <1> 	push	cx
  1535                              <1> .zero:
  1536 00000F25 E461                <1> 	in	al,port_b_reg
  1537 00000F27 A810                <1> 	test	al,refresh_flag
  1538 00000F29 74FA                <1> 	jz	.zero
  1539 00000F2B 49                  <1> 	dec	cx
  1540 00000F2C 7409                <1> 	jz	.exit
  1541                              <1> .one:
  1542 00000F2E E461                <1> 	in	al,port_b_reg
  1543 00000F30 A810                <1> 	test	al,refresh_flag
  1544 00000F32 75FA                <1> 	jnz	.one
  1545 00000F34 49                  <1> 	dec	cx
  1546 00000F35 75EE                <1> 	jnz	.zero
  1547                              <1> .exit:
  1548 00000F37 59                  <1> 	pop	cx
  1549 00000F38 58                  <1> 	pop	ax
  1550 00000F39 C3                  <1> 	ret
  1551                              <1> 
  1552                              <1> %if 0
  1553                              <1> ;=========================================================================
  1554                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1555                              <1> ; Input:
  1556                              <1> ;	DX:AX	- dividend
  1557                              <1> ;	CX	- divisor
  1558                              <1> ; Output:
  1559                              <1> ;	DX:AX	- quotient
  1560                              <1> ;-------------------------------------------------------------------------
  1561                              <1> divide_32:
  1562                              <1> 	or	dx,dx
  1563                              <1> 	jnz	.1
  1564                              <1> 	div	cx
  1565                              <1> 	xor	dx,dx
  1566                              <1> 	ret
  1567                              <1> .1:
  1568                              <1> 	push	bx
  1569                              <1> 	mov	bx,ax
  1570                              <1> 	mov	ax,dx
  1571                              <1> 	xor	dx,dx
  1572                              <1> 	div	cx
  1573                              <1> 	xchg	bx,ax
  1574                              <1> 	div	cx
  1575                              <1> 	mov	dx,bx
  1576                              <1> 	pop	bx
  1577                              <1> 	ret
  1578                              <1> %endif ; 0
  1579                                  %include	"time1.inc"		; time services
  1580                              <1> ;=========================================================================
  1581                              <1> ; time1.inc - BIOS Time Services
  1582                              <1> ;       INT 1Ah - BIOS Time Services
  1583                              <1> ;		functions AH=00h to AH=07h
  1584                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1585                              <1> ;-------------------------------------------------------------------------
  1586                              <1> ;
  1587                              <1> ; Compiles with NASM 2.07, might work with other versions
  1588                              <1> ;
  1589                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1590                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1591                              <1> ;
  1592                              <1> ; This program is free software: you can redistribute it and/or modify
  1593                              <1> ; it under the terms of the GNU General Public License as published by
  1594                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1595                              <1> ; (at your option) any later version.
  1596                              <1> ;
  1597                              <1> ; This program is distributed in the hope that it will be useful,
  1598                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1599                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1600                              <1> ; GNU General Public License for more details.
  1601                              <1> ;
  1602                              <1> ; You should have received a copy of the GNU General Public License
  1603                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1604                              <1> ;
  1605                              <1> ;=========================================================================
  1606                              <1> 
  1607                              <1> ;=========================================================================
  1608                              <1> ; int_1A_fn00 - Read current time
  1609                              <1> ; Input:
  1610                              <1> ;	AH = 0 - read current time
  1611                              <1> ; Output:
  1612                              <1> ;	CX = high word of tick count
  1613                              <1> ;	DX = low word of tick count
  1614                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1615                              <1> ;-------------------------------------------------------------------------
  1616                              <1> int_1A_fn00:
  1617 00000F3A 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1618 00000F3E 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1619 00000F42 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1620 00000F45 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1621 00000F49 E9496F              <1> 	jmp	int_1A_exit
  1622                              <1> 
  1623                              <1> ;=========================================================================
  1624                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1625                              <1> ; Input:
  1626                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1627                              <1> ;	CX = high word of tick count
  1628                              <1> ;	DX = low word of tick count
  1629                              <1> ; Output:
  1630                              <1> ;	None
  1631                              <1> ;-------------------------------------------------------------------------
  1632                              <1> int_1A_fn01:
  1633 00000F4C 89166C00            <1> 	mov	word [ticks_lo],dx
  1634 00000F50 890E6E00            <1> 	mov	word [ticks_hi],cx
  1635 00000F54 C606700000          <1> 	mov	byte [new_day],00h
  1636 00000F59 E9396F              <1> 	jmp	int_1A_exit
  1637                              <1> 
  1638                              <1> ;=========================================================================
  1639                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1640                              <1> ; Input:
  1641                              <1> ;	AH = 02h - function 02h - read RTC time
  1642                              <1> ; Output:
  1643                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1644                              <1> ;	CH = BCD hours
  1645                              <1> ;	CL = BCD minutes
  1646                              <1> ;	DH = BCD seconds
  1647                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1648                              <1> ;-------------------------------------------------------------------------
  1649                              <1> int_1A_fn02:
  1650 00000F5C 50                  <1> 	push	ax
  1651 00000F5D B00A                <1> 	mov	al,cmos_control_a
  1652 00000F5F E8C0FB              <1> 	call	rtc_read		; read control A register
  1653 00000F62 A880                <1> 	test	al,cmos_uip
  1654 00000F64 7405                <1> 	jz	.1			; no update in progess
  1655 00000F66 F9                  <1> 	stc
  1656 00000F67 58                  <1> 	pop	ax
  1657 00000F68 E92D6F              <1> 	jmp	int_1A_exitf
  1658                              <1> .1:
  1659 00000F6B B00B                <1> 	mov	al,cmos_control_b
  1660 00000F6D E8B2FB              <1> 	call	rtc_read		; read control B register
  1661 00000F70 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1662 00000F72 88C2                <1> 	mov	dl,al
  1663 00000F74 B000                <1> 	mov	al,cmos_seconds
  1664 00000F76 E8A9FB              <1> 	call	rtc_read		; read seconds
  1665 00000F79 88C6                <1> 	mov	dh,al
  1666 00000F7B B002                <1> 	mov	al,cmos_minutes
  1667 00000F7D E8A2FB              <1> 	call	rtc_read		; read minutes
  1668 00000F80 88C1                <1> 	mov	cl,al
  1669 00000F82 B004                <1> 	mov	al,cmos_hours
  1670 00000F84 E89BFB              <1> 	call	rtc_read		; read hours
  1671 00000F87 88C5                <1> 	mov	ch,al
  1672 00000F89 F8                  <1> 	clc
  1673 00000F8A 58                  <1> 	pop	ax
  1674 00000F8B E90A6F              <1> 	jmp	int_1A_exitf
  1675                              <1> 
  1676                              <1> ;=========================================================================
  1677                              <1> ; int_1A_fn03 - Set real time clock
  1678                              <1> ; Input:
  1679                              <1> ;	AH = 03h - function 03h - set RTC time
  1680                              <1> ;	CH = BCD hours
  1681                              <1> ;	CL = BCD minutes
  1682                              <1> ;	DH = BCD seconds
  1683                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1684                              <1> ; Output:
  1685                              <1> ;	None
  1686                              <1> ;-------------------------------------------------------------------------
  1687                              <1> int_1A_fn03:
  1688 00000F8E 50                  <1> 	push	ax
  1689 00000F8F B00B                <1> 	mov	al,cmos_control_b
  1690 00000F91 E88EFB              <1> 	call	rtc_read		; read control B register
  1691 00000F94 88C4                <1> 	mov	ah,al
  1692 00000F96 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1693 00000F99 B00B                <1> 	mov	al,cmos_control_b
  1694 00000F9B E88FFB              <1> 	call	rtc_write		; write control B register
  1695                              <1> 
  1696 00000F9E 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1697 00000FA1 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1698 00000FA4 08D4                <1> 	or	ah,dl			; add it from the input
  1699 00000FA6 B00B                <1> 	mov	al,cmos_control_b
  1700 00000FA8 E882FB              <1> 	call	rtc_write		; write control B register
  1701                              <1> 
  1702 00000FAB B000                <1> 	mov	al,cmos_seconds
  1703 00000FAD 88F4                <1> 	mov	ah,dh
  1704 00000FAF E87BFB              <1> 	call	rtc_write		; write seconds
  1705 00000FB2 B002                <1> 	mov	al,cmos_minutes
  1706 00000FB4 88CC                <1> 	mov	ah,cl
  1707 00000FB6 E874FB              <1> 	call	rtc_write		; write minutes
  1708 00000FB9 B004                <1> 	mov	al,cmos_hours
  1709 00000FBB 88EC                <1> 	mov	ah,ch
  1710 00000FBD E86DFB              <1> 	call	rtc_write		; write hours
  1711                              <1> 
  1712 00000FC0 B00B                <1> 	mov	al,cmos_control_b
  1713 00000FC2 E85DFB              <1> 	call	rtc_read		; read control B register
  1714 00000FC5 88C4                <1> 	mov	ah,al
  1715 00000FC7 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1716 00000FCA B00B                <1> 	mov	al,cmos_control_b
  1717 00000FCC E85EFB              <1> 	call	rtc_write		; write control B register
  1718 00000FCF 58                  <1> 	pop	ax
  1719 00000FD0 E9C26E              <1> 	jmp	int_1A_exit
  1720                              <1> 
  1721                              <1> ;=========================================================================
  1722                              <1> ; int_1A_fn04 - Read date from real time clock
  1723                              <1> ; Input:
  1724                              <1> ;	AH = 04h - function 04h - read RTC date
  1725                              <1> ; Output:
  1726                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1727                              <1> ;	CH = BCD century
  1728                              <1> ;	CL = BCD year
  1729                              <1> ;	DH = BCD month
  1730                              <1> ;	DL = BCD date
  1731                              <1> ;-------------------------------------------------------------------------
  1732                              <1> int_1A_fn04:
  1733 00000FD3 50                  <1> 	push	ax
  1734 00000FD4 B00A                <1> 	mov	al,cmos_control_a
  1735 00000FD6 E849FB              <1> 	call	rtc_read		; read control A register
  1736 00000FD9 A880                <1> 	test	al,cmos_uip
  1737 00000FDB 7405                <1> 	jz	.1			; no update in progess
  1738 00000FDD F9                  <1> 	stc
  1739 00000FDE 58                  <1> 	pop	ax
  1740 00000FDF E9B66E              <1> 	jmp	int_1A_exitf
  1741                              <1> .1:
  1742 00000FE2 B007                <1> 	mov	al,cmos_date
  1743 00000FE4 E83BFB              <1> 	call	rtc_read		; read date
  1744 00000FE7 88C2                <1> 	mov	dl,al
  1745 00000FE9 B008                <1> 	mov	al,cmos_month
  1746 00000FEB E834FB              <1> 	call	rtc_read		; read month
  1747 00000FEE 88C6                <1> 	mov	dh,al
  1748 00000FF0 B009                <1> 	mov	al,cmos_year
  1749 00000FF2 E82DFB              <1> 	call	rtc_read		; read year
  1750 00000FF5 88C1                <1> 	mov	cl,al
  1751 00000FF7 B032                <1> 	mov	al,cmos_century
  1752 00000FF9 E826FB              <1> 	call	rtc_read		; read century
  1753 00000FFC 88C5                <1> 	mov	ch,al
  1754 00000FFE F8                  <1> 	clc
  1755 00000FFF 58                  <1> 	pop	ax
  1756 00001000 E9956E              <1> 	jmp	int_1A_exitf
  1757                              <1> 
  1758                              <1> ;=========================================================================
  1759                              <1> ; int_1A_fn05 - Set date in real time clock
  1760                              <1> ; Input:
  1761                              <1> ;	AH = 05h - function 05h - set RTC date
  1762                              <1> ;	CH = BCD century
  1763                              <1> ;	CL = BCD year
  1764                              <1> ;	DH = BCD month
  1765                              <1> ;	DL = BCD date
  1766                              <1> ; Output:
  1767                              <1> ;	None
  1768                              <1> ;-------------------------------------------------------------------------
  1769                              <1> int_1A_fn05:
  1770 00001003 50                  <1> 	push	ax
  1771 00001004 B00B                <1> 	mov	al,cmos_control_b
  1772 00001006 E819FB              <1> 	call	rtc_read		; read control B register
  1773 00001009 88C4                <1> 	mov	ah,al
  1774 0000100B 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1775 0000100E B00B                <1> 	mov	al,cmos_control_b
  1776 00001010 E81AFB              <1> 	call	rtc_write		; write control B register
  1777                              <1> 
  1778 00001013 B007                <1> 	mov	al,cmos_date
  1779 00001015 88D4                <1> 	mov	ah,dl
  1780 00001017 E813FB              <1> 	call	rtc_write		; write date
  1781                              <1> 
  1782 0000101A B008                <1> 	mov	al,cmos_month
  1783 0000101C 88F4                <1> 	mov	ah,dh
  1784 0000101E E80CFB              <1> 	call	rtc_write		; write month
  1785 00001021 B009                <1> 	mov	al,cmos_year
  1786 00001023 88CC                <1> 	mov	ah,cl
  1787 00001025 E805FB              <1> 	call	rtc_write		; write year
  1788 00001028 B032                <1> 	mov	al,cmos_century
  1789 0000102A 88EC                <1> 	mov	ah,ch
  1790 0000102C E8FEFA              <1> 	call	rtc_write		; write centry
  1791                              <1> 
  1792 0000102F B00B                <1> 	mov	al,cmos_control_b
  1793 00001031 E8EEFA              <1> 	call	rtc_read		; read control B register
  1794 00001034 88C4                <1> 	mov	ah,al
  1795 00001036 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1796 00001039 B00B                <1> 	mov	al,cmos_control_b
  1797 0000103B E8EFFA              <1> 	call	rtc_write		; write control B register
  1798 0000103E 58                  <1> 	pop	ax
  1799 0000103F E9536E              <1> 	jmp	int_1A_exit
  1800                              <1> 
  1801                              <1> ;=========================================================================
  1802                              <1> ; int_1A_fn06 - Set real time clock alarm
  1803                              <1> ; Input:
  1804                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1805                              <1> ;	CH = BCD hours
  1806                              <1> ;	CL = BCD minutes
  1807                              <1> ;	DH = BCD seconds
  1808                              <1> ; Output:
  1809                              <1> ;	CF = 1 - alarm already set
  1810                              <1> ;-------------------------------------------------------------------------
  1811                              <1> int_1A_fn06:
  1812 00001042 50                  <1> 	push	ax
  1813 00001043 B00B                <1> 	mov	al,cmos_control_b
  1814 00001045 E8DAFA              <1> 	call	rtc_read		; read control B register
  1815 00001048 A820                <1> 	test	al,cmos_aie
  1816 0000104A 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1817 0000104C F9                  <1> 	stc
  1818 0000104D 58                  <1> 	pop	ax
  1819 0000104E E9476E              <1> 	jmp	int_1A_exitf
  1820                              <1> .1:
  1821 00001051 88C4                <1> 	mov	ah,al
  1822 00001053 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1823 00001056 B00B                <1> 	mov	al,cmos_control_b
  1824 00001058 E8D2FA              <1> 	call	rtc_write		; write control B register
  1825                              <1> 
  1826 0000105B B001                <1> 	mov	al,cmos_alarm_secs
  1827 0000105D 88F4                <1> 	mov	ah,dh
  1828 0000105F E8CBFA              <1> 	call	rtc_write		; write alarm seconds
  1829 00001062 B003                <1> 	mov	al,cmos_alarm_mins
  1830 00001064 88CC                <1> 	mov	ah,cl
  1831 00001066 E8C4FA              <1> 	call	rtc_write		; write alarm minutes
  1832 00001069 B005                <1> 	mov	al,cmos_alarm_hrs
  1833 0000106B 88EC                <1> 	mov	ah,ch
  1834 0000106D E8BDFA              <1> 	call	rtc_write		; write alarm hours
  1835                              <1> 
  1836 00001070 B00B                <1> 	mov	al,cmos_control_b
  1837 00001072 E8ADFA              <1> 	call	rtc_read		; read control B register
  1838 00001075 88C4                <1> 	mov	ah,al
  1839 00001077 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1840 0000107A B00B                <1> 	mov	al,cmos_control_b
  1841 0000107C E8AEFA              <1> 	call	rtc_write		; write control B register
  1842                              <1> 
  1843 0000107F B00B                <1> 	mov	al,cmos_control_b
  1844 00001081 E89EFA              <1> 	call	rtc_read		; read control B register
  1845 00001084 88C4                <1> 	mov	ah,al
  1846 00001086 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1847 00001089 B00B                <1> 	mov	al,cmos_control_b
  1848 0000108B E89FFA              <1> 	call	rtc_write		; write control B register with AIE set
  1849                              <1> 
  1850 0000108E 58                  <1> 	pop	ax
  1851 0000108F F8                  <1> 	clc
  1852 00001090 E9056E              <1> 	jmp	int_1A_exitf
  1853                              <1> 
  1854                              <1> ;=========================================================================
  1855                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1856                              <1> ; Input:
  1857                              <1> ;	AH = 07h - function 07h - set RTC time
  1858                              <1> ; Output:
  1859                              <1> ;	None
  1860                              <1> ;-------------------------------------------------------------------------
  1861                              <1> int_1A_fn07:
  1862 00001093 50                  <1> 	push	ax
  1863                              <1> 
  1864 00001094 B00B                <1> 	mov	al,cmos_control_b
  1865 00001096 E889FA              <1> 	call	rtc_read		; read control B register
  1866 00001099 88C4                <1> 	mov	ah,al
  1867 0000109B 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1868 0000109E B00B                <1> 	mov	al,cmos_control_b
  1869 000010A0 E88AFA              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1870                              <1> 
  1871 000010A3 58                  <1> 	pop	ax
  1872 000010A4 E9EE6D              <1> 	jmp	int_1A_exit
  1873                              <1> 	
  1874                              <1> ;=========================================================================
  1875                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1876                              <1> ; Notes:
  1877                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1878                              <1> ;-------------------------------------------------------------------------
  1879                              <1> int_70:
  1880 000010A7 50                  <1> 	push	ax
  1881 000010A8 B020                <1> 	mov	al,20h
  1882 000010AA E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1883 000010AC E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1884 000010AE B00C                <1> 	mov	al,cmos_control_c
  1885 000010B0 E86FFA              <1> 	call	rtc_read		; read control C register
  1886 000010B3 A840                <1> 	test	al,cmos_af		; check for alarm flag
  1887 000010B5 7402                <1> 	jz	.1
  1888 000010B7 CD4A                <1> 	int	4Ah			; call INT 4Ah
  1889                              <1> .1:
  1890 000010B9 58                  <1> 	pop	ax
  1891 000010BA CF                  <1> 	iret
  1892                                  %include	"floppy1.inc"		; floppy services
  1893                              <1> ;=========================================================================
  1894                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
  1895                              <1> ;       INT 13h, function AH=00h
  1896                              <1> ;       INT 13h, function AH=01h
  1897                              <1> ;       INT 13h, function AH=08h
  1898                              <1> ;       INT 13h, function AH=15h
  1899                              <1> ;       INT 13h, function AH=16h
  1900                              <1> ;       INT 13h, function AH=17h
  1901                              <1> ;       INT 13h, function AH=18h
  1902                              <1> ;       INT 13h, function AH=08h
  1903                              <1> ;	- see floppy2.inc for other INT 13h functions
  1904                              <1> ;-------------------------------------------------------------------------
  1905                              <1> ;
  1906                              <1> ; Compiles with NASM 2.07, might work with other versions
  1907                              <1> ;
  1908                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1909                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1910                              <1> ;
  1911                              <1> ; This program is free software: you can redistribute it and/or modify
  1912                              <1> ; it under the terms of the GNU General Public License as published by
  1913                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1914                              <1> ; (at your option) any later version.
  1915                              <1> ;
  1916                              <1> ; This program is distributed in the hope that it will be useful,
  1917                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1918                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1919                              <1> ; GNU General Public License for more details.
  1920                              <1> ;
  1921                              <1> ; You should have received a copy of the GNU General Public License
  1922                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1923                              <1> ;
  1924                              <1> ;=========================================================================
  1925                              <1> 
  1926                              <1> ;-------------------------------------------------------------------------
  1927                              <1> ; FDC registers
  1928                              <1> 
  1929                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1930                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1931                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1932                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1933                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1934                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1935                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1936                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1937                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1938                              <1> 
  1939                              <1> ;-------------------------------------------------------------------------
  1940                              <1> ; DMAC registers
  1941                              <1> 
  1942                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1943                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1944                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1945                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1946                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1947                              <1> 					; first / last flip-flop
  1948                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1949                              <1> 
  1950                              <1> ;-------------------------------------------------------------------------
  1951                              <1> ; Floppy disk services - error codes
  1952                              <1> 
  1953                              <1> fdc_e_success	equ	00h		; successful completion
  1954                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1955                              <1> fdc_e_address	equ	02h		; address mark not found
  1956                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1957                              <1> fdc_e_notfound	equ	04h		; sector not found
  1958                              <1> fdc_e_changed	equ	06h		; disk changed
  1959                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1960                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1961                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1962                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1963                              <1> fdc_e_failure	equ	20h		; controller failure
  1964                              <1> fdc_e_seek	equ	40h		; seek failed
  1965                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1966                              <1> 
  1967                              <1> ;-------------------------------------------------------------------------
  1968                              <1> ; Drive media state for fdc_media_state
  1969                              <1> 
  1970                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1971                              <1> 					; 00b = 500 Kbit/sec
  1972                              <1> 					; 01b = 300 Kbit/sec
  1973                              <1> 					; 10b = 250 Kbit/sec
  1974                              <1> 					; 11b = 1 Mbit/sec
  1975                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
  1976                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
  1977                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1978                              <1> 					; 000b = trying 360K in 360K drive
  1979                              <1> 					; 001b = trying 360K in 1.2M drive
  1980                              <1> 					; 010b = trying 1.2M in 1.2M drive
  1981                              <1> 					; 011b = known 360K in 360K drive
  1982                              <1> 					; 100b = known 360K in 1.2M drive
  1983                              <1> 					; 101b = known 1.2M in 1.2M drive
  1984                              <1> 					; 110b = not used
  1985                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
  1986                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1987                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1988                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
  1989                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1990                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1991                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1992                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1993                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1994                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  1995                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  1996                              <1> 
  1997                              <1> ;-------------------------------------------------------------------------
  1998                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  1999                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  2000                              <1> 
  2001                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  2002                              <1> 
  2003                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  2004                              <1> ;	       unset for read or verify
  2005                              <1> 
  2006                              <1> fdc_write_flag	equ	80h		; write or format operation
  2007                              <1> 
  2008                              <1> ;-------------------------------------------------------------------------
  2009                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  2010                              <1> 
  2011                              <1> cmos_no_floppy	equ	00h
  2012                              <1> cmos_360	equ	01h
  2013                              <1> cmos_1200	equ	02h
  2014                              <1> cmos_720	equ	03h
  2015                              <1> cmos_1440	equ	04h
  2016                              <1> cmos_2880	equ	06h
  2017                              <1> 
  2018                              <1> ;=========================================================================
  2019                              <1> ; int_13_fn00: Reset disk system
  2020                              <1> ; Input:
  2021                              <1> ;	AH = 00h
  2022                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2023                              <1> ; Output:
  2024                              <1> ;	CF clear if successful
  2025                              <1> ;		AH = 00h - successful completion
  2026                              <1> ;	CF set on error
  2027                              <1> ;		AH = 20h - controller failure
  2028                              <1> ;		AH = 80h - timeout / device not ready
  2029                              <1> ; Note:
  2030                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2031                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2032                              <1> ;-------------------------------------------------------------------------
  2033                              <1> int_13_fn00:
  2034 000010BB E80700              <1> 	call	fdc_init
  2035 000010BE 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2036 000010C2 E9115C              <1> 	jmp	int_13_exit
  2037                              <1> 
  2038                              <1> ;=========================================================================
  2039                              <1> ; fdc_init - Initialize floppy disk controller
  2040                              <1> ; Input:
  2041                              <1> ;	none
  2042                              <1> ; Output:
  2043                              <1> ;	CF clear on success
  2044                              <1> ;		AH = 00h - successful completion
  2045                              <1> ;	CF set if error
  2046                              <1> ;		AH = 20h - controller failure
  2047                              <1> ;		AH = 80h - timeout / device not ready
  2048                              <1> ;-------------------------------------------------------------------------
  2049                              <1> fdc_init:
  2050 000010C5 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  2051 000010CA E80906              <1> 	call	fdc_reset		; reset FDC
  2052 000010CD 7257                <1> 	jc	fdc_init_error
  2053 000010CF BAF403              <1> 	mov	dx,fdc_status_reg
  2054 000010D2 EC                  <1> 	in	al,dx
  2055 000010D3 A880                <1> 	test	al,80h
  2056 000010D5 7404                <1> 	jz	.try_again		; try again if FDC not ready
  2057 000010D7 A840                <1> 	test	al,40h
  2058 000010D9 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  2059                              <1> .try_again:
  2060 000010DB E8F805              <1> 	call	fdc_reset
  2061 000010DE BAF403              <1> 	mov	dx,fdc_status_reg
  2062 000010E1 EC                  <1> 	in	al,dx
  2063 000010E2 A880                <1> 	test	al,80h
  2064 000010E4 7440                <1> 	jz	fdc_init_error
  2065 000010E6 A840                <1> 	test	al,40h
  2066 000010E8 753C                <1> 	jnz	fdc_init_error
  2067                              <1> .fdc_ready:
  2068 000010EA B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2069 000010EC E83905              <1> 	call	fdc_write		; send the command
  2070 000010EF 7235                <1> 	jc	fdc_init_error
  2071 000010F1 E88105              <1> 	call	fdc_read		; read ST0
  2072 000010F4 7230                <1> 	jc	fdc_init_error
  2073 000010F6 A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  2074 000010F9 88C4                <1> 	mov	ah,al			; save AL to AH
  2075 000010FB E87705              <1> 	call	fdc_read		; read current cylinder
  2076 000010FE 7226                <1> 	jc	fdc_init_error
  2077 00001100 A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  2078 00001103 80E4C0              <1> 	and	ah,0C0h
  2079 00001106 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  2080 00001109 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  2081                              <1> 
  2082                              <1> ; fall through to fdc_send_specify
  2083                              <1> 
  2084                              <1> ;=========================================================================
  2085                              <1> ; fdc_send_specify - Send specify command to FDC
  2086                              <1> ; Input:
  2087                              <1> ;	none
  2088                              <1> ; Output:
  2089                              <1> ;	CF clear on success
  2090                              <1> ;		AH = 00 - successful completion
  2091                              <1> ;	CF set if error
  2092                              <1> ;		AH = 20h - controller failure
  2093                              <1> ;	AX,CL,SI trashed
  2094                              <1> ; Note:
  2095                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  2096                              <1> ;-------------------------------------------------------------------------
  2097                              <1> fdc_send_specify:
  2098                              <1> 
  2099 0000110B 1E                  <1> 	push	ds
  2100 0000110C 31C0                <1> 	xor	ax,ax
  2101 0000110E 8ED8                <1> 	mov	ds,ax
  2102 00001110 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2103 00001114 B003                <1> 	mov	al,3		 	; FDC Specify command
  2104 00001116 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  2105 00001118 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  2106 0000111B B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  2107 0000111D 1F                  <1> 	pop	ds
  2108 0000111E E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  2109 00001121 7203                <1> 	jc	fdc_init_error
  2110 00001123 B400                <1> 	mov	ah,fdc_e_success	; successful completion
  2111 00001125 C3                  <1> 	ret
  2112                              <1> 
  2113                              <1> fdc_init_error:
  2114 00001126 B420                <1> 	mov	ah,fdc_e_failure
  2115 00001128 F9                  <1> 	stc
  2116 00001129 C3                  <1> 	ret
  2117                              <1> 
  2118                              <1> ;=========================================================================
  2119                              <1> ; int_13_fn01 - Get status of last operation
  2120                              <1> ; Input:
  2121                              <1> ;	AH = 01h
  2122                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2123                              <1> ; Output:
  2124                              <1> ;	CF clear if last operation was successful
  2125                              <1> ;		AH = 00h - successful completion
  2126                              <1> ;	CF set on error
  2127                              <1> ;		AH - error code of the last operation
  2128                              <1> ; Note:
  2129                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2130                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2131                              <1> ;-------------------------------------------------------------------------
  2132                              <1> int_13_fn01:
  2133 0000112A 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  2134 0000112E 08E4                <1> 	or	ah,ah
  2135 00001130 7401                <1> 	jz	.no_error
  2136 00001132 F9                  <1> 	stc
  2137                              <1> .no_error:
  2138 00001133 E9A05B              <1> 	jmp	int_13_exit
  2139                              <1> 
  2140                              <1> ;=========================================================================
  2141                              <1> ; int_13_fn08: Get drive parameters
  2142                              <1> ; Input:
  2143                              <1> ;	AH = 08h
  2144                              <1> ;	DL = drive number (0 - 7Fh)
  2145                              <1> ; Output:
  2146                              <1> ;	CF clear if successful
  2147                              <1> ;		AX = 0000h
  2148                              <1> ;		BH = 00h
  2149                              <1> ;		BL = CMOS drive type
  2150                              <1> ;		CH = maximal cylinder number - 1
  2151                              <1> ;		CL = maximal sector number
  2152                              <1> ;		DH = maximal head number
  2153                              <1> ;		DL = number of drives
  2154                              <1> ;		ES:DI -> diskette parameter table
  2155                              <1> ;	CF set on error
  2156                              <1> ;		AH = 01h - drive number is greater than 7Fh
  2157                              <1> ; Notes:
  2158                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  2159                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  2160                              <1> ;	- If media type is not established function sets media parameters 
  2161                              <1> ;	based on CMOS drive type
  2162                              <1> ;-------------------------------------------------------------------------
  2163                              <1> int_13_fn08:
  2164 00001136 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  2165 00001139 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  2166 0000113E A01000              <1> 	mov	al,byte [equipment_list]
  2167 00001141 2441                <1> 	and	al,equip_floppies|equip_floppy2
  2168 00001143 B402                <1> 	mov	ah,2			; assume two floppy drives
  2169 00001145 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  2170 00001147 7406                <1> 	je	.check_drive_number
  2171 00001149 FECC                <1> 	dec	ah			; assume one floppy drive
  2172 0000114B 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  2173 0000114D 757C                <1> 	jne	.no_drives
  2174                              <1> 
  2175                              <1> .check_drive_number:
  2176 0000114F 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  2177 00001152 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  2178                              <1> 					; than number of disks?
  2179 00001154 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  2180 00001156 E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  2181 00001159 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  2182                              <1> 
  2183 0000115B C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  2184 0000115F 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  2185 00001162 8CC9                <1> 	mov	cx,cs
  2186 00001164 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  2187                              <1> 
  2188 00001166 3C01                <1> 	cmp	al,cmos_360
  2189 00001168 7417                <1> 	je	.set_360
  2190 0000116A 3C03                <1> 	cmp	al,cmos_720
  2191 0000116C 741E                <1> 	je	.set_720
  2192 0000116E 3C02                <1> 	cmp	al,cmos_1200
  2193 00001170 7425                <1> 	je	.set_1200
  2194 00001172 3C04                <1> 	cmp	al,cmos_1440
  2195 00001174 742C                <1> 	je	.set_1440
  2196                              <1> 
  2197                              <1> .set_2880:
  2198 00001176 B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  2199 00001178 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  2200 0000117C B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  2201 0000117F EB2A                <1> 	jmp	.set_media_type
  2202                              <1> 
  2203                              <1> .set_360:
  2204 00001181 B093                <1> 	mov	al,fdc_m_360in360
  2205 00001183 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2206 00001187 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  2207 0000118A EB1F                <1> 	jmp	.set_media_type
  2208                              <1> 
  2209                              <1> .set_720:
  2210 0000118C B097                <1> 	mov	al,fdc_m_720
  2211 0000118E 8D3E[896F]          <1> 	lea	di,[media_720]
  2212 00001192 B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  2213 00001195 EB14                <1> 	jmp	.set_media_type
  2214                              <1> 
  2215                              <1> .set_1200:
  2216 00001197 B002                <1> 	mov	al,fdc_m_try_1200in1200
  2217 00001199 8D3E[7C6F]          <1> 	lea	di,[media_1200]
  2218 0000119D B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  2219 000011A0 EB09                <1> 	jmp	.set_media_type
  2220                              <1> 
  2221                              <1> .set_1440:
  2222 000011A2 B007                <1> 	mov	al,fdc_m_try_1440
  2223 000011A4 8D3E[966F]          <1> 	lea	di,[media_1440]
  2224 000011A8 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  2225                              <1> 
  2226                              <1> .set_media_type:
  2227 000011AB BB9000              <1> 	mov	bx,fdc_media_state
  2228 000011AE 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2229 000011B0 F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  2230 000011B3 7502                <1> 	jnz	.set_parameters		; no need to update if established
  2231 000011B5 8807                <1> 	mov	[bx],al
  2232                              <1> 
  2233                              <1> .set_parameters:
  2234 000011B7 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  2235 000011B9 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  2236 000011BC A24100              <1> 	mov	byte [fdc_last_error],al
  2237 000011BF 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  2238 000011C2 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  2239 000011C5 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  2240 000011C8 E90B5B              <1> 	jmp	int_13_exit
  2241                              <1> 
  2242                              <1> .no_drives:
  2243 000011CB C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  2244                              <1> 
  2245                              <1> .non_existent_drive:
  2246 000011CF 31C9                <1> 	xor	cx,cx
  2247 000011D1 31FF                <1> 	xor	di,di
  2248 000011D3 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  2249 000011D6 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  2250 000011D9 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  2251 000011DB EBDA                <1> 	jmp	.set_parameters
  2252                              <1> 
  2253                              <1> .invalid_drive:
  2254 000011DD B401                <1> 	mov	ah,fdc_e_invalid
  2255 000011DF F9                  <1> 	stc
  2256 000011E0 E9F35A              <1> 	jmp	int_13_exit
  2257                              <1> 
  2258                              <1> ;=========================================================================
  2259                              <1> ; int_13_fn15: Get disk type
  2260                              <1> ; Input:
  2261                              <1> ;	AH = 15h
  2262                              <1> ;	DL = drive number (0 or 1)
  2263                              <1> ; Output:
  2264                              <1> ;	AH = type code:
  2265                              <1> ;		00h - no such drive (invalid drive specified)
  2266                              <1> ;		01h - floppy without change-line support
  2267                              <1> ;		02h - floppy with change-line support
  2268                              <1> ;-------------------------------------------------------------------------
  2269                              <1> int_13_fn15:
  2270 000011E3 B400                <1> 	mov	ah,00h			; assume no drive
  2271 000011E5 80FA01              <1> 	cmp	dl,1
  2272 000011E8 7711                <1> 	ja	.exit			; jump if invalid drive number
  2273 000011EA E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  2274 000011ED 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  2275 000011EF B401                <1> 	mov	ah,01h			; assume no change-line support
  2276 000011F1 3C01                <1> 	cmp	al,cmos_360
  2277 000011F3 7406                <1> 	je	.exit
  2278 000011F5 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  2279 000011F7 7402                <1> 	je	.exit
  2280 000011F9 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  2281                              <1> 
  2282                              <1> .exit:
  2283 000011FB F8                  <1> 	clc
  2284 000011FC C606410000          <1> 	mov	byte [fdc_last_error],0
  2285 00001201 E9D25A              <1> 	jmp	int_13_exit
  2286                              <1> 
  2287                              <1> ;=========================================================================
  2288                              <1> ; int_13_fn16 - Detect disk change
  2289                              <1> ; Input:
  2290                              <1> ;	AH = 16h
  2291                              <1> ;	DL = drive number (0 or 1)
  2292                              <1> ; Output:
  2293                              <1> ;	CF clear if change line inactive
  2294                              <1> ;		AH = 00h - disk not changed
  2295                              <1> ;	CF set if change line active or error
  2296                              <1> ;		AH = 01h - invalid drive number
  2297                              <1> ;		AH = 06h - disk changed or change line not supported
  2298                              <1> ;		AH = 80h - timeout / device not ready
  2299                              <1> ;-------------------------------------------------------------------------
  2300                              <1> int_13_fn16:
  2301 00001204 80FA01              <1> 	cmp	dl,1
  2302 00001207 7741                <1> 	ja	.invalid_drive
  2303 00001209 E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  2304 0000120C 723C                <1> 	jc	.invalid_drive
  2305                              <1> 
  2306 0000120E 3C01                <1> 	cmp	al,cmos_360
  2307 00001210 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  2308 00001212 3C03                <1> 	cmp	al,cmos_720
  2309 00001214 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  2310                              <1> 
  2311 00001216 E86302              <1> 	call	fdc_motor_on		; turn motor on
  2312 00001219 30E4                <1> 	xor	ah,ah			; assume disk not changed
  2313 0000121B BAF703              <1> 	mov	dx,fdc_dir_reg
  2314 0000121E EC                  <1> 	in	al,dx			; read disk change line
  2315 0000121F D0E0                <1> 	shl	al,1			; bit 7 to CF
  2316 00001221 7303                <1> 	jnc	.exit
  2317 00001223 B406                <1> 	mov	ah,fdc_e_changed
  2318 00001225 F9                  <1> 	stc
  2319                              <1> 
  2320                              <1> .exit:
  2321 00001226 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2322 0000122A 9C                  <1> 	pushf
  2323 0000122B 1E                  <1> 	push	ds
  2324 0000122C 31F6                <1> 	xor	si,si
  2325 0000122E 8EDE                <1> 	mov	ds,si
  2326 00001230 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2327 00001234 8A4C02              <1> 	mov	cl,byte [si+2]
  2328 00001237 1F                  <1> 	pop	ds
  2329 00001238 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  2330 0000123C 9D                  <1> 	popf
  2331 0000123D E9965A              <1> 	jmp	int_13_exit
  2332                              <1> 
  2333                              <1> 
  2334                              <1> .no_change_line:
  2335 00001240 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  2336 00001242 F9                  <1> 	stc
  2337 00001243 88264100            <1> 	mov	byte [fdc_last_error],ah
  2338 00001247 E98C5A              <1> 	jmp	int_13_exit
  2339                              <1> 
  2340                              <1> .invalid_drive:
  2341 0000124A B401                <1> 	mov	ah,fdc_e_invalid
  2342 0000124C F9                  <1> 	stc
  2343 0000124D E9865A              <1> 	jmp	int_13_exit
  2344                              <1> 
  2345                              <1> ;=========================================================================
  2346                              <1> ; int_13_fn17 - Set disk type for format
  2347                              <1> ; Input:
  2348                              <1> ;	AH = 17h
  2349                              <1> ;	AL = format type
  2350                              <1> ;		01h - 320K / 360K disk in 360K drive
  2351                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  2352                              <1> ;		03h - 1.2M disk in 1.2M drive
  2353                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  2354                              <1> ;	DL = drive number (0 or 1)
  2355                              <1> ; Output:
  2356                              <1> ;	CF clear if successful
  2357                              <1> ;		AH = 00h - successful completion
  2358                              <1> ;	CF set on error
  2359                              <1> ;		AH = 01h - invalid drive number
  2360                              <1> ;		AH = 06h - disk changed
  2361                              <1> ;		AH = 80h - timeout / device not ready
  2362                              <1> ;-------------------------------------------------------------------------
  2363                              <1> int_13_fn17:
  2364 00001250 80FA01              <1> 	cmp	dl,1
  2365 00001253 7762                <1> 	ja	.invalid_parameters
  2366 00001255 E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  2367 00001258 725D                <1> 	jc	.invalid_parameters
  2368 0000125A 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  2369 0000125D 80F900              <1> 	cmp	cl,0			; validate parameters
  2370 00001260 7455                <1> 	je	.invalid_parameters
  2371 00001262 80F904              <1> 	cmp	cl,4
  2372 00001265 7750                <1> 	ja	.invalid_parameters
  2373 00001267 BB9000              <1> 	mov	bx,fdc_media_state
  2374 0000126A 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2375 0000126C 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  2376 0000126F 7507                <1> 	jne	.not_360in360
  2377 00001271 C60793              <1> 	mov	byte [bx],fdc_m_360in360
  2378 00001274 B400                <1> 	mov	ah,0			; no error
  2379 00001276 EB33                <1> 	jmp	.exit_check_error
  2380                              <1> 
  2381                              <1> .not_360in360:
  2382 00001278 E80102              <1> 	call	fdc_motor_on
  2383 0000127B 89DE                <1> 	mov	si,bx
  2384 0000127D E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  2385 00001280 80FC06              <1> 	cmp	ah,fdc_e_changed
  2386 00001283 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  2387 00001285 80FC80              <1> 	cmp	ah,fdc_e_timeout
  2388 00001288 750A                <1> 	jne	.set_type		; floppy disk is installed
  2389 0000128A 803F97              <1> 	cmp	byte [bx],fdc_m_720	; 250 Kbps and not 5.25?
  2390 0000128D 741C                <1> 	je	.exit_check_error
  2391 0000128F C60761              <1> 	mov	byte [bx],fdc_m_try_360in1200 ; 300 Kpbs, try 360 in 1.2M
  2392 00001292 EB17                <1> 	jmp	.exit_check_error
  2393                              <1> 
  2394                              <1> .set_type:
  2395 00001294 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  2396 00001297 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  2397 00001299 C60797              <1> 	mov	byte [bx],fdc_m_720
  2398 0000129C EB0D                <1> 	jmp	.exit_check_error
  2399                              <1> 
  2400                              <1> .check_360in1200:
  2401 0000129E 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  2402 000012A1 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  2403 000012A3 C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  2404 000012A6 EB03                <1> 	jmp	.exit_check_error
  2405                              <1> 
  2406                              <1> .set_1200in1200:
  2407 000012A8 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  2408                              <1> 
  2409                              <1> .exit_check_error:
  2410 000012AB 88264100            <1> 	mov	byte [fdc_last_error],ah
  2411 000012AF 08E4                <1> 	or	ah,ah
  2412 000012B1 7401                <1> 	jz	.exit			; jump if no error
  2413 000012B3 F9                  <1> 	stc				; indicate error
  2414                              <1> 
  2415                              <1> .exit:
  2416 000012B4 E9FE59              <1> 	jmp	int_13_upd_exit
  2417                              <1> 
  2418                              <1> .invalid_parameters:
  2419 000012B7 B401                <1> 	mov	ah,fdc_e_invalid
  2420 000012B9 EBF9                <1> 	jmp	.exit
  2421                              <1> 
  2422                              <1> ;=========================================================================
  2423                              <1> ; int_13_fn18 - Set media type for format
  2424                              <1> ; Input:
  2425                              <1> ;	AH = 18h
  2426                              <1> ;	DL = drive number (0 or 1)
  2427                              <1> ;	CH = number of cylinders - 1
  2428                              <1> ;	CL = sectors per track
  2429                              <1> ; Output:
  2430                              <1> ;	CF = clear if successful
  2431                              <1> ;		AH = 00h - requested format is supported
  2432                              <1> ;		ES:DI -> diskette parameter table
  2433                              <1> ;	CF = set on error
  2434                              <1> ;		AH = 01h - invalid drive number specified
  2435                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  2436                              <1> ;-------------------------------------------------------------------------
  2437                              <1> int_13_fn18:
  2438 000012BB 80FA01              <1> 	cmp	dl,1
  2439 000012BE 7603E99900          <1> 	ja	.invalid_drive
  2440 000012C3 E84504              <1> 	call	read_cmos_type		; get drive type in AL
  2441 000012C6 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  2442                              <1> 
  2443 000012CB BB9000              <1> 	mov	bx,fdc_media_state
  2444 000012CE 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2445                              <1> 
  2446 000012D0 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  2447 000012D2 7511                <1> 	jne	.try_drive_1200
  2448 000012D4 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  2449 000012D8 7403E98300          <1> 	jnz	.unsupported_format
  2450 000012DD B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
  2451 000012DF 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2452 000012E3 EB54                <1> 	jmp	.set_media
  2453                              <1> 
  2454                              <1> .try_drive_1200:
  2455 000012E5 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2456 000012E7 751C                <1> 	jne	.try_drive_2880
  2457 000012E9 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2458 000012ED 7508                <1> 	jne	.try_media_360_in_1200
  2459 000012EF B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
  2460 000012F1 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
  2461 000012F5 EB42                <1> 	jmp	.set_media
  2462                              <1> 
  2463                              <1> .try_media_360_in_1200:
  2464 000012F7 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2465 000012FB 7563                <1> 	jne	.unsupported_format
  2466 000012FD B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
  2467 000012FF 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2468 00001303 EB34                <1> 	jmp	.set_media
  2469                              <1> 
  2470                              <1> .try_drive_2880:
  2471 00001305 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2472 00001307 750E                <1> 	jne	.try_drive_1440
  2473 00001309 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2474 0000130D 750C                <1> 	jne	.try_media_1440
  2475 0000130F B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2476 00001311 8D3E[B06F]          <1> 	lea	di,[media_2880]
  2477 00001315 EB22                <1> 	jmp	.set_media
  2478                              <1> 
  2479                              <1> .try_drive_1440:
  2480 00001317 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2481 00001319 750E                <1> 	jne	.try_drive_720
  2482                              <1> 
  2483                              <1> .try_media_1440:
  2484 0000131B 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2485 0000131F 750C                <1> 	jne	.try_media_720
  2486 00001321 B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2487 00001323 8D3E[966F]          <1> 	lea	di,[media_1440]
  2488 00001327 EB10                <1> 	jmp	.set_media
  2489                              <1> 
  2490                              <1> .try_drive_720:
  2491 00001329 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2492 0000132B 7533                <1> 	jne	.unsupported_format	; should never happen...
  2493                              <1> 
  2494                              <1> .try_media_720:	
  2495 0000132D 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2496 00001331 752D                <1> 	jne	.unsupported_format
  2497 00001333 B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
  2498 00001335 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
  2499                              <1> 
  2500                              <1> .set_media:
  2501 00001339 8807                <1> 	mov	byte [bx],al		; set physical media
  2502 0000133B E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2503 0000133E D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2504 00001340 D0C8                <1> 	ror	al,1
  2505 00001342 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2506 00001347 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2507 0000134B 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2508 0000134E 8CC9                <1> 	mov	cx,cs
  2509 00001350 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2510 00001352 C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2511 00001357 30E4                <1> 	xor	ah,ah
  2512 00001359 E95959              <1> 	jmp	int_13_upd_exit
  2513                              <1> 
  2514                              <1> .invalid_drive:
  2515 0000135C B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2516 0000135E EB02                <1> 	jmp	.error
  2517                              <1> 
  2518                              <1> .unsupported_format:
  2519 00001360 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2520                              <1> 
  2521                              <1> .error:
  2522 00001362 F9                  <1> 	stc
  2523 00001363 E94F59              <1> 	jmp	int_13_upd_exit
  2524                              <1> 
  2525                              <1> ;=========================================================================
  2526                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2527                              <1> ; Input:
  2528                              <1> ;	DL = drive number (0 or 1)
  2529                              <1> ; Output:
  2530                              <1> ;	CF clear if successful
  2531                              <1> ;		AH = 00h - successful completion
  2532                              <1> ;	CF set on error
  2533                              <1> ;		AH = 20h - controller failure
  2534                              <1> ;		AH = 20h - timeout
  2535                              <1> ;	AH trashed
  2536                              <1> ;-------------------------------------------------------------------------
  2537                              <1> fdc_recalibrate:
  2538 00001366 56                  <1> 	push	si
  2539 00001367 51                  <1> 	push	cx
  2540 00001368 52                  <1> 	push	dx
  2541 00001369 B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2542 0000136B 88D4                <1> 	mov	ah,dl			; drive number
  2543 0000136D B102                <1> 	mov	cl,2			; 2 bytes command
  2544 0000136F 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2545 00001374 E86502              <1> 	call	fdc_send_cmd
  2546 00001377 7244                <1> 	jc	recal_end		; failure
  2547 00001379 E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2548 0000137C 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2549 0000137E B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2550 00001380 B101                <1> 	mov	cl,1			; 1 byte command
  2551 00001382 E85702              <1> 	call	fdc_send_cmd
  2552 00001385 7236                <1> 	jc	recal_end		; failure
  2553 00001387 B90200              <1> 	mov	cx,2			; 2 bytes result
  2554 0000138A E8B402              <1> 	call	fdc_get_result		; store result
  2555 0000138D 722E                <1> 	jc	recal_end		; failure
  2556 0000138F BB4200              <1> 	mov	bx,fdc_ctrl_status
  2557 00001392 B440                <1> 	mov	ah,fdc_e_seek
  2558 00001394 8A17                <1> 	mov	dl,[bx]			; ST0
  2559 00001396 80E260              <1> 	and	dl,60h
  2560 00001399 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2561 0000139C F9                  <1> 	stc				; indicate error
  2562 0000139D 741E                <1> 	je	recal_end		; failure
  2563 0000139F 5A                  <1> 	pop	dx
  2564 000013A0 52                  <1> 	push	dx
  2565 000013A1 30F6                <1> 	xor	dh,dh				 
  2566 000013A3 BB9400              <1> 	mov	bx,fdc_cylinder
  2567 000013A6 01D3                <1> 	add	bx,dx
  2568 000013A8 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2569 000013AB 88D1                <1> 	mov	cl,dl
  2570 000013AD B201                <1> 	mov	dl,1
  2571 000013AF D2E2                <1> 	shl	dl,cl
  2572 000013B1 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2573 000013B5 B94300              <1> 	mov	cx,43h
  2574 000013B8 E868FB              <1> 	call	delay_15us		; 1 ms delay
  2575 000013BB 30E4                <1> 	xor	ah,ah
  2576                              <1> 
  2577                              <1> recal_end:
  2578 000013BD 88264100            <1> 	mov	byte [fdc_last_error],ah
  2579 000013C1 5A                  <1> 	pop	dx
  2580 000013C2 59                  <1> 	pop	cx
  2581 000013C3 5E                  <1> 	pop	si
  2582 000013C4 C3                  <1> 	ret
  2583                              <1> 
  2584                              <1> ;=========================================================================
  2585                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2586                              <1> ; Input:
  2587                              <1> ;	DL = drive number
  2588                              <1> ;	DH = head number
  2589                              <1> ;	CH = cylinder
  2590                              <1> ; Output:
  2591                              <1> ;	CF clear if successful
  2592                              <1> ;		AH = 00h - successful completion
  2593                              <1> ;	CF set on error
  2594                              <1> ;		AH = 20h - controller failure
  2595                              <1> ;		AH = 40h - seek failed
  2596                              <1> ;		AH = 80h - timeout / device not ready
  2597                              <1> ;-------------------------------------------------------------------------
  2598                              <1> fdc_seek:
  2599 000013C5 53                  <1> 	push	bx
  2600 000013C6 51                  <1> 	push	cx
  2601 000013C7 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2602 000013CB 88D1                <1> 	mov	cl,dl
  2603 000013CD FEC1                <1> 	inc	cl
  2604 000013CF D2EC                <1> 	shr	ah,cl
  2605 000013D1 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2606 000013D3 E890FF              <1> 	call	fdc_recalibrate
  2607 000013D6 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2608 000013D8 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2609 000013DB 727F                <1> 	jc	.exit			; no luck...
  2610                              <1> 
  2611                              <1> .skip_recalibrate:
  2612 000013DD B700                <1> 	mov	bh,00h
  2613 000013DF 88D3                <1> 	mov	bl,dl			; BX = drive number
  2614 000013E1 F687900020          <1> 	test	byte [fdc_media_state+bx],fdc_m_double_step ; check double
  2615                              <1> 					; steppig bit
  2616 000013E6 7402                <1> 	jz	.no_double_stepping
  2617 000013E8 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2618                              <1> 
  2619                              <1> .no_double_stepping:
  2620 000013EA 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2621 000013EE 750B                <1> 	jne	.do_seek		; jump if seek is required
  2622 000013F0 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2623 000013F5 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2624 000013F7 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2625 000013F9 EB61                <1> 	jmp	.exit
  2626                              <1> 
  2627                              <1> .do_seek:
  2628 000013FB 88E8                <1> 	mov	al,ch			; cylinder
  2629 000013FD 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2630 000013FF B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2631 00001401 88F4                <1> 	mov	ah,dh			; head
  2632 00001403 D0E4                <1> 	shl	ah,1
  2633 00001405 D0E4                <1> 	shl	ah,1
  2634 00001407 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2635 00001409 B103                <1> 	mov	cl,3			; 3 bytes command
  2636 0000140B 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2637 00001410 E8C901              <1> 	call	fdc_send_cmd
  2638 00001413 7243                <1> 	jc	.set_result		; seek error
  2639 00001415 E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2640 00001418 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2641                              <1> 
  2642 0000141A B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2643 0000141C B101                <1> 	mov	cl,1			; 1 byte command
  2644 0000141E E8BB01              <1> 	call	fdc_send_cmd
  2645 00001421 7235                <1> 	jc	.set_result		; failure
  2646 00001423 B102                <1> 	mov	cl,2
  2647 00001425 53                  <1> 	push	bx
  2648 00001426 E81802              <1> 	call	fdc_get_result		; read result bytes
  2649 00001429 5B                  <1> 	pop	bx
  2650 0000142A 722C                <1> 	jc	.set_result		; error
  2651 0000142C B440                <1> 	mov	ah,fdc_e_seek
  2652 0000142E A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2653 00001431 2460                <1> 	and	al,60h
  2654 00001433 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2655 00001435 F9                  <1> 	stc
  2656 00001436 7420                <1> 	je	.set_result		; seek error
  2657 00001438 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2658                              <1> 
  2659 0000143C 1E                  <1> 	push	ds
  2660 0000143D 31F6                <1> 	xor	si,si
  2661 0000143F 8EDE                <1> 	mov	ds,si
  2662 00001441 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2663 00001445 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2664 00001448 1F                  <1> 	pop	ds
  2665                              <1> 
  2666 00001449 08C0                <1> 	or	al,al			; head settle time is zero?!
  2667 0000144B 7412                <1> 	jz	.get_settle_time
  2668                              <1> 
  2669 0000144D B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2670 0000144F F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2671 00001451 89C1                <1> 	mov	cx,ax
  2672                              <1> 
  2673                              <1> .wait:
  2674 00001453 E8CDFA              <1> 	call	delay_15us
  2675                              <1> 
  2676                              <1> .wait_end:
  2677 00001456 30E4                <1> 	xor	ah,ah
  2678                              <1> 
  2679                              <1> .set_result:
  2680 00001458 88264100            <1> 	mov	byte [fdc_last_error],ah
  2681                              <1> 
  2682                              <1> .exit:
  2683 0000145C 59                  <1> 	pop	cx
  2684 0000145D 5B                  <1> 	pop	bx
  2685 0000145E C3                  <1> 	ret
  2686                              <1> 
  2687                              <1> .get_settle_time:
  2688 0000145F F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2689 00001464 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2690                              <1> 	
  2691 00001466 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2692 0000146A 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2693 0000146D B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2694 00001470 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2695 00001472 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2696 00001475 74DC                <1> 	je	.wait			; jump if 360K, media established
  2697 00001477 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2698 0000147A EBD7                <1> 	jmp	.wait
  2699                              <1> 
  2700                              <1> ;=========================================================================
  2701                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2702                              <1> ; Input:
  2703                              <1> ;	DL = drive number (0 or 1)
  2704                              <1> ; Output:
  2705                              <1> ;	none
  2706                              <1> ;-------------------------------------------------------------------------
  2707                              <1> fdc_motor_on:
  2708 0000147C 50                  <1> 	push	ax
  2709 0000147D 51                  <1> 	push	cx
  2710 0000147E 52                  <1> 	push	dx
  2711 0000147F FA                  <1> 	cli				; entering critical section
  2712 00001480 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2713 00001485 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2714 0000148A 88D1                <1> 	mov	cl,dl			; CL = drive number
  2715 0000148C D0E2                <1> 	shl	dl,1
  2716 0000148E D0E2                <1> 	shl	dl,1
  2717 00001490 D0E2                <1> 	shl	dl,1
  2718 00001492 D0E2                <1> 	shl	dl,1
  2719 00001494 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2720 00001498 FEC1                <1> 	inc	cl
  2721 0000149A 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2722 0000149E D2EA                <1> 	shr	dl,cl
  2723 000014A0 7255                <1> 	jc	.already_on
  2724 000014A2 B201                <1> 	mov	dl,1
  2725 000014A4 FEC9                <1> 	dec	cl
  2726 000014A6 D2E2                <1> 	shl	dl,cl
  2727 000014A8 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2728 000014AC FB                  <1> 	sti				; end of critical section
  2729 000014AD A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2730 000014B0 D0C8                <1> 	ror	al,1
  2731 000014B2 D0C8                <1> 	ror	al,1
  2732 000014B4 D0C8                <1> 	ror	al,1
  2733 000014B6 D0C8                <1> 	ror	al,1
  2734 000014B8 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2735 000014BA BAF203              <1> 	mov	dx,fdc_dor_reg
  2736 000014BD EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2737 000014BE B8FD90              <1> 	mov	ax,90FDh
  2738 000014C1 CD15                <1> 	int	15h			; call OS hook
  2739 000014C3 722E                <1> 	jc	.exit
  2740 000014C5 1E                  <1> 	push	ds
  2741 000014C6 56                  <1> 	push	si
  2742 000014C7 31F6                <1> 	xor	si,si
  2743 000014C9 8EDE                <1> 	mov	ds,si
  2744 000014CB C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2745 000014CF 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2746 000014D2 5E                  <1> 	pop	si
  2747 000014D3 1F                  <1> 	pop	ds
  2748                              <1> 
  2749 000014D4 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2750 000014D9 7408                <1> 	jz	.read_verify		; jump if not write operation
  2751 000014DB 3C08                <1> 	cmp	al,8
  2752 000014DD 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2753 000014DF B008                <1> 	mov	al,8			; wait at least 1 second for write
  2754 000014E1 EB06                <1> 	jmp	.wait_loop
  2755                              <1> 
  2756                              <1> .read_verify:
  2757 000014E3 3C05                <1> 	cmp	al,5
  2758 000014E5 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2759 000014E7 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2760                              <1> 
  2761                              <1> .wait_loop:
  2762 000014E9 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2763 000014EC E834FA              <1> 	call	delay_15us		; wait 125 ms
  2764 000014EF FEC8                <1> 	dec	al
  2765 000014F1 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2766                              <1> 
  2767                              <1> .exit:
  2768 000014F3 59                  <1> 	pop	cx
  2769 000014F4 5A                  <1> 	pop	dx
  2770 000014F5 58                  <1> 	pop	ax
  2771 000014F6 C3                  <1> 	ret
  2772                              <1> 
  2773                              <1> .already_on:
  2774 000014F7 FB                  <1> 	sti
  2775 000014F8 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2776 000014FB D0C8                <1> 	ror	al,1
  2777 000014FD D0C8                <1> 	ror	al,1
  2778 000014FF D0C8                <1> 	ror	al,1
  2779 00001501 D0C8                <1> 	ror	al,1
  2780 00001503 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2781 00001505 BAF203              <1> 	mov	dx,fdc_dor_reg
  2782 00001508 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2783 00001509 EBE8                <1> 	jmp	.exit
  2784                              <1> 
  2785                              <1> ;=========================================================================
  2786                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2787                              <1> ; Input:
  2788                              <1> ;	CH = cylinder
  2789                              <1> ;	DH = head
  2790                              <1> ; Output:
  2791                              <1> ;	BL = next sector to be transferred
  2792                              <1> ;-------------------------------------------------------------------------	
  2793                              <1> 
  2794                              <1> fdc_end_io:
  2795 0000150B 50                  <1> 	push	ax
  2796 0000150C 1E                  <1> 	push	ds
  2797 0000150D 31DB                <1> 	xor	bx,bx
  2798 0000150F 8EDB                <1> 	mov	ds,bx
  2799 00001511 C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2800 00001515 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2801 00001518 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2802 0000151B FEC0                <1> 	inc	al
  2803 0000151D 1F                  <1> 	pop	ds
  2804 0000151E BB4200              <1> 	mov	bx,fdc_ctrl_status
  2805 00001521 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2806 00001524 7508                <1> 	jne	.exit
  2807 00001526 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2808 00001529 7503                <1> 	jne	.exit
  2809 0000152B 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2810                              <1> .exit:
  2811 0000152E 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2812 00001532 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2813 00001534 58                  <1> 	pop	ax
  2814 00001535 C3                  <1> 	ret
  2815                              <1> 
  2816                              <1> ;========================================================================
  2817                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2818                              <1> ; Input:
  2819                              <1> ;	AL = CMOS drive type
  2820                              <1> ;	DS:SI -> drive media type
  2821                              <1> ; Output:
  2822                              <1> ;	CF clear if disk not changed
  2823                              <1> ;		AH = 00h - disk not changed
  2824                              <1> ;	CF set if disk changed or on error
  2825                              <1> ;		AH = 06h - disk changed
  2826                              <1> ;		AH = error code
  2827                              <1> ; Note:
  2828                              <1> ;	Motor needs to be turned on before calling this function
  2829                              <1> ;------------------------------------------------------------------------
  2830                              <1> fdc_disk_change:
  2831 00001536 51                  <1> 	push	cx
  2832 00001537 B400                <1> 	mov	ah,0
  2833 00001539 3C01                <1> 	cmp	al,cmos_360
  2834 0000153B 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2835 0000153D 3C03                <1> 	cmp	al,cmos_720
  2836 0000153F 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2837                              <1> .cmos_invalid:
  2838 00001541 8A04                <1> 	mov	al,[si]			; media type
  2839 00001543 2407                <1> 	and	al,fdc_m_state_bits
  2840 00001545 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2841 00001547 3C03                <1> 	cmp	al,3
  2842 00001549 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2843 0000154B BAF703              <1> 	mov	dx,fdc_dir_reg
  2844 0000154E EC                  <1> 	in	al,dx			; read disk change line
  2845 0000154F D0E0                <1> 	shl	al,1
  2846 00001551 7326                <1> 	jnc	.exit			; no disk change
  2847 00001553 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2848 00001556 E86CFB              <1> 	call	fdc_init		; full initialization
  2849 00001559 721E                <1> 	jc	.exit
  2850 0000155B 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2851 0000155E B501                <1> 	mov	ch,1
  2852 00001560 E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2853 00001563 7214                <1> 	jc	.exit
  2854 00001565 B500                <1> 	mov	ch,0
  2855 00001567 E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2856 0000156A 720D                <1> 	jc	.exit
  2857 0000156C B406                <1> 	mov	ah,fdc_e_changed
  2858 0000156E BAF703              <1> 	mov	dx,fdc_dir_reg
  2859 00001571 EC                  <1> 	in	al,dx			; read disk change line
  2860 00001572 D0E0                <1> 	shl	al,1
  2861 00001574 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2862 00001576 B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2863                              <1> 
  2864                              <1> .changed_or_error:
  2865 00001578 F9                  <1> 	stc
  2866                              <1> 
  2867                              <1> .exit:
  2868 00001579 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2869 0000157C 59                  <1> 	pop	cx
  2870 0000157D C3                  <1> 	ret
  2871                              <1> 
  2872                              <1> ;=========================================================================
  2873                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2874                              <1> ; Input:
  2875                              <1> ;	AL = DMA mode byte
  2876                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2877                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2878                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2879                              <1> ;	CX = byte count (minus 1)
  2880                              <1> ;	ES:BX -> buffer address for DMA operation
  2881                              <1> ; Output:
  2882                              <1> ;	CF clear on success
  2883                              <1> ;	CF set if error
  2884                              <1> ;		AH = 08h - DMA overrun
  2885                              <1> ;	AX,BX trashed
  2886                              <1> ; Note:
  2887                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2888                              <1> ;-------------------------------------------------------------------------
  2889                              <1> fdc_configure_dma:
  2890 0000157E 52                  <1> 	push	dx
  2891 0000157F 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2892 00001581 D1C2                <1> 	rol	dx,1
  2893 00001583 D1C2                <1> 	rol	dx,1
  2894 00001585 D1C2                <1> 	rol	dx,1
  2895 00001587 D1C2                <1> 	rol	dx,1
  2896 00001589 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2897 0000158B 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2898 0000158E 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2899 00001591 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2900 00001593 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2901                              <1> 
  2902 00001596 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2903 00001598 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2904 0000159A 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2905                              <1> 
  2906 0000159C FA                  <1> 	cli
  2907 0000159D E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2908 0000159F EB00                <1> 	jmp	$+2
  2909 000015A1 EB00                <1> 	jmp	$+2
  2910 000015A3 E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2911 000015A5 EB00                <1> 	jmp	$+2
  2912 000015A7 EB00                <1> 	jmp	$+2
  2913 000015A9 88C8                <1> 	mov	al,cl
  2914 000015AB E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2915 000015AD EB00                <1> 	jmp	$+2
  2916 000015AF EB00                <1> 	jmp	$+2
  2917 000015B1 88E8                <1> 	mov	al,ch
  2918 000015B3 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2919 000015B5 EB00                <1> 	jmp	$+2
  2920 000015B7 EB00                <1> 	jmp	$+2
  2921 000015B9 88D0                <1> 	mov	al,dl
  2922 000015BB E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2923 000015BD EB00                <1> 	jmp	$+2
  2924 000015BF EB00                <1> 	jmp	$+2
  2925 000015C1 88F0                <1> 	mov	al,dh
  2926 000015C3 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2927 000015C5 EB00                <1> 	jmp	$+2
  2928 000015C7 EB00                <1> 	jmp	$+2
  2929 000015C9 88E0                <1> 	mov	al,ah
  2930 000015CB E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2931 000015CD EB00                <1> 	jmp	$+2
  2932 000015CF EB00                <1> 	jmp	$+2
  2933 000015D1 B002                <1> 	mov	al,2
  2934 000015D3 E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2935 000015D5 FB                  <1> 	sti
  2936                              <1> 
  2937                              <1> .exit:
  2938 000015D6 5A                  <1> 	pop	dx
  2939 000015D7 C3                  <1> 	ret
  2940                              <1> 
  2941                              <1> .dma_boundary:				; Note: CF is already set
  2942 000015D8 B409                <1> 	mov	ah,fdc_e_boundary
  2943 000015DA EBFA                <1> 	jmp	.exit
  2944                              <1> 
  2945                              <1> ;=========================================================================
  2946                              <1> ; fdc_send_cmd - Send a command to FDC
  2947                              <1> ; Input:
  2948                              <1> ;	AL = 1st byte of the command
  2949                              <1> ;	AH = 2nd byte of the command
  2950                              <1> ;	SI = 3rd and 4th bytes of the command
  2951                              <1> ;	DI = 5th and 6th bytes of the command
  2952                              <1> ;	BL = 7th byte of the command
  2953                              <1> ;	BH = 8th byte of the command
  2954                              <1> ;	CH = 9th byte of the command
  2955                              <1> ;	CL = command length (number of bytes)
  2956                              <1> ; Output:
  2957                              <1> ;	CF clear if successful
  2958                              <1> ;		AH = 00h - successful completion
  2959                              <1> ;	CF set on error
  2960                              <1> ;		AH = 20h - controller failure
  2961                              <1> ;		AH = 80h - timeout / device not ready
  2962                              <1> ;	AX trashed
  2963                              <1> ;-------------------------------------------------------------------------
  2964                              <1> fdc_send_cmd:
  2965 000015DC E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2966 000015DF FEC9                <1> 	dec	cl
  2967 000015E1 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2968 000015E3 88E0                <1> 	mov	al,ah
  2969 000015E5 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2970 000015E8 FEC9                <1> 	dec	cl
  2971 000015EA 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2972 000015EC 89F0                <1> 	mov	ax,si
  2973 000015EE E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2974 000015F1 FEC9                <1> 	dec	cl
  2975 000015F3 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2976 000015F5 88E0                <1> 	mov	al,ah
  2977 000015F7 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2978 000015FA FEC9                <1> 	dec	cl
  2979 000015FC 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2980 000015FE 89F8                <1> 	mov	ax,di
  2981 00001600 E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2982 00001603 FEC9                <1> 	dec	cl
  2983 00001605 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2984 00001607 88E0                <1> 	mov	al,ah
  2985 00001609 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2986 0000160C FEC9                <1> 	dec	cl
  2987 0000160E 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2988 00001610 88D8                <1> 	mov	al,bl
  2989 00001612 E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2990 00001615 FEC9                <1> 	dec	cl
  2991 00001617 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2992 00001619 88F8                <1> 	mov	al,bh
  2993 0000161B E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2994 0000161E FEC9                <1> 	dec	cl
  2995 00001620 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2996 00001622 88E8                <1> 	mov	al,ch
  2997 00001624 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  2998                              <1> 
  2999                              <1> .send_cmd_exit:
  3000 00001627 C3                  <1> 	ret
  3001                              <1> 
  3002                              <1> ;=========================================================================
  3003                              <1> ; fdc_write - Send byte to FDC
  3004                              <1> ; Input:
  3005                              <1> ;	AL = byte to send
  3006                              <1> ; Output:
  3007                              <1> ;	CF clear if successful
  3008                              <1> ;	CF set if timeout
  3009                              <1> ;		AH = 80h - timeout / device not ready
  3010                              <1> ;-------------------------------------------------------------------------
  3011                              <1> fdc_write:
  3012 00001628 52                  <1> 	push	dx
  3013 00001629 50                  <1> 	push	ax
  3014 0000162A E83502              <1> 	call	fdc_wait_ready
  3015 0000162D 720D                <1> 	jc	.timeout
  3016 0000162F 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  3017 00001631 3C80                <1> 	cmp	al,fdc_stat_ready
  3018 00001633 7507                <1> 	jne	.timeout
  3019 00001635 58                  <1> 	pop	ax
  3020 00001636 BAF503              <1> 	mov	dx,fdc_data_reg
  3021 00001639 EE                  <1> 	out	dx,al			; write byte
  3022                              <1> 
  3023                              <1> .exit:
  3024 0000163A 5A                  <1> 	pop	dx
  3025 0000163B C3                  <1> 	ret
  3026                              <1> 
  3027                              <1> .timeout:
  3028 0000163C 58                  <1> 	pop	ax
  3029 0000163D B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3030 0000163F EBF9                <1> 	jmp	.exit
  3031                              <1> 
  3032                              <1> ;=========================================================================
  3033                              <1> ; fdc_get_result - Read FDC result
  3034                              <1> ; Input:
  3035                              <1> ;	CL = number of result bytes
  3036                              <1> ; Output:
  3037                              <1> ;	CF clear if successful
  3038                              <1> ;		AH = 00h - operation successful
  3039                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  3040                              <1> ;	CF set on error
  3041                              <1> ;		AH = 20h - controller failure
  3042                              <1> ;		AH = 80h - timeout / device not ready
  3043                              <1> ;	AL,BX - trashed
  3044                              <1> ;-------------------------------------------------------------------------
  3045                              <1> fdc_get_result:
  3046 00001641 52                  <1> 	push	dx
  3047 00001642 BB4200              <1> 	mov	bx,fdc_ctrl_status
  3048                              <1> 
  3049                              <1> .next_byte:
  3050 00001645 E81A02              <1> 	call	fdc_wait_ready
  3051 00001648 7222                <1> 	jc	.timeout
  3052 0000164A 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  3053 0000164C 88C4                <1> 	mov	ah,al
  3054 0000164E 80E4EF              <1> 	and	ah,~fdc_stat_busy
  3055 00001651 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  3056 00001654 7412                <1> 	je	.done			; jump if finished
  3057 00001656 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  3058 00001658 7516                <1> 	jne	.failure		; jump on invalid controller status
  3059 0000165A 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  3060 0000165D 7311                <1> 	jnb	.failure		; controller error if so
  3061 0000165F BAF503              <1> 	mov	dx,fdc_data_reg
  3062 00001662 EC                  <1> 	in	al,dx
  3063 00001663 8807                <1> 	mov	byte [bx],al
  3064 00001665 43                  <1> 	inc	bx
  3065 00001666 EBDD                <1> 	jmp	.next_byte
  3066                              <1> 
  3067                              <1> .done:
  3068 00001668 30E4                <1> 	xor	ah,ah			; operation successful
  3069                              <1> 
  3070                              <1> .exit:
  3071 0000166A 5A                  <1> 	pop	dx
  3072 0000166B C3                  <1> 	ret
  3073                              <1> 
  3074                              <1> .timeout:
  3075 0000166C B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3076 0000166E EBFA                <1> 	jmp	.exit
  3077                              <1> 
  3078                              <1> .failure:
  3079 00001670 B420                <1> 	mov	ah,fdc_e_failure
  3080 00001672 F9                  <1> 	stc
  3081 00001673 EBF5                <1> 	jmp	.exit
  3082                              <1> 
  3083                              <1> ;=========================================================================
  3084                              <1> ; fdc_read - Read byte from FDC
  3085                              <1> ; Input:
  3086                              <1> ;	none
  3087                              <1> ; Output:
  3088                              <1> ;	CF clear if successful
  3089                              <1> ;		AL = byte read from FDC
  3090                              <1> ;		AH - unchanged
  3091                              <1> ;	CF set on error
  3092                              <1> ;		AH = 20h - controller failure
  3093                              <1> ;		AH = 80h - timeout / device not ready
  3094                              <1> ;	CX trashed
  3095                              <1> ;-------------------------------------------------------------------------
  3096                              <1> fdc_read:
  3097 00001675 52                  <1> 	push	dx
  3098 00001676 BAF403              <1> 	mov	dx,fdc_status_reg
  3099 00001679 E8E601              <1> 	call	fdc_wait_ready
  3100 0000167C 720F                <1> 	jc	.timeout
  3101 0000167E EC                  <1> 	in	al,dx
  3102 0000167F A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  3103 00001681 740E                <1> 	jz	.failure		; jump if not ready
  3104 00001683 EB00                <1> 	jmp	short $+2		; I/O delay
  3105 00001685 EB00                <1> 	jmp	short $+2
  3106 00001687 BAF503              <1> 	mov	dx,fdc_data_reg
  3107 0000168A EC                  <1> 	in	al,dx			; read the byte
  3108                              <1> 
  3109                              <1> .exit:
  3110 0000168B 5A                  <1> 	pop	dx
  3111 0000168C C3                  <1> 	ret
  3112                              <1> 
  3113                              <1> .timeout:
  3114 0000168D B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3115 0000168F EBFA                <1> 	jmp	.exit
  3116                              <1> 
  3117                              <1> .failure:
  3118 00001691 B420                <1> 	mov	ah,fdc_e_failure
  3119 00001693 F9                  <1> 	stc
  3120 00001694 EBF5                <1> 	jmp	.exit
  3121                              <1> 
  3122                              <1> ;=========================================================================
  3123                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  3124                              <1> ; Input:
  3125                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  3126                              <1> ; Output:
  3127                              <1> ;	AH = error code
  3128                              <1> ;-------------------------------------------------------------------------
  3129                              <1> 
  3130                              <1> fdc_get_error:
  3131 00001696 BB4200              <1> 	mov	bx,fdc_ctrl_status
  3132 00001699 8B1F                <1> 	mov	bx,[bx]
  3133 0000169B F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  3134 0000169E B400                <1> 	mov	ah,fdc_e_success
  3135 000016A0 7433                <1> 	jz	.exit			; jump if successful completion
  3136 000016A2 F6C340              <1> 	test	bl,40h			; abnormal termination?
  3137 000016A5 B420                <1> 	mov	ah,fdc_e_failure
  3138 000016A7 742C                <1> 	jz	.exit
  3139 000016A9 F6C701              <1> 	test	bh,1			; address mark not found?
  3140 000016AC B402                <1> 	mov	ah,fdc_e_address
  3141 000016AE 7525                <1> 	jnz	.exit
  3142 000016B0 F6C702              <1> 	test	bh,2			; disk write protected?
  3143 000016B3 B403                <1> 	mov	ah,fdc_e_wprotect
  3144 000016B5 751E                <1> 	jnz	.exit
  3145 000016B7 F6C704              <1> 	test	bh,4			; sector not found?
  3146 000016BA B404                <1> 	mov	ah,fdc_e_notfound
  3147 000016BC 7517                <1> 	jnz	.exit
  3148 000016BE F6C710              <1> 	test	bh,10H			; DMA overrun?
  3149 000016C1 B408                <1> 	mov	ah,fdc_e_dma
  3150 000016C3 7510                <1> 	jnz	.exit
  3151 000016C5 F6C720              <1> 	test	bh,20H			; CRC error?
  3152 000016C8 B410                <1> 	mov	ah,fdc_e_crc
  3153 000016CA 7509                <1> 	jnz	.exit
  3154 000016CC F6C780              <1> 	test	bh,80h			; access after last sector?
  3155 000016CF B404                <1> 	mov	ah,fdc_e_notfound
  3156 000016D1 7502                <1> 	jnz	.exit
  3157 000016D3 B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  3158                              <1> 
  3159                              <1> .exit:
  3160 000016D5 C3                  <1> 	ret
  3161                              <1> 
  3162                              <1> ;=========================================================================
  3163                              <1> ; fdc_reset - Reset FDC
  3164                              <1> ; Input:
  3165                              <1> ;	none
  3166                              <1> ; Output:
  3167                              <1> ;	Resets FDC flags in BIOS area
  3168                              <1> ;	AX,CX,DX - trashed 
  3169                              <1> ;-------------------------------------------------------------------------
  3170                              <1> 
  3171                              <1> fdc_reset:
  3172 000016D6 FA                  <1> 	cli
  3173 000016D7 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  3174 000016DC 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3175 000016E1 A03F00              <1> 	mov	al,byte [fdc_motor_state]
  3176 000016E4 D0C0                <1> 	rol	al,1			; after rol:
  3177 000016E6 D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  3178 000016E8 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  3179 000016EA D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  3180 000016EC 24FB                <1> 	and	al,0FBh			; clear reserved bit
  3181 000016EE 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  3182 000016F0 BAF203              <1> 	mov	dx,fdc_dor_reg
  3183 000016F3 EE                  <1> 	out	dx,al			; send it to FDC
  3184 000016F4 B90300              <1> 	mov	cx,3
  3185 000016F7 E829F8              <1> 	call	delay_15us		; 30-45 us delay
  3186 000016FA 0C0C                <1> 	or	al,0Ch
  3187 000016FC EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  3188 000016FD FB                  <1> 	sti
  3189 000016FE E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3190 00001701 7207                <1> 	jc	.exit
  3191 00001703 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  3192 00001708 30E4                <1> 	xor	ah,ah			; no errors
  3193                              <1> .exit:
  3194 0000170A C3                  <1> 	ret
  3195                              <1> 
  3196                              <1> ;=========================================================================
  3197                              <1> ; read_cmos_type - Read drive type from CMOS
  3198                              <1> ; Input:
  3199                              <1> ;	DL = drive number (0 or 1)
  3200                              <1> ; Output:
  3201                              <1> ;	CF clear if successful
  3202                              <1> ;		AL = drive type
  3203                              <1> ;	CF set on error (invalid drive type)
  3204                              <1> ;=========================================================================
  3205                              <1> 
  3206                              <1> read_cmos_type:
  3207 0000170B B010                <1> 	mov	al,cmos_floppy
  3208 0000170D E812F4              <1> 	call	rtc_read		; read drive type
  3209 00001710 08D2                <1> 	or	dl,dl			; drive 0?
  3210 00001712 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  3211 00001714 D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  3212 00001716 D0E8                <1> 	shr	al,1
  3213 00001718 D0E8                <1> 	shr	al,1
  3214 0000171A D0E8                <1> 	shr	al,1
  3215                              <1> .drive_1:
  3216 0000171C 240F                <1> 	and	al,0Fh			; mask drive bits
  3217 0000171E 3C00                <1> 	cmp	al,cmos_no_floppy
  3218 00001720 740A                <1> 	je	.error
  3219 00001722 3C05                <1> 	cmp	al,5			; invalid value
  3220 00001724 7406                <1> 	je	.error
  3221 00001726 3C06                <1> 	cmp	al,cmos_2880
  3222 00001728 7702                <1> 	ja	.error
  3223 0000172A F8                  <1> 	clc
  3224 0000172B C3                  <1> 	ret
  3225                              <1> 
  3226                              <1> .error:
  3227 0000172C F9                  <1> 	stc
  3228 0000172D C3                  <1> 	ret
  3229                              <1> 
  3230                              <1> ;=========================================================================
  3231                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  3232                              <1> ; Input:
  3233                              <1> ;	none, expects drive number in [bp+int_13_dl]
  3234                              <1> ; Output:
  3235                              <1> ;	CF clear if successful
  3236                              <1> ;		AH = 00h
  3237                              <1> ;	CF set on error
  3238                              <1> ;		AH = 20h - invalid CMOS
  3239                              <1> ;-------------------------------------------------------------------------
  3240                              <1> fdc_detect_media:
  3241 0000172E 52                  <1> 	push	dx
  3242 0000172F 51                  <1> 	push	cx
  3243 00001730 53                  <1> 	push	bx
  3244 00001731 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  3245 00001734 BB9000              <1> 	mov	bx,fdc_media_state
  3246 00001737 00D3                <1> 	add	bl,dl
  3247 00001739 E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  3248 0000173C B400                <1> 	mov	ah,0
  3249 0000173E 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  3250                              <1> 
  3251 00001740 3C03                <1> 	cmp	al,cmos_720
  3252 00001742 7410                <1> 	je	.set_720
  3253 00001744 3C02                <1> 	cmp	al,cmos_1200
  3254 00001746 7415                <1> 	je	.detect_1200
  3255 00001748 3C04                <1> 	cmp	al,cmos_1440
  3256 0000174A 7427                <1> 	je	.detect_1440
  3257 0000174C 3C06                <1> 	cmp	al,cmos_2880
  3258 0000174E 7439                <1> 	je	.detect_2880
  3259                              <1> 	
  3260 00001750 B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  3261 00001752 EB02                <1> 	jmp	.set_rate
  3262                              <1> 
  3263                              <1> .set_720:
  3264 00001754 B097                <1> 	mov	al,fdc_m_720
  3265                              <1> 
  3266                              <1> .set_rate:
  3267 00001756 50                  <1> 	push	ax
  3268 00001757 E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  3269 0000175A 58                  <1> 	pop	ax
  3270 0000175B EB49                <1> 	jmp	.exit_set_media
  3271                              <1> 
  3272                              <1> .detect_1200:
  3273 0000175D B000                <1> 	mov	al,0			; try 500 Kbps
  3274 0000175F E85300              <1> 	call	fdc_read_id
  3275 00001762 B015                <1> 	mov	al,fdc_m_1200in1200
  3276 00001764 7340                <1> 	jnc	.exit_set_media		; jump if successful
  3277 00001766 B040                <1> 	mov	al,40h			; try 300 Kbps
  3278 00001768 E84A00              <1> 	call	fdc_read_id
  3279 0000176B B074                <1> 	mov	al,fdc_m_360in1200
  3280 0000176D 7337                <1> 	jnc	.exit_set_media		; jump if successful
  3281 0000176F B002                <1> 	mov	al,fdc_m_try_1200in1200
  3282 00001771 EB33                <1> 	jmp	.exit_set_media
  3283                              <1> 
  3284                              <1> .detect_1440:
  3285 00001773 B000                <1> 	mov	al,0			; try 500 Kbps
  3286 00001775 E83D00              <1> 	call	fdc_read_id
  3287 00001778 B017                <1> 	mov	al,fdc_m_1440
  3288 0000177A 732A                <1> 	jnc	.exit_set_media		; jump if successful
  3289 0000177C B080                <1> 	mov	al,80h			; try 250 Kbps
  3290 0000177E E83400              <1> 	call	fdc_read_id
  3291 00001781 B097                <1> 	mov	al,fdc_m_720
  3292 00001783 7321                <1> 	jnc	.exit_set_media		; jump if successful
  3293 00001785 B007                <1> 	mov	al,fdc_m_try_1440
  3294 00001787 EB1D                <1> 	jmp	.exit_set_media
  3295                              <1> 
  3296                              <1> .detect_2880:
  3297 00001789 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  3298 0000178B E82700              <1> 	call	fdc_read_id
  3299 0000178E B0D7                <1> 	mov	al,fdc_m_2880
  3300 00001790 7314                <1> 	jnc	.exit_set_media		; jump if successful
  3301 00001792 B000                <1> 	mov	al,0			; try 500 Kbps
  3302 00001794 E81E00              <1> 	call	fdc_read_id
  3303 00001797 B017                <1> 	mov	al,fdc_m_1440
  3304 00001799 730B                <1> 	jnc	.exit_set_media		; jump if successful
  3305 0000179B B080                <1> 	mov	al,80h			; try 250 Kbps
  3306 0000179D E81500              <1> 	call	fdc_read_id
  3307 000017A0 B097                <1> 	mov	al,fdc_m_720
  3308 000017A2 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  3309 000017A4 B0C7                <1> 	mov	al,fdc_m_try_2880
  3310                              <1> 
  3311                              <1> .exit_set_media:
  3312 000017A6 8807                <1> 	mov	byte [bx],al		; set media type
  3313                              <1> 
  3314                              <1> .exit:
  3315 000017A8 88264100            <1> 	mov	byte [fdc_last_error],ah
  3316 000017AC 5B                  <1> 	pop	bx
  3317 000017AD 59                  <1> 	pop	cx
  3318 000017AE 5A                  <1> 	pop	dx
  3319 000017AF C3                  <1> 	ret
  3320                              <1> 
  3321                              <1> .invalid_cmos:
  3322 000017B0 B420                <1> 	mov	ah,fdc_e_failure
  3323 000017B2 F9                  <1> 	stc
  3324 000017B3 EBF3                <1> 	jmp	.exit
  3325                              <1> 
  3326                              <1> ;=========================================================================
  3327                              <1> ; fdc_read_id - Read ID
  3328                              <1> ; Input:
  3329                              <1> ;	AL = data transfer rate (bits 7-6)
  3330                              <1> ; Output:
  3331                              <1> ;	CF clear if successful
  3332                              <1> ;		AH = 0 - successful completion
  3333                              <1> ;		AL = ID (bits 7-6)
  3334                              <1> ;	CF set on error
  3335                              <1> ;		AH = error code
  3336                              <1> ;-------------------------------------------------------------------------
  3337                              <1> fdc_read_id:
  3338 000017B5 53                  <1> 	push	bx
  3339 000017B6 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  3340 000017BB E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  3341 000017BE 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  3342 000017C1 E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  3343 000017C4 7305                <1> 	jnc	.do_read_id
  3344 000017C6 E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  3345 000017C9 722D                <1> 	jc	.error
  3346                              <1> 
  3347                              <1> .do_read_id:
  3348 000017CB B90300              <1> 	mov	cx,3			; 3 attempts
  3349                              <1> 
  3350                              <1> .read_id_loop:
  3351 000017CE 51                  <1> 	push	cx
  3352 000017CF B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  3353 000017D1 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  3354 000017D3 B102                <1> 	mov	cl,2			; 2 byte commands
  3355 000017D5 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3356 000017DA E8FFFD              <1> 	call	fdc_send_cmd
  3357 000017DD 7218                <1> 	jc	.error_cmd
  3358 000017DF E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3359 000017E2 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  3360 000017E4 B107                <1> 	mov	cl,7
  3361 000017E6 E858FE              <1> 	call	fdc_get_result		; read result bytes
  3362 000017E9 720C                <1> 	jc	.error_cmd
  3363 000017EB E8A8FE              <1> 	call	fdc_get_error		; get error code
  3364 000017EE 59                  <1> 	pop	cx
  3365 000017EF 08E4                <1> 	or	ah,ah
  3366 000017F1 7406                <1> 	jz	.exit			; if no errors
  3367 000017F3 E2D9                <1> 	loop	.read_id_loop		; retry
  3368 000017F5 EB01                <1> 	jmp	.error
  3369                              <1> 
  3370                              <1> .error_cmd:
  3371 000017F7 59                  <1> 	pop	cx
  3372                              <1> 
  3373                              <1> .error:
  3374 000017F8 F9                  <1> 	stc
  3375                              <1> 
  3376                              <1> .exit:
  3377 000017F9 5B                  <1> 	pop	bx
  3378 000017FA C3                  <1> 	ret
  3379                              <1> 
  3380                              <1> ;=========================================================================
  3381                              <1> ; fdc_select_rate - Select FDC transfer rate
  3382                              <1> ; Input:
  3383                              <1> ;	none
  3384                              <1> ; Output:
  3385                              <1> ;	AL = data transfer rate (bits 7-6)
  3386                              <1> ;-------------------------------------------------------------------------
  3387                              <1> fdc_select_rate:
  3388 000017FB 53                  <1> 	push	bx
  3389 000017FC BB9000              <1> 	mov	bx,fdc_media_state
  3390 000017FF 00D3                <1> 	add	bl,dl			; SI -> drive media state
  3391 00001801 8A37                <1> 	mov	dh,byte [bx]		; new media status
  3392 00001803 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  3393 00001807 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  3394 0000180B 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  3395 0000180D 740E                <1> 	je	.exit			; exit if rate is already selected
  3396 0000180F 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  3397 00001814 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  3398 00001818 88F0                <1> 	mov	al,dh
  3399 0000181A E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  3400                              <1> 
  3401                              <1> .exit:
  3402 0000181D 5B                  <1> 	pop	bx
  3403 0000181E 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  3404 00001821 C3                  <1> 	ret
  3405                              <1> 
  3406                              <1> ;=========================================================================
  3407                              <1> ; fdc_set_rate - Set transfer rate
  3408                              <1> ; Input:
  3409                              <1> ;	AL = transfer rate (bits 7 and 6)
  3410                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  3411                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  3412                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  3413                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  3414                              <1> ; Output:
  3415                              <1> ;	AL = transfer rate (bits 1 and 0)
  3416                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  3417                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  3418                              <1> ;	DX = 3F7h - FDC CCR
  3419                              <1> ;-------------------------------------------------------------------------
  3420                              <1> fdc_set_rate:
  3421 00001822 24C0                <1> 	and	al,fdc_m_rate_bits
  3422 00001824 D0C0                <1> 	rol	al,1
  3423 00001826 D0C0                <1> 	rol	al,1
  3424 00001828 BAF703              <1> 	mov	dx,fdc_ccr_reg
  3425 0000182B EE                  <1> 	out	dx,al
  3426 0000182C C3                  <1> 	ret
  3427                              <1> 
  3428                              <1> ;=========================================================================
  3429                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  3430                              <1> ; Input:
  3431                              <1> ;	none
  3432                              <1> ; Output:
  3433                              <1> ;	CF clear if interrupt had occurred
  3434                              <1> ;		AH = 00h - successful completion
  3435                              <1> ;	CF set if no interrupt
  3436                              <1> ;		AH = 80h - timeout
  3437                              <1> ;	BX = fdc_calib_state
  3438                              <1> ;	AL,CX - trashed
  3439                              <1> ;-------------------------------------------------------------------------
  3440                              <1> fdc_wait_irq:
  3441 0000182D FB                  <1> 	sti
  3442 0000182E F8                  <1> 	clc
  3443 0000182F B80190              <1> 	mov	ax,9001h
  3444 00001832 CD15                <1> 	int	15h			; call OS hook
  3445 00001834 7221                <1> 	jc	.timeout
  3446 00001836 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  3447 00001839 31C9                <1> 	xor	cx,cx
  3448                              <1> 
  3449                              <1> .zero:
  3450 0000183B F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3451 0000183E 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3452                              <1> 
  3453                              <1> .zero_loop:
  3454 00001840 E461                <1> 	in	al,port_b_reg
  3455 00001842 A810                <1> 	test	al,refresh_flag
  3456 00001844 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3457 00001846 E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3458 00001848 EB0D                <1> 	jmp	.timeout
  3459                              <1> 
  3460                              <1> .one:
  3461 0000184A F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3462 0000184D 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3463                              <1> 
  3464                              <1> .one_loop:
  3465 0000184F E461                <1> 	in	al,port_b_reg
  3466 00001851 A810                <1> 	test	al,refresh_flag
  3467 00001853 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3468 00001855 E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3469                              <1> 
  3470                              <1> .timeout:
  3471 00001857 B480                <1> 	mov	ah,fdc_e_timeout
  3472 00001859 F9                  <1> 	stc
  3473 0000185A C3                  <1> 	ret
  3474                              <1> 
  3475                              <1> .exit:
  3476 0000185B 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3477 0000185E B400                <1> 	mov	ah,fdc_e_success
  3478 00001860 F8                  <1> 	clc				; DEBUG - remove after debug
  3479 00001861 C3                  <1> 	ret
  3480                              <1> 
  3481                              <1> ;=========================================================================
  3482                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3483                              <1> ;		   but no more than one second
  3484                              <1> ; Input:
  3485                              <1> ; Output:
  3486                              <1> ;	CF clear if FDC is ready
  3487                              <1> ;		AL = FDC main status register
  3488                              <1> ;	CF set on timeout
  3489                              <1> ;		AL trashed
  3490                              <1> ;	DX - trashed
  3491                              <1> ;-------------------------------------------------------------------------
  3492                              <1> 
  3493                              <1> fdc_wait_ready:
  3494 00001862 51                  <1> 	push	cx
  3495 00001863 BAF403              <1> 	mov	dx,fdc_status_reg
  3496 00001866 31C9                <1> 	xor	cx,cx
  3497                              <1> 
  3498                              <1> .zero:
  3499 00001868 EC                  <1> 	in	al,dx			; read I/O port
  3500 00001869 A880                <1> 	test	al,fdc_stat_ready
  3501 0000186B 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3502                              <1> 
  3503                              <1> .zero_loop:
  3504 0000186D E461                <1> 	in	al,port_b_reg
  3505 0000186F A810                <1> 	test	al,refresh_flag
  3506 00001871 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3507 00001873 49                  <1> 	dec	cx
  3508 00001874 740D                <1> 	jz	.timeout
  3509 00001876 EC                  <1> 	in	al,dx			; read I/O port again
  3510 00001877 A880                <1> 	test	al,fdc_stat_ready
  3511 00001879 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3512                              <1> 
  3513                              <1> .one_loop:
  3514 0000187B E461                <1> 	in	al,port_b_reg
  3515 0000187D A810                <1> 	test	al,refresh_flag
  3516 0000187F 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3517 00001881 E2E5                <1> 	loop	.zero
  3518                              <1> 
  3519                              <1> .timeout:
  3520 00001883 F9                  <1> 	stc
  3521                              <1> 
  3522                              <1> .exit:
  3523 00001884 59                  <1> 	pop	cx
  3524 00001885 C3                  <1> 	ret
  3525                              <1> 
  3526                              <1> ;=========================================================================
  3527                              <1> ; print_floppy - Print floppy configuration
  3528                              <1> ; Input:
  3529                              <1> ;	AL = NVRAM floppy configuration byte
  3530                              <1> ; Ouput:
  3531                              <1> ;	none
  3532                              <1> ;-------------------------------------------------------------------------
  3533                              <1> print_floppy:
  3534 00001886 50                  <1> 	push	ax
  3535 00001887 56                  <1> 	push	si
  3536 00001888 BE[0202]            <1> 	mov	si,msg_floppy
  3537 0000188B E8460D              <1> 	call	print
  3538 0000188E D0C8                <1> 	ror	al,1
  3539 00001890 D0C8                <1> 	ror	al,1
  3540 00001892 D0C8                <1> 	ror	al,1
  3541 00001894 D0C8                <1> 	ror	al,1
  3542 00001896 89C6                <1> 	mov	si,ax
  3543 00001898 83E607              <1> 	and	si,0007h
  3544 0000189B D1E6                <1> 	shl	si,1
  3545 0000189D 2E8BB4[1207]        <1>     cs	mov	si,word [tbl_floppy+si]
  3546 000018A2 E82F0D              <1> 	call	print
  3547 000018A5 BE[2802]            <1> 	mov	si,msg_floppy_2
  3548 000018A8 E8290D              <1> 	call	print
  3549 000018AB D0C8                <1> 	ror	al,1
  3550 000018AD D0C8                <1> 	ror	al,1
  3551 000018AF D0C8                <1> 	ror	al,1
  3552 000018B1 D0C8                <1> 	ror	al,1
  3553 000018B3 89C6                <1> 	mov	si,ax
  3554 000018B5 83E607              <1> 	and	si,0007h
  3555 000018B8 D1E6                <1> 	shl	si,1
  3556 000018BA 2E8BB4[1207]        <1>     cs	mov	si,word [tbl_floppy+si]
  3557 000018BF E8120D              <1> 	call	print
  3558 000018C2 BE[8800]            <1> 	mov	si,msg_crlf
  3559 000018C5 E80C0D              <1> 	call	print
  3560 000018C8 5E                  <1> 	pop	si
  3561 000018C9 58                  <1> 	pop	ax
  3562 000018CA C3                  <1> 	ret
  3563                                  %include	"kbc.inc"		; keyboard controller functions
  3564                              <1> ;=========================================================================
  3565                              <1> ; kbc.inc - Keyboard controller support
  3566                              <1> ;-------------------------------------------------------------------------
  3567                              <1> ;
  3568                              <1> ; Compiles with NASM 2.07, might work with other versions
  3569                              <1> ;
  3570                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  3571                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3572                              <1> ;
  3573                              <1> ; This program is free software: you can redistribute it and/or modify
  3574                              <1> ; it under the terms of the GNU General Public License as published by
  3575                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3576                              <1> ; (at your option) any later version.
  3577                              <1> ;
  3578                              <1> ; This program is distributed in the hope that it will be useful,
  3579                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3580                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3581                              <1> ; GNU General Public License for more details.
  3582                              <1> ;
  3583                              <1> ; You should have received a copy of the GNU General Public License
  3584                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3585                              <1> ;
  3586                              <1> ;=========================================================================
  3587                              <1> 
  3588                              <1> ;=========================================================================
  3589                              <1> ; Keyboard controller defines - ports, commands, and flags
  3590                              <1> ;-------------------------------------------------------------------------
  3591                              <1> kbc_data_reg	equ	60h
  3592                              <1> kbc_input_reg	equ	60h
  3593                              <1> kbc_output_reg	equ	60h
  3594                              <1> ; keyboard controller return codes
  3595                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3596                              <1> ; keyboard controller status register and its bits
  3597                              <1> kbc_status_reg	equ	64h
  3598                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3599                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3600                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3601                              <1> ; keyboard contoller command register and commands
  3602                              <1> kbc_command_reg	equ	64h
  3603                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3604                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3605                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3606                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3607                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3608                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3609                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3610                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3611                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3612                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3613                              <1> ; keyboard controller control register bits
  3614                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3615                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3616                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3617                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3618                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3619                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3620                              <1> ; keyboard controller input port bits
  3621                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3622                              <1> 
  3623                              <1> ;=========================================================================
  3624                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3625                              <1> ; Input:
  3626                              <1> ;	AL = command
  3627                              <1> ; Output:
  3628                              <1> ;	none
  3629                              <1> ;-------------------------------------------------------------------------
  3630                              <1> kbc_kb_send:
  3631 000018CB 50                  <1> 	push	ax
  3632 000018CC 51                  <1> 	push	cx
  3633 000018CD 88C4                <1> 	mov	ah,al			; save command to AH
  3634 000018CF B90300              <1> 	mov	cx,3			; try 3 times
  3635                              <1> 
  3636                              <1> .1:
  3637 000018D2 51                  <1> 	push	cx
  3638 000018D3 FA                  <1> 	cli
  3639                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3640 000018D4 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3641 000018D9 31C9                <1> 	xor	cx,cx
  3642                              <1> 
  3643                              <1> .2:					; wait for KBC to empty input buffer
  3644 000018DB E464                <1> 	in	al,kbc_status_reg
  3645 000018DD A802                <1> 	test	al,kbc_stat_ibf
  3646 000018DF E0FA                <1> 	loopnz	.2
  3647                              <1> 
  3648 000018E1 88E0                <1> 	mov	al,ah
  3649 000018E3 E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3650 000018E5 FB                  <1> 	sti
  3651 000018E6 31C9                <1> 	xor	cx,cx
  3652                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3653 000018E8 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3654 000018ED E1F9                <1> 	loopz	.3
  3655 000018EF 59                  <1> 	pop	cx
  3656 000018F0 7507                <1> 	jnz	.4
  3657 000018F2 E2DE                <1> 	loop	.1			; try again
  3658                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3659 000018F4 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3660                              <1> .4:
  3661 000018F9 59                  <1> 	pop	cx
  3662 000018FA 58                  <1> 	pop	ax
  3663 000018FB C3                  <1> 	ret
  3664                              <1> 
  3665                              <1> ;=========================================================================
  3666                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3667                              <1> ; Input:
  3668                              <1> ;	AL - command byte
  3669                              <1> ;	AH = argument
  3670                              <1> ; Output:
  3671                              <1> ;	ZF == 0 - success
  3672                              <1> ;	ZF == 1 - error
  3673                              <1> ;-------------------------------------------------------------------------
  3674                              <1> kbc_send_cmd:
  3675 000018FC 51                  <1> 	push	cx
  3676 000018FD 88C5                <1> 	mov	ch,al			; save command byte to CH
  3677 000018FF B11E                <1> 	mov	cl,30			; 30 retries
  3678                              <1> .1:
  3679 00001901 FA                  <1> 	cli
  3680 00001902 88E8                <1> 	mov	al,ch
  3681 00001904 E82800              <1> 	call	kbc_send_cmd_byte
  3682 00001907 7522                <1> 	jnz	.exit			; time out
  3683 00001909 E464                <1> 	in	al,kbc_status_reg
  3684 0000190B A801                <1> 	test	al,kbc_stat_obf
  3685 0000190D 7414                <1> 	jz	.3			; output buffer is empty
  3686 0000190F A820                <1> 	test	al,kbc_stat_aobf
  3687 00001911 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3688 00001913 E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3689                              <1> %ifdef PS2_MOUSE
  3690 00001915 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3691                              <1> %endif ; PS2_MOUSE
  3692 0000191A EB07                <1> 	jmp	.3
  3693                              <1> .2:
  3694 0000191C FB                  <1> 	sti
  3695 0000191D FEC9                <1> 	dec	cl
  3696 0000191F 75E0                <1> 	jnz	.1
  3697 00001921 EB08                <1> 	jmp	.exit			; note: ZF=1
  3698                              <1> .3:
  3699 00001923 88E0                <1> 	mov	al,ah
  3700 00001925 E660                <1> 	out	kbc_input_reg,al
  3701 00001927 FB                  <1> 	sti
  3702 00001928 80C901              <1> 	or	cl,1			; set ZF=0
  3703                              <1> .exit:
  3704 0000192B 88E8                <1> 	mov	al,ch			; restore AL
  3705 0000192D 59                  <1> 	pop	cx
  3706 0000192E C3                  <1> 	ret
  3707                              <1> 
  3708                              <1> ;=========================================================================
  3709                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3710                              <1> ; Input:
  3711                              <1> ;	AL - command byte
  3712                              <1> ; Output:
  3713                              <1> ;	ZF == 1 - success
  3714                              <1> ;	ZF == 0 - time out
  3715                              <1> ; Note:
  3716                              <1> ;	XXX - function should be reused in keyboard code
  3717                              <1> ;-------------------------------------------------------------------------
  3718                              <1> kbc_send_cmd_byte:
  3719 0000192F 51                  <1> 	push	cx
  3720 00001930 50                  <1> 	push	ax
  3721 00001931 31C9                <1> 	xor	cx,cx
  3722                              <1> 				; wait for KBC to empty input buffer
  3723                              <1> .1:
  3724 00001933 E464                <1> 	in	al,kbc_status_reg
  3725 00001935 A802                <1> 	test	al,kbc_stat_ibf
  3726 00001937 E0FA                <1> 	loopnz	.1
  3727 00001939 750C                <1> 	jnz	.exit		; time out
  3728                              <1> 
  3729 0000193B 58                  <1> 	pop	ax
  3730 0000193C E664                <1> 	out	kbc_command_reg,al
  3731                              <1> 
  3732 0000193E 50                  <1> 	push	ax
  3733 0000193F 31C9                <1> 	xor	cx,cx
  3734                              <1> 				; wait for KBC to empty input buffer
  3735                              <1> .2:
  3736 00001941 E464                <1> 	in	al,kbc_status_reg
  3737 00001943 A802                <1> 	test	al,kbc_stat_ibf
  3738 00001945 E0FA                <1> 	loopnz	.2
  3739                              <1> .exit:
  3740 00001947 58                  <1> 	pop	ax
  3741 00001948 59                  <1> 	pop	cx
  3742 00001949 C3                  <1> 	ret
  3743                              <1> 
  3744                              <1> ;=========================================================================
  3745                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3746                              <1> ; Input:
  3747                              <1> ;	none
  3748                              <1> ; Output:
  3749                              <1> ;	AL = keyboard status register
  3750                              <1> ;	ZF == 0 - data is available
  3751                              <1> ;	ZF == 1 - timed out
  3752                              <1> ; Note:
  3753                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3754                              <1> ;	      be merged with kbc_wait_aux_full
  3755                              <1> ;-------------------------------------------------------------------------
  3756                              <1> kbc_wait_output_full:
  3757 0000194A 51                  <1> 	push	cx
  3758 0000194B 31C9                <1> 	xor	cx,cx
  3759                              <1> .1:
  3760 0000194D E464                <1> 	in	al,kbc_status_reg
  3761 0000194F A801                <1> 	test	al,kbc_stat_obf
  3762 00001951 E1FA                <1> 	loopz	.1
  3763 00001953 09C9                <1> 	or	cx,cx
  3764 00001955 59                  <1> 	pop	cx
  3765 00001956 C3                  <1> 	ret
  3766                              <1> 
  3767                              <1> %ifdef PS2_MOUSE
  3768                              <1> ;=========================================================================
  3769                              <1> ; kbc_aux_read - read data from auxiliary device
  3770                              <1> ; Input:
  3771                              <1> ;	none
  3772                              <1> ; Output:
  3773                              <1> ;	AL = data
  3774                              <1> ;	CF == 0 - data is available
  3775                              <1> ;	CF == 1 - time out
  3776                              <1> ;-------------------------------------------------------------------------
  3777                              <1> kbc_aux_read:
  3778 00001957 51                  <1> 	push	cx
  3779                              <1> ;	xor	cx,cx			; XXX too much?!
  3780 00001958 B91400              <1> 	mov	cx,20			; retry 20 times
  3781                              <1> .1:
  3782 0000195B E86000              <1> 	call	kbc_wait_aux_full
  3783 0000195E 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3784 00001960 E1F9                <1> 	loopz	.1
  3785 00001962 EB0B                <1> 	jmp	.error			; time out
  3786                              <1> .2:
  3787 00001964 B90100              <1> 	mov	cx,1
  3788 00001967 E8B9F5              <1> 	call	delay_15us
  3789 0000196A E460                <1> 	in	al,kbc_output_reg
  3790 0000196C F8                  <1> 	clc
  3791 0000196D EB01                <1> 	jmp	.exit
  3792                              <1> .error:
  3793 0000196F F9                  <1> 	stc
  3794                              <1> .exit:
  3795 00001970 59                  <1> 	pop	cx
  3796 00001971 C3                  <1> 	ret
  3797                              <1> 
  3798                              <1> ;=========================================================================
  3799                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3800                              <1> ; Input:
  3801                              <1> ;	AL = command
  3802                              <1> ; Output:
  3803                              <1> ;	AH - status:
  3804                              <1> ;		00h - success
  3805                              <1> ;		03h - interface error (time out)
  3806                              <1> ;		04h - resend requested
  3807                              <1> ;	CF == 0 - no error
  3808                              <1> ;	CF == 1 - error
  3809                              <1> ;-------------------------------------------------------------------------
  3810                              <1> kbc_aux_send:
  3811 00001972 51                  <1> 	push	cx
  3812 00001973 88C4                <1> 	mov	ah,al			; store command to AH
  3813 00001975 B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3814 00001977 E882FF              <1> 	call	kbc_send_cmd
  3815 0000197A 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3816                              <1> 
  3817                              <1> 					; wait for acknowledge
  3818 0000197C B90A00              <1> 	mov	cx,10			; retry 10 times
  3819                              <1> .1:
  3820 0000197F E83C00              <1> 	call	kbc_wait_aux_full
  3821 00001982 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3822 00001984 E2F9                <1> 	loop	.1
  3823 00001986 EB17                <1> 	jmp	.timeout		; no reply - timeout
  3824                              <1> .2:
  3825 00001988 E460                <1> 	in	al,kbc_output_reg
  3826 0000198A 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3827 0000198C 740C                <1> 	je	.ok
  3828 0000198E 3CFE                <1> 	cmp	al,0FEh			; resend?
  3829 00001990 7411                <1> 	je	.resend
  3830 00001992 3CFC                <1> 	cmp	al,0FCh			; error?
  3831 00001994 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3832 00001996 E2E7                <1> 	loop	.1
  3833 00001998 EB05                <1> 	jmp	.timeout
  3834                              <1> 
  3835                              <1> .ok:
  3836 0000199A 30C0                <1> 	xor	al,al			; success - ACK received
  3837 0000199C F8                  <1> 	clc
  3838 0000199D EB07                <1> 	jmp	.exit
  3839                              <1> 
  3840                              <1> .timeout:
  3841 0000199F B003                <1> 	mov	al,03h			; interface error
  3842 000019A1 EB02                <1> 	jmp	.error
  3843                              <1> 
  3844                              <1> .resend:
  3845 000019A3 B004                <1> 	mov	al,04h			; resend
  3846                              <1> 
  3847                              <1> .error:
  3848 000019A5 F9                  <1> 	stc
  3849                              <1> 
  3850                              <1> .exit:
  3851 000019A6 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3852 000019A8 59                  <1> 	pop	cx
  3853 000019A9 C3                  <1> 	ret
  3854                              <1> 
  3855                              <1> ;=========================================================================
  3856                              <1> ; kbc_aux_enable - enable auxiliary device
  3857                              <1> ; Input:
  3858                              <1> ;	none
  3859                              <1> ; Output:
  3860                              <1> ;	ZF = 0 - no error
  3861                              <1> ;	ZF = 1 - error
  3862                              <1> ;-------------------------------------------------------------------------
  3863                              <1> kbc_aux_enable:
  3864 000019AA 50                  <1> 	push	ax
  3865 000019AB B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3866 000019AD B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3867                              <1> 					; enable keyboard, enable aux obf
  3868                              <1> 					; interrupt, enable obf interrupt
  3869 000019AF E84AFF              <1> 	call	kbc_send_cmd
  3870 000019B2 58                  <1> 	pop	ax
  3871 000019B3 C3                  <1> 	ret
  3872                              <1> 
  3873                              <1> ;=========================================================================
  3874                              <1> ; kbc_aux_disable - disable auxiliary device
  3875                              <1> ; Input:
  3876                              <1> ;	none
  3877                              <1> ; Output:
  3878                              <1> ;	ZF = 0 - no error
  3879                              <1> ;	ZF = 1 - error
  3880                              <1> ;-------------------------------------------------------------------------
  3881                              <1> kbc_aux_disable:
  3882 000019B4 50                  <1> 	push	ax
  3883 000019B5 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3884 000019B7 B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3885                              <1> 					; enable keyboard, disable aux obf
  3886                              <1> 					; interrupt, enable obf interrupt
  3887 000019B9 E840FF              <1> 	call	kbc_send_cmd
  3888 000019BC 58                  <1> 	pop	ax
  3889 000019BD C3                  <1> 	ret
  3890                              <1> 
  3891                              <1> ;=========================================================================
  3892                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3893                              <1> ; Input:
  3894                              <1> ;	none
  3895                              <1> ; Output:
  3896                              <1> ;	AL = keyboard status register
  3897                              <1> ;	ZF == 0 - data is available
  3898                              <1> ;	ZF == 1 - timed out
  3899                              <1> ;-------------------------------------------------------------------------
  3900                              <1> kbc_wait_aux_full:
  3901 000019BE E889FF              <1> 	call	kbc_wait_output_full
  3902 000019C1 7402                <1> 	jz	.error
  3903 000019C3 A820                <1> 	test	al,kbc_stat_aobf
  3904                              <1> .error:
  3905 000019C5 C3                  <1> 	ret
  3906                              <1> 
  3907                              <1> %endif ; PS2_MOUSE
  3908                              <1> 
  3909                              <1> ;=========================================================================
  3910                              <1> ; kbc_flush - flush all data from i8042 buffers
  3911                              <1> ; Input:
  3912                              <1> ;	none
  3913                              <1> ; Output:
  3914                              <1> ;	CF = 0 - flushed successfully
  3915                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3916                              <1> ;-------------------------------------------------------------------------
  3917                              <1> kbc_flush:
  3918 000019C6 50                  <1> 	push	ax
  3919 000019C7 51                  <1> 	push	cx
  3920 000019C8 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3921                              <1> .flush_next_byte:
  3922 000019CB E464                <1> 	in	al,kbc_status_reg
  3923 000019CD A801                <1> 	test	al,kbc_stat_obf
  3924 000019CF 740F                <1> 	jz	.flushed
  3925 000019D1 51                  <1> 	push	cx
  3926 000019D2 B90400              <1> 	mov	cx,4
  3927 000019D5 E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3928 000019D8 59                  <1> 	pop	cx
  3929 000019D9 E460                <1> 	in	al,kbc_data_reg
  3930 000019DB E2EE                <1> 	loop	.flush_next_byte
  3931 000019DD F9                  <1> 	stc				; unable to flush it
  3932 000019DE EB01                <1> 	jmp	.exit
  3933                              <1> .flushed:
  3934 000019E0 F8                  <1> 	clc
  3935                              <1> .exit:
  3936 000019E1 59                  <1> 	pop	cx
  3937 000019E2 58                  <1> 	pop	ax
  3938 000019E3 C3                  <1> 	ret
  3939                              <1> 
  3940                              <1> ;=========================================================================
  3941                              <1> ; kbc_init - Initialize keyboard controller
  3942                              <1> ;-------------------------------------------------------------------------
  3943                              <1> kbc_init:
  3944 000019E4 50                  <1> 	push	ax
  3945 000019E5 51                  <1> 	push	cx
  3946 000019E6 52                  <1> 	push	dx
  3947                              <1> 
  3948                              <1> ;-------------------------------------------------------------------------
  3949                              <1> ; test keyboard controller
  3950                              <1> 
  3951 000019E7 E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3952                              <1> 
  3953 000019EA B90A00              <1> 	mov	cx,10			; try 10 times
  3954                              <1> 
  3955                              <1> .kbc_reset_retry:
  3956 000019ED B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3957 000019EF E83DFF              <1> 	call 	kbc_send_cmd_byte
  3958 000019F2 E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3959                              <1> 
  3960 000019F5 E460                <1> 	in	al,kbc_output_reg
  3961 000019F7 3C55                <1> 	cmp	al,55h			; check for success
  3962 000019F9 E0F2                <1> 	loopne	.kbc_reset_retry
  3963 000019FB 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3964                              <1> 
  3965 00001A00 B90A00              <1> 	mov	cx,10			; try 10 times
  3966                              <1> 
  3967                              <1> .kbc_test_retry:
  3968 00001A03 B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3969 00001A05 E827FF              <1> 	call	kbc_send_cmd_byte
  3970 00001A08 E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3971                              <1> 
  3972 00001A0B E460                <1> 	in	al,kbc_output_reg
  3973 00001A0D 3C00                <1> 	cmp	al,0			; check for success
  3974 00001A0F E0F2                <1> 	loopne	.kbc_test_retry
  3975 00001A11 7403E98E00          <1> 	jne	kbd_int_fail
  3976                              <1> 
  3977                              <1> ;-------------------------------------------------------------------------
  3978                              <1> ; read display type and set equipment bits accordingly
  3979                              <1> 
  3980 00001A16 B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3981 00001A18 E814FF              <1> 	call	kbc_send_cmd_byte
  3982 00001A1B E82CFF              <1> 	call	kbc_wait_output_full
  3983                              <1> 
  3984 00001A1E E460                <1> 	in	al,kbc_output_reg
  3985 00001A20 A840                <1> 	test	al,kbc_in_display
  3986 00001A22 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3987 00001A24 830E100030          <1> 	or	word [equipment_list],equip_mono
  3988 00001A29 EB05                <1> 	jmp	.get_disp_done
  3989                              <1> .get_disp_color:
  3990 00001A2B 830E100020          <1> 	or	word [equipment_list],equip_color
  3991                              <1> .get_disp_done:
  3992                              <1> 
  3993                              <1> ;-------------------------------------------------------------------------
  3994                              <1> ; initialize keyboard controller
  3995                              <1> 
  3996 00001A30 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  3997 00001A32 E8FAFE              <1> 	call	kbc_send_cmd_byte
  3998                              <1> 
  3999 00001A35 B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  4000 00001A37 E8F5FE              <1> 	call	kbc_send_cmd_byte
  4001                              <1> 
  4002 00001A3A B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  4003 00001A3C B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  4004                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  4005                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  4006                              <1> 					; Bit 4 = 0 - Enable keyboard
  4007                              <1> 					; Bit 3 = 1 - Disable inhibit
  4008                              <1> 					; Bit 2 = 0 - system flag = 0
  4009                              <1> 					; Bit 1 = 0 - reserved
  4010                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  4011 00001A3E E8BBFE              <1> 	call	kbc_send_cmd
  4012                              <1> 
  4013 00001A41 B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  4014 00001A43 E8E9FE              <1> 	call	kbc_send_cmd_byte
  4015                              <1> 
  4016 00001A46 B90010              <1> 	mov	cx,1000h
  4017 00001A49 E8D7F4              <1> 	call	delay_15us
  4018                              <1> 
  4019 00001A4C E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  4020 00001A4F E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  4021                              <1> 
  4022                              <1> 
  4023                              <1> %ifdef PS2_MOUSE
  4024                              <1> ;-------------------------------------------------------------------------
  4025                              <1> ; check for PS/2 mouse presence
  4026                              <1> 
  4027 00001A51 B90A00              <1> 	mov	cx,10			; try 10 times
  4028                              <1> .mouse_reset_retry:
  4029 00001A54 B0FF                <1> 	mov	al,0FFh
  4030 00001A56 E819FF              <1> 	call	kbc_aux_send
  4031 00001A59 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  4032 00001A5B 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4033 00001A5E E1F4                <1> 	loopz	.mouse_reset_retry
  4034 00001A60 EB13                <1> 	jmp	.no_mouse
  4035                              <1> .mouse_reset_ok:
  4036 00001A62 E8F2FE              <1> 	call	kbc_aux_read
  4037 00001A65 720E                <1> 	jc	.no_mouse
  4038 00001A67 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  4039 00001A69 750A                <1> 	jne	.no_mouse
  4040 00001A6B E8E9FE              <1> 	call	kbc_aux_read
  4041 00001A6E 7205                <1> 	jc	.no_mouse
  4042                              <1> ; mouse reset successful, update equipment word accordingly
  4043 00001A70 830E100004          <1> 	or      word [equipment_list],equip_mouse
  4044                              <1> .no_mouse:
  4045                              <1> %endif ; PS2_MOUSE
  4046                              <1> 
  4047                              <1> ;-------------------------------------------------------------------------
  4048                              <1> ; setup keyboard buffer
  4049                              <1> 
  4050 00001A75 B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  4051 00001A78 A38000              <1>         mov     word [kbd_buffer_start],ax
  4052 00001A7B A31A00              <1>         mov     word [kbd_buffer_head],ax
  4053 00001A7E A31C00              <1>         mov     word [kbd_buffer_tail],ax
  4054 00001A81 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  4055 00001A84 A38200              <1>         mov     word [kbd_buffer_end],ax
  4056 00001A87 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  4057 00001A89 A31700              <1>         mov     word [kbd_flags_1],ax
  4058 00001A8C A31800              <1>         mov     word [kbd_flags_2],ax
  4059 00001A8F A39600              <1>         mov     word [kbd_flags_3],ax
  4060 00001A92 A39700              <1>         mov     word [kbd_flags_4],ax
  4061 00001A95 B010                <1> 	mov	al,e_kbd_ok
  4062 00001A97 E680                <1> 	out	post_reg,al
  4063 00001A99 5A                  <1> 	pop	dx
  4064 00001A9A 59                  <1> 	pop	cx
  4065 00001A9B 58                  <1> 	pop	ax
  4066 00001A9C C3                  <1> 	ret
  4067                              <1> 
  4068                              <1> kbd_ctrl_fail:
  4069 00001A9D B060                <1> 	mov	al,e_kbd_ctrl_fail
  4070 00001A9F E680                <1> 	out	post_reg,al
  4071                              <1> .1:
  4072 00001AA1 F4                  <1> 	hlt
  4073 00001AA2 EBFD                <1> 	jmp	.1
  4074                              <1> 
  4075                              <1> kbd_int_fail:
  4076 00001AA4 240F                <1> 	and	al,0Fh
  4077 00001AA6 0463                <1> 	add	al,e_kbd_int_fail
  4078 00001AA8 E680                <1> 	out	post_reg,al
  4079                              <1> .1:
  4080 00001AAA F4                  <1> 	hlt
  4081 00001AAB EBFD                <1> 	jmp	.1
  4082                              <1> 
  4083                              <1> kbd_key_fail:
  4084 00001AAD B061                <1> 	mov	al,e_kbd_key_fail
  4085 00001AAF E680                <1> 	out	post_reg,al
  4086                              <1> .1:
  4087 00001AB1 F4                  <1> 	hlt
  4088 00001AB2 EBFD                <1> 	jmp	.1
  4089                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  4090                              <1> ;=========================================================================
  4091                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  4092                              <1> ;		 and related INT 16h functions:
  4093                              <1> ;	INT 16h - BIOS Keyboard Services
  4094                              <1> ;		- function AH=00h
  4095                              <1> ;		- function AH=01h
  4096                              <1> ;		- function AH=10h
  4097                              <1> ;		- function AH=11h
  4098                              <1> ;-------------------------------------------------------------------------
  4099                              <1> ;
  4100                              <1> ; Compiles with NASM 2.07, might work with other versions
  4101                              <1> ;
  4102                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4103                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4104                              <1> ;
  4105                              <1> ; This program is free software: you can redistribute it and/or modify
  4106                              <1> ; it under the terms of the GNU General Public License as published by
  4107                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4108                              <1> ; (at your option) any later version.
  4109                              <1> ;
  4110                              <1> ; This program is distributed in the hope that it will be useful,
  4111                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4112                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4113                              <1> ; GNU General Public License for more details.
  4114                              <1> ;
  4115                              <1> ; You should have received a copy of the GNU General Public License
  4116                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4117                              <1> ;
  4118                              <1> ;=========================================================================
  4119                              <1> 
  4120                              <1> ;=========================================================================
  4121                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  4122                              <1> ;                   BIOS scan code translation table
  4123                              <1> ; Note 1: Table starts with scancode == 1
  4124                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  4125                              <1> ;	00 - no flags
  4126                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  4127                              <1> ;	     x in this case equals digit value
  4128                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  4129                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  4130                              <1> ;	8x - F11, F12 BIOS scan codes
  4131                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  4132                              <1> ;-------------------------------------------------------------------------
  4133                              <1> 
  4134                              <1> scan_xlat_table:
  4135                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4136 00001AB4 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  4137 00001ABC 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  4138 00001AC4 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  4139 00001ACC 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  4140 00001AD4 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  4141 00001ADC 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  4142 00001AE4 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  4143 00001AEC 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  4144 00001AF4 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  4145 00001AFC 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  4146 00001B04 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  4147 00001B0C 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  4148 00001B14 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  4149 00001B1C 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  4150 00001B24 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  4151 00001B2C 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  4152                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4153 00001B34 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  4154 00001B3C 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  4155 00001B44 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  4156 00001B4C 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  4157 00001B54 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  4158 00001B5C 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  4159 00001B64 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  4160 00001B6C 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  4161 00001B74 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  4162 00001B7C 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  4163 00001B84 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  4164 00001B8C 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  4165 00001B94 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  4166 00001B9C 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  4167 00001BA4 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  4168 00001BAC 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  4169                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4170 00001BB4 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  4171 00001BBC 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  4172 00001BC4 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  4173 00001BCC 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  4174 00001BD4 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  4175 00001BDC 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  4176 00001BE4 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  4177 00001BEC 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  4178 00001BF4 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  4179 00001BFC 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  4180 00001C04 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  4181 00001C0C 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  4182 00001C14 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  4183 00001C1C 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  4184 00001C24 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  4185 00001C2C 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  4186                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4187 00001C34 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  4188 00001C3C 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  4189 00001C44 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  4190 00001C4C 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  4191 00001C54 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  4192 00001C5C 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  4193 00001C64 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  4194 00001C6C 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  4195 00001C74 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  4196 00001C7C 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  4197 00001C84 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  4198 00001C8C 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  4199 00001C94 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  4200 00001C9C 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  4201 00001CA4 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  4202 00001CAC 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  4203                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4204 00001CB4 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  4205 00001CBC 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  4206 00001CC4 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  4207 00001CCC 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  4208 00001CD4 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  4209 00001CDC 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  4210 00001CE4 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  4211 00001CEC 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  4212 00001CF4 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  4213 00001CFC 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  4214 00001D04 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  4215 00001D0C F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  4216 00001D14 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  4217 00001D1C 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  4218 00001D24 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  4219 00001D2C 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  4220                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  4221 00001D34 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  4222 00001D3C 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  4223 00001D44 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  4224 00001D4C 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  4225 00001D54 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  4226 00001D5C 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  4227 00001D64 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  4228 00001D6C 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  4229                              <1> .end:
  4230                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  4231                              <1> 
  4232                              <1> ;=========================================================================
  4233                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  4234                              <1> ; Input:
  4235                              <1> ;	AL - scan code
  4236                              <1> ; Output:
  4237                              <1> ;	AX - ASCII character / scan code pair
  4238                              <1> ;-------------------------------------------------------------------------
  4239                              <1> scan_xlat:
  4240 00001D74 53                  <1> 	push	bx
  4241 00001D75 FEC8                <1> 	dec	al
  4242 00001D77 3C58                <1> 	cmp	al,scan_xlat_table_size
  4243 00001D79 7205                <1> 	jb	.1
  4244 00001D7B 31C0                <1> 	xor	ax,ax
  4245 00001D7D E9AB00              <1> 	jmp	.exit
  4246                              <1> 
  4247                              <1> .1:
  4248 00001D80 B700                <1> 	mov	bh,00h				; calculate offset of the key
  4249 00001D82 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  4250 00001D84 D1E3                <1> 	shl	bx,1				; BX = AL * 8
  4251 00001D86 D1E3                <1> 	shl	bx,1
  4252 00001D88 D1E3                <1> 	shl	bx,1
  4253                              <1> 
  4254 00001D8A F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  4255 00001D8F 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  4256 00001D91 2E8B87[BA1A]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  4257                              <1> 	; check for numeric Keypad keys
  4258 00001D96 2EF687[B51A]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  4259 00001D9C 7474                <1> 	jz	.check_extended
  4260 00001D9E F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4261 00001DA3 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  4262                              <1> 						; and so it is not a keypad key
  4263                              <1> 
  4264 00001DA5 2E8A87[B51A]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  4265 00001DAA 240F                <1> 	and	al,0Fh				; get the numeric value
  4266 00001DAC 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  4267 00001DB0 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  4268 00001DB2 A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  4269                              <1> 
  4270 00001DB5 31C0                <1> 	xor	ax,ax				; return nothing
  4271 00001DB7 EB72                <1> 	jmp	.exit
  4272                              <1> 
  4273                              <1> .check_ctrl:
  4274 00001DB9 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  4275 00001DBE 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  4276 00001DC0 2E8B87[B81A]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  4277 00001DC5 EB4B                <1> 	jmp	.check_extended
  4278                              <1> 
  4279                              <1> .check_locks:
  4280 00001DC7 2EF687[B51A]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  4281 00001DCD 741D                <1> 	jz	.check_shift			; not affected by Locks
  4282                              <1> 
  4283 00001DCF 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  4284 00001DD1 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  4285                              <1> 
  4286 00001DD3 F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  4287 00001DD8 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  4288 00001DDA EB07                <1> 	jmp	.lock_active
  4289                              <1> 
  4290                              <1> .check_num_lock:
  4291 00001DDC F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  4292 00001DE1 7409                <1> 	jz	.check_shift			; Num Lock is not active
  4293                              <1> .lock_active:
  4294                              <1> 	; are any of Shift keys active?
  4295 00001DE3 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4296 00001DE8 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  4297 00001DEA EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  4298                              <1> 
  4299                              <1> .check_shift:
  4300                              <1> 	; are any of Shift keys active?
  4301 00001DEC F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4302 00001DF1 7407                <1> 	jz	.no_shift
  4303                              <1> .shift:
  4304 00001DF3 2E8B87[B61A]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  4305 00001DF8 EB18                <1> 	jmp	.check_extended
  4306                              <1> 
  4307                              <1> .no_shift:
  4308 00001DFA 88C4                <1> 	mov	ah,al				; Move scan code to AH
  4309 00001DFC FEC4                <1> 	inc	ah
  4310 00001DFE 2E8A87[B41A]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  4311 00001E03 2EF687[B51A]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  4312 00001E09 7407                <1> 	jz	.check_extended			; not F11 or F12
  4313 00001E0B 2E8AA7[B51A]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  4314 00001E10 EB19                <1> 	jmp	.exit
  4315                              <1> 
  4316                              <1> .check_extended:
  4317 00001E12 2EF687[B51A]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  4318 00001E18 7411                <1> 	jz	.exit				; no extended key
  4319 00001E1A F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4320 00001E1F 740A                <1> 	jz	.exit				; ... not a 0E0h
  4321 00001E21 3C00                <1> 	cmp	al,00h
  4322 00001E23 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  4323 00001E25 B0E0                <1> 	mov	al,0E0h				; indicate extended key
  4324 00001E27 EB02                <1> 	jmp	.exit
  4325                              <1> 
  4326                              <1> .ascii_code:
  4327 00001E29 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  4328                              <1> 						; key with valid ASCII code
  4329                              <1> 						; (Keypad Enter, *, and /)
  4330                              <1> 
  4331                              <1> .exit:
  4332 00001E2B 5B                  <1> 	pop	bx
  4333 00001E2C C3                  <1> 	ret
  4334                              <1> 
  4335                              <1> ;=========================================================================
  4336                              <1> ; int_16_fn00 - get keystroke
  4337                              <1> ; Input:
  4338                              <1> ;	AH = 00h
  4339                              <1> ; Output:
  4340                              <1> ;	AH = BIOS scan code
  4341                              <1> ;	AL = ASCII character
  4342                              <1> ; Notes:
  4343                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4344                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4345                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4346                              <1> ;	- Use function AH=10h for extended keystrokes handling
  4347                              <1> ;-------------------------------------------------------------------------
  4348                              <1> int_16_fn00:
  4349 00001E2D FB                  <1> 	sti
  4350                              <1> .1:
  4351 00001E2E 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4352 00001E32 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4353 00001E36 74F6                <1> 	jz	.1			; wait or keystroke
  4354 00001E38 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4355 00001E3A 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4356                              <1> 					;   location
  4357 00001E3D 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4358 00001E41 7504                <1> 	jne	.2
  4359 00001E43 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4360                              <1> .2:
  4361 00001E47 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4362 00001E4B 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4363                              <1> 					;   extended key?
  4364 00001E4D 7504                <1> 	jne	.3			; not a convertible key
  4365 00001E4F B000                <1> 	mov	al,00h			; convert to a standard key
  4366 00001E51 EB2C                <1> 	jmp	.exit
  4367                              <1> .3:
  4368 00001E53 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4369 00001E55 74D7                <1> 	je	.1			; an ignored extended key, get next key
  4370 00001E57 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4371                              <1> 					;   (scancode above 84h)
  4372 00001E5A 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  4373 00001E5C 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4374 00001E5F 751E                <1> 	jne	.exit
  4375 00001E61 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4376 00001E63 7504                <1> 	jne	.4
  4377 00001E65 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4378 00001E67 EB16                <1> 	jmp	.exit
  4379                              <1> .4:
  4380 00001E69 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4381 00001E6B 7504                <1> 	jne	.5
  4382 00001E6D B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4383 00001E6F EB0E                <1> 	jmp	.exit
  4384                              <1> .5:
  4385 00001E71 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4386 00001E73 7504                <1> 	jne	.6
  4387 00001E75 B435                <1> 	mov	ah,35h			; standard / scancode
  4388 00001E77 EB06                <1> 	jmp	.exit
  4389                              <1> .6:
  4390 00001E79 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4391 00001E7B 7502                <1> 	jne	.exit
  4392 00001E7D B437                <1> 	mov	ah,37h			; standard * scancode
  4393                              <1> .exit:
  4394 00001E7F E9E949              <1> 	jmp	int_16_exit
  4395                              <1> 
  4396                              <1> ;=========================================================================
  4397                              <1> ; int_16_fn01 - check for keystroke
  4398                              <1> ; Input:
  4399                              <1> ;	AH = 01h
  4400                              <1> ; Output:
  4401                              <1> ;	ZF = 1 - no keystroke available
  4402                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4403                              <1> ;		AH = BIOS scan code
  4404                              <1> ;		AL = ASCII character
  4405                              <1> ; Notes:
  4406                              <1> ;	- Does not remove keystroke from keyboard buffer
  4407                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4408                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4409                              <1> ;	- Use function AH=11h for extended keystrokes handling
  4410                              <1> ;-------------------------------------------------------------------------
  4411                              <1> int_16_fn01:
  4412 00001E82 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4413 00001E86 8B07                <1> 	mov	ax,word [bx]
  4414 00001E88 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4415 00001E8C 7436                <1> 	jz	.exit			; no keystroke, exit
  4416 00001E8E 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4417                              <1> 					;   extended key?
  4418 00001E90 7504                <1> 	jne	.1			; not a convertible key
  4419 00001E92 B000                <1> 	mov	al,00h			; convert to a standard key
  4420 00001E94 EB2C                <1> 	jmp	.clear_zf
  4421                              <1> .1:
  4422 00001E96 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4423 00001E98 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  4424 00001E9A 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4425                              <1> 					;   (scancode above 84h)
  4426 00001E9D 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  4427 00001E9F 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4428 00001EA2 751E                <1> 	jne	.clear_zf
  4429 00001EA4 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4430 00001EA6 7504                <1> 	jne	.2
  4431 00001EA8 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4432 00001EAA EB16                <1> 	jmp	.clear_zf
  4433                              <1> .2:
  4434 00001EAC 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4435 00001EAE 7504                <1> 	jne	.3
  4436 00001EB0 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4437 00001EB2 EB0E                <1> 	jmp	.clear_zf
  4438                              <1> .3:
  4439 00001EB4 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4440 00001EB6 7504                <1> 	jne	.4
  4441 00001EB8 B435                <1> 	mov	ah,35h			; standard / scancode
  4442 00001EBA EB06                <1> 	jmp	.clear_zf
  4443                              <1> .4:
  4444 00001EBC 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4445 00001EBE 7502                <1> 	jne	.clear_zf
  4446 00001EC0 B437                <1> 	mov	ah,37h			; standard * scancode
  4447                              <1> 
  4448                              <1> .clear_zf:
  4449 00001EC2 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4450                              <1> .exit:
  4451 00001EC4 E9A749              <1> 	jmp	int_16_exitf
  4452                              <1> 
  4453                              <1> .discard_key:
  4454 00001EC7 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4455                              <1> 					;   location
  4456 00001ECA 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4457 00001ECE 7504                <1> 	jne	.5
  4458 00001ED0 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4459                              <1> .5:
  4460 00001ED4 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4461 00001ED8 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4462                              <1> 	
  4463                              <1> 
  4464                              <1> ;=========================================================================
  4465                              <1> ; int_16_fn10 - get extended keystroke
  4466                              <1> ; Input:
  4467                              <1> ;	AH = 10h
  4468                              <1> ; Output:
  4469                              <1> ;	AH = BIOS scan code
  4470                              <1> ;	AL = ASCII character
  4471                              <1> ; Note:
  4472                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4473                              <1> ;-------------------------------------------------------------------------
  4474                              <1> int_16_fn10:
  4475 00001EDA FB                  <1> 	sti
  4476                              <1> .1:
  4477 00001EDB 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4478 00001EDF 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4479 00001EE3 74F6                <1> 	jz	.1			; wait or keystroke
  4480 00001EE5 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4481 00001EE7 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4482                              <1> 					;   location
  4483 00001EEA 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4484 00001EEE 7504                <1> 	jne	.2
  4485 00001EF0 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4486                              <1> .2:
  4487 00001EF4 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4488 00001EF8 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4489 00001EFA 7502                <1> 	jne	.exit			; not a extended key
  4490 00001EFC B000                <1> 	mov	al,00h			; set scancode to zero
  4491                              <1> 
  4492                              <1> .exit:
  4493 00001EFE E96A49              <1> 	jmp	int_16_exit
  4494                              <1> 
  4495                              <1> ;=========================================================================
  4496                              <1> ; int_16_fn11 - check for extended keystroke
  4497                              <1> ; Input:
  4498                              <1> ;	AH = 01h
  4499                              <1> ; Output:
  4500                              <1> ;	ZF = 1 - no keystroke available
  4501                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4502                              <1> ;		AH = BIOS scan code
  4503                              <1> ;		AL = ASCII character
  4504                              <1> ; Note:
  4505                              <1> ;	- Does not remove keystroke from keyboard buffer
  4506                              <1> ;-------------------------------------------------------------------------
  4507                              <1> int_16_fn11:
  4508 00001F01 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4509 00001F05 8B07                <1> 	mov	ax,word [bx]
  4510 00001F07 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4511 00001F0B 7408                <1> 	jz	.exit			; no keystroke, exit
  4512 00001F0D 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4513 00001F0F 7502                <1> 	jne	.clear_zf		; not a extended key
  4514 00001F11 B000                <1> 	mov	al,00h			; set scancode to zero
  4515                              <1> .clear_zf:
  4516 00001F13 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4517                              <1> .exit:
  4518 00001F15 E95649              <1> 	jmp	int_16_exitf
  4519                                  %include	"serial1.inc"		; serial port services & detection
  4520                              <1> ;========================================================================
  4521                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
  4522                              <1> ;       INT 14h, function AH=01h
  4523                              <1> ;	INT 14h, function AH=02h
  4524                              <1> ;	detect_serial
  4525                              <1> ;	serial port related definitions and tables
  4526                              <1> ;	- see serial2.inc for other INT 14h functions
  4527                              <1> ;-------------------------------------------------------------------------
  4528                              <1> ;
  4529                              <1> ; Compiles with NASM 2.07, might work with other versions
  4530                              <1> ;
  4531                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4532                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4533                              <1> ;
  4534                              <1> ; This program is free software: you can redistribute it and/or modify
  4535                              <1> ; it under the terms of the GNU General Public License as published by
  4536                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4537                              <1> ; (at your option) any later version.
  4538                              <1> ;
  4539                              <1> ; This program is distributed in the hope that it will be useful,
  4540                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4541                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4542                              <1> ; GNU General Public License for more details.
  4543                              <1> ;
  4544                              <1> ; You should have received a copy of the GNU General Public License
  4545                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4546                              <1> ;
  4547                              <1> ;=========================================================================
  4548                              <1> 
  4549                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
  4550                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
  4551                              <1> 
  4552                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
  4553                              <1> 
  4554                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
  4555                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
  4556                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
  4557                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
  4558                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
  4559                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
  4560                              <1> 
  4561                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
  4562                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
  4563                              <1> uart_mcr_rts	equ	3		; MCR - request to send (RTS)
  4564                              <1> 
  4565                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
  4566                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
  4567                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
  4568                              <1> 
  4569                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
  4570                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
  4571                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
  4572                              <1> 
  4573                              <1> uart_err_timeout equ	80h		; timeout error
  4574                              <1> 
  4575                              <1> num_serial	equ	4		; number of serial ports
  4576                              <1> 
  4577                              <1> ;=========================================================================
  4578                              <1> ; int_14_fn01 - Send character
  4579                              <1> ; Input:
  4580                              <1> ;	AH = 01h - function 01h - send character
  4581                              <1> ;	AL = character to send
  4582                              <1> ;	DX = serial port number (0-3)
  4583                              <1> ; Output:
  4584                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4585                              <1> ;-------------------------------------------------------------------------
  4586                              <1> int_14_fn01:
  4587 00001F18 50                  <1> 	push	ax
  4588 00001F19 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4589 00001F1B B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR
  4590 00001F1D B320                <1> 	mov	bl,uart_lsr_thre	; and for THR empty in LSR
  4591 00001F1F E82200              <1> 	call	uart_wait_status
  4592 00001F22 59                  <1> 	pop	cx
  4593 00001F23 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
  4594 00001F25 88C8                <1> 	mov	al,cl
  4595 00001F27 EE                  <1> 	out	dx,al			; sent the character
  4596 00001F28 E93B48              <1> 	jmp	int_14_exit
  4597                              <1> 
  4598                              <1> int_14_timeout:
  4599 00001F2B 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
  4600 00001F2D 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
  4601 00001F30 E93348              <1> 	jmp	int_14_exit
  4602                              <1> 
  4603                              <1> ;=========================================================================
  4604                              <1> ; int_14_fn02 - Receive character
  4605                              <1> ; Input:
  4606                              <1> ;	AH = 02h - function 02h - receive character
  4607                              <1> ;	DX = serial port number (0-3)
  4608                              <1> ; Output:
  4609                              <1> ;	AL = character received
  4610                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4611                              <1> ;-------------------------------------------------------------------------
  4612                              <1> int_14_fn02:
  4613 00001F33 50                  <1> 	push	ax
  4614 00001F34 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4615 00001F36 B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR
  4616 00001F38 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR
  4617 00001F3A E80700              <1> 	call	uart_wait_status
  4618 00001F3D 59                  <1> 	pop	cx
  4619 00001F3E 75EB                <1> 	jnz	int_14_timeout
  4620 00001F40 EC                  <1> 	in	al,dx			; receive the character
  4621 00001F41 E92248              <1> 	jmp	int_14_exit
  4622                              <1> 
  4623                              <1> ;=========================================================================
  4624                              <1> ; uart_wait_status - wait for modem and line status
  4625                              <1> ; Input:
  4626                              <1> ;	AL = value to write to MCR (Modem Control Register)
  4627                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
  4628                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
  4629                              <1> ;	DX = UART base address
  4630                              <1> ;	SI = serial port number
  4631                              <1> ; Output:
  4632                              <1> ;	AH = line status
  4633                              <1> ;	ZF = 0 - timeout
  4634                              <1> ;	CX,BX - destroyed
  4635                              <1> ;-------------------------------------------------------------------------
  4636                              <1> uart_wait_status:
  4637 00001F44 52                  <1> 	push	dx
  4638 00001F45 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
  4639 00001F48 EE                  <1> 	out	dx,al			; output MCR value
  4640 00001F49 42                  <1> 	inc	dx
  4641 00001F4A 42                  <1> 	inc	dx			; DX = UART MSR address
  4642                              <1> 					; OPTIMIZATION:
  4643                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
  4644 00001F4B E80A00              <1> 	call	wait_for_port		; wait for MSR status
  4645 00001F4E 7506                <1> 	jnz	.wait_exit
  4646 00001F50 4A                  <1> 	dec	dx			; DX = UART LSR address
  4647                              <1> 					; OPTIMIZATION:
  4648                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
  4649 00001F51 88DF                <1> 	mov	bh,bl			; BH = LSR mask
  4650 00001F53 E80200              <1> 	call	wait_for_port		; wait for LSR status
  4651                              <1> .wait_exit:
  4652 00001F56 5A                  <1> 	pop	dx
  4653 00001F57 C3                  <1> 	ret
  4654                              <1> 
  4655                              <1> ;=========================================================================
  4656                              <1> ; wait_for_port - wait for set bits in a register
  4657                              <1> ;
  4658                              <1> ; Input:
  4659                              <1> ;	BH = mask to wait for (bits that need to be 1)
  4660                              <1> ;	DX = register address
  4661                              <1> ;	SI = address of the timeout value (in seconds)
  4662                              <1> ; Output:
  4663                              <1> ;	AH = last port reading
  4664                              <1> ;	ZF clear on timeout
  4665                              <1> ;	ZF set on success
  4666                              <1> ;	AL - trashed
  4667                              <1> ;	CX - trashed
  4668                              <1> ;-------------------------------------------------------------------------
  4669                              <1> wait_for_port:
  4670 00001F58 53                  <1> 	push	bx
  4671 00001F59 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
  4672                              <1> 
  4673                              <1> .loop_outer:
  4674 00001F5B B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
  4675                              <1> 
  4676                              <1> .loop_inner:
  4677 00001F5E EC                  <1> 	in	al,dx			; read the register
  4678 00001F5F 88C4                <1> 	mov	ah,al			; save register in AH
  4679 00001F61 20F8                <1> 	and	al,bh
  4680 00001F63 38F8                <1> 	cmp	al,bh			; required bits are set?
  4681 00001F65 7414                <1> 	je	.exit
  4682                              <1> 
  4683                              <1> .zero_loop:
  4684 00001F67 E461                <1> 	in	al,port_b_reg
  4685 00001F69 A810                <1> 	test	al,refresh_flag
  4686 00001F6B 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  4687                              <1> 
  4688                              <1> .one_loop:
  4689 00001F6D E461                <1> 	in	al,port_b_reg
  4690 00001F6F A810                <1> 	test	al,refresh_flag
  4691 00001F71 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  4692 00001F73 E2E9                <1> 	loop	.loop_inner
  4693                              <1> 
  4694 00001F75 FECB                <1> 	dec	bl
  4695 00001F77 75E2                <1> 	jnz	.loop_outer
  4696 00001F79 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
  4697                              <1> 
  4698                              <1> .exit:
  4699 00001F7B 5B                  <1> 	pop	bx
  4700 00001F7C C3                  <1> 	ret
  4701                              <1> 
  4702                              <1> ;=========================================================================
  4703                              <1> ; detect_serial - detect and print serial ports
  4704                              <1> ; Input:
  4705                              <1> ;	none
  4706                              <1> ; Output:
  4707                              <1> ;	none (updates BIOS data area)
  4708                              <1> ;-------------------------------------------------------------------------
  4709                              <1> detect_serial:
  4710 00001F7D 50                  <1> 	push	ax
  4711 00001F7E 53                  <1> 	push	bx
  4712 00001F7F 52                  <1> 	push	dx
  4713 00001F80 56                  <1> 	push	si
  4714 00001F81 BE[A902]            <1> 	mov	si,msg_serial
  4715 00001F84 E84D06              <1> 	call	print
  4716 00001F87 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
  4717 00001F8A 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
  4718 00001F8E 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
  4719 00001F92 31DB                <1> 	xor	bx,bx			; BX = 0
  4720                              <1> .detect_loop:
  4721 00001F94 BE[C602]            <1> 	mov	si,msg_serial_com
  4722 00001F97 E83A06              <1> 	call	print
  4723 00001F9A 88D8                <1> 	mov	al,bl
  4724 00001F9C D0E8                <1> 	shr	al,1
  4725 00001F9E FEC0                <1> 	inc	al			; AL = COM port number (1..4)
  4726 00001FA0 E88F06              <1> 	call	print_digit
  4727 00001FA3 BE[9000]            <1> 	mov	si,msg_colon
  4728 00001FA6 E82B06              <1> 	call	print
  4729 00001FA9 2E8B97[F91F]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
  4730 00001FAE EC                  <1> 	in	al,dx
  4731 00001FAF B00F                <1> 	mov	al,0Fh
  4732 00001FB1 EE                  <1> 	out	dx,al			; enable interrupts
  4733 00001FB2 B000                <1> 	mov	al,00h
  4734 00001FB4 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
  4735 00001FB6 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4736 00001FB7 3C0F                <1> 	cmp	al,0Fh
  4737 00001FB9 7516                <1> 	jne	.no_port		; no port at this address
  4738 00001FBB B000                <1> 	mov	al,00h
  4739 00001FBD EE                  <1> 	out	dx,al			; disable interrupts
  4740 00001FBE B0FF                <1> 	mov	al,0FFh
  4741 00001FC0 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4742 00001FC2 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4743 00001FC3 3C00                <1> 	cmp	al,00h
  4744 00001FC5 750A                <1> 	jne	.no_port		; no port at this address
  4745 00001FC7 4A                  <1> 	dec	dx			; DX = UART base address
  4746                              <1> 					; OPTIMIZATION:
  4747                              <1> 					; uart_base = uart_ier_reg - 1
  4748 00001FC8 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
  4749                              <1> 					; data area
  4750 00001FCA 89D0                <1> 	mov	ax,dx
  4751 00001FCC E82006              <1> 	call	print_hex
  4752 00001FCF EB0A                <1> 	jmp	.next
  4753                              <1> 
  4754                              <1> .no_port:
  4755 00001FD1 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
  4756 00001FD5 BE[8B00]            <1> 	mov	si,msg_none
  4757 00001FD8 E8F905              <1> 	call	print
  4758                              <1> 	
  4759                              <1> .next:
  4760 00001FDB 43                  <1> 	inc	bx
  4761 00001FDC 43                  <1> 	inc	bx
  4762 00001FDD 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
  4763 00001FE0 7408                <1> 	je	.done
  4764 00001FE2 BE[9300]            <1> 	mov	si,msg_semicolon
  4765 00001FE5 E8EC05              <1> 	call	print
  4766 00001FE8 EBAA                <1> 	jmp	.detect_loop
  4767                              <1> 
  4768                              <1> .done:
  4769 00001FEA BE[8800]            <1> 	mov	si,msg_crlf
  4770 00001FED E8E405              <1> 	call	print
  4771                              <1> 
  4772 00001FF0 B024                <1> 	mov	al,e_serial_ok		; serial port detection complete
  4773 00001FF2 E680                <1> 	out	post_reg,al
  4774                              <1> 
  4775 00001FF4 5E                  <1> 	pop	si
  4776 00001FF5 5A                  <1> 	pop	dx
  4777 00001FF6 5B                  <1> 	pop	bx
  4778 00001FF7 58                  <1> 	pop	ax
  4779 00001FF8 C3                  <1> 	ret
  4780                              <1> 
  4781                              <1> ;-------------------------------------------------------------------------
  4782                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
  4783 00001FF9 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
  4784 00001FFD E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
  4785                              <1> 
  4786                              <1> ;-------------------------------------------------------------------------
  4787                              <1> ; UART divisor values table
  4788 00002001 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
  4789 00002003 0003                <1> 		dw	uart_osc/16/150		; 150 bps
  4790 00002005 8001                <1> 		dw	uart_osc/16/300		; 300 bps
  4791 00002007 C000                <1> 		dw	uart_osc/16/600		; 600 bps
  4792 00002009 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
  4793 0000200B 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
  4794 0000200D 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
  4795 0000200F 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
  4796 00002011 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
  4797 00002013 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
  4798 00002015 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
  4799 00002017 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
  4800                              <1> num_divisors	equ ($-uart_divisors)/2
  4801                                  %include	"printer1.inc"		; parallel printer services & detection
  4802                              <1> ;========================================================================
  4803                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
  4804                              <1> ;	INT 17h, function AH=01h 
  4805                              <1> ;	detect_parallel
  4806                              <1> ;	- see printer2.inc for other INT 17h functions
  4807                              <1> ;-------------------------------------------------------------------------
  4808                              <1> ;
  4809                              <1> ; Compiles with NASM 2.07, might work with other versions
  4810                              <1> ;
  4811                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4812                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4813                              <1> ;
  4814                              <1> ; This program is free software: you can redistribute it and/or modify
  4815                              <1> ; it under the terms of the GNU General Public License as published by
  4816                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4817                              <1> ; (at your option) any later version.
  4818                              <1> ;
  4819                              <1> ; This program is distributed in the hope that it will be useful,
  4820                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4821                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4822                              <1> ; GNU General Public License for more details.
  4823                              <1> ;
  4824                              <1> ; You should have received a copy of the GNU General Public License
  4825                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4826                              <1> ;
  4827                              <1> ;=========================================================================
  4828                              <1> 
  4829                              <1> num_parallel	equ	3		; number of parallel ports
  4830                              <1> 
  4831                              <1> prn_data_reg	equ	0		; printer data register (out)
  4832                              <1> 
  4833                              <1> prn_stat_reg	equ	1		; printer status register (in)
  4834                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
  4835                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
  4836                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
  4837                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
  4838                              <1> 
  4839                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
  4840                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
  4841                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
  4842                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
  4843                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
  4844                              <1> 
  4845                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
  4846                              <1> 
  4847                              <1> ;=========================================================================
  4848                              <1> ; int_17_fn01 - Initialize printer port
  4849                              <1> ; Input:
  4850                              <1> ;	AH = 1 - function 01h - initialize printer port
  4851                              <1> ;	DX = printer port number (0-2)
  4852                              <1> ; Output:
  4853                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  4854                              <1> ;-------------------------------------------------------------------------
  4855                              <1> int_17_fn01:
  4856 00002019 42                  <1> 	inc	dx
  4857 0000201A 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  4858                              <1> 					; OPTIMIZATION:
  4859                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
  4860 0000201B B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
  4861 0000201D EE                  <1> 	out	dx,al
  4862 0000201E 51                  <1> 	push	cx
  4863 0000201F B9B509              <1> 	mov	cx,prn_init_delay
  4864 00002022 E8FEEE              <1> 	call	delay_15us
  4865 00002025 59                  <1> 	pop	cx
  4866 00002026 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  4867 00002028 EE                  <1> 	out	dx,al			; deactivate init bit
  4868 00002029 4A                  <1> 	dec	dx			; OPTIMIZATION:
  4869                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
  4870 0000202A E90C50              <1> 	jmp	int_17_status		; exit returning status
  4871                              <1> 
  4872                              <1> ;=========================================================================
  4873                              <1> ; detect_parallel - detect and print parallel ports
  4874                              <1> ; Input:
  4875                              <1> ;	none
  4876                              <1> ; Output:
  4877                              <1> ;	none (updates BIOS data area)
  4878                              <1> ; Notes:
  4879                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
  4880                              <1> ;	  enumeration is used:
  4881                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
  4882                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
  4883                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
  4884                              <1> ;-------------------------------------------------------------------------
  4885                              <1> detect_parallel:
  4886 0000202D 50                  <1> 	push	ax
  4887 0000202E 53                  <1> 	push	bx
  4888 0000202F 52                  <1> 	push	dx
  4889 00002030 56                  <1> 	push	si
  4890 00002031 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
  4891 00002034 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
  4892 00002038 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
  4893 0000203C 31DB                <1> 	xor	bx,bx			; BX = 0
  4894 0000203E 31FF                <1> 	xor	di,di			; DI = 0
  4895                              <1> .detect_loop:
  4896 00002040 2E8B95[B720]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
  4897 00002045 B05A                <1> 	mov	al,05Ah			; just some test value
  4898 00002047 EE                  <1> 	out	dx,al			; write it to the printer data register
  4899 00002048 B0FF                <1> 	mov	al,0FFh
  4900 0000204A E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4901 0000204C EC                  <1> 	in	al,dx
  4902 0000204D 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
  4903 0000204F 7505                <1> 	jne	.no_port		; no port at this address
  4904 00002051 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
  4905                              <1> 					; data area
  4906 00002054 EB09                <1> 	jmp	.next
  4907                              <1> 
  4908                              <1> .no_port:
  4909 00002056 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
  4910 0000205B 09FF                <1> 	or	di,di			; no printer port at 3BCh?
  4911 0000205D 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
  4912                              <1> .next:
  4913 0000205F 43                  <1> 	inc	bx
  4914 00002060 43                  <1> 	inc	bx
  4915                              <1> 
  4916                              <1> .next_skip_3BC:
  4917 00002061 47                  <1> 	inc	di
  4918 00002062 47                  <1> 	inc	di
  4919 00002063 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
  4920 00002066 7402                <1> 	je	.print			; done with detection, print findings
  4921 00002068 EBD6                <1> 	jmp	.detect_loop
  4922                              <1> 
  4923                              <1> .print:
  4924 0000206A BE[CA02]            <1> 	mov	si,msg_parallel
  4925 0000206D E86405              <1> 	call	print
  4926 00002070 31DB                <1> 	xor	bx,bx
  4927                              <1> 
  4928                              <1> .print_loop:
  4929 00002072 BE[E702]            <1> 	mov	si,msg_parallel_lpt
  4930 00002075 E85C05              <1> 	call	print
  4931 00002078 88D8                <1> 	mov	al,bl
  4932 0000207A D0E8                <1> 	shr	al,1
  4933 0000207C FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
  4934 0000207E E8B105              <1> 	call	print_digit
  4935 00002081 BE[9000]            <1> 	mov	si,msg_colon
  4936 00002084 E84D05              <1> 	call	print
  4937 00002087 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
  4938 0000208A 09C0                <1> 	or	ax,ax			; parallel interface installed?
  4939 0000208C 7405                <1> 	jz	.print_no_port
  4940 0000208E E85E05              <1> 	call	print_hex
  4941 00002091 EB06                <1> 	jmp	.print_next
  4942                              <1> 
  4943                              <1> .print_no_port:
  4944 00002093 BE[8B00]            <1> 	mov	si,msg_none
  4945 00002096 E83B05              <1> 	call	print
  4946                              <1> 
  4947                              <1> .print_next:
  4948 00002099 43                  <1> 	inc	bx
  4949 0000209A 43                  <1> 	inc	bx
  4950 0000209B 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
  4951 0000209E 7408                <1> 	je	.done
  4952 000020A0 BE[9300]            <1> 	mov	si,msg_semicolon
  4953 000020A3 E82E05              <1> 	call	print
  4954 000020A6 EBCA                <1> 	jmp	.print_loop
  4955                              <1> 
  4956                              <1> .done:
  4957 000020A8 BE[8800]            <1> 	mov	si,msg_crlf
  4958 000020AB E82605              <1> 	call	print
  4959                              <1> 
  4960 000020AE B025                <1> 	mov	al,e_parallel_ok	; parallel port detection complete
  4961 000020B0 E680                <1> 	out	post_reg,al
  4962                              <1> 
  4963 000020B2 5E                  <1> 	pop	si
  4964 000020B3 5A                  <1> 	pop	dx
  4965 000020B4 5B                  <1> 	pop	bx
  4966 000020B5 58                  <1> 	pop	ax
  4967 000020B6 C3                  <1> 	ret
  4968                              <1> 
  4969                              <1> ;-------------------------------------------------------------------------
  4970                              <1> ; parallel port base addresses - used for port detection
  4971 000020B7 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
  4972                                  %ifdef PS2_MOUSE
  4973                                  %ifndef AT_COMPAT
  4974                                  %error "PS2_MOUSE depends on AT_COMPAT. Please fix config.inc."
  4975                                  %endif ; AT_COMPAT
  4976                                  %include	"ps2aux.inc"
  4977                              <1> ;=========================================================================
  4978                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  4979                              <1> ;	INT 15h, function AH=0C2h
  4980                              <1> ;	INT 74h - IRQ12 interrupt handler
  4981                              <1> ;-------------------------------------------------------------------------
  4982                              <1> ;
  4983                              <1> ; Compiles with NASM 2.07, might work with other versions
  4984                              <1> ;
  4985                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4986                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4987                              <1> ;
  4988                              <1> ; This program is free software: you can redistribute it and/or modify
  4989                              <1> ; it under the terms of the GNU General Public License as published by
  4990                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4991                              <1> ; (at your option) any later version.
  4992                              <1> ;
  4993                              <1> ; This program is distributed in the hope that it will be useful,
  4994                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4995                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4996                              <1> ; GNU General Public License for more details.
  4997                              <1> ;
  4998                              <1> ; You should have received a copy of the GNU General Public License
  4999                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5000                              <1> ;
  5001                              <1> ;=========================================================================
  5002                              <1> 
  5003                              <1> ;-------------------------------------------------------------------------
  5004                              <1> ; offsets for registers on stack
  5005                              <1> int_15_fnC2_bp	equ	0
  5006                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  5007                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  5008                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  5009                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  5010                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  5011                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  5012                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  5013                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  5014                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  5015                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  5016                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  5017                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  5018                              <1> 
  5019                              <1> ;=========================================================================
  5020                              <1> ; int_15_fnC2 - mouse functions
  5021                              <1> ; Input:
  5022                              <1> ;	AH = 0C2h - mouse functions
  5023                              <1> ;	AL - function:
  5024                              <1> ;		00h - enable / disable PS/2 mouse
  5025                              <1> ;		01h - reset PS/2 mouse
  5026                              <1> ;		02h - set sample rate
  5027                              <1> ;		03h - set resolution
  5028                              <1> ;		04h - read device type
  5029                              <1> ;		05h - initialize PS/2 mouse
  5030                              <1> ;		06h - set scaling or get status
  5031                              <1> ;		07h - set PS/2 mouse driver address
  5032                              <1> ; Output:
  5033                              <1> ;	AH - exit status:
  5034                              <1> ;		00h - no error
  5035                              <1> ;		01h - invalid function call
  5036                              <1> ;		02h - invalid input value
  5037                              <1> ;		03h - interface error
  5038                              <1> ;		04h - request for resend received from 8042
  5039                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  5040                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  5041                              <1> ;-------------------------------------------------------------------------
  5042                              <1> int_15_fnC2:
  5043 000020BD 50                  <1> 	push	ax
  5044 000020BE 53                  <1> 	push	bx
  5045 000020BF 51                  <1> 	push	cx
  5046 000020C0 52                  <1> 	push	dx
  5047 000020C1 1E                  <1> 	push	ds
  5048 000020C2 55                  <1> 	push	bp
  5049 000020C3 89E5                <1> 	mov	bp,sp			; establish stack addressing
  5050 000020C5 BB4000              <1> 	mov	bx,biosdseg
  5051 000020C8 8EDB                <1> 	mov	ds,bx
  5052 000020CA 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  5053 000020CE 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  5054 000020D0 3C08                <1> 	cmp	al,.num_func
  5055 000020D2 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  5056 000020D4 E8DDF8              <1> 	call	kbc_aux_disable		; disable auxiliary device
  5057 000020D7 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  5058 000020D9 B700                <1> 	mov	bh,0
  5059 000020DB D1E3                <1> 	shl	bx,1			; address words
  5060 000020DD 2EFFA7[E220]        <1>     cs	jmp	near [.dispatch+bx]
  5061                              <1> 
  5062                              <1> .dispatch:
  5063 000020E2 [1B21]              <1> 	dw	int_15_fnC200
  5064 000020E4 [3C21]              <1> 	dw	int_15_fnC201
  5065 000020E6 [5F21]              <1> 	dw	int_15_fnC202
  5066 000020E8 [8621]              <1> 	dw	int_15_fnC203
  5067 000020EA [A821]              <1> 	dw	int_15_fnC204
  5068 000020EC [C021]              <1> 	dw	int_15_fnC205
  5069 000020EE [0422]              <1> 	dw	int_15_fnC206
  5070 000020F0 [5522]              <1> 	dw	int_15_fnC207
  5071                              <1> .num_func	equ ($-.dispatch)/2
  5072                              <1> 
  5073                              <1> int_15_fnC2_ok:
  5074 000020F2 B400                <1> 	mov	ah,00h			; no error
  5075 000020F4 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  5076 000020F8 EB14                <1> 	jmp	int_15_fnC2_exit
  5077                              <1> 
  5078                              <1> int_15_fnC2_err1:
  5079 000020FA B401                <1> 	mov	ah,01h			; invalid function call
  5080 000020FC EB0C                <1> 	jmp	int_15_fnC2_err
  5081                              <1> 
  5082                              <1> int_15_fnC2_err2:
  5083 000020FE B402                <1> 	mov	ah,02h			; invalid input value
  5084 00002100 EB08                <1> 	jmp	int_15_fnC2_err
  5085                              <1> 
  5086                              <1> int_15_fnC2_err3:
  5087 00002102 B403                <1> 	mov	ah,03h			; interface error
  5088 00002104 EB04                <1> 	jmp	int_15_fnC2_err
  5089                              <1> 
  5090                              <1> int_15_fnC2_err5:
  5091 00002106 B405                <1> 	mov	ah,05h			; no driver installed
  5092 00002108 EB00                <1> 	jmp	int_15_fnC2_err
  5093                              <1> 
  5094                              <1> int_15_fnC2_err:
  5095 0000210A 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  5096                              <1> 
  5097                              <1> int_15_fnC2_exit:
  5098 0000210E 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  5099 00002111 E896F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
  5100 00002114 5D                  <1> 	pop	bp
  5101 00002115 1F                  <1> 	pop	ds
  5102 00002116 5A                  <1> 	pop	dx
  5103 00002117 59                  <1> 	pop	cx
  5104 00002118 5B                  <1> 	pop	bx
  5105 00002119 58                  <1> 	pop	ax
  5106 0000211A CF                  <1> 	iret
  5107                              <1> 
  5108                              <1> ;=========================================================================
  5109                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  5110                              <1> ; Input:
  5111                              <1> ;	AX = 0C200h
  5112                              <1> ;	BH - sub-function:
  5113                              <1> ;		00h - disable
  5114                              <1> ;		01h - enable
  5115                              <1> ;-------------------------------------------------------------------------
  5116                              <1> int_15_fnC200:
  5117 0000211B 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5118 0000211E 80FF01              <1> 	cmp	bh,01h
  5119 00002121 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5120                              <1> 
  5121 00002123 F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  5122 00002128 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  5123                              <1> 
  5124 0000212A 80FF00              <1> 	cmp	bh,00h
  5125 0000212D 7404                <1> 	je	.disable
  5126 0000212F B0F4                <1> 	mov	al,0F4h			; device enable command
  5127 00002131 EB02                <1> 	jmp	.send_it
  5128                              <1> .disable:
  5129 00002133 B0F5                <1> 	mov	al,0F5h			; device disable command
  5130                              <1> 
  5131                              <1> .send_it:
  5132 00002135 E83AF8              <1> 	call	kbc_aux_send
  5133 00002138 72D0                <1> 	jc	int_15_fnC2_err		; error
  5134 0000213A EBB6                <1> 	jmp	int_15_fnC2_ok
  5135                              <1> 
  5136                              <1> ;=========================================================================
  5137                              <1> ; int_15_fnC201 - reset PS/2 mouse
  5138                              <1> ; Input:
  5139                              <1> ;	AX = 0C201h
  5140                              <1> ; Output:
  5141                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  5142                              <1> ;	     0AAh - BAT successful XXX test!!!
  5143                              <1> ;	     0FCh - BAT error
  5144                              <1> ;	BH = device ID
  5145                              <1> ;-------------------------------------------------------------------------
  5146                              <1> int_15_fnC201:
  5147 0000213C B90A00              <1> 	mov	cx,10			; try the reset 10 times
  5148                              <1> .1:
  5149 0000213F B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5150 00002141 E82EF8              <1> 	call	kbc_aux_send
  5151 00002144 7307                <1> 	jnc	.2			; no error - continue
  5152 00002146 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5153 00002149 E1F4                <1> 	loopz	.1			; try again
  5154 0000214B EBBD                <1> 	jmp	int_15_fnC2_err		; error
  5155                              <1> .2:
  5156 0000214D E807F8              <1> 	call	kbc_aux_read
  5157 00002150 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  5158 00002152 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5159 00002155 E8FFF7              <1> 	call	kbc_aux_read
  5160 00002158 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  5161 0000215A 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5162 0000215D EB93                <1> 	jmp	int_15_fnC2_ok
  5163                              <1> 
  5164                              <1> ;=========================================================================
  5165                              <1> ; int_15_fnC202 - set sample rate
  5166                              <1> ; Input:
  5167                              <1> ;	AX = 0C202h
  5168                              <1> ;	BH - sample rate:
  5169                              <1> ;		00h - 10 samples per second
  5170                              <1> ;		01h - 20 samples per second
  5171                              <1> ;		02h - 40 samples per second
  5172                              <1> ;		03h - 60 samples per second
  5173                              <1> ;		04h - 80 samples per second
  5174                              <1> ;		05h - 100 samples per second
  5175                              <1> ;		06h - 200 samples per second
  5176                              <1> ;-------------------------------------------------------------------------
  5177                              <1> int_15_fnC202:
  5178 0000215F 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5179 00002162 80FF06              <1> 	cmp	bh,06h
  5180 00002165 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  5181 00002167 88FB                <1> 	mov	bl,bh
  5182 00002169 B700                <1> 	mov	bh,00h			; rate index in BX
  5183                              <1> 
  5184 0000216B B0F3                <1> 	mov	al,0F3h			; set sample rate
  5185 0000216D E802F8              <1> 	call	kbc_aux_send
  5186 00002170 7298                <1> 	jc	int_15_fnC2_err		; error
  5187                              <1> 
  5188 00002172 2E8A87[7F21]        <1>     cs	mov	al,byte [.rate_table+bx]
  5189 00002177 E8F8F7              <1> 	call	kbc_aux_send
  5190 0000217A 728E                <1> 	jc	int_15_fnC2_err		; error
  5191 0000217C E973FF              <1> 	jmp	int_15_fnC2_ok
  5192                              <1> 
  5193 0000217F 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  5194                              <1> 	
  5195                              <1> ;=========================================================================
  5196                              <1> ; int_15_fnC203 - set resolution
  5197                              <1> ; Input:
  5198                              <1> ;	AX = 0C203h
  5199                              <1> ;	BH - resolution value:
  5200                              <1> ;		00h - 1 count per millimeter
  5201                              <1> ;		01h - 2 counts per millimeter
  5202                              <1> ;		02h - 4 counts per millimeter
  5203                              <1> ;		03h - 8 counts per millimeter
  5204                              <1> ;-------------------------------------------------------------------------
  5205                              <1> int_15_fnC203:
  5206 00002186 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5207 00002189 80FF03              <1> 	cmp	bh,03h
  5208 0000218C 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5209                              <1> 
  5210 00002191 B0E8                <1> 	mov	al,0E8h			; set resolution
  5211 00002193 E8DCF7              <1> 	call	kbc_aux_send
  5212 00002196 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  5213                              <1> 
  5214 0000219B 88F8                <1> 	mov	al,bh
  5215 0000219D E8D2F7              <1> 	call	kbc_aux_send
  5216 000021A0 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  5217 000021A5 E94AFF              <1> 	jmp	int_15_fnC2_ok
  5218                              <1> 
  5219                              <1> ;=========================================================================
  5220                              <1> ; int_15_fnC204 - read device type
  5221                              <1> ; Input:
  5222                              <1> ;	AX = 0C204h
  5223                              <1> ; Output:
  5224                              <1> ;	BH = device type
  5225                              <1> ;-------------------------------------------------------------------------
  5226                              <1> int_15_fnC204:
  5227 000021A8 B0F2                <1> 	mov	al,0F2h			; read device type
  5228 000021AA E8C5F7              <1> 	call	kbc_aux_send
  5229 000021AD 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  5230 000021B2 E8A2F7              <1> 	call	kbc_aux_read
  5231 000021B5 7303E948FF          <1> 	jc	int_15_fnC2_err3
  5232 000021BA 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5233 000021BD E932FF              <1> 	jmp	int_15_fnC2_ok
  5234                              <1> 
  5235                              <1> ;=========================================================================
  5236                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  5237                              <1> ; Input:
  5238                              <1> ;	AX = 0C205h
  5239                              <1> ;	BH = data package size in bytes (03h or 04h)
  5240                              <1> ; Output:
  5241                              <1> ;	none
  5242                              <1> ;-------------------------------------------------------------------------
  5243                              <1> int_15_fnC205:
  5244 000021C0 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5245 000021C3 80FF03              <1> 	cmp	bh,03h
  5246 000021C6 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  5247 000021CB 80FF04              <1> 	cmp	bh,04h
  5248 000021CE 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5249 000021D3 FECF                <1> 	dec	bh
  5250                              <1> 
  5251 000021D5 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5252 000021D8 24F8                <1> 	and	al,0F8h			; mask out package size bits
  5253 000021DA 08F8                <1> 	or	al,bh			; add the new package size
  5254 000021DC A22700              <1> 	mov	byte [mouse_flags_2],al
  5255                              <1> 
  5256 000021DF B90500              <1> 	mov	cx,5			; try the reset 5 times
  5257                              <1> .1:
  5258 000021E2 B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5259 000021E4 E88BF7              <1> 	call	kbc_aux_send
  5260 000021E7 7308                <1> 	jnc	.2			; no error - continue
  5261 000021E9 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5262 000021EC E1F4                <1> 	loopz	.1			; try again
  5263 000021EE E919FF              <1> 	jmp	int_15_fnC2_err		; error
  5264                              <1> .2:
  5265 000021F1 E863F7              <1> 	call	kbc_aux_read
  5266 000021F4 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5267 000021F9 E85BF7              <1> 	call	kbc_aux_read
  5268 000021FC 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5269 00002201 E9EEFE              <1> 	jmp	int_15_fnC2_ok
  5270                              <1> 
  5271                              <1> ;=========================================================================
  5272                              <1> ; int_15_fnC206 - set scaling or get status
  5273                              <1> ; Input:
  5274                              <1> ;	AX = 0C206h
  5275                              <1> ;	BH - sub-function:
  5276                              <1> ;		00h - return status
  5277                              <1> ;		01h - set scaling factor to 1:1
  5278                              <1> ;		02h - set scaling factor to 2:1
  5279                              <1> ; Output:
  5280                              <1> ;	if BH = 00h on entry:
  5281                              <1> ;		BL - status byte 1:
  5282                              <1> ;			bit 0 = 1 - right button pressed
  5283                              <1> ;			bit 1 = 0 - reserved
  5284                              <1> ;			bit 2 = 1 - left button pressed
  5285                              <1> ;			bit 3 = 0 - reserved
  5286                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  5287                              <1> ;			bit 5 = 0 - disable, 1 - enable
  5288                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  5289                              <1> ;			bit 7 = 0 - reserved
  5290                              <1> ;		CL - status byte 2:
  5291                              <1> ;			00h - 1 count per millimeter
  5292                              <1> ;			01h - 2 counts per millimeter
  5293                              <1> ;			02h - 4 counts per millimeter
  5294                              <1> ;			03h - 8 counts per millimeter
  5295                              <1> ;		DL - status byte 3:
  5296                              <1> ;			0Ah - 10 samples per second
  5297                              <1> ;			14h - 20 samples per second
  5298                              <1> ;			3Ch - 40 samples per second
  5299                              <1> ;			3Ch - 60 samples per second
  5300                              <1> ;			50h - 80 samples per second
  5301                              <1> ;			64h - 100 samples per second
  5302                              <1> ;			0C8h - 200 samples per second
  5303                              <1> ;-------------------------------------------------------------------------
  5304                              <1> int_15_fnC206:
  5305 00002204 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5306 00002207 80FF02              <1> 	cmp	bh,02h
  5307 0000220A 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5308 0000220F 7433                <1> 	je	.scale_2x1
  5309 00002211 80FF01              <1> 	cmp	bh,01h
  5310 00002214 7432                <1> 	je	.scale_1x1
  5311                              <1> 					; BH == 0, return status
  5312 00002216 B0E9                <1> 	mov	al,0E9h			; request status command
  5313 00002218 E857F7              <1> 	call	kbc_aux_send
  5314 0000221B 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  5315 00002220 E834F7              <1> 	call	kbc_aux_read
  5316 00002223 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5317 00002228 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5318 0000222B E829F7              <1> 	call	kbc_aux_read
  5319 0000222E 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5320 00002233 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  5321 00002236 E81EF7              <1> 	call	kbc_aux_read
  5322 00002239 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  5323 0000223E 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  5324 00002241 E9AEFE              <1> 	jmp	int_15_fnC2_ok
  5325                              <1> 
  5326                              <1> .scale_2x1:
  5327 00002244 B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  5328 00002246 EB02                <1> 	jmp	.send_it
  5329                              <1> .scale_1x1:
  5330 00002248 B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  5331                              <1> .send_it:
  5332 0000224A E825F7              <1> 	call	kbc_aux_send
  5333 0000224D 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  5334 00002252 E99DFE              <1> 	jmp	int_15_fnC2_ok
  5335                              <1> 
  5336                              <1> ;=========================================================================
  5337                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  5338                              <1> ; Input:
  5339                              <1> ;	AX = 0C207h
  5340                              <1> ;	ES:BX - pointer to mouse driver
  5341                              <1> ;-------------------------------------------------------------------------
  5342                              <1> int_15_fnC207:
  5343 00002255 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  5344 00002258 891E2200            <1> 	mov	word [mouse_driver],bx
  5345 0000225C 8CC0                <1> 	mov	ax,es
  5346 0000225E A32400              <1> 	mov	word [mouse_driver+2],ax
  5347 00002261 09C0                <1> 	or	ax,ax
  5348 00002263 750C                <1> 	jnz	.set_handler
  5349 00002265 09DB                <1> 	or	bx,bx
  5350 00002267 7508                <1> 	jnz	.set_handler
  5351                              <1> ; remove handler
  5352 00002269 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  5353 0000226E E981FE              <1> 	jmp	int_15_fnC2_ok
  5354                              <1> 
  5355                              <1> .set_handler:
  5356 00002271 800E270080          <1> 	or	byte [mouse_flags_2],80h
  5357 00002276 E979FE              <1> 	jmp	int_15_fnC2_ok
  5358                              <1> 
  5359                              <1> ;=========================================================================
  5360                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  5361                              <1> ;-------------------------------------------------------------------------
  5362                              <1> int_74:
  5363 00002279 FB                  <1> 	sti
  5364 0000227A 50                  <1> 	push	ax
  5365 0000227B 53                  <1> 	push	bx
  5366 0000227C 1E                  <1> 	push	ds
  5367 0000227D B84000              <1> 	mov	ax,biosdseg
  5368 00002280 8ED8                <1> 	mov	ds,ax
  5369 00002282 A10E00              <1> 	mov	ax,word [ebda_segment]
  5370 00002285 8ED8                <1> 	mov	ds,ax
  5371                              <1> 
  5372 00002287 E464                <1> 	in	al,kbc_status_reg
  5373 00002289 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  5374 0000228B 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  5375 0000228D 7561                <1> 	jne	.exit			; no mouse data in the buffer
  5376                              <1> 
  5377 0000228F E460                <1> 	in	al,kbc_data_reg
  5378 00002291 88C4                <1> 	mov	ah,al			; save to AH
  5379                              <1> 
  5380 00002293 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5381 00002296 A880                <1> 	test	al,80h
  5382 00002298 7456                <1> 	jz	.exit			; no mouse driver installed
  5383                              <1> 
  5384 0000229A A02600              <1> 	mov	al,byte [mouse_flags_1]
  5385 0000229D 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  5386 0000229F BB2800              <1> 	mov	bx,mouse_data
  5387 000022A2 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  5388 000022A4 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  5389                              <1> 
  5390 000022A6 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  5391 000022AA 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  5392                              <1> 
  5393 000022AD 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  5394 000022AF 7306                <1> 	jae	.call_driver
  5395                              <1> 
  5396 000022B1 FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  5397 000022B5 EB39                <1> 	jmp	.exit
  5398                              <1> 
  5399                              <1> .call_driver:
  5400                              <1> 
  5401                              <1> ;-------------------------------------------------------------------------
  5402                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  5403                              <1> ; package sizes.
  5404                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  5405                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  5406                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  5407                              <1> ;-------------------------------------------------------------------------
  5408                              <1> 
  5409 000022B7 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  5410 000022BA 7413                <1> 	jz	.four_bytes
  5411                              <1> 					; put data in stack for 3 bytes format
  5412 000022BC 31C0                <1> 	xor	ax,ax
  5413 000022BE A02800              <1> 	mov	al,byte [mouse_data]
  5414 000022C1 50                  <1> 	push	ax
  5415 000022C2 A02900              <1> 	mov	al,byte [mouse_data+1]
  5416 000022C5 50                  <1> 	push	ax
  5417 000022C6 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5418 000022C9 50                  <1> 	push	ax
  5419 000022CA B000                <1> 	mov	al,00h
  5420 000022CC 50                  <1> 	push	ax
  5421 000022CD EB15                <1> 	jmp	.do_call
  5422                              <1> 
  5423                              <1> .four_bytes:				; put data in stack for 4 bytes format
  5424 000022CF 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  5425 000022D3 A02800              <1> 	mov	al,byte [mouse_data]
  5426 000022D6 50                  <1> 	push	ax
  5427 000022D7 B400                <1> 	mov	ah,00h
  5428 000022D9 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5429 000022DC 50                  <1> 	push	ax
  5430 000022DD A02B00              <1> 	mov	al,byte [mouse_data+3]
  5431 000022E0 50                  <1> 	push	ax
  5432 000022E1 B000                <1> 	mov	al,00h
  5433 000022E3 50                  <1> 	push	ax
  5434                              <1> 
  5435                              <1> .do_call:
  5436 000022E4 FF1E2200            <1> 	call	far [mouse_driver]
  5437 000022E8 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  5438 000022EB 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  5439                              <1> 
  5440                              <1> .exit:
  5441 000022F0 B020                <1> 	mov	al,20h
  5442 000022F2 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  5443 000022F4 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  5444 000022F6 1F                  <1> 	pop	ds
  5445 000022F7 5B                  <1> 	pop	bx
  5446 000022F8 58                  <1> 	pop	ax
  5447 000022F9 CF                  <1> 	iret
  5448                                  %endif
  5449                                  %include	"sound.inc"		; sound test
  5450                              <1> ;=========================================================================
  5451                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  5452                              <1> ;-------------------------------------------------------------------------
  5453                              <1> ;
  5454                              <1> ; Compiles with NASM 2.07, might work with other versions
  5455                              <1> ;
  5456                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5457                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5458                              <1> ;
  5459                              <1> ; This program is free software: you can redistribute it and/or modify
  5460                              <1> ; it under the terms of the GNU General Public License as published by
  5461                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5462                              <1> ; (at your option) any later version.
  5463                              <1> ;
  5464                              <1> ; This program is distributed in the hope that it will be useful,
  5465                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5466                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5467                              <1> ; GNU General Public License for more details.
  5468                              <1> ;
  5469                              <1> ; You should have received a copy of the GNU General Public License
  5470                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5471                              <1> ;
  5472                              <1> ;=========================================================================
  5473                              <1> 
  5474 000022FA 6908                <1> notes	dw	pic_freq/554		; D flat
  5475 000022FC FFFF                <1> 	dw	-1			; silent
  5476 000022FE 8814                <1> 	dw	pic_freq/227		; D flat
  5477 00002300 980C                <1> 	dw	pic_freq/370		; G flat
  5478 00002302 8814                <1> 	dw	pic_freq/227		; D flat
  5479 00002304 3B0B                <1> 	dw	pic_freq/415		; A flat
  5480 00002306 0000                <1> 	dw	0
  5481                              <1> 
  5482                              <1> ;=========================================================================
  5483                              <1> ; sound - Play power-on sound.
  5484                              <1> ; Input:
  5485                              <1> ;	none
  5486                              <1> ; Output:
  5487                              <1> ;	none, destroys some registers
  5488                              <1> ;-------------------------------------------------------------------------
  5489                              <1> sound:
  5490 00002308 FC                  <1> 	cld
  5491 00002309 BE[FA22]            <1> 	mov	si,notes		; set SI to notes table
  5492                              <1> 
  5493 0000230C B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5494 0000230E E643                <1> 	out	pit_ctl_reg,al
  5495                              <1> 
  5496                              <1> .loop:
  5497 00002310 2EAD                <1>     cs	lodsw				; load next note to AX
  5498 00002312 83F800              <1> 	cmp	ax,0
  5499 00002315 7422                <1> 	jz	.exit
  5500 00002317 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  5501 00002319 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5502 0000231B 88E0                <1> 	mov	al,ah
  5503 0000231D E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5504                              <1> 
  5505 0000231F E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5506 00002321 0C03                <1>         or      al,03h			; turn on the speaker
  5507 00002323 E661                <1>         out     port_b_reg,al		; write the new value
  5508                              <1> 
  5509                              <1> .silent:
  5510 00002325 B90030              <1> 	mov	cx,3000h
  5511 00002328 E8F8EB              <1> 	call	delay_15us		; delay while note is playing
  5512                              <1> 
  5513 0000232B E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5514 0000232D 24FC                <1> 	and	al,0FCh			; turn off the speaker
  5515 0000232F E661                <1>         out     port_b_reg,al		; write the new value
  5516                              <1> 
  5517 00002331 B90001              <1>         mov     cx,0100h
  5518 00002334 E8ECEB              <1> 	call	delay_15us		; delay after the note
  5519                              <1>         
  5520 00002337 EBD7                <1>         jmp     .loop			; play the next note
  5521                              <1> .exit:
  5522 00002339 C3                  <1> 	ret
  5523                              <1> 
  5524                              <1> ;=========================================================================
  5525                              <1> ; beep - Play a beep sound
  5526                              <1> ; Input:
  5527                              <1> ;	BL - duration in 0.1 second
  5528                              <1> ; Output:
  5529                              <1> ;	BL = 0
  5530                              <1> ;-------------------------------------------------------------------------
  5531                              <1> beep:
  5532 0000233A 50                  <1> 	push	ax
  5533 0000233B B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5534 0000233D E643                <1> 	out	pit_ctl_reg,al
  5535 0000233F B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  5536 00002342 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5537 00002344 88E0                <1> 	mov	al,ah
  5538 00002346 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5539 00002348 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5540 0000234A 0C03                <1> 	or	al,03h			; turn on the speaker
  5541 0000234C E661                <1> 	out	port_b_reg,al		; write the new value
  5542                              <1> .loop:
  5543 0000234E B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  5544 00002351 E8CFEB              <1> 	call	delay_15us
  5545 00002354 FECB                <1> 	dec	bl
  5546 00002356 75F6                <1> 	jnz	.loop
  5547 00002358 3403                <1> 	xor	al,03h			; turn off the speaker
  5548 0000235A E661                <1> 	out	port_b_reg,al		; write the new value
  5549 0000235C 58                  <1> 	pop	ax
  5550 0000235D C3                  <1> 	ret
  5551                                  %include	"cpu.inc"		; CPU and FPU detection
  5552                              <1> ;=========================================================================
  5553                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  5554                              <1> ;-------------------------------------------------------------------------
  5555                              <1> ;
  5556                              <1> ; Compiles with NASM 2.07, might work with other versions
  5557                              <1> ;
  5558                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5559                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5560                              <1> ;
  5561                              <1> ; This program is free software: you can redistribute it and/or modify
  5562                              <1> ; it under the terms of the GNU General Public License as published by
  5563                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5564                              <1> ; (at your option) any later version.
  5565                              <1> ;
  5566                              <1> ; This program is distributed in the hope that it will be useful,
  5567                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5568                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5569                              <1> ; GNU General Public License for more details.
  5570                              <1> ;
  5571                              <1> ; You should have received a copy of the GNU General Public License
  5572                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5573                              <1> ;
  5574                              <1> ;=========================================================================
  5575                              <1> 
  5576                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  5577                              <1> 
  5578                              <1> ;=========================================================================
  5579                              <1> ; detect_cpu - detect and print CPU type
  5580                              <1> ; Note:
  5581                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  5582                              <1> ;	  incorrect results if used on other CPU types.
  5583                              <1> ;-------------------------------------------------------------------------
  5584                              <1> detect_cpu:
  5585 0000235E 50                  <1> 	push	ax
  5586 0000235F 56                  <1> 	push	si
  5587 00002360 BE[9600]            <1> 	mov	si,msg_cpu
  5588 00002363 E86E02              <1> 	call	print
  5589                              <1> 
  5590                              <1> ; test for NEC V20
  5591 00002366 B80101              <1> 	mov	ax,0101h
  5592 00002369 D510                <1> 	aad	10h			; NEC V20 ignores the argument
  5593 0000236B 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  5594 0000236D 7452                <1> 	je	.nec_v20
  5595                              <1> 
  5596                              <1> ; not NEC V20, test for various 8088 versions
  5597                              <1> .i8088:					; 8088 - NMOS version of 8088
  5598 0000236F FA                  <1> 	cli				; disable interrupts
  5599 00002370 1E                  <1> 	push	ds
  5600 00002371 31C0                <1> 	xor	ax,ax
  5601 00002373 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  5602 00002375 B8[CE23]            <1> 	mov	ax,.int_01		; new int 01h offset
  5603 00002378 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  5604 0000237C 50                  <1> 	push	ax			; save to stack
  5605 0000237D 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  5606 0000237F 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  5607 00002383 50                  <1> 	push	ax			; save to stack
  5608 00002384 9C                  <1> 	pushf				; push flags to stack (save)
  5609 00002385 9C                  <1> 	pushf				; push flags to stack (modify)
  5610 00002386 58                  <1> 	pop	ax			; and move them to AX
  5611 00002387 0D0001              <1> 	or	ax,flags_tf		; set TF
  5612 0000238A 50                  <1> 	push	ax
  5613 0000238B 31C0                <1> 	xor	ax,ax			; AX = 0
  5614 0000238D 9D                  <1> 	popf				; load modified value to FLAGS register
  5615                              <1> 					; enable single-step
  5616 0000238E 90                  <1> 	nop
  5617 0000238F 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  5618                              <1> 					; after PUSH SREG instructions
  5619                              <1> .push_sreg:				; and will not single-step to here
  5620 00002390 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  5621                              <1> 					; after modifying segment registers
  5622                              <1> .pop_sreg:				; and will not single-step to here
  5623 00002391 90                  <1> 	nop
  5624 00002392 9D                  <1> 	popf				; restore original FLAGS, disable
  5625                              <1> 					; single-step
  5626                              <1> 
  5627 00002393 5E                  <1> 	pop	si			; get original int 01h segment
  5628 00002394 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  5629 00002398 5E                  <1> 	pop	si			; get original int 01h offset
  5630 00002399 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  5631 0000239D 1F                  <1> 	pop	ds
  5632 0000239E FB                  <1> 	sti				; enable interrupts
  5633 0000239F 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  5634 000023A2 740D                <1> 	jz	.i8088_78
  5635                              <1> 
  5636 000023A4 83F802              <1> 	cmp	ax,0002h
  5637 000023A7 7410                <1> 	jz	.i8088_81
  5638                              <1> 
  5639                              <1> .harris:				; Harris / Intersil 80C88
  5640 000023A9 BE[6201]            <1> 	mov	si,msg_cpu_harris
  5641 000023AC E82502              <1> 	call	print
  5642 000023AF EB16                <1> 	jmp	.exit
  5643                              <1> 
  5644                              <1> .i8088_78:
  5645 000023B1 BE[D000]            <1> 	mov	si,msg_cpu_8088_78
  5646 000023B4 E81D02              <1> 	call	print
  5647 000023B7 EB0E                <1> 	jmp	.exit
  5648                              <1> 
  5649                              <1> .i8088_81:
  5650 000023B9 BE[3101]            <1> 	mov	si,msg_cpu_8088_81
  5651 000023BC E81502              <1> 	call	print
  5652 000023BF EB06                <1> 	jmp	.exit
  5653                              <1> 
  5654                              <1> .nec_v20:
  5655 000023C1 BE[7A01]            <1> 	mov	si,msg_cpu_nec_v20
  5656 000023C4 E80D02              <1> 	call	print
  5657                              <1> 
  5658                              <1> .exit:
  5659 000023C7 B021                <1> 	mov	al,e_cpu_detect_ok	; CPU detection finished
  5660 000023C9 E680                <1> 	out	post_reg,al
  5661                              <1> 
  5662 000023CB 5E                  <1> 	pop	si
  5663 000023CC 58                  <1> 	pop	ax
  5664 000023CD C3                  <1> 	ret
  5665                              <1> 
  5666                              <1> ; stack frame after "push bp"
  5667                              <1> ; BP - word [BP]
  5668                              <1> ; IP - word [BP+2]
  5669                              <1> ; CS - word [BP+4]
  5670                              <1> ; FLAGS - word [BP+6]
  5671                              <1> .int_01:
  5672 000023CE 55                  <1> 	push	bp
  5673 000023CF 89E5                <1> 	mov	bp,sp
  5674 000023D1 817E02[9123]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  5675 000023D6 7504                <1> 	jne	.1
  5676 000023D8 B001                <1> 	mov	al,01h			; (C) INTEL '79
  5677 000023DA EB09                <1> 	jmp	.int_01_exit
  5678                              <1> .1:
  5679 000023DC 817E02[9023]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  5680 000023E1 7502                <1> 	jne	.int_01_exit
  5681 000023E3 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  5682                              <1> .int_01_exit:
  5683 000023E5 5D                  <1> 	pop	bp
  5684 000023E6 CF                  <1> 	iret
  5685                              <1> 
  5686                              <1> ;=========================================================================
  5687                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  5688                              <1> ;-------------------------------------------------------------------------
  5689                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  5690                              <1> detect_fpu:
  5691 000023E7 50                  <1> 	push	ax
  5692 000023E8 51                  <1> 	push	cx
  5693 000023E9 56                  <1> 	push	si
  5694 000023EA BE[B300]            <1> 	mov	si,msg_fpu
  5695 000023ED E8E401              <1> 	call	print
  5696 000023F0 DBE3                <1> 	fninit				; initialize coprocessor
  5697 000023F2 B90300              <1> 	mov	cx,3
  5698                              <1> .wait:
  5699 000023F5 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  5700                              <1> 					;   (can't use fwait, since it could
  5701                              <1> 					;   be no coprocessor at all)
  5702 000023F7 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  5703 000023FB C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  5704 00002401 D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  5705 00002405 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  5706 0000240B 750D                <1> 	jne	.no_fpu			;   after finit
  5707                              <1> 
  5708                              <1> .fpu:
  5709 0000240D BE[8401]            <1> 	mov	si,msg_fpu_present
  5710 00002410 E8C101              <1> 	call	print
  5711 00002413 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  5712 00002418 EB06                <1> 	jmp	.exit
  5713                              <1> 
  5714                              <1> .no_fpu:
  5715                              <1> 
  5716 0000241A BE[A002]            <1> 	mov	si,msg_absent
  5717 0000241D E8B401              <1> 	call	print
  5718                              <1> 
  5719                              <1> .exit:
  5720 00002420 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  5721                              <1> 
  5722 00002424 B022                <1> 	mov	al,e_fpu_detect_ok	; FPU detection finished
  5723 00002426 E680                <1> 	out	post_reg,al
  5724                              <1> 
  5725 00002428 5E                  <1> 	pop	si
  5726 00002429 59                  <1> 	pop	cx
  5727 0000242A 58                  <1> 	pop	ax
  5728 0000242B C3                  <1> 	ret
  5729                                  
  5730                                  %ifdef AT_COMPAT
  5731                                  
  5732                                  ;=========================================================================
  5733                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  5734                                  ;-------------------------------------------------------------------------
  5735                                  int_ignore2:
  5736 0000242C 50                      	push	ax
  5737 0000242D B020                    	mov	al,20h
  5738 0000242F E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5739 00002431 E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5740 00002433 58                      	pop	ax
  5741 00002434 CF                      	iret
  5742                                  
  5743                                  ;=========================================================================
  5744                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  5745                                  ;-------------------------------------------------------------------------
  5746                                  int_71:
  5747 00002435 50                      	push	ax
  5748 00002436 B020                    	mov	al,20h
  5749 00002438 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5750 0000243A 58                      	pop	ax
  5751 0000243B CD0A                    	int	0Ah		; call IRQ2 ISR
  5752 0000243D CF                      	iret
  5753                                  
  5754                                  ;=========================================================================
  5755                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  5756                                  ;-------------------------------------------------------------------------
  5757                                  int_75:
  5758 0000243E 50                      	push	ax
  5759 0000243F B020                    	mov	al,20h
  5760 00002441 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5761 00002443 E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5762 00002445 58                      	pop	ax
  5763 00002446 CD02                    	int	02h		; call NMI ISR
  5764 00002448 CF                      	iret
  5765                                  
  5766                                  %endif ; AT_COMPAT
  5767                                  
  5768                                  ;=========================================================================
  5769                                  ; extension_scan - scan for BIOS extensions
  5770                                  ; Input:
  5771                                  ;	DX - start segment
  5772                                  ;	BX - end segment
  5773                                  ; Returns:
  5774                                  ;	DX - address for the continuation of the scan
  5775                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  5776                                  ;-------------------------------------------------------------------------
  5777                                  extension_scan:
  5778 00002449 C70667000000            	mov	word [67h],0
  5779 0000244F C70669000000            	mov	word [69h],0
  5780                                  .scan:
  5781 00002455 8EC2                    	mov	es,dx
  5782 00002457 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  5783 0000245E 7532                    	jnz	.next			; no signature, check next 2 KiB
  5784 00002460 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  5785 00002464 B400                    	mov	ah,0
  5786 00002466 B105                    	mov	cl,5
  5787 00002468 D3E0                    	shl	ax,cl			; convert size to paragraphs
  5788 0000246A 01C2                    	add	dx,ax
  5789 0000246C 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  5790 0000246F 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  5791 00002472 B104                    	mov	cl,4
  5792 00002474 D3E0                    	shl	ax,cl			; convert size to bytes
  5793 00002476 89C1                    	mov	cx,ax
  5794 00002478 B000                    	mov	al,0
  5795 0000247A 31F6                    	xor	si,si
  5796                                  .checksum:
  5797 0000247C 260204                      es	add	al,byte [si]
  5798 0000247F 46                      	inc	si
  5799 00002480 E2FA                    	loop	.checksum
  5800 00002482 08C0                    	or	al,al			; AL == 0?
  5801 00002484 750C                    	jnz	.next			; AL not zero - bad checksum
  5802 00002486 C70667000300            	mov	word [67h],3		; extension initialization offset
  5803 0000248C 8C066900                	mov	word [69h],es		; extension segment
  5804 00002490 EB08                    	jmp	.exit
  5805                                  .next:
  5806 00002492 81C28000                	add	dx,80h			; add 2 KiB
  5807 00002496 39DA                    	cmp	dx,bx
  5808 00002498 72BB                    	jb	.scan
  5809                                  .exit:
  5810 0000249A C3                      	ret
  5811                                  
  5812                                  ;=========================================================================
  5813                                  ; ipl - Initial Program Load - try to read and execute boot sector
  5814                                  ;-------------------------------------------------------------------------
  5815                                  ipl:
  5816 0000249B FB                      	sti
  5817 0000249C 31C0                    	xor	ax,ax
  5818 0000249E 8ED8                    	mov	ds,ax
  5819 000024A0 C7067800[C76F]          	mov	word [78h],int_1E
  5820 000024A6 8C0E7A00                	mov	word [7Ah],cs
  5821                                  
  5822                                  .retry:
  5823 000024AA B004                    	mov	al,4			; try booting from floppy 4 times
  5824                                  
  5825                                  .fd_loop:
  5826 000024AC 50                      	push	ax
  5827 000024AD B400                    	mov	ah,00h			; reset disk system
  5828 000024AF B200                    	mov	dl,00h			; drive 0
  5829 000024B1 CD13                    	int	13h
  5830 000024B3 722C                    	jb	.fd_failed
  5831 000024B5 B408                    	mov	ah,08h			; get drive parameters
  5832 000024B7 B200                    	mov	dl,00h			; drive 0
  5833 000024B9 CD13                    	int	13h
  5834 000024BB 7224                    	jc	.fd_failed
  5835 000024BD 80FA00                  	cmp	dl,00h
  5836 000024C0 741F                    	jz	.fd_failed		; jump if zero drives
  5837 000024C2 B80102                  	mov	ax,0201h		; read one sector
  5838 000024C5 31D2                    	xor	dx,dx			; head 0, drive 0
  5839 000024C7 8EC2                    	mov	es,dx			; to 0000:7C00
  5840 000024C9 BB007C                  	mov	bx,7C00h
  5841 000024CC B90100                  	mov	cx,0001h		; track 0, sector 1
  5842 000024CF CD13                    	int	13h
  5843 000024D1 720E                    	jc	.fd_failed
  5844 000024D3 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5845 000024DA 7505                    	jnz	.fd_failed
  5846 000024DC EA007C0000              	jmp	0000h:7C00h
  5847                                  
  5848                                  .fd_failed:
  5849 000024E1 58                      	pop	ax
  5850 000024E2 FEC8                    	dec	al
  5851 000024E4 75C6                    	jnz	.fd_loop
  5852                                  
  5853                                  ; try booting from HDD
  5854                                  
  5855 000024E6 B40D                    	mov	ah,0Dh			; reset hard disks
  5856 000024E8 B280                    	mov	dl,80h			; drive 80h
  5857 000024EA CD13                    	int	13h
  5858 000024EC 7222                    	jc	.hd_failed
  5859 000024EE B80102                  	mov	ax,0201h		; read one sector
  5860 000024F1 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  5861 000024F4 31DB                    	xor	bx,bx
  5862 000024F6 8EC3                    	mov	es,bx			; to 0000:7C00
  5863 000024F8 BB007C                  	mov	bx,7C00h
  5864 000024FB B90100                  	mov	cx,0001h		; track 0, sector 1
  5865 000024FE CD13                    	int	13h
  5866 00002500 720E                    	jc	.hd_failed
  5867 00002502 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5868 00002509 7505                    	jnz	.hd_failed
  5869 0000250B EA007C0000              	jmp	0000h:7C00h
  5870                                  
  5871                                  .hd_failed:
  5872 00002510 BE[8B03]                	mov	si,msg_boot_failed
  5873 00002513 E8BE00                  	call	print
  5874 00002516 B400                    	mov	ah,00h
  5875 00002518 CD16                    	int	16h
  5876 0000251A EB8E                    	jmp	.retry
  5877                                  
  5878                                  ;=========================================================================
  5879                                  ; get_line - read an ASCIIZ string from the console
  5880                                  ; Input:
  5881                                  ;	ES:DI - pointer to the buffer
  5882                                  ;	AX - max string length
  5883                                  ; Output:
  5884                                  ;	AX - string length
  5885                                  ; Notes:
  5886                                  ;	Buffer must have size of max string length + 1 to accomodate 00h
  5887                                  ;-------------------------------------------------------------------------
  5888                                  get_line:
  5889 0000251C 53                      	push	bx
  5890 0000251D 52                      	push	dx
  5891 0000251E 56                      	push	si
  5892 0000251F 57                      	push	di
  5893                                  
  5894 00002520 FC                      	cld
  5895 00002521 89FE                    	mov	si,di
  5896 00002523 01C6                    	add	si,ax			; SI = last character position
  5897 00002525 31D2                    	xor	dx,dx			; DX = 0 - string length
  5898                                  
  5899                                  .read_char_loop:
  5900 00002527 B400                    	mov	ah,00h			; read character from keyboard
  5901 00002529 CD16                    	int	16h
  5902                                  
  5903 0000252B 3C08                    	cmp	al,08h			; <Backspace> key
  5904 0000252D 741B                    	jz	.backspace
  5905                                  
  5906 0000252F 3C0D                    	cmp	al,0Dh			; <Enter> key
  5907 00002531 7441                    	jz	.enter
  5908                                  
  5909 00002533 3C20                    	cmp	al,20h			; below printable ASCII code?
  5910 00002535 7233                    	jb	.error_input
  5911                                  
  5912 00002537 3C7E                    	cmp	al,7Eh			; above printable ASCII code?
  5913 00002539 772F                    	ja	.error_input
  5914                                  
  5915 0000253B 39F7                    	cmp	di,si			; end of buffer reached?
  5916 0000253D 732B                    	jae	.error_input
  5917                                  
  5918 0000253F AA                      	stosb				; store character in the buffer
  5919 00002540 42                      	inc	dx			; increment strng length
  5920                                  
  5921 00002541 B40E                    	mov	ah,0Eh			; teletype output (echo)
  5922 00002543 BB0700                  	mov	bx,0007h
  5923 00002546 CD10                    	int	10h
  5924                                  
  5925 00002548 EBDD                    	jmp	.read_char_loop
  5926                                  
  5927                                  .backspace:
  5928 0000254A 09D2                    	or	dx,dx			; empty string?
  5929 0000254C 741C                    	jz	.error_input
  5930                                  
  5931 0000254E 4F                      	dec	di			; move pointer back
  5932 0000254F 4A                      	dec	dx			; decrement string size
  5933                                  
  5934 00002550 B8080E                  	mov	ax,0E08h		; move the cursor back
  5935 00002553 BB0700                  	mov	bx,0007h
  5936 00002556 CD10                    	int	10h
  5937                                  
  5938 00002558 B8200E                  	mov	ax,0E20h		; erase the character under the cursor
  5939 0000255B BB0700                  	mov	bx,0007h
  5940 0000255E CD10                    	int	10h
  5941                                  
  5942 00002560 B8080E                  	mov	ax,0E08h		; move the cursor back again
  5943 00002563 BB0700                  	mov	bx,0007h
  5944 00002566 CD10                    	int	10h
  5945                                  
  5946 00002568 EBBD                    	jmp	.read_char_loop
  5947                                  
  5948                                  .error_input:
  5949 0000256A B8070E                  	mov	ax,0E07h		; beep
  5950 0000256D BB0700                  	mov	bx,0007h
  5951 00002570 CD10                    	int	10h
  5952                                  
  5953 00002572 EBB3                    	jmp	.read_char_loop
  5954                                  
  5955                                  .enter:
  5956 00002574 B000                    	mov	al,00h			; store 00h at the end of the string
  5957 00002576 AA                      	stosb
  5958                                  
  5959 00002577 B80D0E                  	mov	ax,0E0Dh		; CR
  5960 0000257A BB0700                  	mov	bx,0007h
  5961 0000257D CD10                    	int	10h
  5962                                  
  5963 0000257F B80A0E                  	mov	ax,0E0Ah		; LF
  5964 00002582 BB0700                  	mov	bx,0007h
  5965 00002585 CD10                    	int	10h
  5966                                  
  5967 00002587 89D0                    	mov	ax,dx			; string length to AX
  5968                                  
  5969 00002589 5F                      	pop	di
  5970 0000258A 5E                      	pop	si
  5971 0000258B 5A                      	pop	dx
  5972 0000258C 5B                      	pop	bx
  5973 0000258D C3                      	ret
  5974                                  
  5975                                  ;=========================================================================
  5976                                  ; atoi - convert ASCIIZ string to an 16-bit integer number
  5977                                  ; Input:
  5978                                  ;	ES:DI - pointer to string
  5979                                  ; Output:
  5980                                  ;	AX - number
  5981                                  ; 	ES:DI - pointer moved to the position following the number
  5982                                  ;-------------------------------------------------------------------------
  5983                                  atoi:
  5984 0000258E 53                      	push	bx
  5985 0000258F 51                      	push	cx
  5986 00002590 52                      	push	dx
  5987                                  
  5988 00002591 31C0                    	xor	ax,ax			; zero the result
  5989 00002593 BB0A00                  	mov	bx,10			; multiplier
  5990                                  
  5991                                  .atoi_loop:
  5992 00002596 268A0D                      es	mov	cl,byte [di]
  5993                                  
  5994 00002599 80F930                  	cmp	cl,'0'			; ASCII code below '0'
  5995 0000259C 7211                    	jb	.exit
  5996                                  
  5997 0000259E 80F939                  	cmp	cl,'9'			; ASCII code above '9'
  5998 000025A1 770C                    	ja	.exit
  5999                                  
  6000 000025A3 47                      	inc	di			; move to the next character
  6001                                  
  6002 000025A4 80E930                  	sub	cl,'0'			; convert to ASCII to binary
  6003                                  
  6004 000025A7 F7E3                    	mul	bx			; DX:AX = AX * 10
  6005 000025A9 B500                    	mov	ch,0
  6006 000025AB 01C8                    	add	ax,cx			; AX = AX + CX
  6007                                  	
  6008 000025AD EBE7                    	jmp	.atoi_loop
  6009                                  
  6010                                  .exit:
  6011 000025AF 5A                      	pop	dx
  6012 000025B0 59                      	pop	cx
  6013 000025B1 5B                      	pop	bx
  6014 000025B2 C3                      	ret
  6015                                  
  6016                                  ;=========================================================================
  6017                                  ; bin_to_bcd - convert binary number to a packed BCD
  6018                                  ; Input:
  6019                                  ;	AX - binary number
  6020                                  ; Output:
  6021                                  ;	AX - packed BCD number
  6022                                  ;-------------------------------------------------------------------------
  6023                                  bin_to_bcd:
  6024 000025B3 53                      	push	bx
  6025 000025B4 51                      	push	cx
  6026 000025B5 52                      	push	dx
  6027 000025B6 56                      	push	si
  6028                                  
  6029 000025B7 B100                    	mov	cl,0			; shift amount
  6030 000025B9 31F6                    	xor	si,si			; zero result
  6031 000025BB BB0A00                  	mov	bx,10			; BX - divisor
  6032                                  
  6033                                  .bin_to_bcd_loop:
  6034 000025BE 31D2                    	xor	dx,dx			; DX - zero for 32-bit div operand
  6035 000025C0 F7F3                    	div	bx
  6036                                  
  6037 000025C2 D3E2                    	shl	dx,cl			; shift digit to the required position
  6038 000025C4 80C104                  	add	cl,4			; calculate next position
  6039                                  
  6040 000025C7 01D6                    	add	si,dx			; add reminder to the result
  6041 000025C9 09C0                    	or	ax,ax			; quotient is zero?
  6042 000025CB 75F1                    	jnz	.bin_to_bcd_loop
  6043                                  
  6044 000025CD 89F0                    	mov	ax,si			; result to AX
  6045                                  
  6046 000025CF 5E                      	pop	si
  6047 000025D0 5A                      	pop	dx
  6048 000025D1 59                      	pop	cx
  6049 000025D2 5B                      	pop	bx
  6050 000025D3 C3                      	ret
  6051                                  
  6052                                  
  6053                                  ;=========================================================================
  6054                                  ; print - print ASCIIZ string to the console
  6055                                  ; Input:
  6056                                  ;	CS:SI - pointer to string to print
  6057                                  ; Output:
  6058                                  ;	none
  6059                                  ;-------------------------------------------------------------------------
  6060                                  print:
  6061 000025D4 9C                      	pushf
  6062 000025D5 50                      	push	ax
  6063 000025D6 53                      	push	bx
  6064 000025D7 56                      	push	si
  6065 000025D8 1E                      	push	ds
  6066 000025D9 0E                      	push	cs
  6067 000025DA 1F                      	pop	ds
  6068 000025DB FC                      	cld
  6069                                  .1:
  6070 000025DC AC                      	lodsb
  6071 000025DD 08C0                    	or	al,al
  6072 000025DF 7408                    	jz	.exit
  6073 000025E1 B40E                    	mov	ah,0Eh
  6074 000025E3 B30F                    	mov	bl,0Fh
  6075 000025E5 CD10                    	int	10h
  6076 000025E7 EBF3                    	jmp	.1
  6077                                  .exit:
  6078 000025E9 1F                      	pop	ds
  6079 000025EA 5E                      	pop	si
  6080 000025EB 5B                      	pop	bx
  6081 000025EC 58                      	pop	ax
  6082 000025ED 9D                      	popf
  6083 000025EE C3                      	ret
  6084                                  
  6085                                  ;=========================================================================
  6086                                  ; print_hex - print 16-bit number in hexadecimal
  6087                                  ; Input:
  6088                                  ;	AX - number to print
  6089                                  ; Output:
  6090                                  ;	none
  6091                                  ;-------------------------------------------------------------------------
  6092                                  print_hex:
  6093 000025EF 86C4                    	xchg	al,ah
  6094 000025F1 E80600                  	call	print_byte		; print the upper byte
  6095 000025F4 86C4                    	xchg	al,ah
  6096 000025F6 E80100                  	call	print_byte		; print the lower byte
  6097 000025F9 C3                      	ret
  6098                                  
  6099                                  ;=========================================================================
  6100                                  ; print_byte - print a byte in hexadecimal
  6101                                  ; Input:
  6102                                  ;	AL - byte to print
  6103                                  ; Output:
  6104                                  ;	none
  6105                                  ;-------------------------------------------------------------------------
  6106                                  print_byte:
  6107 000025FA D0C0                    	rol	al,1
  6108 000025FC D0C0                    	rol	al,1
  6109 000025FE D0C0                    	rol	al,1
  6110 00002600 D0C0                    	rol	al,1
  6111 00002602 E82D00                  	call	print_digit
  6112 00002605 D0C0                    	rol	al,1
  6113 00002607 D0C0                    	rol	al,1
  6114 00002609 D0C0                    	rol	al,1
  6115 0000260B D0C0                    	rol	al,1
  6116 0000260D E82200                  	call	print_digit
  6117 00002610 C3                      	ret
  6118                                  
  6119                                  ;=========================================================================
  6120                                  ; print_dec - print 16-bit number in decimal
  6121                                  ; Input:
  6122                                  ;	AX - number to print
  6123                                  ; Output:
  6124                                  ;	none
  6125                                  ;-------------------------------------------------------------------------
  6126                                  print_dec:
  6127 00002611 50                      	push	ax
  6128 00002612 51                      	push	cx
  6129 00002613 52                      	push	dx
  6130 00002614 B90A00                  	mov	cx,10		; base = 10
  6131 00002617 E80400                  	call	.print_rec
  6132 0000261A 5A                      	pop	dx
  6133 0000261B 59                      	pop	cx
  6134 0000261C 58                      	pop	ax
  6135 0000261D C3                      	ret
  6136                                  
  6137                                  .print_rec:			; print all digits recursively
  6138 0000261E 52                      	push	dx
  6139 0000261F 31D2                    	xor	dx,dx		; DX = 0
  6140 00002621 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  6141 00002623 83F800                  	cmp	ax,0
  6142 00002626 7403                    	je	.below10
  6143 00002628 E8F3FF                  	call	.print_rec	; print number / 10 recursively
  6144                                  .below10:
  6145 0000262B 89D0                    	mov	ax,dx		; reminder is in DX
  6146 0000262D E80200                  	call	print_digit	; print reminder
  6147 00002630 5A                      	pop	dx
  6148 00002631 C3                      	ret
  6149                                  
  6150                                  ;=========================================================================
  6151                                  ; print_digit - print hexadecimal digit
  6152                                  ; Input:
  6153                                  ;	AL - bits 3...0 - digit to print (0...F)
  6154                                  ; Output:
  6155                                  ;	none
  6156                                  ;-------------------------------------------------------------------------
  6157                                  print_digit:
  6158 00002632 50                      	push	ax
  6159 00002633 53                      	push	bx
  6160 00002634 240F                    	and	al,0Fh
  6161 00002636 0430                    	add	al,'0'			; convert to ASCII
  6162 00002638 3C39                    	cmp	al,'9'			; less or equal 9?
  6163 0000263A 7602                    	jna	.1
  6164 0000263C 0407                    	add	al,'A'-'9'-1		; a hex digit
  6165                                  .1:
  6166 0000263E B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  6167 00002640 B307                    	mov	bl,07h			; just in case we're in graphic mode
  6168 00002642 CD10                    	int	10h
  6169 00002644 5B                      	pop	bx
  6170 00002645 58                      	pop	ax
  6171 00002646 C3                      	ret
  6172                                  
  6173                                  ;=========================================================================
  6174                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  6175                                  ; Input:
  6176                                  ;	AX = memory size in KiB
  6177                                  ; Notes:
  6178                                  ;	- Assumes that EBDA memory was cleaned
  6179                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  6180                                  ;-------------------------------------------------------------------------
  6181                                  reserve_ebda:
  6182                                  %ifdef PS2_MOUSE
  6183 00002647 50                      	push	ax
  6184 00002648 51                      	push	cx
  6185 00002649 F70610000400            	test	word [equipment_list],equip_mouse
  6186 0000264F 742B                    	jz	.no_mouse
  6187 00002651 A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  6188 00002654 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  6189 00002657 A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  6190 0000265A B106                    	mov	cl,6
  6191 0000265C D3E0                    	shl	ax,cl			; convert to segment
  6192 0000265E A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  6193 00002661 1E                      	push	ds
  6194 00002662 8ED8                    	mov	ds,ax
  6195 00002664 B80100                  	mov	ax,EBDA_SIZE
  6196 00002667 A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  6197 0000266A 1F                      	pop	ds
  6198 0000266B 56                      	push	si
  6199 0000266C BE[4A03]                	mov	si,msg_ebda
  6200 0000266F E862FF                  	call	print
  6201 00002672 E89CFF                  	call	print_dec
  6202 00002675 BE[8403]                	mov	si,msg_kib
  6203 00002678 E859FF                  	call	print
  6204 0000267B 5E                      	pop	si
  6205                                  .no_mouse:
  6206 0000267C 59                      	pop	cx
  6207 0000267D 58                      	pop	ax
  6208                                  %endif ; PS2_MOUSE
  6209 0000267E C3                      	ret
  6210                                  
  6211                                  ;=========================================================================
  6212                                  ; detect_ram - Determine the size of installed RAM and test it
  6213                                  ; Input:
  6214                                  ;	none
  6215                                  ; Output:
  6216                                  ;	AX = RAM size
  6217                                  ;	CX, SI - trashed
  6218                                  ;-------------------------------------------------------------------------
  6219                                  detect_ram:
  6220 0000267F B030                    	mov	al,e_ram_start		; RAM scan start
  6221 00002681 E680                    	out	post_reg,al
  6222                                  
  6223 00002683 1E                      	push	ds
  6224 00002684 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  6225 00002686 B82000                  	mov	ax,MIN_RAM_SIZE
  6226                                  
  6227                                  .fill_loop:
  6228 00002689 50                      	push	ax
  6229 0000268A D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6230 0000268C 8ED8                    	mov	ds,ax
  6231 0000268E A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  6232 00002691 58                      	pop	ax
  6233 00002692 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6234 00002695 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6235 00002698 75EF                    	jne	.fill_loop
  6236 0000269A B82000                  	mov	ax,MIN_RAM_SIZE
  6237                                  
  6238                                  .size_loop:
  6239 0000269D 50                      	push	ax
  6240 0000269E D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6241 000026A0 8ED8                    	mov	ds,ax
  6242 000026A2 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  6243 000026A6 750B                    	jne	.size_done
  6244 000026A8 58                      	pop	ax
  6245 000026A9 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6246 000026AC 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6247 000026AF 7303                    	jnb	.size_exit
  6248 000026B1 EBEA                    	jmp	.size_loop
  6249                                  
  6250                                  .size_done:
  6251 000026B3 58                      	pop	ax
  6252                                  
  6253                                  .size_exit:
  6254 000026B4 1F                      	pop	ds
  6255 000026B5 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  6256                                  
  6257                                  ; AX = detected memory size, now test the RAM
  6258                                  
  6259 000026B8 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  6260 000026BE 7474                    	je	.test_done
  6261                                  
  6262 000026C0 BE[EB02]                	mov	si,msg_ram_testing
  6263 000026C3 E80EFF                  	call	print
  6264 000026C6 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  6265                                  
  6266                                  .test_loop:
  6267 000026C9 50                      	push	ax
  6268 000026CA B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  6269 000026CC B700                    	mov	bh,00h			; page 0
  6270 000026CE CD10                    	int	10h			; position returned in DX
  6271 000026D0 58                      	pop	ax
  6272 000026D1 E83DFF                  	call	print_dec
  6273 000026D4 50                      	push	ax
  6274 000026D5 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  6275 000026D7 B700                    	mov	bh,00h			; page 0
  6276 000026D9 CD10                    	int	10h
  6277 000026DB B401                    	mov	ah,01h
  6278 000026DD CD16                    	int	16h
  6279 000026DF 7412                    	jz	.test_no_key
  6280 000026E1 B400                    	mov	ah,00h
  6281 000026E3 CD16                    	int	16h			; read the keystroke
  6282 000026E5 3C1B                    	cmp	al,1Bh			; ESC?
  6283 000026E7 7421                    	je	.test_esc
  6284 000026E9 3D003B                  	cmp	ax,3B00h		; F1?
  6285 000026EC 7505                    	jne	.test_no_key
  6286 000026EE 800E120001              	or	byte [post_flags],post_setup
  6287                                  
  6288                                  .test_no_key:
  6289 000026F3 58                      	pop	ax
  6290 000026F4 E83E00                  	call	ram_test_block
  6291 000026F7 721D                    	jc	.test_error		; error in last test
  6292 000026F9 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  6293 000026FC 3B061300                	cmp	ax,word [memory_size]
  6294 00002700 72C7                    	jb	.test_loop
  6295                                  
  6296 00002702 50                      	push	ax
  6297 00002703 B031                    	mov	al,e_ram_complete	; RAM scan complete
  6298 00002705 E680                    	out	post_reg,al
  6299 00002707 58                      	pop	ax
  6300                                  
  6301 00002708 EB2A                    	jmp	.test_done
  6302                                  
  6303                                  .test_esc:
  6304 0000270A 58                      	pop	ax
  6305 0000270B A11300                  	mov	ax,word [memory_size]
  6306                                  
  6307 0000270E 50                      	push	ax
  6308 0000270F B032                    	mov	al,e_ram_esc		; RAM scan canceled
  6309 00002711 E680                    	out	post_reg,al
  6310 00002713 58                      	pop	ax
  6311                                  
  6312 00002714 EB1E                    	jmp	.test_done
  6313                                  
  6314                                  .test_error:
  6315 00002716 A31300                  	mov	word [memory_size],ax	; store size of good memory
  6316 00002719 BE[0803]                	mov	si,msg_ram_error
  6317 0000271C E8B5FE                  	call	print
  6318 0000271F E8EFFE                  	call	print_dec
  6319 00002722 BE[8403]                	mov	si,msg_kib
  6320 00002725 E8ACFE                  	call	print
  6321 00002728 BE[8800]                	mov	si,msg_crlf
  6322 0000272B E8A6FE                  	call	print
  6323                                  
  6324 0000272E 50                      	push	ax
  6325 0000272F B080                    	mov	al,e_ram_fail		; RAM scan failed
  6326 00002731 E680                    	out	post_reg,al
  6327 00002733 58                      	pop	ax
  6328                                  
  6329                                  .test_done:
  6330 00002734 C3                      	ret
  6331                                  
  6332                                  ;=========================================================================
  6333                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  6334                                  ; Input:
  6335                                  ;	AX = address of the memory to test (in KiB)
  6336                                  ; Output:
  6337                                  ;	CF = status
  6338                                  ;		0 = passed
  6339                                  ;		1 = failed
  6340                                  ;-------------------------------------------------------------------------
  6341                                  ram_test_block:
  6342 00002735 50                      	push	ax
  6343 00002736 53                      	push	bx
  6344 00002737 51                      	push	cx
  6345 00002738 56                      	push	si
  6346 00002739 57                      	push	di
  6347 0000273A 1E                      	push	ds
  6348 0000273B 06                      	push	es
  6349 0000273C B106                    	mov	cl,6			; convert KiB to segment address
  6350 0000273E D3E0                    	shl	ax,cl			; (multiply by 64)
  6351 00002740 8ED8                    	mov	ds,ax
  6352 00002742 8EC0                    	mov	es,ax
  6353 00002744 31F6                    	xor	si,si
  6354 00002746 31FF                    	xor	di,di
  6355 00002748 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  6356 0000274B B8AA55                  	mov	ax,55AAh		; first test pattern
  6357 0000274E 89D9                    	mov	cx,bx
  6358 00002750 F3AB                        rep	stosw				; store test pattern
  6359 00002752 89D9                    	mov	cx,bx			; RAM test block size
  6360                                  .1:
  6361 00002754 AD                      	lodsw
  6362 00002755 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6363 00002758 7522                    	jne	.fail
  6364 0000275A E2F8                    	loop	.1
  6365 0000275C 31F6                    	xor	si,si
  6366 0000275E 31FF                    	xor	di,di
  6367 00002760 B855AA                  	mov	ax,0AA55h		; second test pattern
  6368 00002763 89D9                    	mov	cx,bx			; RAM test block size
  6369 00002765 F3AB                        rep stosw				; store test pattern
  6370 00002767 89D9                    	mov	cx,bx			; RAM test block size
  6371                                  .2:
  6372 00002769 AD                      	lodsw
  6373 0000276A 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6374 0000276D 750D                    	jne	.fail
  6375 0000276F E2F8                    	loop	.2
  6376 00002771 31FF                    	xor	di,di
  6377 00002773 31C0                    	xor	ax,ax			; zero
  6378 00002775 89D9                    	mov	cx,bx			; RAM test block size
  6379 00002777 F3AB                        rep stosw				; zero the memory
  6380 00002779 F8                      	clc				; test passed, clear CF
  6381 0000277A EB01                    	jmp	.exit
  6382                                  
  6383                                  .fail:
  6384 0000277C F9                      	stc				; test failed, set CF
  6385                                  	
  6386                                  .exit:
  6387 0000277D 07                      	pop	es
  6388 0000277E 1F                      	pop	ds
  6389 0000277F 5F                      	pop	di
  6390 00002780 5E                      	pop	si
  6391 00002781 59                      	pop	cx
  6392 00002782 5B                      	pop	bx
  6393 00002783 58                      	pop	ax
  6394 00002784 C3                      	ret
  6395                                  
  6396                                  ;=========================================================================
  6397                                  ; print display type
  6398                                  ;-------------------------------------------------------------------------
  6399                                  print_display:
  6400 00002785 BE[9101]                	mov	si,msg_disp
  6401 00002788 E849FE                  	call	print
  6402 0000278B A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  6403 0000278E 2430                    	and	al,equip_video		; get video adapter type
  6404 00002790 BE[D301]                	mov	si,msg_disp_mda
  6405 00002793 3C30                    	cmp	al,equip_mono		; monochrome?
  6406 00002795 740A                    	jz	.print_disp
  6407 00002797 BE[CD01]                	mov	si,msg_disp_cga
  6408 0000279A 3C20                    	cmp	al,equip_color		; CGA?
  6409 0000279C 7403                    	jz	.print_disp
  6410 0000279E BE[AE01]                	mov	si,msg_disp_ega		; otherwise EGA or later
  6411                                  .print_disp:
  6412 000027A1 E830FE                  	call	print
  6413 000027A4 C3                      	ret
  6414                                  
  6415                                  ;=========================================================================
  6416                                  ; print PS/2 mouse presence
  6417                                  ;-------------------------------------------------------------------------
  6418                                  
  6419                                  print_mouse:
  6420 000027A5 BE[7902]                	mov	si,msg_mouse
  6421 000027A8 E829FE                  	call	print
  6422 000027AB BE[A002]                	mov	si,msg_absent
  6423 000027AE F606100004              	test	byte [equipment_list],equip_mouse
  6424 000027B3 7403                    	jz	.print_mouse
  6425 000027B5 BE[9602]                	mov	si,msg_present
  6426                                  .print_mouse:
  6427 000027B8 E819FE                  	call	print
  6428 000027BB C3                      	ret
  6429                                  
  6430                                  ;=========================================================================
  6431                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  6432                                  ;-------------------------------------------------------------------------
  6433                                  
  6434                                  detect_rom_ext:
  6435 000027BC B040                    	mov	al,e_ext_start		; ROM extension scan start
  6436 000027BE E680                    	out	post_reg,al
  6437                                  
  6438 000027C0 BA00C8                  	mov	dx,0C800h
  6439 000027C3 BB00F8                  	mov	bx,0F800h
  6440                                  
  6441                                  .ext_scan_loop:
  6442 000027C6 E880FC                  	call	extension_scan
  6443 000027C9 833E670000              	cmp	word [67h],0
  6444 000027CE 7429                    	jz	.ext_scan_done		; No ROM extension found
  6445 000027D0 B041                    	mov	al,e_ext_detect		; ROM extension found
  6446 000027D2 E680                    	out	post_reg,al
  6447 000027D4 BE[C703]                	mov	si,msg_rom_found
  6448 000027D7 E8FAFD                  	call	print
  6449 000027DA A16900                  	mov	ax,word [69h]		; ROM extension's segment
  6450 000027DD E80FFE                  	call	print_hex
  6451 000027E0 BE[E403]                	mov	si,msg_rom_init
  6452 000027E3 E8EEFD                  	call	print
  6453 000027E6 53                      	push	bx
  6454 000027E7 52                      	push	dx
  6455 000027E8 FF1E6700                	call	far [67h]
  6456 000027EC B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6457 000027EF 8ED8                    	mov	ds,ax
  6458 000027F1 B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  6459 000027F3 E680                    	out	post_reg,al
  6460 000027F5 5A                      	pop	dx
  6461 000027F6 5B                      	pop	bx
  6462 000027F7 EBCD                    	jmp	.ext_scan_loop
  6463                                  
  6464                                  .ext_scan_done:
  6465 000027F9 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  6466 000027FB E680                    	out	post_reg,al
  6467                                  
  6468 000027FD C3                      	ret
  6469                                  
  6470                                  ;=========================================================================	
  6471                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  6472                                  ;-------------------------------------------------------------------------
  6473                                  interrupt_table:
  6474 000027FE [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
  6475 00002800 [537F]                  	dw	int_dummy		; INT 01 - Single step
  6476 00002802 [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  6477 00002804 [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  6478 00002806 [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  6479 00002808 [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
  6480 0000280A [537F]                  	dw	int_dummy		; INT 06
  6481 0000280C [537F]                  	dw	int_dummy		; INT 07
  6482 0000280E [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  6483 00002810 [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  6484 00002812 [237F]                  	dw	int_ignore		; INT 0A - IRQ2
  6485 00002814 [237F]                  	dw	int_ignore		; INT 0B - IRQ3
  6486 00002816 [237F]                  	dw	int_ignore		; INT 0C - IRQ4
  6487 00002818 [237F]                  	dw	int_ignore		; INT 0D - IRQ5
  6488 0000281A [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  6489 0000281C [237F]                  	dw	int_ignore		; INT 0F - IRQ7
  6490 0000281E [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
  6491 00002820 [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  6492 00002822 [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  6493 00002824 [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  6494 00002826 [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  6495 00002828 [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  6496 0000282A [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  6497 0000282C [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  6498 0000282E [4D63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  6499 00002830 [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  6500 00002832 [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
  6501 00002834 [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  6502 00002836 [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
  6503 00002838 [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
  6504 0000283A [C76F]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  6505 0000283C [2207]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  6506                                  
  6507                                  %ifdef AT_COMPAT
  6508                                  interrupt_table2:
  6509 0000283E [A710]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  6510 00002840 [3524]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  6511 00002842 [2C24]                  	dw	int_ignore2		; INT 72 - IRQ10
  6512 00002844 [2C24]                  	dw	int_ignore2		; INT 73 - IRQ11
  6513                                  %ifndef PS2_MOUSE
  6514                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  6515                                  %else
  6516 00002846 [7922]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  6517                                  %endif
  6518 00002848 [3E24]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  6519 0000284A [2C24]                  	dw	int_ignore2		; INT 76 - IRQ14
  6520 0000284C [2C24]                  	dw	int_ignore2		; INT 77 - IRQ15
  6521                                  %endif ; AT_COMPAT
  6522                                  
  6523                                  ;=========================================================================
  6524                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  6525                                  ;-------------------------------------------------------------------------	
  6526 0000284E FF<rept>                	setloc	0E05Bh		; POST Entry Point
  6527          ******************       warning: (setloc:7) Inserting 14349 bytes
  6528                                  cold_start:
  6529 0000605B B84000                  	mov	ax,biosdseg
  6530 0000605E 8ED8                    	mov	ds,ax
  6531 00006060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  6532                                  
  6533                                  warm_start:
  6534 00006066 FA                      	cli				; disable interrupts
  6535 00006067 FC                      	cld				; clear direction flag
  6536 00006068 B001                    	mov	al,e_start
  6537 0000606A E680                    	out	post_reg,al		; POST start code
  6538                                  
  6539                                  ;-------------------------------------------------------------------------
  6540                                  ; test CPU's FLAG register
  6541                                  
  6542 0000606C 31C0                    	xor	ax,ax			; AX = 0
  6543 0000606E 724A                    	jb	cpu_fail
  6544 00006070 7048                    	jo	cpu_fail
  6545 00006072 7846                    	js	cpu_fail
  6546 00006074 7544                    	jnz	cpu_fail
  6547 00006076 7B42                    	jpo	cpu_fail
  6548 00006078 83C001                  	add	ax,1			; AX = 1
  6549 0000607B 743D                    	jz	cpu_fail
  6550 0000607D 7A3B                    	jpe	cpu_fail
  6551 0000607F 2D0280                  	sub	ax,8002h
  6552 00006082 7836                    	js	cpu_fail
  6553 00006084 40                      	inc	ax
  6554 00006085 7133                    	jno	cpu_fail
  6555 00006087 D1E0                    	shl	ax,1
  6556 00006089 732F                    	jnb	cpu_fail
  6557 0000608B 752D                    	jnz	cpu_fail
  6558 0000608D D1E0                    	shl	ax,1
  6559 0000608F 7229                    	jb	cpu_fail
  6560                                  
  6561                                  ;-------------------------------------------------------------------------
  6562                                  ; Test CPU registers
  6563                                  
  6564 00006091 B8AAAA                  	mov	ax,0AAAAh
  6565                                  .1:
  6566 00006094 8ED8                    	mov	ds,ax
  6567 00006096 8CDB                    	mov	bx,ds
  6568 00006098 8EC3                    	mov	es,bx
  6569 0000609A 8CC1                    	mov	cx,es
  6570 0000609C 8ED1                    	mov	ss,cx
  6571 0000609E 8CD2                    	mov	dx,ss
  6572 000060A0 89D5                    	mov	bp,dx
  6573 000060A2 89EC                    	mov	sp,bp
  6574 000060A4 89E6                    	mov	si,sp
  6575 000060A6 89F7                    	mov	di,si
  6576 000060A8 81FFAAAA                	cmp	di,0AAAAh
  6577 000060AC 7506                    	jnz	.2
  6578 000060AE 89F8                    	mov	ax,di
  6579 000060B0 F7D0                    	not	ax
  6580 000060B2 EBE0                    	jmp	.1
  6581                                  .2:
  6582 000060B4 81FF5555                	cmp	di,5555h
  6583 000060B8 741A                    	jz	cpu_ok
  6584                                  
  6585                                  cpu_fail:
  6586 000060BA B052                    	mov	al,e_cpu_fail
  6587 000060BC E680                    	out	post_reg,al
  6588                                  
  6589                                  ;-------------------------------------------------------------------------
  6590                                  ; CPU error: continious beep - 400 Hz
  6591                                  
  6592 000060BE B0B6                    	mov	al,0B6h
  6593 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6594 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6595 000060C5 E642                    	out	pit_ch2_reg,al
  6596 000060C7 88E0                    	mov	al,ah
  6597 000060C9 E642                    	out	pit_ch2_reg,al
  6598 000060CB E461                    	in	al,port_b_reg
  6599 000060CD 0C03                    	or	al,3			; turn speaker on and enable
  6600 000060CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6601                                  
  6602                                  .1:
  6603 000060D1 F4                      	hlt
  6604 000060D2 EBFD                    	jmp	.1
  6605                                  
  6606                                  ;-------------------------------------------------------------------------
  6607                                  ; CPU test passed
  6608                                  
  6609                                  cpu_ok:
  6610 000060D4 B002                    	mov	al,e_cpu_ok
  6611 000060D6 E680                    	out	post_reg,al
  6612                                  
  6613                                  ;-------------------------------------------------------------------------
  6614                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  6615                                  
  6616 000060D8 B00D                    	mov	al,0Dh & nmi_disable
  6617 000060DA E670                    	out	rtc_addr_reg,al		; disable NMI
  6618 000060DC EB00                    	jmp	$+2
  6619 000060DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  6620                                  
  6621 000060E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  6622 000060E2 E661                    	out	port_b_reg,al
  6623 000060E4 B000                    	mov	al,00h			; clear turbo bit
  6624 000060E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  6625                                  
  6626 000060E8 BAD803                  	mov	dx,cga_mode_reg
  6627 000060EB EE                      	out	dx,al			; disable video output on CGA
  6628 000060EC FEC0                    	inc	al
  6629 000060EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  6630 000060F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  6631                                  
  6632                                  ;-------------------------------------------------------------------------
  6633                                  ; Initialize DMAC (8237)
  6634                                   
  6635 000060F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  6636 000060F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  6637 000060F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6638 000060F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  6639 000060FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6640 000060FC B042                     	mov	al,42h			; single mode, verify, channel 2
  6641 000060FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6642 00006100 B043                     	mov	al,43h			; single mode, verify, channel 3
  6643 00006102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6644 00006104 B000                     	mov	al,0			; DMA Command register bits:
  6645                                   					; DACK active low, DREQ active high,
  6646                                   					; late write, fixed priority,
  6647                                   					; normal timing, controller enable
  6648                                   					; channel 0 addr hold disable
  6649                                   					; memory to memory disable
  6650 00006106 E608                     	out	08h,al			; DMA Command register
  6651 00006108 E681                     	out	81h,al			; DMA Page, channel 2
  6652 0000610A E682                     	out	82h,al			; DMA Page, channel 3
  6653 0000610C E683                     	out	83h,al			; DMA Page, channels 0,1
  6654 0000610E B003                    	mov	al,e_dmac_ok
  6655 00006110 E680                    	out	post_reg,al
  6656                                  
  6657                                  ;-------------------------------------------------------------------------
  6658                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  6659                                  
  6660                                  low_ram_test:
  6661 00006112 31F6                    	xor	si,si
  6662 00006114 31FF                    	xor	di,di
  6663 00006116 8EDF                    	mov	ds,di
  6664 00006118 8EC7                    	mov	es,di
  6665 0000611A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  6666 0000611E B8AA55                  	mov	ax,55AAh		; first test pattern
  6667 00006121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6668 00006124 F3AB                        rep	stosw				; store test pattern
  6669 00006126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6670                                  .1:
  6671 00006129 AD                      	lodsw
  6672 0000612A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6673 0000612D 7524                    	jne	low_ram_fail
  6674 0000612F E2F8                    	loop	.1
  6675 00006131 31F6                    	xor	si,si
  6676 00006133 31FF                    	xor	di,di
  6677 00006135 B855AA                  	mov	ax,0AA55h		; second test pattern
  6678 00006138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6679 0000613B F3AB                        rep stosw				; store test pattern
  6680 0000613D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6681                                  .2:
  6682 00006140 AD                      	lodsw
  6683 00006141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6684 00006144 750D                    	jne	low_ram_fail
  6685 00006146 E2F8                    	loop	.2
  6686 00006148 31FF                    	xor	di,di
  6687 0000614A 31C0                    	xor	ax,ax			; zero
  6688 0000614C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6689 0000614F F3AB                        rep stosw				; zero the memory
  6690 00006151 EB29                    	jmp	low_ram_ok		; test passed
  6691                                  
  6692                                  low_ram_fail:
  6693 00006153 B054                    	mov	al,e_low_ram_fail	; test failed
  6694 00006155 E680                    	out	post_reg,al
  6695                                  
  6696                                  ;-------------------------------------------------------------------------
  6697                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  6698                                  
  6699 00006157 B0B6                    	mov	al,0B6h
  6700 00006159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6701 0000615B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6702 0000615E E642                    	out	pit_ch2_reg,al
  6703 00006160 88E0                    	mov	al,ah
  6704 00006162 E642                    	out	pit_ch2_reg,al
  6705 00006164 E461                    	in	al,port_b_reg
  6706                                  .1:
  6707 00006166 0C03                    	or	al,3			; turn speaker on and enable
  6708 00006168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6709 0000616A B90000                  	mov	cx,0
  6710                                  .2:
  6711 0000616D 90                      	nop
  6712 0000616E E2FD                    	loop	.2
  6713 00006170 24FC                    	and	al,0FCh			; turn of speaker
  6714 00006172 E661                    	out	port_b_reg,al
  6715 00006174 B90000                  	mov	cx,0
  6716                                  .3:
  6717 00006177 90                      	nop
  6718 00006178 E2FD                    	loop	.3
  6719 0000617A EBEA                    	jmp	.1
  6720                                  
  6721                                  ;-------------------------------------------------------------------------
  6722                                  ; Low memory test passed
  6723                                  
  6724                                  low_ram_ok:
  6725 0000617C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  6726 00006180 B004                    	mov	al,e_low_ram_ok
  6727 00006182 E680                    	out	post_reg,al
  6728                                  
  6729                                  ;-------------------------------------------------------------------------
  6730                                  ; Set up stack - using upper 256 bytes of interrupt table
  6731                                  
  6732 00006184 B83000                  	mov	ax,0030h
  6733 00006187 8ED0                    	mov	ss,ax
  6734 00006189 BC0001                  	mov	sp,0100h
  6735                                  
  6736                                  ;-------------------------------------------------------------------------
  6737                                  ; Initialize interrupt table
  6738                                  
  6739 0000618C 0E                      	push	cs
  6740 0000618D 1F                      	pop	ds
  6741 0000618E 31FF                    	xor	di,di
  6742 00006190 8EC7                    	mov	es,di
  6743 00006192 BE[FE27]                	mov	si,interrupt_table
  6744 00006195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  6745 00006198 B800F0                  	mov	ax,bioscseg
  6746                                  .1:
  6747 0000619B A5                      	movsw				; copy ISR address (offset part)
  6748 0000619C AB                      	stosw				; store segment part
  6749 0000619D E2FC                    	loop	.1
  6750                                  %ifdef AT_COMPAT
  6751 0000619F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  6752 000061A2 BE[3E28]                	mov	si,interrupt_table2
  6753 000061A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  6754                                  .2:
  6755 000061A8 A5                      	movsw				; copy ISR address (offset part)
  6756 000061A9 AB                      	stosw				; store segment part
  6757 000061AA E2FC                    	loop	.2
  6758                                  %endif ; AT_COMPAT
  6759 000061AC B005                    	mov     al,e_int_ok
  6760 000061AE E680                    	out	post_reg,al
  6761                                  
  6762                                  ;-------------------------------------------------------------------------
  6763                                  ; set DS to BIOS data area
  6764                                  
  6765 000061B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6766 000061B3 8ED8                    	mov	ds,ax
  6767                                  
  6768                                  ;-------------------------------------------------------------------------
  6769                                  ; Initialize PIT (8254 timer)
  6770                                  
  6771 000061B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  6772 000061B7 E643                    	out	pit_ctl_reg,al
  6773 000061B9 B000                    	mov	al,0
  6774 000061BB E640                    	out	pit_ch0_reg,al
  6775 000061BD E640                    	out	pit_ch0_reg,al
  6776 000061BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  6777 000061C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  6778 000061C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  6779 000061C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  6780 000061C7 B040                    	mov	al,40h			; XXX timer latch
  6781 000061C9 E643                    	out	pit_ctl_reg,al
  6782                                  
  6783                                  ;-------------------------------------------------------------------------
  6784                                  ; Play "power on" sound - also tests PIT functionality
  6785 000061CB E83AC1                  	call	sound
  6786                                  
  6787 000061CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  6788 000061D0 E680                    	out	post_reg,al
  6789                                  
  6790                                  ;-------------------------------------------------------------------------
  6791                                  ; Initialize PIC (8259)
  6792                                  
  6793                                  %ifdef AT_COMPAT
  6794 000061D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  6795 000061D4 E620                    	out	pic1_reg0,al
  6796 000061D6 E6A0                    	out	pic2_reg0,al
  6797 000061D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  6798 000061DA E621                    	out	pic1_reg1,al
  6799 000061DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  6800 000061DE E6A1                    	out	pic2_reg1,al
  6801 000061E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  6802 000061E2 E621                    	out	pic1_reg1,al
  6803 000061E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  6804 000061E6 E6A1                    	out	pic2_reg1,al
  6805 000061E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  6806 000061EA E621                    	out	pic1_reg1,al
  6807 000061EC E6A1                    	out	pic2_reg1,al
  6808                                  %else
  6809                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  6810                                  	out	pic1_reg0,al
  6811                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  6812                                  	out	pic1_reg1,al
  6813                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  6814                                  	out	pic1_reg1,al
  6815                                  	mov	al,e_pic_ok
  6816                                  	out	post_reg,al
  6817                                  %endif ; AT_COMPAT
  6818                                  
  6819                                  ;-------------------------------------------------------------------------
  6820                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  6821                                  
  6822 000061EE E8F3B7                  	call	kbc_init
  6823                                  
  6824                                  ;-------------------------------------------------------------------------
  6825                                  ; enable interrupts
  6826                                  
  6827                                  %ifdef AT_COMPAT
  6828 000061F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  6829 000061F3 E621                    	out	pic1_reg1,al
  6830                                  %ifndef PS2_MOUSE
  6831                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  6832                                  %else
  6833 000061F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  6834                                  %endif ; PS2_MOUSE
  6835 000061F7 E6A1                    	out	pic2_reg1,al
  6836                                  %else
  6837                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  6838                                  	out	pic1_reg1,al
  6839                                  %endif ; AT_COMPAT
  6840 000061F9 FB                      	sti
  6841                                  
  6842                                  ;-------------------------------------------------------------------------
  6843                                  ; look for video BIOS, initialize it if present
  6844                                  
  6845 000061FA BA00C0                  	mov	dx,0C000h
  6846 000061FD BB00C8                  	mov	bx,0C800h
  6847 00006200 E846C2                  	call	extension_scan
  6848 00006203 833E670000              	cmp	word [67h],0
  6849 00006208 7418                    	jz	.no_video_bios
  6850 0000620A B011                    	mov	al,e_video_bios_ok
  6851 0000620C E680                    	out	post_reg,al
  6852 0000620E FF1E6700                	call	far [67h]
  6853 00006212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6854 00006215 8ED8                    	mov	ds,ax
  6855 00006217 B012                    	mov	al,e_video_init_ok
  6856 00006219 E680                    	out	post_reg,al
  6857                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  6858 0000621B 83261000CF              	and	word [equipment_list],~equip_video
  6859 00006220 EB14                    	jmp	.video_initialized
  6860                                  
  6861                                  .no_video_bios:
  6862 00006222 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  6863 00006226 80E430                  	and	ah,equip_video		; get video adapter type
  6864 00006229 B007                    	mov	al,07h			; monochrome 80x25 mode
  6865 0000622B 80FC30                  	cmp	ah,equip_mono		; monochrome?
  6866 0000622E 7402                    	jz	.set_mode
  6867 00006230 B003                    	mov	al,03h			; color 80x25 mode
  6868                                  
  6869                                  .set_mode:
  6870 00006232 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  6871 00006234 CD10                    	int	10h
  6872                                  
  6873                                  .video_initialized:
  6874                                  
  6875                                  ;-------------------------------------------------------------------------
  6876                                  ; print the copyright message
  6877                                  
  6878 00006236 BE[0000]                	mov	si,msg_copyright
  6879 00006239 E898C3                  	call	print
  6880                                  
  6881                                  ;-------------------------------------------------------------------------
  6882                                  ; Initialize RTC / NVRAM
  6883                                  
  6884 0000623C E8FDA8                  	call	rtc_init
  6885                                  
  6886                                  ; read equipment byte from CMOS and set it in BIOS data area
  6887                                  
  6888 0000623F BE[6904]                	mov	si,msg_setup
  6889 00006242 E88FC3                  	call	print
  6890                                  
  6891                                  ;-------------------------------------------------------------------------
  6892                                  ; detect and print availability of various equipment
  6893                                  
  6894 00006245 E816C1                  	call	detect_cpu		; detect and print CPU type
  6895 00006248 E89CC1                  	call	detect_fpu		; detect and print FPU presence
  6896                                  
  6897 0000624B E870AC                  	call	print_rtc		; print current RTC time
  6898                                  
  6899 0000624E E834C5                  	call	print_display		; print display type
  6900 00006251 E851C5                  	call	print_mouse		; print mouse presence
  6901                                  
  6902 00006254 E826BD                  	call	detect_serial		; detect serial ports and print findings
  6903 00006257 E8D3BD                  	call	detect_parallel		; detect parallel ports and print
  6904                                  					; findings
  6905                                  
  6906 0000625A B010                    	mov	al,cmos_floppy
  6907 0000625C E8C3A8                  	call	rtc_read		; floppies type to AL
  6908 0000625F E824B6                  	call	print_floppy		; print floppy drive types
  6909                                  
  6910 00006262 E81AC4                  	call	detect_ram		; test RAM, get RAM size in AX
  6911                                  
  6912 00006265 BE[2C03]                	mov	si,msg_ram_total
  6913 00006268 E869C3                  	call	print
  6914 0000626B E8A3C3                  	call	print_dec		; print RAM size
  6915 0000626E BE[8403]                	mov	si,msg_kib
  6916 00006271 E860C3                  	call	print
  6917                                  
  6918 00006274 E8D0C3                  	call	reserve_ebda		; reserve EBDA if needed
  6919                                  
  6920 00006277 BE[6703]                	mov	si,msg_ram_avail
  6921 0000627A E857C3                  	call	print
  6922 0000627D A11300                  	mov	ax,word [memory_size]
  6923 00006280 E88EC3                  	call	print_dec		; print remaining RAM size
  6924 00006283 BE[8403]                	mov	si,msg_kib
  6925 00006286 E84BC3                  	call	print
  6926                                  
  6927 00006289 E830C5                  	call	detect_rom_ext		; detect and initialize extension ROMs
  6928                                  
  6929                                  ;-------------------------------------------------------------------------
  6930                                  ; Check for F1 (setup key), run setup utility if pressed
  6931                                  
  6932 0000628C B401                    	mov	ah,01h
  6933 0000628E CD16                    	int	16h
  6934 00006290 740E                    	jz	.no_key
  6935 00006292 B400                    	mov	ah,00h
  6936 00006294 CD16                    	int	16h			; read the keystroke
  6937 00006296 3D003B                  	cmp	ax,3B00h		; F1?
  6938 00006299 7505                    	jne	.no_key
  6939 0000629B 800E120001              	or	byte [post_flags],post_setup
  6940                                  .no_key:
  6941                                  
  6942 000062A0 F606120001              	test	byte [post_flags],post_setup
  6943 000062A5 7403                    	jz	.no_setup
  6944 000062A7 E8ADA9                  	call	rtc_setup
  6945                                  
  6946                                  .no_setup:
  6947                                  
  6948                                  ;-------------------------------------------------------------------------
  6949                                  ; boot the OS
  6950                                  
  6951 000062AA B000                    	mov	al,e_boot		; boot the OS POST code
  6952 000062AC E680                    	out	post_reg,al
  6953                                  
  6954 000062AE BE[F903]                	mov	si,msg_boot
  6955 000062B1 E820C3                  	call	print
  6956 000062B4 CD19                    	int	19h			; boot the OS
  6957                                  
  6958                                  ;=========================================================================
  6959                                  ; int_02 - NMI
  6960                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  6961                                  ;	implemented
  6962                                  ;-------------------------------------------------------------------------
  6963 000062B6 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  6964          ******************       warning: (setloc:7) Inserting 13 bytes
  6965                                  int_02:
  6966 000062C3 50                      	push	ax
  6967 000062C4 B00D                    	mov	al,0Dh & nmi_disable
  6968 000062C6 E859A8                  	call	rtc_read		; disable NMI
  6969 000062C9 E461                    	in	al,port_b_reg		; read Port B
  6970 000062CB 88C4                    	mov	ah,al
  6971 000062CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  6972 000062CF E661                    	out	port_b_reg,al
  6973 000062D1 A840                    	test	al,iochk_status
  6974 000062D3 7506                    	jnz	.iochk_nmi
  6975 000062D5 88E0                    	mov	al,ah
  6976 000062D7 E661                    	out	port_b_reg,al		; restore original bits
  6977 000062D9 EB24                    	jmp	.exit
  6978                                  
  6979                                  .iochk_nmi:
  6980 000062DB 56                      	push	si
  6981 000062DC BE[0663]                	mov	si,msg_iochk_nmi
  6982 000062DF E8F2C2                  	call	print
  6983 000062E2 5E                      	pop	si
  6984                                  .1:
  6985 000062E3 B400                    	mov	ah,0h
  6986 000062E5 CD16                    	int	16h
  6987 000062E7 3C69                    	cmp	al,'i'			; exit from NMI
  6988 000062E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  6989 000062EB 3C49                    	cmp	al,'I'
  6990 000062ED 7410                    	je	.exit
  6991 000062EF 3C72                    	cmp	al,'r'
  6992 000062F1 7503E965FD              	je	cold_start
  6993 000062F6 3C52                    	cmp	al,'R'
  6994 000062F8 7503E95EFD              	je	cold_start
  6995 000062FD EBE4                    	jmp	.1
  6996                                  .exit:
  6997 000062FF B08D                    	mov	al,0Dh | nmi_enable
  6998 00006301 E81EA8                  	call	rtc_read		; enable NMI
  6999 00006304 58                      	pop	ax
  7000 00006305 CF                      	iret
  7001                                  
  7002                                  msg_iochk_nmi:
  7003 00006306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  7004 0000630F 206465746563746564-
  7005 00006318 2E2054797065202769-
  7006 00006321 2720746F2069676E6F-
  7007 0000632A 726520494F43484B20-
  7008 00006333 4E4D49732C206F7220-
  7009 0000633C 27722720746F207265-
  7010 00006345 626F6F742E         
  7011 0000634A 0D0A00                  	db	0Dh, 0Ah, 00h
  7012                                  
  7013                                  ;=========================================================================
  7014                                  ; int_18 - execute ROM BASIC
  7015                                  ; Note:
  7016                                  ;	Prints an error message since we don't have ROM BASIC
  7017                                  ;-------------------------------------------------------------------------
  7018                                  int_18:
  7019 0000634D BE[B803]                	mov	si,msg_no_basic
  7020 00006350 E881C2                  	call	print
  7021                                  .1:
  7022 00006353 F4                      	hlt
  7023 00006354 EBFD                    	jmp	.1
  7024                                  
  7025                                  ;=========================================================================
  7026                                  ; int_19 - load and execute the boot sector
  7027                                  ;-------------------------------------------------------------------------
  7028 00006356 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  7029          ******************       warning: (setloc:7) Inserting 924 bytes
  7030                                  int_19:
  7031 000066F2 E9A6BD                  	jmp	ipl
  7032                                  
  7033                                  ;=========================================================================
  7034                                  ; configuration data table
  7035                                  ;-------------------------------------------------------------------------
  7036                                  	setloc	0E6F5h
  7037                                  config_table:
  7038 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  7039                                  .bytes:
  7040                                  %ifdef AT_COMPAT
  7041 000066F7 FC                      	db	0FCh			; byte 2: model = AT
  7042 000066F8 00                      	db	00h			; byte 3: submodel = 0
  7043 000066F9 00                      	db	00h			; byte 4: release = 0
  7044 000066FA 70                      	db	01110000b		; byte 5: feature byte 1
  7045                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7046                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7047                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7048                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7049                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7050                                  ;		||`-- real time clock installed
  7051                                  ;		|`-- 2nd interrupt controller installed
  7052                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7053 000066FB 00                      	db	00h			; byte 6: feature byte 2
  7054 000066FC 00                      	db	00h			; byte 7: feature byte 3
  7055 000066FD 00                      	db	00h			; byte 8: feature byte 4
  7056 000066FE 00                      	db	00h			; byte 9: feature byte 5
  7057                                  %else
  7058                                  	db	0FEh			; byte 2: model = XT
  7059                                  	db	00h			; byte 3: submodel = 0
  7060                                  	db	00h			; byte 4: release = 0
  7061                                  	db	00000000b		; byte 5: feature byte 1
  7062                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7063                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7064                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7065                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7066                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7067                                  ;		||`-- real time clock installed
  7068                                  ;		|`-- 2nd interrupt controller installed
  7069                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7070                                  	db	00h			; byte 6: feature byte 2
  7071                                  	db	00h			; byte 7: feature byte 3
  7072                                  	db	00h			; byte 8: feature byte 4
  7073                                  	db	00h			; byte 9: feature byte 5
  7074                                  %endif ; AT_COMPAT
  7075                                  .size	equ	$-.bytes
  7076                                  
  7077                                  ;=========================================================================
  7078                                  ; Includes with fixed entry points (for IBM compatibility)
  7079                                  ;-------------------------------------------------------------------------
  7080                                  
  7081                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  7082                              <1> ;========================================================================
  7083                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  7084                              <1> ;       INT 14h, function AH=00h
  7085                              <1> ;       INT 14h, function AH=03h
  7086                              <1> ;       INT 14h, function AH=04h
  7087                              <1> ;       INT 14h, function AH=05h
  7088                              <1> ;	- see serial1.inc for other INT 14h functions
  7089                              <1> ;-------------------------------------------------------------------------
  7090                              <1> ;
  7091                              <1> ; Compiles with NASM 2.07, might work with other versions
  7092                              <1> ;
  7093                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7094                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7095                              <1> ;
  7096                              <1> ; This program is free software: you can redistribute it and/or modify
  7097                              <1> ; it under the terms of the GNU General Public License as published by
  7098                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7099                              <1> ; (at your option) any later version.
  7100                              <1> ;
  7101                              <1> ; This program is distributed in the hope that it will be useful,
  7102                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7103                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7104                              <1> ; GNU General Public License for more details.
  7105                              <1> ;
  7106                              <1> ; You should have received a copy of the GNU General Public License
  7107                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7108                              <1> ;
  7109                              <1> ;=========================================================================
  7110                              <1> 
  7111                              <1> ;=========================================================================
  7112                              <1> ; int_14 - BIOS Serial Port Communication Services
  7113                              <1> ;-------------------------------------------------------------------------
  7114 000066FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  7115          ******************  <1>  warning: (setloc:7) Inserting 42 bytes
  7116                              <1> int_14:
  7117 00006729 FB                  <1> 	sti
  7118 0000672A 51                  <1> 	push	cx
  7119 0000672B 52                  <1> 	push	dx
  7120 0000672C 56                  <1> 	push	si
  7121 0000672D 1E                  <1> 	push	ds
  7122 0000672E 53                  <1> 	push	bx
  7123 0000672F BB4000              <1> 	mov	bx,biosdseg
  7124 00006732 8EDB                <1> 	mov	ds,bx
  7125 00006734 80FC06              <1> 	cmp	ah,.max/2
  7126 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
  7127 00006739 83FA04              <1> 	cmp	dx,num_serial
  7128 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
  7129 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  7130 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  7131 00006743 89D3                <1> 	mov	bx,dx
  7132 00006745 D1E3                <1> 	shl	bx,1
  7133 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  7134 00006749 09D2                <1> 	or	dx,dx
  7135 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
  7136 0000674D B700                <1> 	mov	bh,0
  7137 0000674F 88E3                <1> 	mov	bl,ah
  7138 00006751 D1E3                <1> 	shl	bx,1
  7139 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
  7140                              <1> .dispatch:
  7141 00006758 [6C67]              <1> 	dw	int_14_fn00
  7142 0000675A [181F]              <1> 	dw	int_14_fn01
  7143 0000675C [331F]              <1> 	dw	int_14_fn02
  7144 0000675E [A167]              <1> 	dw	int_14_fn03
  7145 00006760 [AB67]              <1> 	dw	int_14_fn04
  7146 00006762 [0568]              <1> 	dw	int_14_fn05
  7147                              <1> .max	equ	$-.dispatch
  7148                              <1> 
  7149                              <1> int_14_error:
  7150 00006764 31C0                <1> 	xor	ax,ax
  7151                              <1> 
  7152                              <1> int_14_exit:
  7153 00006766 5B                  <1> 	pop	bx
  7154 00006767 1F                  <1> 	pop	ds
  7155 00006768 5E                  <1> 	pop	si
  7156 00006769 5A                  <1> 	pop	dx
  7157 0000676A 59                  <1> 	pop	cx
  7158 0000676B CF                  <1> 	iret
  7159                              <1> 
  7160                              <1> ;=========================================================================
  7161                              <1> ; int_14_fn00 - Initialize serial port
  7162                              <1> ; Input:
  7163                              <1> ;	AH = 0 - function 00h - initialize serial port
  7164                              <1> ;	AL - initialization parameters
  7165                              <1> ;		bit 1,0	= 10	- 7 data bits
  7166                              <1> ;			= 11	- 8 data bits
  7167                              <1> ;		bit 2	= 0	- 1 stop bit
  7168                              <1> ;			= 1	- 2 stop bits
  7169                              <1> ;		bit 3	= 0	- parity disable
  7170                              <1> ;			= 1	- parity enable
  7171                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  7172                              <1> ;			= 1	- even parity (if parity enabled)
  7173                              <1> ;		bit 7-5 = 000	- 110 bps
  7174                              <1> ;			= 001	- 150 bps
  7175                              <1> ;			= 010	- 300 bps
  7176                              <1> ;			= 011	- 600 bps
  7177                              <1> ;			= 100	- 1200 bps
  7178                              <1> ;			= 101	- 2400 bps
  7179                              <1> ;			= 110	- 4800 bps
  7180                              <1> ;			= 111	- 9600 bps
  7181                              <1> ;	DX = serial port number (0-3)
  7182                              <1> ; Output:
  7183                              <1> ;	AL = modem status
  7184                              <1> ;		bit 0	= 1	- delta clear to send
  7185                              <1> ;		bit 1	= 1	- delta data set ready
  7186                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  7187                              <1> ;		bit 3	= 1	- delta data carrier detect
  7188                              <1> ;		bit 4	= 1	- clear to send
  7189                              <1> ;		bit 5	= 1	- data set ready
  7190                              <1> ;		bit 6	= 1	- ring indicator
  7191                              <1> ;		bit 7	= 1	- data carrier detect
  7192                              <1> ;	AH = line status
  7193                              <1> ;		bit 0	= 1	- data ready
  7194                              <1> ;		bit 1	= 1	- overrun error
  7195                              <1> ;		bit 2	= 1	- parity error
  7196                              <1> ;		bit 3	= 1	- framing error
  7197                              <1> ;		bit 4	= 1	- break interrupt
  7198                              <1> ;		bit 5	= 1	- transmitter holding register
  7199                              <1> ;		bit 6	= 1	- transmitter empty
  7200                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  7201                              <1> ;-------------------------------------------------------------------------
  7202                              <1> int_14_fn00:
  7203 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  7204 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7205 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7206 00006773 EE                  <1> 	out	dx,al
  7207 00006774 31DB                <1> 	xor	bx,bx
  7208 00006776 88E3                <1> 	mov	bl,ah
  7209 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  7210 0000677B D0EB                <1> 	shr	bl,1
  7211 0000677D D0EB                <1> 	shr	bl,1
  7212 0000677F D0EB                <1> 	shr	bl,1
  7213 00006781 D0EB                <1> 	shr	bl,1
  7214 00006783 2E8B9F[0120]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7215 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7216 0000678B 88D8                <1> 	mov	al,bl
  7217 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  7218 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  7219 0000678F 88F8                <1> 	mov	al,bh
  7220 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  7221 00006792 42                  <1> 	inc	dx
  7222 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  7223 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  7224 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  7225                              <1> 					; get control bits
  7226 00006798 EE                  <1> 	out	dx,al			; set LCR
  7227 00006799 4A                  <1> 	dec	dx
  7228 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  7229                              <1> 					; OPTIMIZATION:
  7230                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7231 0000679B B000                <1> 	mov	al,0
  7232 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  7233 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  7234                              <1> 					; OPTIMIZATION:
  7235                              <1> 					; uart_base = uart_ier_reg - 1
  7236 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7237                              <1> 
  7238                              <1> ;=========================================================================
  7239                              <1> ; int_14_fn03 - Return serial port status
  7240                              <1> ; Input:
  7241                              <1> ;	AH = 03h - function 03h - return serial port status
  7242                              <1> ;	DX = serial port number (0-3)
  7243                              <1> ; Output:
  7244                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7245                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7246                              <1> ;-------------------------------------------------------------------------
  7247                              <1> int_14_fn03:
  7248 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  7249 000067A4 EC                  <1> 	in	al,dx
  7250 000067A5 88C4                <1> 	mov	ah,al
  7251 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  7252 000067A8 EC                  <1> 	in	al,dx
  7253 000067A9 EBBB                <1> 	jmp	int_14_exit
  7254                              <1> 
  7255                              <1> ;=========================================================================
  7256                              <1> ; int_14_fn04 - Extended initialize serial port
  7257                              <1> ; Input:
  7258                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  7259                              <1> ;	AL - break status:
  7260                              <1> ;		00h = no break
  7261                              <1> ;		01h = break
  7262                              <1> ;	BH - parity:
  7263                              <1> ;		00h = no parity
  7264                              <1> ;		01h = odd parity
  7265                              <1> ;		02h = even parity
  7266                              <1> ;		03h = stick parity odd
  7267                              <1> ;		04h = stick parity even
  7268                              <1> ;	BL - stop bits:
  7269                              <1> ;		00h = 1 stop bit
  7270                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  7271                              <1> ;	CH - word length:
  7272                              <1> ;		00h = 5 bits
  7273                              <1> ;		01h = 6 bits
  7274                              <1> ;		02h = 7 bits
  7275                              <1> ;		03h = 8 bits
  7276                              <1> ;	CL - bps rate:
  7277                              <1> ;		00h = 110 bps
  7278                              <1> ;		01h = 150 bps
  7279                              <1> ;		02h = 300 bps
  7280                              <1> ;		03h = 600 bps
  7281                              <1> ;		04h = 1200 bps
  7282                              <1> ;		05h = 2400 bps
  7283                              <1> ;		06h = 6000 bps
  7284                              <1> ;		07h = 9600 bps
  7285                              <1> ;		08h = 19200 bps
  7286                              <1> ;		09h = 38400 bps
  7287                              <1> ;		0Ah = 57600 bps
  7288                              <1> ;		0Bh = 115200 bps
  7289                              <1> ;	DX = serial port number (0-3)
  7290                              <1> ; Output:
  7291                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7292                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7293                              <1> ;-------------------------------------------------------------------------
  7294                              <1> int_14_fn04:
  7295 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  7296 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  7297 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  7298                              <1> 					; exit returning modem and line status
  7299 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7300 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7301 000067B7 EE                  <1> 	out	dx,al
  7302 000067B8 31DB                <1> 	xor	bx,bx
  7303 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  7304 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  7305 000067BE 2E8B9F[0120]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7306 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7307 000067C6 88D8                <1> 	mov	al,bl
  7308 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  7309 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  7310 000067CA 88F8                <1> 	mov	al,bh
  7311 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  7312 000067CD 42                  <1> 	inc	dx
  7313 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  7314                              <1> 
  7315 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  7316 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  7317                              <1> 
  7318 000067D4 D0E0                <1> 	shl	al,1
  7319 000067D6 D0E0                <1> 	shl	al,1
  7320 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  7321                              <1> 	
  7322 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  7323 000067DB 53                  <1> 	push	bx			; push it back to the stack
  7324                              <1> 
  7325 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  7326 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  7327 000067E1 FECF                <1> 	dec	bh
  7328 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  7329 000067E6 D0E7                <1> 	shl	bh,1
  7330 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  7331                              <1> 
  7332                              <1> .set_parity:
  7333 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  7334                              <1> 
  7335 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  7336                              <1> 	
  7337 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  7338 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  7339                              <1> 
  7340 000067F3 D0E0                <1> 	shl	al,1
  7341 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  7342                              <1> 
  7343 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  7344 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  7345                              <1> 
  7346 000067FC EE                  <1> 	out	dx,al			; set LCR
  7347 000067FD 4A                  <1> 	dec	dx
  7348 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  7349                              <1> 					; OPTIMIZATION:
  7350                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7351 000067FF B000                <1> 	mov	al,0
  7352 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  7353 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  7354                              <1> 					; OPTIMIZATION:
  7355                              <1> 					; uart_base = uart_ier_reg - 1
  7356 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7357                              <1> 
  7358                              <1> ;=========================================================================
  7359                              <1> ; int_14_fn05 - Extended serial port control
  7360                              <1> ; Input:
  7361                              <1> ;	AH = 05h - function 05h - extended serial port control
  7362                              <1> ;	AL - sub-function:
  7363                              <1> ;		00h = read modem control register
  7364                              <1> ;		01h = write modem control register
  7365                              <1> ;			BL = modem control register
  7366                              <1> ;	DX = serial port number (0-3)
  7367                              <1> ; Output:
  7368                              <1> ;	AX = status	
  7369                              <1> ;	sub-function AL = 00h:
  7370                              <1> ;		BL = modem control register
  7371                              <1> ;-------------------------------------------------------------------------
  7372                              <1> int_14_fn05:
  7373 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  7374 00006807 750D                <1> 	jnz	int_14_fn05_01
  7375                              <1> 
  7376                              <1> ;-------------------------------------------------------------------------
  7377                              <1> ; sub-function 00h - read modem control register
  7378                              <1> ; int_14_fn05_00:
  7379 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7380 0000680C EC                  <1> 	in	al,dx
  7381 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  7382 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  7383 00006810 53                  <1> 	push	bx			; put BX back to the stack
  7384 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7385 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7386                              <1> 
  7387                              <1> ;-------------------------------------------------------------------------
  7388                              <1> ; sub-function 01h - write modem control register
  7389                              <1> int_14_fn05_01:
  7390 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7391 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  7392 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  7393 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  7394 0000681D EE                  <1> 	out	dx,al
  7395 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7396 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7397                                  %include	"atkbd.inc"		; INT 16, INT 09
  7398                              <1> ;=========================================================================
  7399                              <1> ; atkbd.inc - AT keyboard support
  7400                              <1> ;       INT 16h - BIOS Keyboard Services
  7401                              <1> ;		- function AH=02h
  7402                              <1> ;		- function AH=03h
  7403                              <1> ;		- function AH=05h
  7404                              <1> ;		- function AH=12h
  7405                              <1> ;		- see scancode.inc for other (scancode related)
  7406                              <1> ;                 INT 16h functions
  7407                              <1> ;       INT 09h - IRQ1 interrupt handler
  7408                              <1> ;-------------------------------------------------------------------------
  7409                              <1> ;
  7410                              <1> ; Compiles with NASM 2.07, might work with other versions
  7411                              <1> ;
  7412                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  7413                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7414                              <1> ;
  7415                              <1> ; This program is free software: you can redistribute it and/or modify
  7416                              <1> ; it under the terms of the GNU General Public License as published by
  7417                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7418                              <1> ; (at your option) any later version.
  7419                              <1> ;
  7420                              <1> ; This program is distributed in the hope that it will be useful,
  7421                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7422                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7423                              <1> ; GNU General Public License for more details.
  7424                              <1> ;
  7425                              <1> ; You should have received a copy of the GNU General Public License
  7426                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7427                              <1> ;
  7428                              <1> ;=========================================================================
  7429                              <1> 
  7430                              <1> ;=========================================================================
  7431                              <1> ; Scan codes and keyboard flags
  7432                              <1> ;-------------------------------------------------------------------------
  7433                              <1> 
  7434                              <1> ; scancodes for special keys
  7435                              <1> 
  7436                              <1> kbd_num_code	equ	45h
  7437                              <1> kbd_scroll_code	equ	46h
  7438                              <1> kbd_caps_code	equ	3ah
  7439                              <1> kbd_ctrl_code	equ	1dh
  7440                              <1> kbd_alt_code	equ	38h
  7441                              <1> kbd_rshift_code	equ	36h
  7442                              <1> kbd_prtsc_code	equ	37h
  7443                              <1> kbd_lshift_code	equ	2ah
  7444                              <1> kbd_ins_code	equ	52h
  7445                              <1> kbd_del_code	equ	53h
  7446                              <1> 
  7447                              <1> ; Bits for the various modifier keys
  7448                              <1> 
  7449                              <1> kbd_rshft_bit	equ	1
  7450                              <1> kbd_lshft_bit	equ	2
  7451                              <1> kbd_ctrl_bit	equ	4
  7452                              <1> kbd_alt_bit	equ	8
  7453                              <1> kbd_scroll_bit	equ	10h
  7454                              <1> kbd_num_bit	equ	20h
  7455                              <1> kbd_caps_bit	equ	40h
  7456                              <1> kbd_ins_bit	equ	80h
  7457                              <1> 
  7458                              <1> ;=========================================================================
  7459                              <1> ; int_16 - BIOS keyboard functions
  7460                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  7461                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  7462                              <1> ;	conditions
  7463                              <1> ;-------------------------------------------------------------------------
  7464 00006824 FF<rept>            <1> 	setloc	0E82Eh
  7465          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  7466                              <1> int_16:
  7467 0000682E 53                  <1> 	push	bx
  7468 0000682F 1E                  <1> 	push	ds
  7469 00006830 BB4000              <1> 	mov	bx,biosdseg
  7470 00006833 8EDB                <1> 	mov	ds,bx
  7471 00006835 80FC13              <1> 	cmp	ah,.num_func
  7472 00006838 7331                <1> 	jae	int_16_exit
  7473 0000683A B700                <1> 	mov	bh,0
  7474 0000683C 88E3                <1> 	mov	bl,ah
  7475 0000683E D1E3                <1> 	shl	bx,1
  7476 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
  7477                              <1> 
  7478                              <1> .dispatch:
  7479 00006845 [2D1E]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  7480 00006847 [821E]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  7481 00006849 [7468]              <1> 	dw	int_16_fn02		; get shift status
  7482 0000684B [7968]              <1> 	dw	int_16_fn03		; set delays
  7483 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
  7484 0000684F [A668]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  7485 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
  7486 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
  7487 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
  7488 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
  7489 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
  7490 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  7491 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  7492 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  7493 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  7494 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  7495 00006865 [DA1E]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  7496 00006867 [011F]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  7497 00006869 [CF68]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  7498                              <1> .num_func	equ	($-.dispatch)/2
  7499                              <1> 
  7500                              <1> int_16_exit:
  7501 0000686B 1F                  <1> 	pop	ds
  7502 0000686C 5B                  <1> 	pop	bx
  7503 0000686D CF                  <1> 	iret
  7504                              <1> 
  7505                              <1> int_16_exitf:
  7506 0000686E 1F                  <1> 	pop	ds
  7507 0000686F 5B                  <1> 	pop	bx
  7508 00006870 FB                  <1> 	sti
  7509 00006871 CA0200              <1> 	retf	2
  7510                              <1> 
  7511                              <1> ;=========================================================================
  7512                              <1> ; int_16_fn02 - get shift flags
  7513                              <1> ; Input:
  7514                              <1> ;	AH = 02h
  7515                              <1> ; Output:
  7516                              <1> ;	AL - shift flags
  7517                              <1> ;            AL bits:
  7518                              <1> ;		7 - Insert active
  7519                              <1> ;		6 - Caps Lock active
  7520                              <1> ;		5 - Num Lock active
  7521                              <1> ;		4 - Scroll Lock active
  7522                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  7523                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  7524                              <1> ;		1 - left shift key pressed
  7525                              <1> ;		0 - right shift key pressed
  7526                              <1> ;-------------------------------------------------------------------------
  7527                              <1> int_16_fn02:
  7528 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7529 00006877 EBF2                <1> 	jmp	int_16_exit
  7530                              <1> 
  7531                              <1> ;=========================================================================
  7532                              <1> ; int_16_fn03 - set keyboard typematic rate
  7533                              <1> ; Input:
  7534                              <1> ;	AH = 03
  7535                              <1> ;	AL - subfunction
  7536                              <1> ;	     00 - set typematic rate to default
  7537                              <1> ;	     01 - increase initial delay
  7538                              <1> ;	     02 - slow typematic rate by 1/2
  7539                              <1> ;	     04 - turn off typematic chars
  7540                              <1> ;	     05 - set typematic rate/delay
  7541                              <1> ;	BH - repeat delay (AL=5)
  7542                              <1> ;		0 - 250ms	2 - 750ms
  7543                              <1> ;		1 - 500ms	3 - 1000ms
  7544                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  7545                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  7546                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  7547                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  7548                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  7549                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  7550                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  7551                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  7552                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  7553                              <1> ; Output:
  7554                              <1> ;	none
  7555                              <1> ;-------------------------------------------------------------------------
  7556                              <1> int_16_fn03:
  7557 00006879 3C05                <1> 	cmp	al,05
  7558 0000687B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  7559 0000687D 53                  <1> 	push	bx
  7560 0000687E 51                  <1> 	push	cx
  7561 0000687F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7562 00006881 E8ABB0              <1> 	call	kbc_send_cmd_byte
  7563 00006884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  7564 00006887 B105                <1> 	mov	cl,5
  7565 00006889 D2E7                <1> 	shl	bh,cl
  7566 0000688B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  7567 0000688E B0F3                <1> 	mov	al,0F3h
  7568 00006890 E838B0              <1> 	call	kbc_kb_send
  7569 00006893 88F8                <1> 	mov	al,bh
  7570 00006895 E833B0              <1> 	call	kbc_kb_send
  7571 00006898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7572 0000689A E892B0              <1> 	call	kbc_send_cmd_byte
  7573 0000689D B004                <1> 	mov	al,04h
  7574 0000689F E829B0              <1> 	call	kbc_kb_send
  7575 000068A2 59                  <1> 	pop	cx
  7576 000068A3 5B                  <1> 	pop	bx
  7577                              <1> .exit:
  7578 000068A4 EBC5                <1> 	jmp	int_16_exit
  7579                              <1> 
  7580                              <1> ;=========================================================================
  7581                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  7582                              <1> ; Input:
  7583                              <1> ;	AH = 05h
  7584                              <1> ;	CH = BIOS scan code
  7585                              <1> ;	CL = ACII character
  7586                              <1> ; Output:
  7587                              <1> ;	AL - status
  7588                              <1> ;	     00h - success
  7589                              <1> ;	     01h - keyboard buffer full
  7590                              <1> ;-------------------------------------------------------------------------
  7591                              <1> int_16_fn05:
  7592 000068A6 56                  <1> 	push	si
  7593 000068A7 B001                <1> 	mov	al,1			; assume no space
  7594 000068A9 FA                  <1> 	cli				; critical section
  7595 000068AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7596 000068AE 89DE                <1> 	mov	si,bx
  7597 000068B0 83C302              <1> 	add	bx,2
  7598 000068B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7599 000068B7 7504                <1> 	jne	.1
  7600 000068B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7601                              <1> .1:
  7602 000068BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7603 000068C1 7408                <1> 	je	.no_space		; no space in buffer
  7604 000068C3 890C                <1> 	mov	word [si],cx
  7605 000068C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7606 000068C9 B000                <1> 	mov	al,0			; stored successfully
  7607                              <1> .no_space:
  7608 000068CB FB                  <1> 	sti
  7609 000068CC 5E                  <1> 	pop	si
  7610 000068CD EB9C                <1> 	jmp	int_16_exit
  7611                              <1> 
  7612                              <1> ;=========================================================================
  7613                              <1> ; int_16_fn12 - get extended shift flags
  7614                              <1> ; Input:
  7615                              <1> ;	AH = 12h
  7616                              <1> ; Output:
  7617                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  7618                              <1> ;	AH - shift flags 2
  7619                              <1> ;            AH bits:
  7620                              <1> ;		7 - SysRq key pressed
  7621                              <1> ;		6 - Caps Lock pressed
  7622                              <1> ;		5 - Num Lock pressed
  7623                              <1> ;		4 - Scroll Lock pressed
  7624                              <1> ;		3 - right Alt key pressed
  7625                              <1> ;		2 - right Ctrl key pressed
  7626                              <1> ;		1 - left Alt key pressed
  7627                              <1> ;		0 - left Ctrl key pressed
  7628                              <1> ;-------------------------------------------------------------------------
  7629                              <1> int_16_fn12:
  7630 000068CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  7631 000068D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  7632 000068D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  7633 000068D9 7403                <1> 	je	.1
  7634 000068DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  7635                              <1> .1:
  7636 000068DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  7637 000068E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  7638 000068E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  7639 000068E6 08C4                <1> 	or	ah,al			; copy to AH
  7640 000068E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7641 000068EB E97DFF              <1> 	jmp	int_16_exit
  7642                              <1> 
  7643                              <1> ;=========================================================================
  7644                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  7645                              <1> ;-------------------------------------------------------------------------
  7646 000068EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  7647          ******************  <1>  warning: (setloc:7) Inserting 153 bytes
  7648                              <1> int_09:
  7649 00006987 50                  <1> 	push	ax
  7650 00006988 53                  <1> 	push	bx
  7651 00006989 1E                  <1> 	push	ds
  7652                              <1> 
  7653 0000698A B84000              <1> 	mov	ax,biosdseg
  7654 0000698D 8ED8                <1> 	mov	ds,ax
  7655                              <1> 
  7656                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7657                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7658                              <1> 	call    kbc_send_cmd_byte
  7659                              <1> %endif
  7660 0000698F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  7661 00006991 FB                  <1> 	sti
  7662 00006992 B44F                <1> 	mov	ah,4Fh
  7663 00006994 F9                  <1> 	stc
  7664 00006995 CD15                <1> 	int	15h			; keyboard intercept
  7665 00006997 7203E9CB01          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  7666                              <1> 
  7667                              <1> ; check for KBC response codes
  7668                              <1> 
  7669 0000699C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  7670 0000699E 7503E9C401          <1> 	je      keyboard_int_exit
  7671 000069A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  7672 000069A5 7508                <1> 	jne     .2
  7673 000069A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  7674 000069AC E9B801              <1> 	jmp	keyboard_int_exit
  7675                              <1> .2:
  7676 000069AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  7677 000069B1 7508                <1> 	jne	.3
  7678 000069B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  7679 000069B8 E9AC01              <1> 	jmp	keyboard_int_exit
  7680                              <1> 
  7681                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  7682                              <1> 
  7683                              <1> .3:
  7684                              <1> 
  7685                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  7686                              <1> 
  7687 000069BB 3CE0                <1> 	cmp	al,0E0h
  7688 000069BD 750D                <1> 	jne	.4
  7689 000069BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  7690 000069C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  7691 000069C9 E99B01              <1> 	jmp	keyboard_int_exit
  7692                              <1> .4:
  7693 000069CC 3CE1                <1> 	cmp	al,0E1h
  7694 000069CE 750D                <1> 	jne	.5
  7695 000069D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  7696 000069D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  7697 000069DA E98A01              <1> 	jmp	keyboard_int_exit
  7698                              <1> 
  7699                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  7700                              <1> 
  7701                              <1> .5:
  7702 000069DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  7703 000069E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  7704 000069E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  7705 000069E7 7529                <1> 	jne	.6
  7706 000069E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  7707 000069EB 750B                <1> 	jne	.check_minus
  7708 000069ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  7709 000069F3 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  7710                              <1> 
  7711                              <1> .check_minus:
  7712 000069F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  7713 000069FA 7509                <1> 	jne	.check_plus
  7714                              <1> 
  7715                              <1> .turbo_off:
  7716 000069FC E461                <1> 	in	al,port_b_reg
  7717 000069FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  7718 00006A00 E661                <1> 	out	port_b_reg,al
  7719 00006A02 E96201              <1> 	jmp	keyboard_int_exit
  7720                              <1> 
  7721                              <1> .check_plus:
  7722 00006A05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  7723 00006A07 7509                <1> 	jne	.6
  7724                              <1> 
  7725                              <1> .turbo_on:
  7726 00006A09 E461                <1> 	in	al,port_b_reg
  7727 00006A0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  7728 00006A0D E661                <1> 	out	port_b_reg,al
  7729 00006A0F E95501              <1> 	jmp	keyboard_int_exit
  7730                              <1> 
  7731                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  7732                              <1> ; in the keyboard flags variables.
  7733                              <1> 
  7734                              <1> .6:
  7735 00006A12 3C52                <1> 	cmp	al,kbd_ins_code
  7736 00006A14 7508                <1> 	jne	.7
  7737 00006A16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  7738 00006A1B E90A01              <1> 	jmp	.translate	   	; pass on INS key
  7739                              <1> 
  7740                              <1> .7:
  7741 00006A1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  7742 00006A20 750D                <1> 	jne     .8
  7743 00006A22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  7744 00006A27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  7745 00006A2C E93301              <1> 	jmp     .no_buffer
  7746                              <1> 
  7747                              <1> ; handle the left and right Shift keys
  7748                              <1> 
  7749                              <1> .8:
  7750 00006A2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  7751 00006A31 7508                <1> 	jne	.9
  7752 00006A33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  7753 00006A38 E92701              <1> 	jmp	.no_buffer
  7754                              <1> .9:
  7755 00006A3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  7756 00006A3D 7508                <1> 	jne     .10
  7757 00006A3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  7758 00006A44 E91B01              <1> 	jmp     .no_buffer
  7759                              <1> .10:
  7760 00006A47 3C36                <1> 	cmp	al,kbd_rshift_code
  7761 00006A49 7508                <1> 	jne	.11
  7762 00006A4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  7763 00006A50 E90F01              <1> 	jmp	.no_buffer
  7764                              <1> .11:
  7765 00006A53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  7766 00006A55 7508                <1> 	jne     .12
  7767 00006A57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  7768 00006A5C E90301              <1> 	jmp	.no_buffer
  7769                              <1> 
  7770                              <1> ; handle the Alt key
  7771                              <1> 
  7772                              <1> .12:
  7773 00006A5F 3C38                <1> 	cmp	al,kbd_alt_code
  7774 00006A61 7508                <1> 	jne	.13
  7775 00006A63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  7776 00006A68 E9F700              <1> 	jmp	.no_buffer
  7777                              <1> .13:
  7778 00006A6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  7779 00006A6D 751C                <1> 	jne	.14
  7780 00006A6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  7781 00006A74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  7782 00006A79 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  7783 00006A7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  7784 00006A81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  7785 00006A86 B400                <1> 	mov	ah,0
  7786 00006A88 E9B600              <1> 	jmp	.put_in_buffer
  7787                              <1> 
  7788                              <1> ; handle the Ctrl key
  7789                              <1> 
  7790                              <1> .14:
  7791 00006A8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  7792 00006A8D 7508                <1> 	jne	.15
  7793 00006A8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  7794 00006A94 E9CB00              <1> 	jmp	.no_buffer
  7795                              <1> .15:
  7796 00006A97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  7797 00006A99 7508                <1> 	jne	.16
  7798 00006A9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  7799 00006AA0 E9BF00              <1> 	jmp	.no_buffer
  7800                              <1> 
  7801                              <1> ; handle the Caps Lock key
  7802                              <1> 
  7803                              <1> .16:
  7804 00006AA3 3C3A                <1> 	cmp	al,kbd_caps_code
  7805 00006AA5 750D                <1> 	jne	.17
  7806 00006AA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  7807 00006AAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  7808 00006AB1 E9AE00              <1> 	jmp	.no_buffer
  7809                              <1> .17:
  7810 00006AB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  7811 00006AB6 7508                <1> 	jne	.18
  7812 00006AB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  7813 00006ABD E9D000              <1> 	jmp	set_LEDs
  7814                              <1> 
  7815                              <1> ; check if print screen key was pressed
  7816                              <1> 
  7817                              <1> .18:
  7818 00006AC0 3C37                <1> 	cmp	al,kbd_prtsc_code
  7819 00006AC2 750A                <1> 	jne	.test_scroll_loc
  7820 00006AC4 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7821 00006AC9 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  7822 00006ACB E9B500              <1> 	jmp	print_screen
  7823                              <1> 
  7824                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  7825                              <1> 
  7826                              <1> .test_scroll_loc:
  7827 00006ACE 3C46                <1> 	cmp	al,kbd_scroll_code
  7828 00006AD0 7528                <1> 	jne	.19
  7829 00006AD2 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7830 00006AD7 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  7831                              <1> 
  7832                              <1> ; handle Ctrl-Break
  7833                              <1> 
  7834 00006AD9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  7835 00006ADD 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  7836 00006AE1 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7837 00006AE5 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  7838 00006AEA CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  7839 00006AEC EB74                <1> 	jmp	.no_buffer
  7840                              <1> 
  7841                              <1> ; handle Scroll Lock
  7842                              <1> 
  7843                              <1> .scroll_lock:
  7844 00006AEE 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  7845 00006AF3 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  7846 00006AF8 EB68                <1> 	jmp	.no_buffer
  7847                              <1> .19:
  7848 00006AFA 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  7849 00006AFC 7508                <1> 	jne	.20
  7850 00006AFE 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  7851 00006B03 E98A00              <1> 	jmp	set_LEDs
  7852                              <1> 
  7853                              <1> ; handle the Num Lock
  7854                              <1> 
  7855                              <1> .20:
  7856 00006B06 3C45                <1> 	cmp	al,kbd_num_code
  7857 00006B08 7513                <1> 	jne	.21
  7858 00006B0A F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  7859 00006B0F 755E                <1> 	jnz	pause			; jump if pause
  7860 00006B11 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  7861 00006B16 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  7862 00006B1B EB45                <1> 	jmp	.no_buffer
  7863                              <1> .21:
  7864 00006B1D 3CC5                <1> 	cmp	al,kbd_num_code+80h
  7865 00006B1F 7507                <1> 	jne	.translate
  7866 00006B21 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  7867 00006B26 EB68                <1> 	jmp	set_LEDs
  7868                              <1> 
  7869                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  7870                              <1> 
  7871                              <1> .translate:
  7872 00006B28 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  7873 00006B2D 7407                <1> 	jz	.check_release
  7874 00006B2F 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  7875 00006B34 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  7876                              <1> .check_release:
  7877 00006B36 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  7878 00006B38 7528                <1> 	jnz	.no_buffer
  7879                              <1> 
  7880 00006B3A E837B2              <1> 	call	scan_xlat
  7881 00006B3D 85C0                <1> 	test	ax,ax		 	; check for bad code
  7882 00006B3F 7421                <1> 	je	.no_buffer
  7883                              <1> 
  7884                              <1> .put_in_buffer:
  7885 00006B41 56                  <1> 	push	si			; XXX - use Int 16h/05?
  7886 00006B42 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7887 00006B46 89DE                <1> 	mov	si,bx
  7888 00006B48 83C302              <1> 	add	bx,2
  7889 00006B4B 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7890 00006B4F 7504                <1> 	jne	.1
  7891 00006B51 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7892                              <1> .1:
  7893 00006B55 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7894 00006B59 7406                <1> 	je	.no_space		; no space in buffer
  7895 00006B5B 8904                <1> 	mov	word [si],ax
  7896 00006B5D 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7897                              <1> 
  7898                              <1> .no_space:
  7899 00006B61 5E                  <1> 	pop	si
  7900                              <1> 
  7901                              <1> .no_buffer:
  7902 00006B62 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  7903                              <1> 
  7904                              <1> keyboard_int_exit:
  7905                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7906                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7907                              <1> 	call	kbc_send_cmd_byte
  7908                              <1> %endif
  7909 00006B67 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7910 00006B69 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  7911                              <1> 
  7912                              <1> keyboard_int_exit1:
  7913 00006B6B 1F                  <1> 	pop	ds
  7914 00006B6C 5B                  <1> 	pop	bx
  7915 00006B6D 58                  <1> 	pop	ax
  7916 00006B6E CF                  <1> 	iret
  7917                              <1> 
  7918                              <1> pause:
  7919 00006B6F 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  7920 00006B74 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  7921                              <1> 
  7922 00006B76 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7923 00006B78 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7924                              <1> 
  7925                              <1> .pause_loop:
  7926 00006B7A F606180008          <1> 	test	byte [kbd_flags_2],08h
  7927 00006B7F 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  7928 00006B81 EBE8                <1> 	jmp	keyboard_int_exit1
  7929                              <1> 
  7930                              <1> print_screen:
  7931 00006B83 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7932 00006B85 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7933 00006B87 CD05                <1> 	int	5h			; INT 5 - print screen
  7934 00006B89 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  7935 00006B8E EBDB                <1> 	jmp	keyboard_int_exit1
  7936                              <1> 
  7937                              <1> ;=========================================================================
  7938                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  7939                              <1> ; 	     variable and update LEDs on the keyboard
  7940                              <1> ;-------------------------------------------------------------------------
  7941                              <1> set_LEDs:
  7942                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7943                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7944                              <1> 	call	kbc_send_cmd_byte
  7945                              <1> %endif
  7946                              <1> 
  7947 00006B90 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7948 00006B92 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7949                              <1> 
  7950 00006B94 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7951 00006B97 D0E8                <1> 	shr	al,1
  7952 00006B99 D0E8                <1> 	shr	al,1
  7953 00006B9B D0E8                <1> 	shr	al,1
  7954 00006B9D D0E8                <1> 	shr	al,1
  7955 00006B9F 2407                <1> 	and	al,111b
  7956 00006BA1 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  7957 00006BA6 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  7958 00006BAA 88C4                <1> 	mov	ah,al			; save LED bits
  7959                              <1> 
  7960 00006BAC B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7961 00006BAE E87EAD              <1> 	call	kbc_send_cmd_byte
  7962                              <1> 
  7963 00006BB1 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  7964 00006BB3 E815AD              <1> 	call	kbc_kb_send		; send the command to the keyboard
  7965 00006BB6 88E0                <1> 	mov	al,ah			; get parameter byte
  7966 00006BB8 E810AD              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  7967                              <1> 
  7968 00006BBB B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7969 00006BBD E86FAD              <1> 	call	kbc_send_cmd_byte
  7970 00006BC0 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  7971 00006BC2 E806AD              <1> 	call	kbc_kb_send
  7972 00006BC5 EBA4                <1> 	jmp	keyboard_int_exit1
  7973                              <1> 
  7974                                  %include	"floppy2.inc"		; INT 13
  7975                              <1> ;=========================================================================
  7976                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  7977                              <1> ;       INT 13h, function AH=02h
  7978                              <1> ;       INT 13h, function AH=03h
  7979                              <1> ;       INT 13h, function AH=04h
  7980                              <1> ;       INT 13h, function AH=05h
  7981                              <1> ;	- see floppy1.inc for other INT 13h functions
  7982                              <1> ;-------------------------------------------------------------------------
  7983                              <1> ;
  7984                              <1> ; Compiles with NASM 2.07, might work with other versions
  7985                              <1> ;
  7986                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7987                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7988                              <1> ;
  7989                              <1> ; This program is free software: you can redistribute it and/or modify
  7990                              <1> ; it under the terms of the GNU General Public License as published by
  7991                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7992                              <1> ; (at your option) any later version.
  7993                              <1> ;
  7994                              <1> ; This program is distributed in the hope that it will be useful,
  7995                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7996                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7997                              <1> ; GNU General Public License for more details.
  7998                              <1> ;
  7999                              <1> ; You should have received a copy of the GNU General Public License
  8000                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8001                              <1> ;
  8002                              <1> ;=========================================================================
  8003                              <1> 
  8004                              <1> ;-------------------------------------------------------------------------
  8005                              <1> ; offsets for registers on stack
  8006                              <1> int_13_bp	equ	0
  8007                              <1> int_13_ds	equ	int_13_bp+2
  8008                              <1> int_13_di	equ	int_13_ds+2
  8009                              <1> int_13_si	equ	int_13_di+2
  8010                              <1> int_13_dx	equ	int_13_si+2
  8011                              <1> int_13_dl	equ	int_13_dx
  8012                              <1> int_13_dh	equ	int_13_dx+1
  8013                              <1> int_13_cx	equ	int_13_dx+2
  8014                              <1> int_13_cl	equ	int_13_cx
  8015                              <1> int_13_ch	equ	int_13_cx+1
  8016                              <1> int_13_bx	equ	int_13_cx+2
  8017                              <1> int_13_bl	equ	int_13_bx
  8018                              <1> int_13_bh	equ	int_13_bx+1
  8019                              <1> int_13_ax	equ	int_13_bx+2
  8020                              <1> int_13_al	equ	int_13_ax
  8021                              <1> int_13_ah	equ	int_13_ax+1
  8022                              <1> int_13_ip	equ	int_13_ax+2
  8023                              <1> int_13_cs	equ	int_13_ip+2
  8024                              <1> int_13_flags	equ	int_13_cs+2
  8025                              <1> int_13_flags_l	equ	int_13_flags
  8026                              <1> 
  8027                              <1> ;=========================================================================
  8028                              <1> ; int_13 - BIOS floppy disk services
  8029                              <1> ; Input:
  8030                              <1> ;	AH = function
  8031                              <1> ;		00h - Reset disk system
  8032                              <1> ;		01h - Get status of last operation
  8033                              <1> ;		02h - Read disk sectors
  8034                              <1> ;		03h - Write disk sectors
  8035                              <1> ;		04h - Verify disk sectors
  8036                              <1> ;		05h - Format track
  8037                              <1> ;		08h - Get drive parameters
  8038                              <1> ;		15h - Get disk type
  8039                              <1> ;		16h - Detect disk change
  8040                              <1> ;		17h - Set disk type for format
  8041                              <1> ;		18h - Set media type for format
  8042                              <1> ; Output:
  8043                              <1> ;	- depends on function
  8044                              <1> ;	- for most functions:
  8045                              <1> ;		CF clear if successful
  8046                              <1> ;			AH = 00h - successful completion
  8047                              <1> ;		CF set on error
  8048                              <1> ;			AH = error code
  8049                              <1> ;-------------------------------------------------------------------------
  8050 00006BC7 FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  8051          ******************  <1>  warning: (setloc:7) Inserting 146 bytes
  8052                              <1> int_13:
  8053 00006C59 FB                  <1> 	sti
  8054 00006C5A 50                  <1> 	push	ax
  8055 00006C5B 53                  <1> 	push	bx
  8056 00006C5C 51                  <1> 	push	cx
  8057 00006C5D 52                  <1> 	push	dx
  8058 00006C5E 56                  <1> 	push	si
  8059 00006C5F 57                  <1> 	push	di
  8060 00006C60 1E                  <1> 	push	ds
  8061 00006C61 55                  <1> 	push	bp
  8062 00006C62 89E5                <1> 	mov	bp,sp
  8063 00006C64 80FC19              <1> 	cmp	ah,.num_func
  8064 00006C67 7743                <1> 	ja	.invalid_function
  8065 00006C69 88E0                <1> 	mov	al,ah
  8066 00006C6B 98                  <1> 	cbw
  8067 00006C6C 89C7                <1> 	mov	di,ax
  8068 00006C6E D1E7                <1> 	shl	di,1
  8069 00006C70 B84000              <1> 	mov	ax,biosdseg
  8070 00006C73 8ED8                <1> 	mov	ds,ax
  8071 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  8072                              <1> 
  8073                              <1> .dispatch:
  8074 00006C7A [BB10]              <1> 	dw	int_13_fn00		; Reset disk system
  8075 00006C7C [2A11]              <1> 	dw	int_13_fn01		; Get status of last operation
  8076 00006C7E [EF6C]              <1> 	dw	int_13_fn02		; Read disk sectors
  8077 00006C80 [EF6C]              <1> 	dw	int_13_fn03		; Write disk sectors
  8078 00006C82 [EF6C]              <1> 	dw	int_13_fn04		; Verify disk sectors
  8079 00006C84 [5D6E]              <1> 	dw	int_13_fn05		; Format track
  8080 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  8081 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  8082 00006C8A [3611]              <1> 	dw	int_13_fn08		; Get drive parameters
  8083 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  8084 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  8085 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  8086 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  8087 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  8088 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  8089 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  8090 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  8091 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  8092 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  8093 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  8094 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  8095 00006CA4 [E311]              <1> 	dw	int_13_fn15		; Get disk type
  8096 00006CA6 [0412]              <1> 	dw	int_13_fn16		; Detect disk change
  8097 00006CA8 [5012]              <1> 	dw	int_13_fn17		; Set disk type for format
  8098 00006CAA [BB12]              <1> 	dw	int_13_fn18		; Set media type for format
  8099                              <1> .num_func	equ ($-.dispatch)/2
  8100                              <1> 
  8101                              <1> .invalid_function:
  8102 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  8103 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  8104 00006CB2 F9                  <1> 	stc				; error condition
  8105 00006CB3 EB21                <1> 	jmp	int_13_exit
  8106                              <1> 
  8107                              <1> ;-------------------------------------------------------------------------
  8108                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  8109                              <1> 
  8110                              <1> int_13_upd_exit:
  8111 00006CB5 9C                  <1> 	pushf
  8112 00006CB6 50                  <1> 	push	ax
  8113 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  8114 00006CBA 3C01                <1> 	cmp	al,1
  8115 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  8116 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  8117 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  8118 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  8119 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  8120 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  8121 00006CCA 08C0                <1> 	or	al,al
  8122 00006CCC 7402                <1> 	jz	.drive_0
  8123 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  8124                              <1> 
  8125                              <1> .drive_0:
  8126 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  8127                              <1> 
  8128                              <1> .no_update:
  8129 00006CD4 58                  <1> 	pop	ax
  8130 00006CD5 9D                  <1> 	popf
  8131                              <1> 
  8132                              <1> int_13_exit:
  8133 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  8134 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  8135 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  8136 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  8137 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  8138                              <1> 
  8139                              <1> .set_error:
  8140 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  8141 00006CE6 5D                  <1> 	pop	bp
  8142 00006CE7 1F                  <1> 	pop	ds
  8143 00006CE8 5F                  <1> 	pop	di
  8144 00006CE9 5E                  <1> 	pop	si
  8145 00006CEA 5A                  <1> 	pop	dx
  8146 00006CEB 59                  <1> 	pop	cx
  8147 00006CEC 5B                  <1> 	pop	bx
  8148 00006CED 58                  <1> 	pop	ax
  8149 00006CEE CF                  <1> 	iret
  8150                              <1> 
  8151                              <1> ;=========================================================================
  8152                              <1> ; int_13_fn02 - Read disk sectors
  8153                              <1> ; int_13_fn03 - Write disk sectors
  8154                              <1> ; int_13_fn04 - Verify disk sectors
  8155                              <1> ; Input:
  8156                              <1> ;	AH = function
  8157                              <1> ;		02h - read
  8158                              <1> ;		03h - write
  8159                              <1> ;		04h - verify
  8160                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  8161                              <1> ;	CH = cylinder number
  8162                              <1> ;	CL = sector number
  8163                              <1> ;	DH = head number (0 or 1)
  8164                              <1> ;	DL = drive number (0 or 1)
  8165                              <1> ;	ES:BX -> data buffer
  8166                              <1> ; Output:
  8167                              <1> ;	CF clear if successful
  8168                              <1> ;		AH = 00h - successful completion
  8169                              <1> ;		AL = number of sectors transferred or verified
  8170                              <1> ;	CF set on error
  8171                              <1> ;		AH = error code
  8172                              <1> ;-------------------------------------------------------------------------
  8173                              <1> int_13_fn02:
  8174                              <1> int_13_fn03:
  8175                              <1> int_13_fn04:
  8176 00006CEF 80FA01              <1> 	cmp	dl,1
  8177 00006CF2 7603E94801          <1> 	ja	.invalid_drive
  8178 00006CF7 BE9000              <1> 	mov	si,fdc_media_state
  8179 00006CFA 52                  <1> 	push	dx
  8180 00006CFB B600                <1> 	mov	dh,00h
  8181 00006CFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  8182 00006CFF 5A                  <1> 	pop	dx
  8183                              <1> 
  8184 00006D00 E808AA              <1> 	call	read_cmos_type		; get drive type in AL
  8185 00006D03 7303E93701          <1> 	jc	.invalid_drive
  8186                              <1> 
  8187 00006D08 BF3F00              <1> 	mov	di,fdc_motor_state
  8188 00006D0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  8189 00006D0E 80FC03              <1> 	cmp	ah,03h			; write function
  8190 00006D11 7503                <1> 	jne	.motor_on		; jump if not write function
  8191 00006D13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  8192                              <1> 
  8193                              <1> .motor_on:
  8194 00006D16 E863A7              <1> 	call	fdc_motor_on
  8195 00006D19 3C01                <1> 	cmp	al,cmos_360
  8196 00006D1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  8197 00006D20 3C03                <1> 	cmp	al,cmos_720
  8198 00006D22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  8199                              <1> 
  8200 00006D27 E80CA8              <1> 	call	fdc_disk_change
  8201 00006D2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  8202                              <1> 
  8203 00006D2F F60410              <1> 	test	byte [si],fdc_m_established
  8204 00006D32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  8205                              <1> 
  8206 00006D37 E8C1AA              <1> 	call	fdc_select_rate		; select transfer rate
  8207                              <1> 	
  8208                              <1> .fdc_send_specify:
  8209 00006D3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  8210                              <1> 					; 0BFh - specify byte 0 for 1.44M
  8211 00006D3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  8212 00006D40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  8213 00006D42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  8214 00006D44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  8215 00006D47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  8216 00006D49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  8217                              <1> 
  8218                              <1> .fdc_send_specify_cmd:
  8219 00006D4B BE0200              <1> 	mov	si,2			; specify byte 1
  8220 00006D4E B103                <1> 	mov	cl,3			; 3 bytes command
  8221 00006D50 E889A8              <1> 	call	fdc_send_cmd
  8222 00006D53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  8223 00006D58 1E                  <1> 	push	ds
  8224 00006D59 31F6                <1> 	xor	si,si
  8225 00006D5B 8EDE                <1> 	mov	ds,si
  8226 00006D5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8227 00006D61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  8228 00006D64 B400                <1> 	mov	ah,00h
  8229 00006D66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  8230 00006D68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  8231 00006D6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  8232 00006D6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  8233 00006D70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  8234 00006D72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  8235                              <1> 
  8236                              <1> .calc_dma_count:
  8237 00006D75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  8238 00006D78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  8239 00006D7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  8240 00006D7D 1F                  <1> 	pop	ds
  8241 00006D7E 48                  <1> 	dec	ax			; minus one byte
  8242 00006D7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  8243                              <1> 
  8244 00006D81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  8245 00006D84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  8246 00006D86 80FC02              <1> 	cmp	ah,02h			; read function?
  8247 00006D89 7409                <1> 	je	.configure_dma		; jump if read function
  8248 00006D8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8249 00006D8D 80FC03              <1> 	cmp	ah,03h			; write function?
  8250 00006D90 7402                <1> 	je	.configure_dma		; jump if write function
  8251 00006D92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  8252                              <1> 
  8253                              <1> .configure_dma:
  8254 00006D94 E8E7A7              <1> 	call	fdc_configure_dma
  8255 00006D97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  8256 00006D9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  8257                              <1> 
  8258 00006D9F E823A6              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8259 00006DA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8260                              <1> 
  8261 00006DA7 1E                  <1> 	push	ds
  8262 00006DA8 31C0                <1> 	xor	ax,ax
  8263 00006DAA 8ED8                <1> 	mov	ds,ax
  8264 00006DAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8265 00006DB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  8266 00006DB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  8267 00006DB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  8268 00006DB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  8269 00006DBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  8270 00006DBD 1F                  <1> 	pop	ds
  8271                              <1> 
  8272 00006DBE BE9000              <1> 	mov	si,fdc_media_state
  8273 00006DC1 B600                <1> 	mov	dh,00h
  8274 00006DC3 01D6                <1> 	add	si,dx
  8275 00006DC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  8276 00006DC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  8277 00006DC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  8278 00006DCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  8279 00006DCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  8280 00006DD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  8281 00006DD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  8282 00006DD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  8283 00006DD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  8284 00006DDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  8285 00006DDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  8286 00006DDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  8287                              <1> 	
  8288                              <1> .gap_set:
  8289 00006DE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  8290 00006DE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  8291 00006DE7 88F4                <1> 	mov	ah,dh			; head
  8292 00006DE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  8293 00006DEB D0E4                <1> 	shl	ah,1
  8294 00006DED D0E4                <1> 	shl	ah,1
  8295 00006DEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  8296 00006DF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  8297 00006DF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  8298 00006DF7 7502                <1> 	jne	.send_command		; jump if not write 
  8299 00006DF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  8300                              <1> 
  8301                              <1> .send_command:
  8302 00006DFB B109                <1> 	mov	cl,9			; 9 bytes command
  8303 00006DFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8304 00006E02 E8D7A7              <1> 	call	fdc_send_cmd
  8305 00006E05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  8306 00006E07 E823AA              <1> 	call	fdc_wait_irq
  8307 00006E0A 7228                <1> 	jc	.error_fdc_get_result
  8308 00006E0C B107                <1> 	mov	cl,7
  8309 00006E0E E830A8              <1> 	call	fdc_get_result		; read result bytes
  8310 00006E11 7228                <1> 	jc	.error_end_io
  8311                              <1> 
  8312 00006E13 E880A8              <1> 	call	fdc_get_error
  8313                              <1> 
  8314                              <1> .exit_end_io:
  8315 00006E16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  8316                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  8317 00006E19 E8EFA6              <1> 	call	fdc_end_io		; return number of last sector in BL
  8318 00006E1C 08C0                <1> 	or	al,al
  8319 00006E1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  8320 00006E20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  8321 00006E22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  8322                              <1> 
  8323                              <1> .zero_sectors:
  8324 00006E25 08E4                <1> 	or	ah,ah
  8325 00006E27 7401                <1> 	jz	.exit			; jump if no errors
  8326                              <1> 
  8327                              <1> .error:
  8328 00006E29 F9                  <1> 	stc				; indicate error
  8329                              <1> 
  8330                              <1> .exit:
  8331 00006E2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  8332 00006E2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  8333 00006E31 E981FE              <1> 	jmp	int_13_upd_exit
  8334                              <1> 
  8335                              <1> .error_fdc_get_result:
  8336 00006E34 B107                <1> 	mov	cl,7
  8337 00006E36 50                  <1> 	push	ax
  8338 00006E37 E807A8              <1> 	call	fdc_get_result		; read result bytes
  8339 00006E3A 58                  <1> 	pop	ax
  8340                              <1> 
  8341                              <1> .error_end_io:
  8342 00006E3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  8343 00006E3D EBD7                <1> 	jmp	.exit_end_io
  8344                              <1> 
  8345                              <1> .invalid_drive:
  8346 00006E3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  8347 00006E42 EBE5                <1> 	jmp	.error
  8348                              <1> 
  8349                              <1> ; 360K and 720K drives don't support change line, and only support
  8350                              <1> ; one media type - set it here
  8351                              <1> 
  8352                              <1> .set_media_360:
  8353 00006E44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  8354 00006E46 EB02                <1> 	jmp	.set_media
  8355                              <1> 
  8356                              <1> .set_media_720:
  8357 00006E48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  8358                              <1> 
  8359                              <1> .set_media:
  8360 00006E4A 8804                <1> 	mov	byte [si],al		; save media state
  8361 00006E4C E8D3A9              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  8362 00006E4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  8363 00006E52 E9E5FE              <1> 	jmp	.fdc_send_specify
  8364                              <1> 
  8365                              <1> ; establish media type
  8366                              <1> 
  8367                              <1> .establish_media:
  8368 00006E55 E8D6A8              <1> 	call	fdc_detect_media
  8369 00006E58 72E1                <1> 	jc	.error_end_io
  8370 00006E5A E9DDFE              <1> 	jmp	.fdc_send_specify
  8371                              <1> 	
  8372                              <1> 
  8373                              <1> ;=========================================================================
  8374                              <1> ; int_13_fn05 - Format track
  8375                              <1> ; Input:
  8376                              <1> ;	AH = 05h
  8377                              <1> ;	CH = track number
  8378                              <1> ;	DH = head number (0 or 1)
  8379                              <1> ;	DL = drive number (0 or 1)
  8380                              <1> ;	ES:BX -> address field buffer
  8381                              <1> ; Output:
  8382                              <1> ;	CF clear if successful
  8383                              <1> ;		AH = 00h - successful completion
  8384                              <1> ;	CF set on error
  8385                              <1> ;		AH = error code 
  8386                              <1> ;-------------------------------------------------------------------------
  8387                              <1> int_13_fn05:
  8388 00006E5D 80FA01              <1> 	cmp	dl,1
  8389 00006E60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  8390 00006E65 E8A3A8              <1> 	call	read_cmos_type		; get drive type in AL
  8391 00006E68 7303E99500          <1> 	jc	.invalid_drive
  8392 00006E6D BE9000              <1> 	mov	si,fdc_media_state
  8393 00006E70 52                  <1> 	push	dx
  8394 00006E71 B600                <1> 	mov	dh,00h
  8395 00006E73 01D6                <1> 	add	si,dx			; SI -> drive media state
  8396 00006E75 5A                  <1> 	pop	dx
  8397 00006E76 803C00              <1> 	cmp	byte [si],0
  8398 00006E79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  8399 00006E7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  8400 00006E83 E8F6A5              <1> 	call	fdc_motor_on
  8401 00006E86 E8ADA6              <1> 	call	fdc_disk_change		; read disk change line
  8402 00006E89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  8403 00006E8B E86DA9              <1> 	call	fdc_select_rate		; select transfer rate
  8404 00006E8E E87AA2              <1> 	call	fdc_send_specify	; send FDC Specify command
  8405 00006E91 1E                  <1> 	push	ds
  8406 00006E92 31F6                <1> 	xor	si,si
  8407 00006E94 8EDE                <1> 	mov	ds,si
  8408 00006E96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8409 00006E9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  8410 00006E9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  8411 00006EA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  8412 00006EA3 1F                  <1> 	pop	ds
  8413 00006EA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  8414 00006EA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  8415 00006EA8 D1E1                <1> 	shl	cx,1
  8416 00006EAA 49                  <1> 	dec	cx	 		; minus one byte...
  8417 00006EAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8418 00006EAD E8CEA6              <1> 	call	fdc_configure_dma
  8419 00006EB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  8420 00006EB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  8421 00006EB5 56                  <1> 	push	si
  8422 00006EB6 E80CA5              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8423 00006EB9 5E                  <1> 	pop	si
  8424 00006EBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8425                              <1> 
  8426 00006EBC 88F4                <1> 	mov	ah,dh
  8427 00006EBE D0E4                <1> 	shl	ah,1
  8428 00006EC0 D0E4                <1> 	shl	ah,1
  8429 00006EC2 08D4                <1> 	or	ah,dl
  8430 00006EC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  8431                              <1> 
  8432 00006EC6 B106                <1> 	mov	cl,6			; 6 byte command
  8433 00006EC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8434 00006ECD E80CA7              <1> 	call	fdc_send_cmd
  8435 00006ED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  8436 00006ED2 E858A9              <1> 	call	fdc_wait_irq
  8437 00006ED5 720A                <1> 	jc	.exit_end_io
  8438 00006ED7 B107                <1> 	mov	cl,7
  8439 00006ED9 E865A7              <1> 	call	fdc_get_result		; read result bytes
  8440 00006EDC 7203                <1> 	jc	.exit_end_io
  8441 00006EDE E8B5A7              <1> 	call	fdc_get_error		; get error code
  8442                              <1> 
  8443                              <1> .exit_end_io:
  8444 00006EE1 E827A6              <1> 	call	fdc_end_io
  8445 00006EE4 08E4                <1> 	or	ah,ah
  8446 00006EE6 7401                <1> 	jz	.exit			; jump if no errors
  8447                              <1> 
  8448                              <1> .error:
  8449 00006EE8 F9                  <1> 	stc				; indicate error
  8450                              <1> 
  8451                              <1> .exit:
  8452 00006EE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  8453 00006EED E9C5FD              <1> 	jmp	int_13_upd_exit
  8454                              <1> 
  8455                              <1> .error_fdc_get_result:
  8456 00006EF0 B107                <1> 	mov	cl,7
  8457 00006EF2 50                  <1> 	push	ax
  8458 00006EF3 E84BA7              <1> 	call	fdc_get_result		; read result bytes
  8459 00006EF6 58                  <1> 	pop	ax
  8460 00006EF7 EBE8                <1> 	jmp	.exit_end_io
  8461                              <1> 
  8462                              <1> .error_end_io:
  8463 00006EF9 E80FA6              <1> 	call	fdc_end_io
  8464 00006EFC EBEA                <1> 	jmp	.error
  8465                              <1> 
  8466                              <1> .timeout:
  8467 00006EFE B480                <1> 	mov	ah,fdc_e_timeout
  8468 00006F00 EBE6                <1> 	jmp	.error
  8469                              <1> 
  8470                              <1> .invalid_drive:
  8471 00006F02 B401                <1> 	mov	ah,fdc_e_invalid
  8472 00006F04 EBE2                <1> 	jmp	.error
  8473                              <1> 
  8474                              <1> ;=========================================================================
  8475                              <1> ; int_0E - IRQ6 (FDC) service routine
  8476                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  8477                              <1> ;-------------------------------------------------------------------------
  8478 00006F06 FF<rept>            <1> 	setloc	0EF57h
  8479          ******************  <1>  warning: (setloc:7) Inserting 81 bytes
  8480                              <1> 
  8481                              <1> int_0E:
  8482 00006F57 50                  <1> 	push	ax
  8483 00006F58 1E                  <1> 	push	ds
  8484 00006F59 B84000              <1> 	mov	ax,biosdseg
  8485 00006F5C 8ED8                <1> 	mov	ds,ax
  8486 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  8487 00006F63 1F                  <1> 	pop	ds
  8488 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  8489 00006F66 E620                <1> 	out	pic1_reg0,al
  8490 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  8491 00006F6B CD15                <1> 	int	15h
  8492 00006F6D 58                  <1> 	pop	ax
  8493 00006F6E CF                  <1> 	iret
  8494                              <1> 
  8495                              <1> ;=========================================================================
  8496                              <1> ; Disk parameter tables in INT 1Eh format
  8497                              <1> ; Byte 0: First byte for specify command:
  8498                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  8499                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  8500                              <1> ; Byte 1: Second byte for specify command:
  8501                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  8502                              <1> ;	bit 0: non-DMA mode (always 0)
  8503                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  8504                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  8505                              <1> ; Byte 4: sectors per track
  8506                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  8507                              <1> ; Byte 6: special sector size (0FFh - not used)
  8508                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  8509                              <1> ; Byte 8: format filler byte (default 0F6h)
  8510                              <1> ; Byte 9: head settle time in milliseconds
  8511                              <1> ; Byte A: motor start time, in 1/8 seconds
  8512                              <1> ; Byte B: number of cylinders minus one
  8513                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  8514                              <1> ;-------------------------------------------------------------------------
  8515                              <1> media_360_in_360:
  8516 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8517 00006F78 0F08                <1>
  8518 00006F7A 2780                <1> 	db	27h, 80h
  8519                              <1> media_1200:
  8520 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  8521 00006F85 0F08                <1>
  8522 00006F87 4F00                <1> 	db	4Fh, 00h
  8523                              <1> media_720:
  8524 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8525 00006F92 0F08                <1>
  8526 00006F94 4F80                <1> 	db	4Fh, 80h
  8527                              <1> media_1440:
  8528 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  8529 00006F9F 0F08                <1>
  8530 00006FA1 4F00                <1> 	db	4Fh, 00h
  8531                              <1> media_360_in_1200:
  8532 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  8533 00006FAC 0F08                <1>
  8534 00006FAE 2740                <1> 	db	27h, 40h
  8535                              <1> media_2880:
  8536 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8537 00006FB9 0F08                <1>
  8538 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  8539                              <1> 
  8540                              <1> ;=========================================================================
  8541                              <1> ; Disk parameter table for IBM compatibility
  8542                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  8543                              <1> ;-------------------------------------------------------------------------
  8544 00006FBD FF<rept>            <1> 	setloc	0EFC7h
  8545          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  8546                              <1> int_1E:
  8547 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8548 00006FD0 0F08                <1>
  8549                                  %include	"printer2.inc"		; INT 17
  8550                              <1> ;=========================================================================
  8551                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  8552                              <1> ;       INT 17h, function AH=00h
  8553                              <1> ;	INT 17h, function AH=02h
  8554                              <1> ;	- see printer1.inc for other INT 17h functions
  8555                              <1> ;-------------------------------------------------------------------------
  8556                              <1> ;
  8557                              <1> ; Compiles with NASM 2.07, might work with other versions
  8558                              <1> ;
  8559                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8560                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8561                              <1> ;
  8562                              <1> ; This program is free software: you can redistribute it and/or modify
  8563                              <1> ; it under the terms of the GNU General Public License as published by
  8564                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8565                              <1> ; (at your option) any later version.
  8566                              <1> ;
  8567                              <1> ; This program is distributed in the hope that it will be useful,
  8568                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8569                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8570                              <1> ; GNU General Public License for more details.
  8571                              <1> ;
  8572                              <1> ; You should have received a copy of the GNU General Public License
  8573                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8574                              <1> ;
  8575                              <1> ;=========================================================================
  8576                              <1> 
  8577                              <1> ;=========================================================================
  8578                              <1> ; int_17  - BIOS Printer Services
  8579                              <1> ;-------------------------------------------------------------------------
  8580                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  8581                              <1> int_17:
  8582 00006FD2 FB                  <1> 	sti
  8583 00006FD3 53                  <1> 	push	bx
  8584 00006FD4 52                  <1> 	push	dx
  8585 00006FD5 56                  <1> 	push	si
  8586 00006FD6 1E                  <1> 	push	ds
  8587 00006FD7 BB4000              <1> 	mov	bx,biosdseg
  8588 00006FDA 8EDB                <1> 	mov	ds,bx
  8589 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
  8590 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  8591 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  8592 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  8593 00006FE6 89D3                <1> 	mov	bx,dx
  8594 00006FE8 D1E3                <1> 	shl	bx,1
  8595 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  8596 00006FED 09D2                <1> 	or	dx,dx
  8597 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  8598                              <1> 
  8599 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  8600                              <1> 
  8601 00006FF3 08E4                <1> 	or	ah,ah
  8602 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  8603 00006FF7 FECC                <1> 	dec	ah
  8604 00006FF9 7503E91BB0          <1> 	jz	int_17_fn01		; AH = 01h
  8605 00006FFE FECC                <1> 	dec	ah
  8606 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  8607                              <1> 
  8608                              <1> int_17_exit:
  8609 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  8610 00007005 88D8                <1> 	mov	al,bl			; restore AL
  8611                              <1> 
  8612                              <1> int_17_error:
  8613 00007007 1F                  <1> 	pop	ds
  8614 00007008 5E                  <1> 	pop	si
  8615 00007009 5A                  <1> 	pop	dx
  8616 0000700A 5B                  <1> 	pop	bx
  8617 0000700B CF                  <1> 	iret
  8618                              <1> 
  8619                              <1> ;=========================================================================
  8620                              <1> ; int_17_fn00 - Print character
  8621                              <1> ; Input:
  8622                              <1> ;	AH = 0 - function 00h - print character
  8623                              <1> ;	AL = character to print
  8624                              <1> ;	DX = printer port number (0-2)
  8625                              <1> ; Output:
  8626                              <1> ;	AH = printer status:
  8627                              <1> ;		bit 0	= 1	- timeout error
  8628                              <1> ;		bit 1,2		- reserved
  8629                              <1> ;		bit 3	= 1	- I/O error
  8630                              <1> ;		bit 4	= 1	- printed selected
  8631                              <1> ;		bit 5	= 1	- out of paper
  8632                              <1> ;		bit 6	= 1	- acknowledge from printer
  8633                              <1> ;		bit 7	= 1	- printer not busy
  8634                              <1> ;-------------------------------------------------------------------------
  8635                              <1> int_17_fn00:
  8636 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  8637 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8638                              <1> 					; OPTIMIZATION:
  8639                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8640 0000700E EC                  <1> 	in	al,dx			; read status
  8641 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  8642 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  8643 00007014 750C                <1>         jnz     .not_busy
  8644                              <1> 
  8645 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  8646 00007019 CD15                <1> 	int	15h			; call OS hook
  8647                              <1> 
  8648 0000701B B780                <1> 	mov	bh,prn_stat_busy
  8649 0000701D E838AF              <1> 	call	wait_for_port		; wait for printer to be ready
  8650 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  8651                              <1> 
  8652                              <1> .not_busy:
  8653 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  8654                              <1> 					; OPTIMIZATION:
  8655                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  8656 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  8657 00007025 EE                  <1> 	out	dx,al			; activate strobe
  8658 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  8659 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  8660 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  8661 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  8662 0000702E EBD2                <1> 	jmp	int_17_exit
  8663                              <1> 
  8664                              <1> .timeout:
  8665 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  8666 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  8667 00007036 EBCA                <1> 	jmp	int_17_exit
  8668                              <1> 
  8669                              <1> ;=========================================================================
  8670                              <1> ; int_17_fn02 - Return printer status
  8671                              <1> ; Input:
  8672                              <1> ;	AH = 2 - function 02h - return printer status
  8673                              <1> ;	DX = printer port number (0-2)
  8674                              <1> ; Output:
  8675                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  8676                              <1> ;-------------------------------------------------------------------------
  8677                              <1> int_17_fn02:
  8678 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8679                              <1> 					; OPTIMIZATION:
  8680                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8681                              <1> int_17_status:
  8682 00007039 EC                  <1> 	in	al,dx			; read the status
  8683 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  8684 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  8685 0000703F EBC1                <1> 	jmp	int_17_exit
  8686                                  %include	"video.inc"		; INT 10
  8687                              <1> ;=========================================================================
  8688                              <1> ; video.inc - BIOS video services
  8689                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  8690                              <1> ;-------------------------------------------------------------------------
  8691                              <1> ;
  8692                              <1> ; Compiles with NASM 2.07, might work with other versions
  8693                              <1> ;
  8694                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  8695                              <1> ;
  8696                              <1> ; This program is free software: you can redistribute it and/or modify
  8697                              <1> ; it under the terms of the GNU General Public License as published by
  8698                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8699                              <1> ; (at your option) any later version.
  8700                              <1> ;
  8701                              <1> ; This program is distributed in the hope that it will be useful,
  8702                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8703                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8704                              <1> ; GNU General Public License for more details.
  8705                              <1> ;
  8706                              <1> ; You should have received a copy of the GNU General Public License
  8707                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8708                              <1> ;
  8709                              <1> ;=========================================================================
  8710                              <1> 
  8711                              <1> ;-------------------------------------------------------------------------
  8712                              <1> ; CRTC registers
  8713                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  8714                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  8715                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  8716                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  8717                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  8718                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  8719                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  8720                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  8721                              <1> 
  8722                              <1> ;-------------------------------------------------------------------------
  8723                              <1> ; control characters
  8724                              <1> bel	equ	07h
  8725                              <1> bs	equ	08h
  8726                              <1> lf	equ	0Ah
  8727                              <1> cr	equ	0Dh
  8728                              <1> 
  8729 00007041 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  8730          ******************  <1>  warning: (setloc:7) Inserting 4 bytes
  8731                              <1> 
  8732                              <1> int_10_dispatch:
  8733 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
  8734 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  8735 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
  8736 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  8737 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
  8738 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
  8739 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
  8740 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
  8741 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
  8742 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
  8743 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
  8744 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
  8745 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  8746 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  8747 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
  8748 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
  8749                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  8750                              <1> 
  8751                              <1> 
  8752                              <1> ;-------------------------------------------------------------------------
  8753                              <1> ; offsets for registers on stack
  8754                              <1> 
  8755                              <1> int_10_ax	equ	0
  8756                              <1> int_10_al	equ	int_10_ax
  8757                              <1> int_10_ah	equ	int_10_ax+1
  8758                              <1> int_10_bx	equ	int_10_ax+2
  8759                              <1> int_10_bl	equ	int_10_bx
  8760                              <1> int_10_bh	equ	int_10_bx+1
  8761                              <1> int_10_cx	equ	int_10_bx+2
  8762                              <1> int_10_ch	equ	int_10_cx+1
  8763                              <1> int_10_dx	equ	int_10_cx+2
  8764                              <1> 
  8765                              <1> ;=========================================================================
  8766                              <1> ; int_10 - BIOS video services
  8767                              <1> ; Input:
  8768                              <1> ;	AH - Function
  8769                              <1> ;		00h - Set video mode
  8770                              <1> ;		01h - Set text mode cursor shape
  8771                              <1> ;		02h - Set cursor position
  8772                              <1> ;		03h - Get cursor position and shape
  8773                              <1> ;		04h - Read light pen position
  8774                              <1> ;		05h - Select active display page
  8775                              <1> ;		06h - Scroll up window
  8776                              <1> ;		07h - Scroll down window
  8777                              <1> ;		08h - Read character and attribute at cursor position
  8778                              <1> ;		09h - Write character and attribute at cursor position
  8779                              <1> ;		0Ah - Write character only at cursor position
  8780                              <1> ;		0Bh -
  8781                              <1> ;			BH = 00h - Set background/border color
  8782                              <1> ;			BH = 01h - Set palette
  8783                              <1> ;		0Ch - Write graphics pixel
  8784                              <1> ;		0Dh - Read graphics pixel
  8785                              <1> ;		0Eh - Teletype output
  8786                              <1> ;		0Fh - Get current video mode
  8787                              <1> ;-------------------------------------------------------------------------
  8788                              <1> 	setloc	0F065h			; int 10 Entry Point
  8789                              <1> int_10:
  8790 00007065 FB                  <1> 	sti
  8791 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  8792 00007067 55                  <1> 	push	bp
  8793 00007068 06                  <1> 	push	es
  8794 00007069 1E                  <1> 	push	ds
  8795 0000706A 56                  <1> 	push	si
  8796 0000706B 57                  <1> 	push	di
  8797 0000706C 52                  <1> 	push	dx
  8798 0000706D 51                  <1> 	push	cx
  8799 0000706E 53                  <1> 	push	bx
  8800 0000706F 50                  <1> 	push	ax
  8801 00007070 BB4000              <1> 	mov	bx,biosdseg
  8802 00007073 8EDB                <1> 	mov	ds,bx
  8803 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  8804 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  8805 0000707C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  8806 0000707F 7202                <1> 	jb	.color			; it is CGA
  8807 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  8808                              <1> 
  8809                              <1> .color:
  8810 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  8811 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  8812 00007087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  8813 0000708A 730B                <1> 	jae	.exit			; invalid function
  8814 0000708C B700                <1> 	mov	bh,0
  8815 0000708E 88E3                <1> 	mov	bl,ah
  8816 00007090 D1E3                <1> 	shl	bx,1
  8817 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  8818                              <1> 
  8819                              <1> .exit:
  8820 00007097 58                  <1> 	pop	ax
  8821 00007098 5B                  <1> 	pop	bx
  8822 00007099 59                  <1> 	pop	cx
  8823 0000709A 5A                  <1> 	pop	dx
  8824 0000709B 5F                  <1> 	pop	di
  8825 0000709C 5E                  <1> 	pop	si
  8826 0000709D 1F                  <1> 	pop	ds
  8827 0000709E 07                  <1> 	pop	es
  8828 0000709F 5D                  <1> 	pop	bp
  8829 000070A0 CF                  <1> 	iret
  8830                              <1> 
  8831                              <1> 
  8832                              <1> ;=========================================================================
  8833                              <1> ; int_1D - Video parameters tables
  8834                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  8835                              <1> ; video mode initialization
  8836                              <1> ;-------------------------------------------------------------------------
  8837 000070A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  8838          ******************  <1>  warning: (setloc:7) Inserting 3 bytes
  8839                              <1> int_1D:
  8840                              <1> 	; CGA test 40x25 modes
  8841 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  8842 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8843                              <1> 
  8844                              <1> 	; CGA text 80x25 modes
  8845 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  8846 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8847                              <1> 
  8848                              <1> 	; CGA graphics modes
  8849 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  8850 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  8851                              <1> 
  8852                              <1> 	; MDA text 80x25 mode
  8853 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  8854 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  8855                              <1> 
  8856                              <1> page_size:
  8857 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  8858 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  8859 000070E8 0040                <1> 	dw	4000h			; graphics modes
  8860 000070EA 0040                <1> 	dw	4000h
  8861                              <1> 
  8862                              <1> columns:
  8863 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  8864 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  8865 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  8866 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  8867                              <1> 
  8868 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  8869                              <1> 
  8870 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  8871                              <1> 
  8872                              <1> ;=========================================================================
  8873                              <1> ; int_10_fn00 - Set video mode
  8874                              <1> ; Input:
  8875                              <1> ;	AH = 00h
  8876                              <1> ;	AL = video mode
  8877                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  8878                              <1> ;		01h - CGA - text 40x25, 16 colors
  8879                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  8880                              <1> ;		03h - CGA - text 80x25, 16 colors
  8881                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  8882                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  8883                              <1> ;		06h - CGA - graphics 640x200, monochrome
  8884                              <1> ;		07h - MDA - text 80x25, monochrome
  8885                              <1> ;-------------------------------------------------------------------------
  8886                              <1> int_10_fn00:
  8887 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  8888 00007107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  8889 0000710A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  8890 0000710D B000                <1> 	mov	al,0
  8891 0000710F 80FB07              <1> 	cmp	bl,07h
  8892 00007112 7206                <1> 	jb	.color			; jump if monochrome mode
  8893 00007114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  8894 00007116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  8895 00007118 FEC0                <1> 	inc	al
  8896                              <1> 
  8897                              <1> .color:
  8898 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  8899 0000711C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  8900 00007120 80C204              <1> 	add	dl,4
  8901 00007123 EE                  <1> 	out	dx,al			; Reset the video
  8902 00007124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  8903 00007128 B700                <1> 	mov	bh,0
  8904 0000712A 53                  <1> 	push	bx
  8905 0000712B 06                  <1> 	push	es
  8906 0000712C 31C0                <1> 	xor	ax,ax
  8907 0000712E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  8908 00007130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  8909 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  8910 0000713A 01DE                <1> 	add	si,bx
  8911                              <1> 
  8912 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  8913 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  8914 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  8915                              <1> 
  8916 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  8917                              <1> 
  8918                              <1> .setup_crt_loop:
  8919 00007149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  8920 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  8921 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  8922 00007151 46                  <1> 	inc	si			;  ...point to next
  8923 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  8924 00007154 07                  <1> 	pop	es
  8925 00007155 31FF                <1> 	xor	di,di
  8926 00007157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  8927 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  8928 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  8929 0000715F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  8930 00007161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  8931 00007163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  8932                              <1> 
  8933                              <1> .text_fill:
  8934 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  8935                              <1> 
  8936                              <1> .clear_screen:
  8937 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  8938                              <1> 
  8939 0000716B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  8940 0000716F 80C204              <1> 	add	dl,4
  8941 00007172 5B                  <1> 	pop	bx
  8942 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  8943 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  8944 00007179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  8945 0000717C 42                  <1> 	inc	dx
  8946 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  8947 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  8948 00007182 7502                <1> 	jnz	.set_palette
  8949 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  8950                              <1> 
  8951                              <1> .set_palette:
  8952 00007186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  8953 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  8954                              <1> 
  8955 0000718A 8CD8                <1> 	mov	ax,ds
  8956 0000718C 8EC0                <1> 	mov	es,ax
  8957 0000718E 31C0                <1> 	xor	ax,ax
  8958 00007190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  8959 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  8960 00007196 BF4E00              <1> 	mov	di,video_page_offt
  8961 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  8962                              <1> 
  8963 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  8964 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  8965 000071A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  8966                              <1> 					; but it means that for mode 7
  8967                              <1> 					; we'll get graphics page size?!
  8968 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  8969 000071AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  8970 000071AE C3                  <1> 	ret
  8971                              <1> 
  8972                              <1> ;=========================================================================
  8973                              <1> ; int_10_fn01 - Set text-mode cursor shape
  8974                              <1> ; Input:
  8975                              <1> ;	AH = 01h
  8976                              <1> ;	CH = cursor scan line start
  8977                              <1> ;	CL = cursor scan line end
  8978                              <1> ; Output:
  8979                              <1> ;	none
  8980                              <1> ;-------------------------------------------------------------------------
  8981                              <1> int_10_fn01:
  8982 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  8983 000071B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  8984 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  8985 000071B8 C3                  <1> 	ret
  8986                              <1> 
  8987                              <1> ;=========================================================================
  8988                              <1> ; int_10_fn02 - Set cursor position
  8989                              <1> ; Input:
  8990                              <1> ;	AH = 02h
  8991                              <1> ;	BH = page number
  8992                              <1> ;	DH = cursor row (00h is top)
  8993                              <1> ;	DL = cursor column (00h is left)
  8994                              <1> ; Output:
  8995                              <1> ;	none
  8996                              <1> ;-------------------------------------------------------------------------
  8997                              <1> int_10_fn02:
  8998 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8999 000071BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  9000 000071C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  9001                              <1> 
  9002                              <1> ;=========================================================================
  9003                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  9004                              <1> ;	BL = page
  9005                              <1> ;	DH = cursor row (00h is top)
  9006                              <1> ;	DL = cursor column (00h is left)
  9007                              <1> ;-------------------------------------------------------------------------
  9008                              <1> set_cur_pos:
  9009 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  9010 000071C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  9011 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  9012 000071CB D1E8                <1> 	shr	ax,1
  9013 000071CD 89C1                <1> 	mov	cx,ax
  9014 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9015 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9016                              <1> bios_set_cur_pos:
  9017 000071D4 B700                <1> 	mov	bh,0
  9018 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  9019 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  9020 000071DB C3                  <1> 	ret
  9021                              <1> 
  9022                              <1> ;=========================================================================
  9023                              <1> ; int_10_fn03 - Get cursor position and shape
  9024                              <1> ; Input:
  9025                              <1> ;	AH = 03h
  9026                              <1> ;	BH = page number
  9027                              <1> ; Output:
  9028                              <1> ;	CH = cursor start scan line
  9029                              <1> ;	CL = cursor end scan line
  9030                              <1> ;	DH = cursor row (00h is top)
  9031                              <1> ;	DL = cursor column (00h is left)
  9032                              <1> ;-------------------------------------------------------------------------
  9033                              <1> int_10_fn03:
  9034 000071DC B700                <1> 	mov	bh,0
  9035 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9036 000071E1 D0E3                <1> 	shl	bl,1
  9037 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  9038 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  9039 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  9040 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  9041 000071EF C3                  <1> 	ret
  9042                              <1> 
  9043                              <1> ;=========================================================================
  9044                              <1> ; int_10_fn04 - Read light pen position
  9045                              <1> ; Input:
  9046                              <1> ;	AH = 04h
  9047                              <1> ; Output:
  9048                              <1> ;	AH - light pen trigger flag
  9049                              <1> ;		00h not down/triggered
  9050                              <1> ;		01h down/triggered
  9051                              <1> ;	If light pen is triggered:
  9052                              <1> ;		DH = character row
  9053                              <1> ;		DL = character column
  9054                              <1> ;		CH = pixel row
  9055                              <1> ;		BX = pixel column
  9056                              <1> ;-------------------------------------------------------------------------
  9057                              <1> int_10_fn04:
  9058 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  9059 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  9060 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  9061 000071FB EC                  <1> 	in	al,dx			; read it
  9062 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  9063 000071FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  9064 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  9065 00007202 7501                <1> 	jnz	.read_pen		; continue if triggered
  9066 00007204 C3                  <1> 	ret				; not triggered - return
  9067                              <1> 
  9068                              <1> .read_pen:
  9069 00007205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  9070 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  9071 0000720B EE                  <1> 	out	dx,al			; select it
  9072 0000720C 42                  <1> 	inc	dx			; CRTC data register
  9073 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  9074 0000720E 88C4                <1> 	mov	ah,al
  9075 00007210 4A                  <1> 	dec	dx			; CRTC index register
  9076 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  9077 00007213 EE                  <1> 	out	dx,al			; select it
  9078 00007214 42                  <1> 	inc	dx			; CRTC data register
  9079 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  9080                              <1> 
  9081 00007216 B700                <1> 	mov	bh,0
  9082 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  9083 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  9084 00007221 29D8                <1> 	sub	ax,bx
  9085 00007223 7902                <1> 	jns	.1
  9086 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  9087                              <1> 
  9088                              <1> .1:
  9089 00007227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  9090 0000722A 7325                <1> 	jnb	.text			; calculate character position if text
  9091 0000722C B228                <1> 	mov	dl,40			; divide by 40
  9092 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  9093 00007230 B700                <1> 	mov	bh,0
  9094 00007232 88E3                <1> 	mov	bl,ah
  9095 00007234 B103                <1> 	mov	cl,3
  9096 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  9097 00007238 88C5                <1> 	mov	ch,al
  9098 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  9099 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  9100 0000723E 88C6                <1> 	mov	dh,al
  9101 00007240 D0EE                <1> 	shr	dh,1
  9102 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  9103 00007244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  9104 00007249 751A                <1> 	jnz	.exit
  9105 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  9106 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  9107 0000724F EB14                <1> 	jmp	.exit
  9108                              <1> 
  9109                              <1> .text:
  9110 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  9111 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  9112 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  9113 00007259 B103                <1> 	mov	cl,3
  9114 0000725B D2E4                <1> 	shl	ah,cl
  9115 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  9116 0000725F B700                <1> 	mov	bh,0
  9117 00007261 88C3                <1> 	mov	bl,al
  9118 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  9119                              <1> 
  9120                              <1> .exit:
  9121 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  9122 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  9123 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  9124 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  9125                              <1> 
  9126                              <1> .reset_pen:
  9127 00007272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  9128 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  9129 00007279 EE                  <1> 	out	dx,al			; reset it
  9130 0000727A C3                  <1> 	ret
  9131                              <1> 
  9132                              <1> .correction:
  9133 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  9134                              <1> 
  9135                              <1> ;=========================================================================
  9136                              <1> ; int_10_fn05 - Select active display page
  9137                              <1> ; Input:
  9138                              <1> ;	AH = 05h
  9139                              <1> ;	AL - new page number (00h is the first page)
  9140                              <1> ; Output:
  9141                              <1> ;	none
  9142                              <1> ;-------------------------------------------------------------------------
  9143                              <1> int_10_fn05:
  9144 00007283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  9145 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  9146 00007288 B400                <1> 	mov	ah,0
  9147 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  9148 0000728E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  9149 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  9150 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  9151 00007295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  9152 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  9153                              <1> 
  9154 0000729A B700                <1> 	mov	bh,0
  9155 0000729C D1E3                <1> 	shl	bx,1
  9156 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  9157 000072A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  9158 000072A4 D1E8                <1> 	shr	ax,1
  9159 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  9160 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9161 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9162 000072AD C3                  <1> 	ret
  9163                              <1> 
  9164                              <1> ;=========================================================================
  9165                              <1> ; int_10_fn06 - scroll up window
  9166                              <1> ; int_10_fn07 - scroll down window
  9167                              <1> ; Input:
  9168                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  9169                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  9170                              <1> ;	BH = attribute used to write blank rows at bottom of window
  9171                              <1> ;	CH,CL = row,column of window's upper left corner
  9172                              <1> ;	DH,DL = row,column of window's lower right corner
  9173                              <1> ; Output:
  9174                              <1> ;	none
  9175                              <1> ; TODO:
  9176                              <1> ;	optimize graphics fill
  9177                              <1> ;-------------------------------------------------------------------------
  9178                              <1> int_10_fn06:
  9179                              <1> int_10_fn07:
  9180 000072AE E86604              <1> 	call	vid_check_mode
  9181 000072B1 7303E9D900          <1> 	jb	.graphics_scroll
  9182                              <1> 
  9183 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  9184 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  9185 000072BD 720A                <1> 	jb	.no_snow
  9186 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  9187 000072C4 7703                <1> 	ja	.no_snow
  9188 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  9189                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  9190                              <1> .no_snow:
  9191 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9192 000072CC 50                  <1> 	push	ax
  9193 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  9194 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  9195 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9196                              <1> 
  9197                              <1> .1:
  9198 000072D6 E89804              <1> 	call	vid_position_to_offset
  9199 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  9200 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9201                              <1> 
  9202                              <1> ; calculate scroll window size (DX)
  9203                              <1> 
  9204 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9205 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  9206 000072E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  9207                              <1> 
  9208                              <1> ; calculate offset between the source and the destination (AX)
  9209                              <1> 
  9210 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  9211 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  9212 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  9213 000072F0 52                  <1> 	push    dx
  9214 000072F1 B400                <1>         mov     ah,0
  9215 000072F3 F7E3                <1>         mul     bx
  9216 000072F5 5A                  <1>         pop     dx
  9217                              <1> 
  9218 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  9219 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  9220 000072FA 1E                  <1> 	push	ds
  9221 000072FB 8CC1                <1> 	mov	cx,es
  9222 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9223 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9224 00007303 7405                <1> 	jz	.2			; jump if scroll up
  9225 00007305 F7D8                <1> 	neg	ax			; negate offset
  9226 00007307 F7DB                <1> 	neg	bx			; negate distance
  9227 00007309 FD                  <1> 	std				; copy backwards
  9228                              <1> 
  9229                              <1> .2:
  9230 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  9231 0000730D 08C9                <1> 	or	cl,cl
  9232 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  9233 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  9234 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  9235 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  9236                              <1> 
  9237 00007316 09DB                <1> 	or	bx,bx
  9238 00007318 7434                <1> 	jz	.text_full_row_scroll
  9239                              <1> 
  9240                              <1> .text_scroll_loop:
  9241 0000731A B500                <1> 	mov	ch,0
  9242 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  9243                              <1> 
  9244 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  9245 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  9246 00007322 E85800              <1> 	call	.retrace_wait
  9247                              <1> 
  9248                              <1> .text_scroll_no_retrace:
  9249 00007325 F3A5                <1> 	repz	movsw			; copy one row
  9250                              <1> 
  9251                              <1> ;.text_scroll_next_row:
  9252 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  9253 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  9254 0000732B FECE                <1> 	dec	dh			; decrement row counter
  9255 0000732D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  9256                              <1> 
  9257                              <1> .text_fill:
  9258 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  9259 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  9260                              <1> 
  9261                              <1> .text_fill_only:
  9262 00007334 B500                <1> 	mov	ch,0
  9263 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  9264 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  9265                              <1> 
  9266                              <1> .text_fill_loop:
  9267 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  9268 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  9269 0000733F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  9270 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  9271                              <1> 
  9272                              <1> .text_fill_no_retrace:
  9273 00007344 F3AB                <1> 	repz	stosw			; fill one row
  9274 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  9275 00007348 FECE                <1> 	dec	dh			; decrement row counter
  9276 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  9277                              <1> 
  9278 0000734C 1F                  <1> 	pop	ds
  9279 0000734D C3                  <1> 	ret
  9280                              <1> 
  9281                              <1> .text_full_row_scroll:
  9282 0000734E 09C0                <1> 	or	ax,ax
  9283 00007350 741F                <1> 	jz	.text_full_row_no_snow
  9284 00007352 50                  <1> 	push	ax
  9285 00007353 88D0                <1> 	mov	al,dl
  9286 00007355 F6E6                <1> 	mul	dh
  9287                              <1> 
  9288                              <1> .text_full_row_loop:
  9289 00007357 B9F000              <1> 	mov	cx,240
  9290 0000735A 39C8                <1> 	cmp	ax,cx
  9291 0000735C 7705                <1> 	ja	.copy_chunk
  9292 0000735E 91                  <1> 	xchg	ax,cx
  9293 0000735F 31C0                <1> 	xor	ax,ax
  9294 00007361 EB02                <1> 	jmp	.do_copy
  9295                              <1> 
  9296                              <1> .copy_chunk:
  9297 00007363 29C8                <1> 	sub	ax,cx
  9298                              <1> 
  9299                              <1> .do_copy:
  9300 00007365 E81500              <1> 	call	.retrace_wait
  9301 00007368 F3A5                <1> 	rep	movsw
  9302 0000736A 09C0                <1> 	or	ax,ax
  9303 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  9304 0000736E 58                  <1> 	pop	ax
  9305 0000736F EBBE                <1> 	jmp	.text_fill
  9306                              <1> 
  9307                              <1> .text_full_row_no_snow:
  9308 00007371 50                  <1> 	push	ax
  9309 00007372 88D0                <1> 	mov	al,dl
  9310 00007374 F6E6                <1> 	mul	dh
  9311 00007376 89C1                <1> 	mov	cx,ax
  9312 00007378 F3A5                <1> 	rep	movsw
  9313 0000737A 58                  <1> 	pop	ax
  9314 0000737B EBB2                <1> 	jmp	.text_fill
  9315                              <1> 
  9316                              <1> ;-------------------------------------------------------------------------
  9317                              <1> ; .retrace_wait - next till the next vertical retrace
  9318                              <1> 
  9319                              <1> .retrace_wait:
  9320 0000737D 50                  <1> 	push	ax
  9321 0000737E 52                  <1> 	push	dx
  9322 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  9323                              <1> 
  9324                              <1> .retrace_wait_not_set:
  9325 00007382 EC                  <1> 	in	al,dx
  9326 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9327 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  9328                              <1> 
  9329                              <1> .retrace_wait_set:
  9330 00007387 EC                  <1> 	in	al,dx
  9331 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9332 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  9333 0000738C 5A                  <1> 	pop	dx
  9334 0000738D 58                  <1> 	pop	ax
  9335                              <1> 
  9336                              <1> .retrace_exit:
  9337 0000738E C3                  <1> 	ret
  9338                              <1> 
  9339                              <1> ;-------------------------------------------------------------------------
  9340                              <1> ; .graphics_scroll - scroll for graphics modes
  9341                              <1> 
  9342                              <1> .graphics_scroll:
  9343 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9344 00007392 50                  <1> 	push	ax
  9345 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  9346 00007397 7403                <1> 	jz	.3			; jump if scroll down
  9347 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9348                              <1> 
  9349                              <1> .3:
  9350 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  9351 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9352                              <1> 
  9353                              <1> ; calculate scroll windows size (DX)
  9354                              <1> 
  9355 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9356 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  9357 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  9358 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  9359 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  9360 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9361 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  9362 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  9363 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  9364 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  9365 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9366 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  9367 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  9368                              <1> 
  9369                              <1> .4:
  9370 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9371 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  9372 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  9373                              <1> 					;   for copying backwards
  9374                              <1> 
  9375                              <1> .5:
  9376 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  9377 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  9378 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  9379 000073CF 53                  <1> 	push	bx
  9380 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  9381 000073D2 B050                <1> 	mov	al,50h
  9382 000073D4 F6E3                <1> 	mul	bl
  9383 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  9384 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9385 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  9386 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  9387 000073E1 BB5020              <1> 	mov	bx,2050h
  9388 000073E4 FD                  <1> 	std				; copy backwards
  9389                              <1> 
  9390                              <1> .6:
  9391 000073E5 89FE                <1> 	mov	si,di
  9392 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  9393 000073E9 58                  <1> 	pop	ax
  9394 000073EA 8CC1                <1> 	mov	cx,es
  9395 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9396 000073EE 08C0                <1> 	or	al,al
  9397 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  9398 000073F2 50                  <1> 	push	ax
  9399                              <1> 
  9400                              <1> .graphics_scroll_loop:
  9401 000073F3 B500                <1> 	mov	ch,0
  9402 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9403 000073F7 56                  <1> 	push	si
  9404 000073F8 57                  <1> 	push	di
  9405 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  9406 000073FB 5F                  <1> 	pop	di
  9407 000073FC 5E                  <1> 	pop	si
  9408 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  9409 00007401 81C70020            <1> 	add	di,2000h
  9410 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9411 00007407 56                  <1> 	push	si
  9412 00007408 57                  <1> 	push	di
  9413 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  9414 0000740B 5F                  <1> 	pop	di
  9415 0000740C 5E                  <1> 	pop	si
  9416 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  9417 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  9418 00007411 FECE                <1> 	dec	dh			; decrement row counter
  9419 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  9420                              <1> 
  9421 00007415 58                  <1> 	pop	ax
  9422 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  9423                              <1> 
  9424                              <1> .graphics_fill:
  9425 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  9426 0000741B B500                <1> 	mov	ch,0
  9427                              <1> 
  9428                              <1> .graphics_fill_loop:
  9429 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9430 0000741F 57                  <1> 	push	di
  9431 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  9432 00007422 5F                  <1> 	pop	di
  9433 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  9434 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9435 00007429 57                  <1> 	push	di
  9436 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  9437 0000742C 5F                  <1> 	pop	di
  9438 0000742D 29DF                <1> 	sub	di,bx
  9439 0000742F FECE                <1> 	dec	dh			; decrement row counter
  9440 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  9441 00007433 C3                  <1> 	ret
  9442                              <1> 
  9443                              <1> ;=========================================================================
  9444                              <1> ; int_10_fn08 - Read character and attribute
  9445                              <1> ; Input:
  9446                              <1> ;	AH = 08h
  9447                              <1> ; Output:
  9448                              <1> ;	AL - character read
  9449                              <1> ;	BH - video attribute (text modes only)
  9450                              <1> ; int_10_fn09 - Write character and attribute
  9451                              <1> ; Input:
  9452                              <1> ;	AH = 09h
  9453                              <1> ;	AL - character to write
  9454                              <1> ;	BH - page number
  9455                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  9456                              <1> ;	CX - number of times to write character
  9457                              <1> ; Output:
  9458                              <1> ;	none
  9459                              <1> ; int_10_fn0A - Write character only
  9460                              <1> ; Input:
  9461                              <1> ;	AH = 0Ah
  9462                              <1> ;	AL - character to write
  9463                              <1> ;	BH - page number
  9464                              <1> ;	CX - repeat count
  9465                              <1> ; Output:
  9466                              <1> ;	none
  9467                              <1> ;-------------------------------------------------------------------------
  9468                              <1> int_10_fn08:
  9469                              <1> int_10_fn09:
  9470                              <1> int_10_fn0A:
  9471 00007434 E8E002              <1> 	call	vid_check_mode
  9472 00007437 7277                <1> 	jb	.graphics		; jump if graphics mode
  9473 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9474 0000743C B700                <1> 	mov	bh,0
  9475 0000743E 53                  <1> 	push	bx
  9476 0000743F E82803              <1> 	call	vid_current_offset
  9477 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  9478 00007444 58                  <1> 	pop	ax			; AX = page number
  9479 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  9480 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  9481 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  9482 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  9483 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  9484 00007454 1E                  <1> 	push	ds
  9485 00007455 8CC3                <1> 	mov	bx,es
  9486 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  9487 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9488 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  9489 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  9490                              <1> 
  9491                              <1> .read_retrace_wait:
  9492 00007460 EC                  <1> 	in	al,dx
  9493 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9494 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  9495 00007465 FA                  <1> 	cli
  9496                              <1> 
  9497                              <1> .read_no_retrace_wait:
  9498 00007466 EC                  <1> 	in	al,dx
  9499 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9500 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  9501                              <1> 
  9502 0000746B AD                  <1> 	lodsw				; read character and attribute
  9503 0000746C FB                  <1> 	sti
  9504 0000746D 1F                  <1> 	pop	ds
  9505 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  9506 00007471 C3                  <1> 	ret
  9507                              <1> 
  9508                              <1> .text_write:
  9509 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  9510 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  9511 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  9512 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  9513 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  9514                              <1> 
  9515                              <1> .write_char_retrace:
  9516 0000747F EC                  <1> 	in	al,dx
  9517 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9518 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  9519                              <1> 
  9520                              <1> .write_retrace_wait1:
  9521 00007484 EC                  <1> 	in	al,dx
  9522 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9523 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  9524 00007489 FA                  <1> 	cli
  9525                              <1> 
  9526                              <1> .write_no_retrace_wait1:
  9527 0000748A EC                  <1> 	in	al,dx
  9528 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9529 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  9530                              <1> 
  9531                              <1> .do_write_char_attr:
  9532 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  9533 00007491 AB                  <1> 	stosw				; write it to video memory
  9534 00007492 FB                  <1> 	sti
  9535 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  9536 00007495 1F                  <1> 	pop	ds
  9537 00007496 C3                  <1> 	ret
  9538                              <1> 
  9539                              <1> .text_write_char_only:
  9540 00007497 EC                  <1> 	in	al,dx
  9541 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9542 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  9543                              <1> 
  9544                              <1> .write_retrace_wait2:
  9545 0000749C EC                  <1> 	in	al,dx
  9546 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9547 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  9548 000074A1 FA                  <1> 	cli
  9549                              <1> 
  9550                              <1> .write_no_retrace_wait2:
  9551 000074A2 EC                  <1> 	in	al,dx
  9552 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9553 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  9554                              <1> 
  9555                              <1> .do_write_char_only:
  9556 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  9557 000074A9 AA                  <1> 	stosb				; write it to video memory
  9558 000074AA FB                  <1> 	sti
  9559 000074AB 47                  <1> 	inc	di			; skip attribute
  9560 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  9561 000074AE 1F                  <1> 	pop	ds
  9562 000074AF C3                  <1> 	ret
  9563                              <1> 
  9564                              <1> .graphics:
  9565 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  9566 000074B4 7503E9B300          <1> 	jz	.graphics_read
  9567                              <1> 
  9568 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  9569 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  9570 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  9571 000074C1 1E                  <1> 	push	ds
  9572 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  9573 000074C5 B400                <1> 	mov	ah,0
  9574 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  9575 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  9576 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  9577 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  9578 000074D0 EB0C                <1> 	jmp	.CG9_03
  9579                              <1> 
  9580                              <1> .CG9_02:
  9581 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  9582 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  9583 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  9584 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  9585 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  9586                              <1> 
  9587                              <1> .CG9_03:
  9588 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  9589 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  9590 000074E1 D3E0                <1> 	shl	ax,cl
  9591 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  9592 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  9593 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  9594 000074ED 1E                  <1> 	push	ds
  9595 000074EE 8EDA                <1> 	mov	ds,dx
  9596 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  9597 000074F2 D1E7                <1> 	shl	di,1
  9598 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  9599 000074F7 83E003              <1> 	and	ax,3
  9600 000074FA BB5555              <1> 	mov	bx,5555h
  9601 000074FD F7E3                <1> 	mul	bx
  9602 000074FF 89C2                <1> 	mov	dx,ax
  9603 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  9604                              <1> 
  9605                              <1> .CG9_04:
  9606 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  9607 00007506 57                  <1> 	push	di
  9608 00007507 56                  <1> 	push	si
  9609                              <1> 
  9610                              <1> .CG9_05:
  9611 00007508 AC                  <1> 	lodsb				; Read the screen
  9612 00007509 51                  <1> 	push	cx
  9613 0000750A 53                  <1> 	push	bx
  9614 0000750B 31DB                <1> 	xor	bx,bx
  9615 0000750D B90800              <1> 	mov	cx,8
  9616                              <1> 
  9617                              <1> .CG9_06:
  9618 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  9619 00007512 D1DB                <1> 	rcr	bx,1
  9620 00007514 D1FB                <1> 	sar	bx,1
  9621 00007516 E2F8                <1> 	loop	.CG9_06
  9622                              <1> 
  9623 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  9624 0000751A 5B                  <1> 	pop	bx
  9625 0000751B 59                  <1> 	pop	cx
  9626 0000751C 21D0                <1> 	and	ax,dx
  9627 0000751E 86E0                <1> 	xchg	ah,al
  9628 00007520 08DB                <1> 	or	bl,bl
  9629 00007522 7903                <1> 	jns	.CG9_07
  9630 00007524 263305              <1>     es	xor	ax,word [di]
  9631                              <1> 
  9632                              <1> .CG9_07:
  9633 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  9634 0000752A 81F70020            <1> 	xor	di,2000h
  9635 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  9636 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  9637 00007534 83C750              <1> 	add	di,50h			; Else advance character
  9638                              <1> 
  9639                              <1> .CG9_08:
  9640 00007537 FECF                <1> 	dec	bh			; Show another char written
  9641 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  9642 0000753B 5E                  <1> 	pop	si
  9643 0000753C 5F                  <1> 	pop	di
  9644 0000753D 47                  <1> 	inc	di
  9645 0000753E 47                  <1> 	inc	di
  9646 0000753F E2C3                <1> 	loop	.CG9_04
  9647 00007541 1F                  <1> 	pop	ds
  9648 00007542 C3                  <1> 	ret
  9649                              <1> 
  9650                              <1> .CG8_02:
  9651 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  9652 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  9653                              <1> 
  9654                              <1> .CG8_03:
  9655 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  9656 0000754B 57                  <1> 	push	di
  9657 0000754C 56                  <1> 	push	si
  9658                              <1> 
  9659                              <1> .CG8_04:
  9660 0000754D AC                  <1> 	lodsb				; Read from one plane
  9661 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  9662 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  9663 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  9664                              <1> 
  9665                              <1> .CG8_05:
  9666 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  9667 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  9668 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  9669 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  9670 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  9671                              <1> 
  9672                              <1> .CG8_06:
  9673 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  9674 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  9675 00007565 5E                  <1> 	pop	si
  9676 00007566 5F                  <1> 	pop	di
  9677 00007567 47                  <1> 	inc	di
  9678 00007568 E2DF                <1> 	loop	.CG8_03
  9679 0000756A 1F                  <1> 	pop	ds
  9680 0000756B C3                  <1> 	ret
  9681                              <1> 
  9682                              <1> .graphics_read:
  9683 0000756C FC                  <1> 	cld				; Increment upwards
  9684 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  9685 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  9686 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  9687 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  9688 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  9689 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  9690 0000757F 8CC0                <1> 	mov	ax,es
  9691 00007581 1E                  <1> 	push	ds
  9692 00007582 57                  <1> 	push	di
  9693 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  9694 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  9695 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  9696 00007589 D1E6                <1> 	shl	si,1
  9697 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  9698                              <1> 
  9699                              <1> CGR_02:
  9700 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  9701 00007590 86E0                <1> 	xchg	ah,al
  9702 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  9703 00007595 B200                <1> 	mov	dl,0
  9704                              <1> 
  9705                              <1> CGR_03:
  9706 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  9707 00007599 F8                  <1> 	clc
  9708 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  9709 0000759C F9                  <1> 	stc				; Else show not set
  9710                              <1> 
  9711                              <1> CGR_04:
  9712 0000759D D0D2                <1> 	rcl	dl,1
  9713 0000759F D1E9                <1> 	shr	cx,1
  9714 000075A1 D1E9                <1> 	shr	cx,1
  9715 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  9716 000075A5 368815              <1>     ss	mov	byte [di],dl
  9717 000075A8 47                  <1> 	inc	di
  9718 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  9719 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  9720 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  9721 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  9722                              <1> 
  9723                              <1> CGR_05:
  9724 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  9725 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  9726 000075B6 EB17                <1> 	jmp	short	CGR_08
  9727                              <1> 
  9728                              <1> CGR_06:
  9729 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  9730                              <1> 
  9731                              <1> CGR_07:
  9732 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  9733 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  9734 000075BF 47                  <1> 	inc	di			;  ...advance
  9735 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  9736 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  9737 000075C7 47                  <1> 	inc	di			;  ...advance
  9738 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  9739 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  9740 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  9741                              <1> 
  9742                              <1> CGR_08:
  9743 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  9744 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  9745 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  9746 000075D6 8CD2                <1> 	mov	dx,ss
  9747 000075D8 8EDA                <1> 	mov	ds,dx
  9748 000075DA 5E                  <1> 	pop	si
  9749 000075DB B000                <1> 	mov	al,0
  9750                              <1> 
  9751                              <1> CGR_09:
  9752 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  9753                              <1> 
  9754                              <1> CGR_10:
  9755 000075E0 56                  <1> 	push	si
  9756 000075E1 57                  <1> 	push	di
  9757 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  9758 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  9759 000075E7 5F                  <1> 	pop	di
  9760 000075E8 5E                  <1> 	pop	si
  9761 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  9762 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  9763 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  9764 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  9765 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  9766                              <1> 
  9767 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  9768 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  9769 000075F7 31DB                <1> 	xor	bx,bx
  9770 000075F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  9771 000075FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  9772 000075FF 8CC3                <1> 	mov	bx,es
  9773 00007601 09FB                <1> 	or	bx,di
  9774 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  9775 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  9776                              <1> 
  9777                              <1> CGR_11:
  9778 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  9779 0000760A 1F                  <1> 	pop	ds
  9780 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  9781 0000760E C3                  <1> 	ret
  9782                              <1> 
  9783                              <1> ;=========================================================================
  9784                              <1> ; int_10_fn0B - Set background color or palette
  9785                              <1> ; Input:
  9786                              <1> ; 	AH - 0Bh
  9787                              <1> ;	BH = 00h - set background / border color
  9788                              <1> ;		BL - background (graphics modes) or border (text modes)
  9789                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  9790                              <1> ;		BL - palette ID:
  9791                              <1> ;			00h - background, green, red, and yellow (brown)
  9792                              <1> ;			01h - background, cyan, magenta, and white
  9793                              <1> ; Output:
  9794                              <1> ;	none
  9795                              <1> ;-------------------------------------------------------------------------
  9796                              <1> int_10_fn0B:
  9797 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  9798 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  9799 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  9800 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  9801                              <1> 
  9802 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  9803 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  9804 00007620 08E0                <1> 	or	al,ah			; apply new color
  9805 00007622 EB09                <1> 	jmp	.write_palet_reg
  9806                              <1> 
  9807                              <1> .set_palette:
  9808 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  9809 00007626 F6C401              <1> 	test	ah,01h
  9810 00007629 7402                <1> 	jz	.write_palet_reg
  9811 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  9812                              <1> 
  9813                              <1> .write_palet_reg:
  9814 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  9815 00007630 8B166300            <1> 	mov	dx,word [video_port]
  9816 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  9817 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  9818 00007638 C3                  <1> 	ret
  9819                              <1> 
  9820                              <1> ;=========================================================================
  9821                              <1> ; int_10_fn0C - Write graphics pixel
  9822                              <1> ; Input:
  9823                              <1> ;	AH = 0Ch
  9824                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  9825                              <1> ;	CX = column
  9826                              <1> ;	DX = row
  9827                              <1> ; Output:
  9828                              <1> ;	none
  9829                              <1> ;-------------------------------------------------------------------------
  9830                              <1> int_10_fn0C:
  9831 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  9832 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9833 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9834 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  9835 00007643 2401                <1> 	and	al,1			; one bit per pixel
  9836 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9837 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  9838 00007649 EB0F                <1> 	jmp	.prepare_mask
  9839                              <1> 
  9840                              <1> .mode_320x200:
  9841 0000764B D0E1                <1> 	shl	cl,1
  9842 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9843 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  9844 00007652 2403                <1> 	and	al,3			; two bit per pixel
  9845 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9846 00007656 D0C8                <1> 	ror	al,1
  9847 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  9848                              <1> 
  9849                              <1> .prepare_mask:
  9850 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  9851 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  9852 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  9853 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  9854 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  9855 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  9856 00007667 EB04                <1> 	jmp	.write_pixel
  9857                              <1> 
  9858                              <1> .set_color:
  9859 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  9860 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  9861                              <1> 
  9862                              <1> .write_pixel:
  9863 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  9864 00007670 C3                  <1> 	ret
  9865                              <1> 
  9866                              <1> ;=========================================================================
  9867                              <1> ; int_10_fn0D - Read graphics pixel
  9868                              <1> ; Input:
  9869                              <1> ;	AH = 0Dh
  9870                              <1> ;	CX = column
  9871                              <1> ;	DX = row
  9872                              <1> ; Output:
  9873                              <1> ;	AL = pixel color 
  9874                              <1> ;-------------------------------------------------------------------------
  9875                              <1> int_10_fn0D:
  9876 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  9877 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  9878 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9879 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  9880 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  9881 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  9882 0000767F EB0A                <1> 	jmp	.exit
  9883                              <1> 
  9884                              <1> .mode_320x200:
  9885 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  9886 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  9887 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  9888 00007687 D0C0                <1> 	rol	al,1
  9889 00007689 2403                <1> 	and	al,3			; two bits per pixel
  9890                              <1> 
  9891                              <1> .exit:
  9892 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  9893 0000768E C3                  <1> 	ret
  9894                              <1> 
  9895                              <1> ;=========================================================================
  9896                              <1> ; int_10_fn0E - Teletype output
  9897                              <1> ; Input:
  9898                              <1> ;	AH = 0Eh
  9899                              <1> ;	AL = character to write
  9900                              <1> ;	BL = foreground color (graphics modes only)
  9901                              <1> ; Output:
  9902                              <1> ;	none
  9903                              <1> ; Notes:
  9904                              <1> ;	- writes character to the active video page
  9905                              <1> ;	- support following control characters: BEL, BS, LF, CR
  9906                              <1> ;-------------------------------------------------------------------------
  9907                              <1> int_10_fn0E:
  9908 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9909 00007693 B700                <1> 	mov	bh,0
  9910 00007695 D0E3                <1> 	shl	bl,1			; word index
  9911 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  9912                              <1> 
  9913 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  9914 0000769D 3C08                <1> 	cmp	al,bs
  9915 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  9916 000076A1 3C0A                <1> 	cmp	al,lf
  9917 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  9918 000076A5 3C07                <1> 	cmp	al,bel
  9919 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  9920 000076A9 3C0D                <1> 	cmp	al,cr
  9921 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  9922 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  9923 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  9924 000076B2 B90100              <1> 	mov	cx,1			; one character
  9925 000076B5 CD10                <1> 	int	10h			; write character
  9926 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  9927 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  9928 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  9929 000076BF B200                <1> 	mov	dl,0			; move to the first position
  9930                              <1> 
  9931                              <1> .lf:
  9932 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  9933 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  9934 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  9935 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  9936                              <1> 
  9937                              <1> .bs:
  9938 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  9939 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  9940 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
  9941 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  9942                              <1> 
  9943                              <1> .cr:
  9944 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  9945                              <1> 
  9946                              <1> .set_cursor_pos:
  9947 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9948 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  9949                              <1> 
  9950                              <1> .bel:
  9951 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
  9952 000076DE E859AC              <1> 	call	beep
  9953 000076E1 C3                  <1> 	ret
  9954                              <1> 
  9955                              <1> .scroll:
  9956 000076E2 B402                <1> 	mov	ah,02h
  9957 000076E4 CD10                <1> 	int	10h			; set new cursor position
  9958 000076E6 E82E00              <1> 	call	vid_check_mode
  9959 000076E9 B700                <1> 	mov	bh,0
  9960 000076EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
  9961 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  9962 000076EF CD10                <1> 	int	10h			; read attirbute at current position
  9963 000076F1 88E7                <1> 	mov	bh,ah
  9964                              <1> 
  9965                              <1> .do_scroll:
  9966 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  9967 000076F5 B001                <1> 	mov	al,1			; scroll one line
  9968 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  9969 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
  9970 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  9971 000076FF FECA                <1> 	dec	dl
  9972 00007701 CD10                <1> 	int	10h			; scroll page up
  9973 00007703 C3                  <1> 	ret
  9974                              <1> 
  9975                              <1> ;=========================================================================
  9976                              <1> ; int_10_fn0F - Get current video mode
  9977                              <1> ; Input:
  9978                              <1> ;	AH = 0Fh
  9979                              <1> ; Output:
  9980                              <1> ;	AL = video mode
  9981                              <1> ;	AH = characters per column
  9982                              <1> ;	BH = active video page
  9983                              <1> ;-------------------------------------------------------------------------
  9984                              <1> int_10_fn0F:
  9985 00007704 A04A00              <1> 	mov	al,byte [video_columns]
  9986 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
  9987 0000770A A04900              <1> 	mov	al,byte [video_mode]
  9988 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
  9989 00007710 A06200              <1> 	mov	al,byte [video_page]
  9990 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
  9991 00007716 C3                  <1> 	ret
  9992                              <1> 
  9993                              <1> ;=========================================================================
  9994                              <1> ; vid_check_mode - Check current video mode
  9995                              <1> ; Input:
  9996                              <1> ;	none
  9997                              <1> ; Output:
  9998                              <1> ;	ZF set if monochrome mode (mode 07h)
  9999                              <1> ;	CF set if graphics modes (modes 04h - 06h)
 10000                              <1> ;-------------------------------------------------------------------------
 10001                              <1> vid_check_mode:
 10002 00007717 50                  <1> 	push	ax
 10003 00007718 A04900              <1> 	mov	al,byte [video_mode]
 10004 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
 10005 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
 10006 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
 10007 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
 10008 00007722 7303                <1> 	jnb	.exit			; jump if not graphics
 10009 00007724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
 10010 00007726 F9                  <1> 	stc				; XXX
 10011                              <1> 
 10012                              <1> .exit:
 10013 00007727 58                  <1> 	pop	ax
 10014 00007728 C3                  <1> 	ret
 10015                              <1> 
 10016                              <1> ;=========================================================================
 10017                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10018                              <1> ; Input:
 10019                              <1> ;	AH = register number
 10020                              <1> ;	CX = word to write
 10021                              <1> ; Output:
 10022                              <1> ;	AX trashed
 10023                              <1> ; Note:
 10024                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
 10025                              <1> ;-------------------------------------------------------------------------
 10026                              <1> vid_crtc_writew:
 10027 00007729 88E8                <1> 	mov	al,ch
 10028 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
 10029 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
 10030 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
 10031                              <1> 
 10032                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
 10033                              <1> 
 10034                              <1> ;=========================================================================
 10035                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10036                              <1> ; Input:
 10037                              <1> ;	AH = register number
 10038                              <1> ;	AL = byte to write
 10039                              <1> ; Output:
 10040                              <1> ;	none
 10041                              <1> ;-------------------------------------------------------------------------
 10042                              <1> vid_crtc_writeb:
 10043 00007732 52                  <1> 	push	dx
 10044 00007733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
 10045 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
 10046 00007739 EE                  <1> 	out	dx,al			; write register number
 10047 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
 10048 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
 10049 0000773E EE                  <1> 	out	dx,al			; write byte
 10050 0000773F 5A                  <1> 	pop	dx
 10051 00007740 C3                  <1> 	ret
 10052                              <1> 
 10053                              <1> ;=========================================================================
 10054                              <1> ; vid_pixel_address - calculate pixel address and mask
 10055                              <1> ; Input:
 10056                              <1> ;	CX - column
 10057                              <1> ;	DX - row
 10058                              <1> ; Output:
 10059                              <1> ;	SI - pixel address
 10060                              <1> ;	CH - pixel mask
 10061                              <1> ;	CL - pixel position in the byte
 10062                              <1> ;	ZF - mode
 10063                              <1> ;		0 = 320x200
 10064                              <1> ;		1 = 640x200
 10065                              <1> ;-------------------------------------------------------------------------
 10066                              <1> vid_pixel_address:
 10067 00007741 31F6                <1> 	xor	si,si			; SI = 0
 10068 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
 10069 00007745 7303                <1> 	jnb	.even			; jump if on even row 
 10070 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
 10071                              <1> 
 10072                              <1> .even:
 10073 0000774A B050                <1> 	mov	al,50h			; bytes in each row
 10074 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
 10075                              <1> 
 10076 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
 10077 00007750 89CA                <1> 	mov	dx,cx			; DX - column
 10078 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
 10079 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
 10080 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
 10081 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
 10082 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
 10083                              <1> 
 10084                              <1> .1:
 10085 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
 10086 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
 10087 00007764 01D6                <1> 	add	si,dx			; add column address to SI
 10088 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
 10089 00007768 9D                  <1> 	popf
 10090 00007769 C3                  <1> 	ret
 10091                              <1> 
 10092                              <1> ;=========================================================================
 10093                              <1> ; vid_current_offset - convert current cursor position to offset
 10094                              <1> ;		       relative to page starting address
 10095                              <1> ; Input:
 10096                              <1> ;	BL = page
 10097                              <1> ; Output:
 10098                              <1> ;	AX = offset
 10099                              <1> ;-------------------------------------------------------------------------
 10100                              <1> vid_current_offset:
 10101 0000776A B700                <1> 	mov	bh,0
 10102 0000776C D1E3                <1> 	shl	bx,1				; word index
 10103 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
 10104                              <1> 
 10105                              <1> ; fall through to vid_position_to_offset
 10106                              <1> 
 10107                              <1> ;=========================================================================
 10108                              <1> ; vid_position_to_offset - convert position (row and column) to offset
 10109                              <1> ;			   relative to page starting address
 10110                              <1> ; Input:
 10111                              <1> ;	AH = row
 10112                              <1> ;	AL = column
 10113                              <1> ; Output:
 10114                              <1> ;	AX = offset
 10115                              <1> ;-------------------------------------------------------------------------
 10116                              <1> vid_position_to_offset:
 10117 00007771 53                  <1> 	push	bx
 10118 00007772 88C3                <1> 	mov	bl,al			; BL = column
 10119 00007774 88E0                <1> 	mov	al,ah			; AL = row
 10120 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10121 0000777A B700                <1> 	mov	bh,0			;
 10122 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
 10123 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
 10124 00007780 5B                  <1> 	pop	bx
 10125 00007781 C3                  <1> 	ret
 10126                              <1> 
 10127                              <1> ;=========================================================================
 10128                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
 10129                              <1> ; Input:
 10130                              <1> ;	AH = row
 10131                              <1> ;	AL = column
 10132                              <1> ; Output:
 10133                              <1> ;	AX = offset
 10134                              <1> ;-------------------------------------------------------------------------
 10135                              <1> vid_gfx_pos_to_offset:
 10136 00007782 53                  <1> 	push	bx
 10137 00007783 88C3                <1> 	mov	bl,al			; BL = column
 10138 00007785 88E0                <1> 	mov	al,ah			; AL = row
 10139 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10140 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
 10141 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
 10142 0000778F B700                <1> 	mov	bh,0
 10143 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
 10144 00007793 5B                  <1> 	pop	bx
 10145 00007794 C3                  <1> 	ret
 10146                                  
 10147                                  ;=========================================================================
 10148                                  ; int_12 - Get memory size
 10149                                  ; Input:
 10150                                  ;	none
 10151                                  ; Output:
 10152                                  ;	AX = memory size
 10153                                  ;-------------------------------------------------------------------------
 10154 00007795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
 10155          ******************       warning: (setloc:7) Inserting 172 bytes
 10156                                  int_12:
 10157 00007841 FB                      	sti
 10158 00007842 1E                      	push	ds
 10159 00007843 B84000                  	mov	ax,biosdseg
 10160 00007846 8ED8                    	mov	ds,ax
 10161 00007848 A11300                  	mov	ax,word [memory_size]
 10162 0000784B 1F                      	pop	ds
 10163 0000784C CF                      	iret
 10164                                  
 10165                                  ;=========================================================================
 10166                                  ; int_11 - Get equipment list
 10167                                  ; Input:
 10168                                  ;	none
 10169                                  ; Output:
 10170                                  ;	AX = equipment list
 10171                                  ;-------------------------------------------------------------------------
 10172                                  	setloc	0F84Dh			; INT 11 Entry Point
 10173                                  int_11:
 10174 0000784D FB                      	sti
 10175 0000784E 1E                      	push	ds
 10176 0000784F B84000                  	mov	ax,biosdseg
 10177 00007852 8ED8                    	mov	ds,ax
 10178 00007854 A11000                  	mov	ax,word [equipment_list]
 10179 00007857 1F                      	pop	ds
 10180 00007858 CF                      	iret
 10181                                  
 10182                                  ;=========================================================================
 10183                                  ; Includes with fixed entry points (for IBM compatibility)
 10184                                  ;-------------------------------------------------------------------------
 10185                                  
 10186                                  %include	"misc.inc"
 10187                              <1> ;=========================================================================
 10188                              <1> ; misc.inc - Miscellaneous BIOS Services
 10189                              <1> ;       INT 15h, functions:
 10190                              <1> ;       	4Fh	- OS hook keyboard intercept
 10191                              <1> ;		90h	- Device busy loop
 10192                              <1> ;		91h	- Interrupt completed
 10193                              <1> ;		0C0h	- Get system configruation
 10194                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
 10195                              <1> ;		
 10196                              <1> ;-------------------------------------------------------------------------
 10197                              <1> ;
 10198                              <1> ; Compiles with NASM 2.07, might work with other versions
 10199                              <1> ;
 10200                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10201                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10202                              <1> ;
 10203                              <1> ; This program is free software: you can redistribute it and/or modify
 10204                              <1> ; it under the terms of the GNU General Public License as published by
 10205                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10206                              <1> ; (at your option) any later version.
 10207                              <1> ;
 10208                              <1> ; This program is distributed in the hope that it will be useful,
 10209                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10210                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10211                              <1> ; GNU General Public License for more details.
 10212                              <1> ;
 10213                              <1> ; You should have received a copy of the GNU General Public License
 10214                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10215                              <1> ;
 10216                              <1> ;=========================================================================
 10217                              <1> 
 10218                              <1> ;-------------------------------------------------------------------------
 10219                              <1> ; offsets for registers on stack
 10220                              <1> int_15_bp	equ	0
 10221                              <1> int_15_ip	equ	int_15_bp+2
 10222                              <1> int_15_cs	equ	int_15_ip+2
 10223                              <1> int_15_flags	equ	int_15_cs+2
 10224                              <1> 
 10225                              <1> ;=========================================================================
 10226                              <1> ; int_15 - Miscellaneous BIOS services
 10227                              <1> ; Input:
 10228                              <1> ;	AH = 4Fh - OS hook keyboard intercept
 10229                              <1> ;		- Does nothing
 10230                              <1> ;	AH = 0C2h - PS/2 mouse services
 10231                              <1> ;		- Implemented in ps2aux.inc
 10232                              <1> ;-------------------------------------------------------------------------
 10233                              <1> 	setloc	0F859h			; INT 15 Entry Point
 10234                              <1> int_15:
 10235 00007859 FB                  <1> 	sti
 10236 0000785A 80FC4F              <1> 	cmp	ah,4Fh
 10237 0000785D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
 10238 0000785F 80FCC0              <1> 	cmp	ah,0C0h
 10239 00007862 742E                <1> 	je	int_15_fnC0
 10240 00007864 3D0190              <1> 	cmp	ax,9001h
 10241 00007867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
 10242 00007869 3DFD90              <1> 	cmp	ax,90FDh
 10243 0000786C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
 10244 0000786E 3D0191              <1> 	cmp	ax,9101h
 10245 00007871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
 10246                              <1> 
 10247                              <1> %ifdef PS2_MOUSE
 10248 00007873 80FCC2              <1> 	cmp	ah,0C2h
 10249 00007876 7503                <1> 	jne	.1
 10250 00007878 E942A8              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
 10251                              <1> .1:
 10252                              <1> %endif
 10253                              <1> 
 10254 0000787B B486                <1> 	mov	ah,86h			; no cassete present
 10255                              <1> 
 10256                              <1> int_15_err:
 10257 0000787D 55                  <1> 	push	bp
 10258 0000787E 89E5                <1> 	mov	bp,sp
 10259 00007880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
 10260 00007884 5D                  <1> 	pop	bp
 10261 00007885 CF                  <1> 	iret
 10262                              <1> 
 10263                              <1> int_15_ok:
 10264 00007886 55                  <1> 	push	bp
 10265 00007887 89E5                <1> 	mov	bp,sp
 10266 00007889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
 10267 0000788D 5D                  <1> 	pop	bp
 10268 0000788E CF                  <1> 	iret
 10269                              <1> 
 10270                              <1> int_15_os_hook:
 10271 0000788F B400                <1> 	mov	ah,00h
 10272                              <1> 
 10273                              <1> int_15_exit:
 10274 00007891 CF                  <1> 	iret
 10275                              <1> 
 10276                              <1> ;=========================================================================
 10277                              <1> ; int_15_fnC0 - Get configuration
 10278                              <1> ; Input:
 10279                              <1> ;	AH = 0C0h - get configuration
 10280                              <1> ; Output:
 10281                              <1> ;	AH = 00h - function supported
 10282                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
 10283                              <1> ;	CF = 0 (success)
 10284                              <1> ;-------------------------------------------------------------------------
 10285                              <1> int_15_fnC0:
 10286 00007892 B400                <1> 	mov	ah,00h
 10287 00007894 BB00F0              <1> 	mov	bx,bioscseg
 10288 00007897 8EC3                <1> 	mov	es,bx
 10289 00007899 BB[F566]            <1> 	mov	bx,config_table
 10290 0000789C EBE8                <1> 	jmp	int_15_ok
 10291                                  %include	"fnt00-7F.inc"
 10292                              <1> ;=========================================================================
 10293                              <1> ; fnt00-7F.inc - Font for graphics modes
 10294                              <1> ;       Characters from 00h to 7Fh
 10295                              <1> ;-------------------------------------------------------------------------
 10296                              <1> ;
 10297                              <1> ; Compiles with NASM 2.07, might work with other versions
 10298                              <1> ;
 10299                              <1> ; This font is borrowed from kbd package (alt-8x8)
 10300                              <1> ;
 10301                              <1> ; This program is free software: you can redistribute it and/or modify
 10302                              <1> ; it under the terms of the GNU General Public License as published by
 10303                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10304                              <1> ; (at your option) any later version.
 10305                              <1> ;
 10306                              <1> ; This program is distributed in the hope that it will be useful,
 10307                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10308                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10309                              <1> ; GNU General Public License for more details.
 10310                              <1> ;
 10311                              <1> ; You should have received a copy of the GNU General Public License
 10312                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10313                              <1> ;
 10314                              <1> ;=========================================================================
 10315 0000789E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
 10316          ******************  <1>  warning: (setloc:7) Inserting 464 bytes
 10317                              <1> gfx_font:
 10318 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
 10319 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
 10320 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
 10321 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
 10322 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
 10323 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
 10324 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
 10325 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
 10326 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
 10327 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
 10328 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
 10329 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
 10330 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
 10331 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
 10332 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
 10333 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
 10334 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
 10335 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
 10336 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
 10337 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
 10338 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
 10339 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
 10340 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
 10341 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
 10342 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
 10343 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
 10344 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
 10345 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
 10346 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
 10347 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
 10348 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
 10349 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
 10350 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
 10351 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
 10352 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
 10353 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
 10354 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
 10355 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
 10356 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
 10357 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
 10358 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
 10359 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
 10360 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
 10361 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
 10362 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
 10363 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
 10364 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
 10365 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
 10366 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
 10367 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
 10368 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
 10369 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
 10370 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
 10371 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
 10372 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
 10373 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
 10374 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
 10375 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
 10376 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
 10377 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
 10378 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
 10379 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
 10380 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
 10381 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
 10382 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
 10383 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
 10384 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
 10385 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
 10386 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
 10387 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
 10388 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
 10389 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
 10390 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
 10391 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10392 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
 10393 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
 10394 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
 10395 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
 10396 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
 10397 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
 10398 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
 10399 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
 10400 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
 10401 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
 10402 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
 10403 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
 10404 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10405 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
 10406 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
 10407 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
 10408 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
 10409 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
 10410 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
 10411 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
 10412 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
 10413 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
 10414 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
 10415 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
 10416 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
 10417 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
 10418 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
 10419 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
 10420 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
 10421 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10422 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
 10423 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
 10424 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
 10425 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
 10426 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10427 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
 10428 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
 10429 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
 10430 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
 10431 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
 10432 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
 10433 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
 10434 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
 10435 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
 10436 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10437 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
 10438 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
 10439 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10440 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
 10441 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
 10442 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
 10443 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
 10444 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
 10445 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
 10446                                  %include	"time2.inc"
 10447                              <1> ;=========================================================================
 10448                              <1> ; time2.int - BIOS Time Services
 10449                              <1> ;       INT 1Ah - BIOS Time Serivces
 10450                              <1> ;		dispatcher
 10451                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
 10452                              <1> ;-------------------------------------------------------------------------
 10453                              <1> ;
 10454                              <1> ; Compiles with NASM 2.07, might work with other versions
 10455                              <1> ;
 10456                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10457                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10458                              <1> ;
 10459                              <1> ; This program is free software: you can redistribute it and/or modify
 10460                              <1> ; it under the terms of the GNU General Public License as published by
 10461                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10462                              <1> ; (at your option) any later version.
 10463                              <1> ;
 10464                              <1> ; This program is distributed in the hope that it will be useful,
 10465                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10466                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10467                              <1> ; GNU General Public License for more details.
 10468                              <1> ;
 10469                              <1> ; You should have received a copy of the GNU General Public License
 10470                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10471                              <1> ;
 10472                              <1> ;=========================================================================
 10473                              <1> 
 10474                              <1> ;=========================================================================
 10475                              <1> ; int_1A - BIOS Time Services
 10476                              <1> ; Note: see time1.inc for functions implementation
 10477                              <1> ;-------------------------------------------------------------------------
 10478                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
 10479                              <1> int_1A:
 10480 00007E6E 53                  <1> 	push	bx
 10481 00007E6F 1E                  <1> 	push	ds
 10482 00007E70 BB4000              <1> 	mov	bx,biosdseg
 10483 00007E73 8EDB                <1> 	mov	ds,bx
 10484 00007E75 80FC08              <1> 	cmp	ah,.max/2
 10485 00007E78 731B                <1> 	jae	int_1A_exit
 10486 00007E7A B700                <1> 	mov	bh,0
 10487 00007E7C 88E3                <1> 	mov	bl,ah
 10488 00007E7E D1E3                <1> 	shl	bx,1
 10489 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
 10490                              <1> .dispatch:
 10491 00007E85 [3A0F]              <1> 	dw	int_1A_fn00
 10492 00007E87 [4C0F]              <1> 	dw	int_1A_fn01
 10493 00007E89 [5C0F]              <1> 	dw	int_1A_fn02
 10494 00007E8B [8E0F]              <1> 	dw	int_1A_fn03
 10495 00007E8D [D30F]              <1> 	dw	int_1A_fn04
 10496 00007E8F [0310]              <1> 	dw	int_1A_fn05
 10497 00007E91 [4210]              <1> 	dw	int_1A_fn06
 10498 00007E93 [9310]              <1> 	dw	int_1A_fn07
 10499                              <1> .max	equ	$-.dispatch
 10500                              <1> int_1A_exit:
 10501 00007E95 1F                  <1> 	pop	ds
 10502 00007E96 5B                  <1> 	pop	bx
 10503 00007E97 CF                  <1> 	iret
 10504                              <1> int_1A_exitf:
 10505 00007E98 1F                  <1> 	pop	ds
 10506 00007E99 5B                  <1> 	pop	bx
 10507 00007E9A CA0200              <1> 	retf	2
 10508                              <1> 
 10509                              <1> ;=========================================================================
 10510                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
 10511                              <1> ;-------------------------------------------------------------------------
 10512 00007E9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
 10513          ******************  <1>  warning: (setloc:7) Inserting 8 bytes
 10514                              <1> int_08:
 10515 00007EA5 50                  <1> 	push	ax
 10516 00007EA6 1E                  <1> 	push	ds
 10517 00007EA7 B84000              <1> 	mov	ax,biosdseg
 10518 00007EAA 8ED8                <1> 	mov	ds,ax
 10519 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
 10520 00007EB1 7413                <1> 	jz	.1
 10521 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
 10522 00007EB7 750D                <1> 	jnz	.1
 10523 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
 10524 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
 10525 00007EC0 52                  <1> 	push	dx
 10526 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
 10527 00007EC4 EE                  <1> 	out	dx,al
 10528 00007EC5 5A                  <1> 	pop	dx
 10529                              <1> .1:
 10530 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
 10531 00007ECA 7504                <1> 	jnz	.2
 10532 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
 10533                              <1> .2:
 10534 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
 10535 00007ED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
 10536 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
 10537 00007EDD 7512                <1> 	jnz	.3
 10538 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
 10539 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
 10540 00007EEB C70670000100        <1> 	mov	word [new_day],1
 10541                              <1> .3:
 10542 00007EF1 CD1C                <1> 	int	1Ch			; User timer interrupt
 10543 00007EF3 B020                <1> 	mov	al,20h
 10544 00007EF5 E620                <1> 	out	pic1_reg0,al
 10545 00007EF7 1F                  <1> 	pop	ds
 10546 00007EF8 58                  <1> 	pop	ax
 10547 00007EF9 CF                  <1> 	iret
 10548                                  
 10549                                  ;=========================================================================
 10550                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
 10551                                  ;-------------------------------------------------------------------------
 10552 00007EFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
 10553          ******************       warning: (setloc:7) Inserting 41 bytes
 10554                                  int_ignore:
 10555 00007F23 50                      	push	ax
 10556 00007F24 1E                      	push	ds
 10557 00007F25 B84000                  	mov	ax,biosdseg
 10558 00007F28 8ED8                    	mov	ds,ax
 10559 00007F2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
 10560 00007F2C E620                    	out	pic1_reg0,al
 10561 00007F2E 90                      	nop
 10562 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
 10563 00007F31 88C4                    	mov	ah,al
 10564 00007F33 08C0                    	or	al,al
 10565 00007F35 7504                    	jnz	.1
 10566 00007F37 B4FF                    	mov	ah,0FFh
 10567 00007F39 EB0A                    	jmp	.2
 10568                                  .1:
 10569 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
 10570 00007F3D 08E0                    	or	al,ah
 10571 00007F3F E621                    	out	pic1_reg1,al
 10572 00007F41 B020                    	mov	al,20h			; end of interrupt
 10573 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
 10574                                  .2:
 10575 00007F45 88266B00                	mov	byte [last_irq],ah
 10576 00007F49 1F                      	pop	ds
 10577 00007F4A 58                      	pop	ax
 10578 00007F4B CF                      	iret
 10579                                  
 10580                                  ;=========================================================================
 10581                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
 10582                                  ;-------------------------------------------------------------------------
 10583 00007F4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
 10584          ******************       warning: (setloc:7) Inserting 7 bytes
 10585                                  int_dummy:
 10586 00007F53 CF                      	iret
 10587                                  
 10588                                  ;=========================================================================
 10589                                  ; int_05 - BIOS Print Screen
 10590                                  ;-------------------------------------------------------------------------
 10591                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
 10592                                  int_05:
 10593 00007F54 FB                      	sti
 10594 00007F55 50                      	push	ax
 10595 00007F56 53                      	push	bx
 10596 00007F57 51                      	push	cx
 10597 00007F58 52                      	push	dx
 10598 00007F59 1E                      	push	ds
 10599 00007F5A B84000                  	mov	ax,biosdseg
 10600 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
 10601 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
 10602 00007F64 746A                    	je	.exit			; print screen is already in progress
 10603 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
 10604                                  					; signal that print screen is running
 10605                                  
 10606 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
 10607 00007F6D CD10                    	int	10h			; returns number of columns in AH
 10608                                  					; and active display page in BH
 10609 00007F6F 88E1                    	mov	cl,ah			; store number columns
 10610                                  
 10611 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
 10612 00007F75 08ED                    	or	ch,ch
 10613 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
 10614                                  
 10615 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
 10616 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
 10617 00007F7E 7602                    	jbe	.get_cursor_pos
 10618                                  
 10619                                  .wrong_num_rows:
 10620 00007F80 B519                    	mov	ch,25			; assume 25 rows
 10621                                  
 10622                                  .get_cursor_pos:
 10623 00007F82 B403                    	mov	ah,03h			; get cursor position and size
 10624 00007F84 CD10                    	int	10h			; returns cursor position in DX
 10625 00007F86 52                      	push	dx			; save original position / DX in stack
 10626                                  
 10627                                  	
 10628 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
 10629 00007F89 E85100                  	call	.print_char
 10630 00007F8C 7548                    	jnz	.error
 10631 00007F8E B40A                    	mov	ah,0Ah
 10632 00007F90 E84A00                  	call	.print_char
 10633 00007F93 7541                    	jnz	.error
 10634                                  
 10635 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
 10636                                  
 10637                                  .row_loop:
 10638 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
 10639                                  
 10640                                  .column_loop:
 10641 00007F99 B402                    	mov	ah,02h
 10642 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
 10643                                  
 10644 00007F9D B408                    	mov	ah,08h
 10645 00007F9F CD10                    	int	10h			; read character at cursor position
 10646                                  
 10647 00007FA1 3C20                    	cmp	al,20h			; control character?
 10648 00007FA3 7302                    	jae	.continue		; no, print it
 10649 00007FA5 B020                    	mov	al,20h			; print space instead
 10650                                  
 10651                                  .continue:
 10652 00007FA7 E83300                  	call	.print_char
 10653 00007FAA 752A                    	jnz	.error
 10654 00007FAC FEC2                    	inc	dl
 10655 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
 10656 00007FB0 72E7                    	jb	.column_loop		; print next column
 10657                                  
 10658 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
 10659 00007FB4 E82600                  	call	.print_char
 10660 00007FB7 751D                    	jnz	.error
 10661 00007FB9 B40A                    	mov	ah,0Ah
 10662 00007FBB E81F00                  	call	.print_char
 10663 00007FBE 7516                    	jnz	.error
 10664                                  
 10665 00007FC0 FEC6                    	inc	dh
 10666 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
 10667 00007FC4 72D1                    	jb	.row_loop		; print next row
 10668                                  
 10669 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
 10670                                  					; ready for the next call
 10671                                  
 10672                                  .restore_cursor:
 10673 00007FCB 5A                      	pop	dx			; DX = original cursor position
 10674 00007FCC B402                    	mov	ah,02h
 10675 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
 10676                                  
 10677                                  .exit:
 10678 00007FD0 1F                      	pop	ds
 10679 00007FD1 5A                      	pop	dx
 10680 00007FD2 59                      	pop	cx
 10681 00007FD3 5B                      	pop	bx
 10682 00007FD4 58                      	pop	ax
 10683 00007FD5 CF                      	iret
 10684                                  
 10685                                  .error:
 10686 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
 10687                                  					; signal failure
 10688 00007FDB EBEE                    	jmp	.restore_cursor
 10689                                  	
 10690                                  
 10691                                  .print_char:
 10692 00007FDD 52                      	push	dx
 10693 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
 10694 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
 10695 00007FE2 CD17                    	int	17h
 10696 00007FE4 5A                      	pop	dx
 10697 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
 10698 00007FE8 C3                      	ret
 10699                                  
 10700                                  ;=========================================================================
 10701                                  ; start - at power up or reset execution starts here (F000:FFF0)
 10702                                  ;-------------------------------------------------------------------------
 10703 00007FE9 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
 10704          ******************       warning: (setloc:7) Inserting 7 bytes
 10705                                  start:
 10706 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
 10707                                  
 10708                                  	setloc	0FFF5h			; ROM Date in ASCII
 10709 00007FF5 30352F32382F3134        	db	DATE			; BIOS release date MM/DD/YY
 10710 00007FFD 20                      	db	20h
 10711                                  
 10712                                  	setloc	0FFFEh			; System Model
 10713                                  %ifdef AT_COMPAT
 10714 00007FFE FC                      	db	0fch			; system is an IBM AT compatible
 10715                                  %else
 10716                                  	db	0feh			; system is an IBM PC/XT compatible
 10717                                  %endif ; AT_COMPAT
 10718 00007FFF FF                      	db	0ffh
