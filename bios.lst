     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 - 2014 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.07, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
   108                                  %include "config.inc"
   109                              <1> ;=========================================================================
   110                              <1> ; config.inc - Compilation time settings and settings
   111                              <1> ;-------------------------------------------------------------------------
   112                              <1> ;
   113                              <1> ; Compiles with NASM 2.07, might work with other versions
   114                              <1> ;
   115                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   116                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   117                              <1> ;
   118                              <1> ; This program is free software: you can redistribute it and/or modify
   119                              <1> ; it under the terms of the GNU General Public License as published by
   120                              <1> ; the Free Software Foundation, either version 3 of the License, or
   121                              <1> ; (at your option) any later version.
   122                              <1> ;
   123                              <1> ; This program is distributed in the hope that it will be useful,
   124                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   125                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   126                              <1> ; GNU General Public License for more details.
   127                              <1> ;
   128                              <1> ; You should have received a copy of the GNU General Public License
   129                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   130                              <1> ;
   131                              <1> ;=========================================================================
   132                              <1> 
   133                              <1> %define DATE		'08/05/16'	; BIOS release date MM/DD/YY
   134                              <1> %define VERSION		'0.9.1'		; BIOS version
   135                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   136                              <1> 
   137                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
   138                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   139                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   140                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   141                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   142                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   143                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   144                              <1> 					; EBDA is required for PS/2 aux support
   145                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   146                                  %include "errno.inc"
   147                              <1> ;=========================================================================
   148                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> ;
   151                              <1> ; Compiles with NASM 2.07, might work with other versions
   152                              <1> ;
   153                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   154                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   155                              <1> ;
   156                              <1> ; This program is free software: you can redistribute it and/or modify
   157                              <1> ; it under the terms of the GNU General Public License as published by
   158                              <1> ; the Free Software Foundation, either version 3 of the License, or
   159                              <1> ; (at your option) any later version.
   160                              <1> ;
   161                              <1> ; This program is distributed in the hope that it will be useful,
   162                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   163                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   164                              <1> ; GNU General Public License for more details.
   165                              <1> ;
   166                              <1> ; You should have received a copy of the GNU General Public License
   167                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   168                              <1> ;
   169                              <1> ;=========================================================================
   170                              <1> 
   171                              <1> e_boot		equ	00h		; Boot the OS
   172                              <1> e_start		equ	01h		; BIOS POST started
   173                              <1> e_cpu_ok	equ	02h		; CPU test passed
   174                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   175                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   176                              <1> e_int_ok	equ	05h		; interrupt table initialized
   177                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   178                              <1> e_pic_ok	equ	08h		; PIC initialized
   179                              <1> e_kbd_ok	equ	10h		; KBD test passed
   180                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   181                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   182                              <1> e_rtc_init_ok	equ	20h		; RTC initialized
   183                              <1> e_cpu_detect_ok	equ	21h		; CPU type detected
   184                              <1> e_fpu_detect_ok	equ	22h		; FPU type detected
   185                              <1> e_serial_ok	equ	24h		; Serial port scan finished
   186                              <1> e_parallel_ok	equ	25h		; Parallel port scan finished
   187                              <1> e_ram_start	equ	30h		; RAM test start
   188                              <1> e_ram_complete	equ	31h		; RAM test completed
   189                              <1> e_ram_esc	equ	32h		; RAM test canceled
   190                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   191                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found
   192                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   193                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   194                              <1> e_cpu_fail	equ	52h		; CPU test failed
   195                              <1> e_low_ram_fail	equ	54h		; low RAM test failed
   196                              <1> e_kbd_ctrl_fail	equ	60h		; KBD test - controller selftest failed
   197                              <1> e_kbd_key_fail	equ	61h		; KBD test - echo test failed
   198                              <1> e_kbd_timeout	equ	62h		; KBD timeout
   199                              <1> e_kbd_int_fail	equ	63h		; KBD test - interface test failed
   200                              <1> e_ram_fail	equ	80h		; RAM test failed
   201                                  
   202                                  bioscseg	equ	0F000h
   203                                  biosdseg	equ	0040h
   204                                  
   205                                  pic1_reg0	equ	20h
   206                                  pic1_reg1	equ	21h
   207                                  pit_ch0_reg	equ	40h
   208                                  pit_ch1_reg	equ	41h
   209                                  pit_ch2_reg	equ	42h
   210                                  pit_ctl_reg	equ	43h
   211                                  port_b_reg	equ	61h
   212                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   213                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   214                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   215                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   216                                  post_reg	equ	80h	; POST status output port
   217                                  pic2_reg0	equ	0A0h
   218                                  pic2_reg1	equ	0A1h
   219                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   220                                  cga_mode_reg	equ	3D8h
   221                                  mda_mode_reg	equ	3B8h
   222                                  
   223                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   224                                  
   225                                  ;========================================================================
   226                                  ; BIOS data area variables
   227                                  ;------------------------------------------------------------------------
   228                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   229                                  				; or 0 if port doesn't exist
   230                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   231                                  				; or 0 if port doesn't exist
   232                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   233                                  equipment_list	equ	10h	; word - equpment list
   234                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   235                                  equip_fpu	equ	0000000000000010b	; FPU installed
   236                                  equip_mouse	equ	0000000000000100b
   237                                  equip_video	equ	0000000000110000b	; video type bit mask
   238                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   239                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   240                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   241                                  ;			|||||||||||||||`-- floppy drives installed
   242                                  ;			||||||||||||||`-- FPU installed
   243                                  ;			|||||||||||||`-- PS/2 mouse installed
   244                                  ;			||||||||||||`-- reserved
   245                                  ;			||||||||||`--- initial video mode
   246                                  ;			||||||||`---- number of floppy drives - 1
   247                                  ;			|||||||`---- O = DMA installed
   248                                  ;			||||`------ number of serial ports
   249                                  ;			|||`------ game adapter installed
   250                                  ;			||`------ internal modem?!
   251                                  ;			`------- number of parallel ports
   252                                  
   253                                  post_flags	equ	12h	; byte - post flags
   254                                  post_setup	equ	01h	; run NVRAM setup
   255                                  memory_size	equ	13h	; word - memory size in KiB
   256                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   257                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   258                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   259                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   260                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   261                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   262                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   263                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   264                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   265                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   266                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   267                                  video_mode	equ	49h	; byte - active video mode number
   268                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   269                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   270                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   271                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   272                                  video_cur_shape	equ	60h	; word - cursor shape
   273                                  video_page	equ	62h	; byte - active video page
   274                                  video_port	equ	63h	; word - I/O port for the display adapter
   275                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   276                                  video_palet_reg	equ	66h	; byte - color palette
   277                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   278                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   279                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   280                                  new_day		equ	70h	; byte - 1 = new day flag
   281                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   282                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   283                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   284                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   285                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   286                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   287                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   288                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   289                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   290                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   291                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   292                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   293                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   294                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   295                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   296                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   297                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   298                                  
   299                                  ;=========================================================================
   300                                  ; Extended BIOS data area variables
   301                                  ;-------------------------------------------------------------------------
   302                                  ebda_size	equ	0h
   303                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   304                                  mouse_flags_1	equ	26h
   305                                  mouse_flags_2	equ	27h
   306                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   307                                  
   308                                  	org	START		; Use only upper 32 KiB of ROM
   309                                  
   310                                  ;=========================================================================
   311                                  ; Includes
   312                                  ;-------------------------------------------------------------------------
   313                                  %include	"messages.inc"		; POST messages
   314                              <1> ;=========================================================================
   315                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> ;
   318                              <1> ; Compiles with NASM 2.07, might work with other versions
   319                              <1> ;
   320                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   321                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   322                              <1> ;
   323                              <1> ; This program is free software: you can redistribute it and/or modify
   324                              <1> ; it under the terms of the GNU General Public License as published by
   325                              <1> ; the Free Software Foundation, either version 3 of the License, or
   326                              <1> ; (at your option) any later version.
   327                              <1> ;
   328                              <1> ; This program is distributed in the hope that it will be useful,
   329                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   330                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   331                              <1> ; GNU General Public License for more details.
   332                              <1> ;
   333                              <1> ; You should have received a copy of the GNU General Public License
   334                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   335                              <1> ;
   336                              <1> ;=========================================================================
   337                              <1> 
   338 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   339 00000002 586920383038382042- <1> 		db	"Xi 8088 BIOS, Version "
   340 0000000B 494F532C2056657273- <1>
   341 00000014 696F6E20            <1>
   342 00000018 302E392E31          <1> 		db	VERSION
   343 0000001D 2E20                <1> 		db	". "
   344 0000001F 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2014 Sergey Kiselev", 0Dh, 0Ah
   345 00000028 202843292032303130- <1>
   346 00000031 202D20323031342053- <1>
   347 0000003A 6572676579204B6973- <1>
   348 00000043 656C65760D0A        <1>
   349 00000049 446973747269627574- <1> 		db	"Distributed under the terms of "
   350 00000052 656420756E64657220- <1>
   351 0000005B 746865207465726D73- <1>
   352 00000064 206F6620            <1>
   353 00000068 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   354 00000071 656E6572616C205075- <1>
   355 0000007A 626C6963204C696365- <1>
   356 00000083 6E73650D0A          <1>
   357 00000088 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   358 0000008B 6E6F6E6500          <1> msg_none	db	'none', 00h
   359 00000090 3A2000              <1> msg_colon	db	': ', 00h
   360 00000093 3B2000              <1> msg_semicolon	db	'; ', 00h
   361 00000096 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   362 0000009F 6573736F723A202020- <1>
   363 000000A8 202020202020202020- <1>
   364 000000B1 2000                <1>
   365 000000B3 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   366 000000BC 637320436F2D70726F- <1>
   367 000000C5 636573736F723A2020- <1>
   368 000000CE 2000                <1>
   369 000000D0 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 0Dh, 0Ah
   370 000000D9 38202737380D0A      <1>
   371 000000E0 5741524E494E473A20- <1> 		db      'WARNING: This CPU does not disable interrupts '
   372 000000E9 546869732043505520- <1>
   373 000000F2 646F6573206E6F7420- <1>
   374 000000FB 64697361626C652069- <1>
   375 00000104 6E7465727275707473- <1>
   376 0000010D 20                  <1>
   377 0000010E 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   378 00000117 64696E67207365676D- <1>
   379 00000120 656E74207265676973- <1>
   380 00000129 74657273210D0A00    <1>
   381 00000131 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   382 0000013A 3820273831206F7220- <1>
   383 00000143 6C617465722C20      <1>
   384 0000014A 6F72204F4B492D6465- <1> 		db      'or OKI-designed 80C88', 0Dh, 0Ah, 00h
   385 00000153 7369676E6564203830- <1>
   386 0000015C 4338380D0A00        <1>
   387 00000162 4861727269732D6465- <1> msg_cpu_harris  db      'Harris-designed 80C88', 0Dh, 0Ah, 00h
   388 0000016B 7369676E6564203830- <1>
   389 00000174 4338380D0A00        <1>
   390 0000017A 4E4543205632300D0A- <1> msg_cpu_nec_v20 db      'NEC V20', 0Dh, 0Ah, 00h
   391 00000183 00                  <1>
   392 00000184 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   393 0000018D 370D0A00            <1>
   394 00000191 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   395 0000019A 646170746572205479- <1>
   396 000001A3 70653A202020202020- <1>
   397 000001AC 2000                <1>
   398 000001AE 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   399 000001B7 566964656F2042494F- <1>
   400 000001C0 532050726573656E74- <1>
   401 000001C9 290D0A00            <1>
   402 000001CD 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   403 000001D3 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   404 000001DC 7263756C65730D0A00  <1>
   405 000001E5 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock) time: ', 00h
   406 000001EE 2054696D6520436C6F- <1>
   407 000001F7 636B292074696D653A- <1>
   408 00000200 2000                <1>
   409 00000202 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   410 0000020B 736B20647269766573- <1>
   411 00000214 3A2020202020202020- <1>
   412 0000021D 20447269766520303A- <1>
   413 00000226 2000                <1>
   414 00000228 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   415 00000231 3A2000              <1>
   416 00000234 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   417 0000023D 2E32352200          <1>
   418 00000242 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   419 0000024B 2E32352200          <1>
   420 00000250 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   421 00000259 2E352200            <1>
   422 0000025D 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   423 00000266 332E352200          <1>
   424 0000026B 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   425 00000274 332E352200          <1>
   426 00000279 50532F322041757820- <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   427 00000282 44657669636520284D- <1>
   428 0000028B 6F757365293A202020- <1>
   429 00000294 2000                <1>
   430 00000296 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   431 0000029F 00                  <1>
   432 000002A0 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   433 000002A9 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   434 000002B2 7274733A2020202020- <1>
   435 000002BB 202020202020202020- <1>
   436 000002C4 2000                <1>
   437 000002C6 434F4D00            <1> msg_serial_com	db	'COM', 00h
   438 000002CA 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   439 000002D3 506F7274733A202020- <1>
   440 000002DC 202020202020202020- <1>
   441 000002E5 2000                <1>
   442 000002E7 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   443 000002EB 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   444 000002F4 414D20284553432074- <1>
   445 000002FD 6F20736B6970293A20- <1>
   446 00000306 2000                <1>
   447 00000308 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   448 00000311 4661756C7479206D65- <1>
   449 0000031A 6D6F72792064657465- <1>
   450 00000323 637465642061742000  <1>
   451 0000032C 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   452 00000335 6E76656E74696F6E61- <1>
   453 0000033E 6C2052414D3A202020- <1>
   454 00000347 202000              <1>
   455 0000034A 526573657276656420- <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   456 00000353 666F7220454244413A- <1>
   457 0000035C 202020202020202020- <1>
   458 00000365 2000                <1>
   459 00000367 417661696C61626C65- <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   460 00000370 20436F6E76656E7469- <1>
   461 00000379 6F6E616C2052414D3A- <1>
   462 00000382 2000                <1>
   463 00000384 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   464 0000038B 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   465 00000394 65642C207072657373- <1>
   466 0000039D 20616E79206B657920- <1>
   467 000003A6 746F20747279206167- <1>
   468 000003AF 61696E2E2E2E0D0A00  <1>
   469 000003B8 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   470 000003C1 5349430D0A00        <1>
   471 000003C7 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   472 000003D0 5320657874656E7369- <1>
   473 000003D9 6F6E20524F4D206174- <1>
   474 000003E2 2000                <1>
   475 000003E4 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   476 000003ED 6C697A696E672E2E2E- <1>
   477 000003F6 0D0A00              <1>
   478 000003F9 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   479 00000402 532E2E2E0D0A00      <1>
   480 00000409 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   481 00000412 432062617474657279- <1>
   482 0000041B 206973206261640D0A- <1>
   483 00000424 00                  <1>
   484 00000425 4552524F523A204E56- <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   485 0000042E 52414D20636865636B- <1>
   486 00000437 73756D20697320696E- <1>
   487 00000440 76616C69642C20      <1>
   488 00000447 6C6F6164696E672064- <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   489 00000450 656661756C74207661- <1>
   490 00000459 6C75657320746F204E- <1>
   491 00000462 5652414D0D0A00      <1>
   492 00000469 507265737320463120- <1> msg_setup	db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   493 00000472 746F2072756E204E56- <1>
   494 0000047B 52414D207365747570- <1>
   495 00000484 2E2E2E0D0A0D0A00    <1>
   496 0000048C 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the NVRAM setup utility', 00h
   497 00000495 20746F20746865204E- <1>
   498 0000049E 5652414D2073657475- <1>
   499 000004A7 70207574696C697479- <1>
   500 000004B0 00                  <1>
   501 000004B1 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   502 000004B3 4E5652414D20736574- <1> 		db	'NVRAM setup commands:', 0Dh, 0Ah
   503 000004BC 757020636F6D6D616E- <1>
   504 000004C5 64733A0D0A          <1>
   505 000004CA 74202D205365742074- <1> 		db	't - Set time', 0Dh, 0Ah
   506 000004D3 696D650D0A          <1>
   507 000004D8 64202D205365742064- <1> 		db	'd - Set date', 0Dh, 0Ah
   508 000004E1 6174650D0A          <1>
   509 000004E6 66202D204368616E67- <1> 		db	'f - Change first floppy drive type', 0Dh, 0Ah
   510 000004EF 652066697273742066- <1>
   511 000004F8 6C6F70707920647269- <1>
   512 00000501 766520747970650D0A  <1>
   513 0000050A 67202D204368616E67- <1> 		db	'g - Change second floppy drive type', 0Dh, 0Ah
   514 00000513 65207365636F6E6420- <1>
   515 0000051C 666C6F707079206472- <1>
   516 00000525 69766520747970650D- <1>
   517 0000052E 0A                  <1>
   518 0000052F 70202D205072696E74- <1> 		db	'p - Print current settings', 0Dh, 0Ah
   519 00000538 2063757272656E7420- <1>
   520 00000541 73657474696E67730D- <1>
   521 0000054A 0A                  <1>
   522 0000054B 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   523 00000554 6368616E6765732061- <1>
   524 0000055D 6E6420657869740D0A  <1>
   525 00000566 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   526 0000056F 776974686F75742073- <1>
   527 00000578 6176696E6720636861- <1>
   528 00000581 6E6765730D0A        <1>
   529 00000587 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   530 00000590 746869732068656C70- <1>
   531 00000599 0D0A00              <1>
   532 0000059C 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   533 000005A5 6F6D6D616E64202868- <1>
   534 000005AE 20666F722068656C70- <1>
   535 000005B7 293A2000            <1>
   536 000005BB 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   537 000005C4 65202868683A6D6D3A- <1>
   538 000005CD 7373293A2000        <1>
   539 000005D3 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   540 000005DC 652028595959592D4D- <1>
   541 000005E5 4D2D4444293A2000    <1>
   542 000005ED 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   543 000005F6 76616C69642074696D- <1>
   544 000005FF 652E0D0A00          <1>
   545 00000604 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   546 0000060D 76616C696420646174- <1>
   547 00000616 652E0D0A00          <1>
   548 0000061B 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   549 0000061D 466C6F707079206472- <1> 		db	'Floppy drive types:', 0Dh, 0Ah
   550 00000626 697665207479706573- <1>
   551 0000062F 3A0D0A              <1>
   552 00000632 30202D204E6F742069- <1> 		db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   553 0000063B 6E7374616C6C656420- <1>
   554 00000644 202033202D20373230- <1>
   555 0000064D 204B422C20332E3522- <1>
   556 00000656 0D0A                <1>
   557 00000658 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   558 00000661 422C20352E32352220- <1>
   559 0000066A 202034202D20312E34- <1>
   560 00000673 34204D422C20332E35- <1>
   561 0000067C 220D0A              <1>
   562 0000067F 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   563 00000688 422C20352E32352220- <1>
   564 00000691 202036202D20322E38- <1>
   565 0000069A 38204D422C20332E35- <1>
   566 000006A3 220D0A              <1>
   567 000006A6 536574757020636F6D- <1> 		db	'Setup commands:', 0Dh, 0Ah
   568 000006AF 6D616E64733A0D0A    <1>
   569 000006B7 72202D205265747572- <1> 		db	'r - Return to the main menu', 0Dh, 0Ah
   570 000006C0 6E20746F2074686520- <1>
   571 000006C9 6D61696E206D656E75- <1>
   572 000006D2 0D0A                <1>
   573 000006D4 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   574 000006DD 746869732068656C70- <1>
   575 000006E6 0D0A00              <1>
   576 000006E9 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   577 000006F2 6C6F70707920647269- <1>
   578 000006FB 766520747970652028- <1>
   579 00000704 6820666F722068656C- <1>
   580 0000070D 70293A20            <1>
   581 00000711 00                  <1> 		db	00h
   582 00000712 [8B00]              <1> tbl_floppy	dw	msg_none
   583 00000714 [3402]              <1> 		dw	msg_floppy_360
   584 00000716 [4202]              <1> 		dw	msg_floppy_1200
   585 00000718 [5002]              <1> 		dw	msg_floppy_720
   586 0000071A [5D02]              <1> 		dw	msg_floppy_1440
   587 0000071C [8B00]              <1> 		dw	msg_none
   588 0000071E [6B02]              <1> 		dw	msg_floppy_2880
   589 00000720 [8B00]              <1> 		dw	msg_none
   590                                  %include	"fnt80-FF.inc"		; font for graphics modes
   591                              <1> ;=========================================================================
   592                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   593                              <1> ;       Characters from 80h to 0FFh
   594                              <1> ;-------------------------------------------------------------------------
   595                              <1> ;
   596                              <1> ; Compiles with NASM 2.07, might work with other versions
   597                              <1> ;
   598                              <1> ; This font is borrowed from kbd package (alt-8x8)
   599                              <1> ;
   600                              <1> ; This program is free software: you can redistribute it and/or modify
   601                              <1> ; it under the terms of the GNU General Public License as published by
   602                              <1> ; the Free Software Foundation, either version 3 of the License, or
   603                              <1> ; (at your option) any later version.
   604                              <1> ;
   605                              <1> ; This program is distributed in the hope that it will be useful,
   606                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   607                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   608                              <1> ; GNU General Public License for more details.
   609                              <1> ;
   610                              <1> ; You should have received a copy of the GNU General Public License
   611                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   612                              <1> ;
   613                              <1> ;=========================================================================
   614                              <1> int_1F:
   615 00000722 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   616 0000072A 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   617 00000732 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   618 0000073A 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   619 00000742 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   620 0000074A 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   621 00000752 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   622 0000075A 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   623 00000762 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   624 0000076A 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   625 00000772 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   626 0000077A 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   627 00000782 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   628 0000078A 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   629 00000792 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   630 0000079A 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   631 000007A2 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   632 000007AA 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   633 000007B2 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   634 000007BA 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   635 000007C2 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   636 000007CA 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   637 000007D2 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   638 000007DA 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   639 000007E2 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   640 000007EA DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   641 000007F2 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   642 000007FA C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   643 00000802 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   644 0000080A 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   645 00000812 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   646 0000081A 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   647 00000822 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   648 0000082A 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   649 00000832 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   650 0000083A 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   651 00000842 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   652 0000084A 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   653 00000852 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   654 0000085A 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   655 00000862 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   656 0000086A 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   657 00000872 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   658 0000087A 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   659 00000882 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   660 0000088A 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   661 00000892 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   662 0000089A 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   663 000008A2 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   664 000008AA 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   665 000008B2 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   666 000008BA 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   667 000008C2 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   668 000008CA 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   669 000008D2 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   670 000008DA 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   671 000008E2 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   672 000008EA 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   673 000008F2 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   674 000008FA 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   675 00000902 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   676 0000090A 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   677 00000912 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   678 0000091A 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   679 00000922 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   680 0000092A 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   681 00000932 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   682 0000093A 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   683 00000942 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   684 0000094A 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   685 00000952 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   686 0000095A 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   687 00000962 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   688 0000096A 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   689 00000972 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   690 0000097A 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   691 00000982 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   692 0000098A 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   693 00000992 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   694 0000099A 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   695 000009A2 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   696 000009AA 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   697 000009B2 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   698 000009BA 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   699 000009C2 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   700 000009CA 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   701 000009D2 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   702 000009DA 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   703 000009E2 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   704 000009EA 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   705 000009F2 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   706 000009FA FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   707 00000A02 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   708 00000A0A F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   709 00000A12 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   710 00000A1A FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   711 00000A22 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   712 00000A2A 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   713 00000A32 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   714 00000A3A 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   715 00000A42 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   716 00000A4A 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   717 00000A52 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   718 00000A5A 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   719 00000A62 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   720 00000A6A 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   721 00000A72 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   722 00000A7A 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   723 00000A82 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   724 00000A8A 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   725 00000A92 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   726 00000A9A 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   727 00000AA2 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   728 00000AAA 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   729 00000AB2 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   730 00000ABA 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   731 00000AC2 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   732 00000ACA 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   733 00000AD2 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   734 00000ADA 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   735 00000AE2 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   736 00000AEA 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   737 00000AF2 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   738 00000AFA 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   739 00000B02 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   740 00000B0A 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   741 00000B12 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   742 00000B1A 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   743                                  ;%include	"inttrace.inc"		; XXX
   744                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   745                              <1> ;=========================================================================
   746                              <1> ; rtc.inc - RTC/CMOS read and write functions
   747                              <1> ;-------------------------------------------------------------------------
   748                              <1> ;
   749                              <1> ; Compiles with NASM 2.07, might work with other versions
   750                              <1> ;
   751                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   752                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   753                              <1> ;
   754                              <1> ; This program is free software: you can redistribute it and/or modify
   755                              <1> ; it under the terms of the GNU General Public License as published by
   756                              <1> ; the Free Software Foundation, either version 3 of the License, or
   757                              <1> ; (at your option) any later version.
   758                              <1> ;
   759                              <1> ; This program is distributed in the hope that it will be useful,
   760                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   761                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   762                              <1> ; GNU General Public License for more details.
   763                              <1> ;
   764                              <1> ; You should have received a copy of the GNU General Public License
   765                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   766                              <1> ;
   767                              <1> ;=========================================================================
   768                              <1> 
   769                              <1> ;-------------------------------------------------------------------------
   770                              <1> ; RTC ports
   771                              <1> rtc_addr_reg	equ	70h	; RTC address port
   772                              <1> rtc_data_reg	equ	71h	; RTC data port
   773                              <1> 
   774                              <1> ;-------------------------------------------------------------------------
   775                              <1> ; locations in RTC and NVRAM
   776                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   777                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   778                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   779                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   780                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   781                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   782                              <1> cmos_day	equ	06h	; day location in RTC
   783                              <1> cmos_date	equ	07h	; date location in RTC
   784                              <1> cmos_month	equ	08h	; month location in RTC
   785                              <1> cmos_year	equ	09h	; year location in RTC
   786                              <1> cmos_floppy	equ	10h	; floppy type byte
   787                              <1> cmos_equip	equ	14h	; equipment byte
   788                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   789                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   790                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   791                              <1> 
   792                              <1> ;-------------------------------------------------------------------------
   793                              <1> ; RTC control register and their bits
   794                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   795                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   796                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   797                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   798                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   799                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   800                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   801                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   802                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   803                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   804                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   805                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   806                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   807                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   808                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   809                              <1> 
   810                              <1> ;-------------------------------------------------------------------------
   811                              <1> ; NMI flag
   812                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   813                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   814                              <1> 
   815                              <1> ;=========================================================================
   816                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   817                              <1> ; Input:
   818                              <1> ;	AL - address and NMI enable bit
   819                              <1> ;		bits 6-0 - address of byte to read
   820                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   821                              <1> ; Output:
   822                              <1> ;	AL = byte from RTC
   823                              <1> ;-------------------------------------------------------------------------
   824                              <1> rtc_read:
   825 00000B22 FA                  <1> 	cli
   826 00000B23 E670                <1> 	out	rtc_addr_reg,al
   827 00000B25 EB00                <1> 	jmp	$+2
   828 00000B27 EB00                <1> 	jmp	$+2
   829                              <1> 	;; SGEO increased pause here, seems to fix my FF byte issue...
   830 00000B29 EB00                <1> 	jmp	$+2
   831 00000B2B EB00                <1> 	jmp	$+2
   832 00000B2D E471                <1> 	in	al,rtc_data_reg
   833 00000B2F FB                  <1> 	sti
   834 00000B30 C3                  <1> 	ret
   835                              <1> 
   836                              <1> ;=========================================================================
   837                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   838                              <1> ; Input:
   839                              <1> ;	AL - address and NMI enable bit
   840                              <1> ;		bits 6-0 - address of byte to read
   841                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   842                              <1> ;	AH = byte to write to RTC
   843                              <1> ;-------------------------------------------------------------------------
   844                              <1> rtc_write:
   845 00000B31 FA                  <1> 	cli
   846 00000B32 E670                <1> 	out	rtc_addr_reg,al
   847 00000B34 EB00                <1> 	jmp	$+2
   848 00000B36 EB00                <1> 	jmp	$+2
   849 00000B38 86E0                <1> 	xchg	ah,al
   850 00000B3A E671                <1> 	out	rtc_data_reg,al
   851 00000B3C 86E0                <1> 	xchg	ah,al
   852 00000B3E FB                  <1> 	sti
   853 00000B3F C3                  <1> 	ret
   854                              <1> 
   855                              <1> ;=========================================================================
   856                              <1> ; rtc_init - Initialize RTC
   857                              <1> ; Notes:
   858                              <1> ;	- makes sure RTC battery is OK, resets time if not
   859                              <1> ;	- disables RTC interrupts
   860                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   861                              <1> ;-------------------------------------------------------------------------
   862                              <1> rtc_init:
   863 00000B40 50                  <1> 	push	ax
   864 00000B41 53                  <1> 	push	bx
   865 00000B42 51                  <1> 	push	cx
   866 00000B43 52                  <1> 	push	dx
   867 00000B44 56                  <1> 	push	si
   868 00000B45 57                  <1> 	push	di
   869 00000B46 B00A                <1> 	mov	al,cmos_control_a	; select control A register
   870 00000B48 B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   871                              <1> 					; set SQW frequency to 1.024 KHz
   872 00000B4A E8E4FF              <1> 	call	rtc_write		; write control register A
   873                              <1> 
   874 00000B4D B00B                <1> 	mov	al,cmos_control_b
   875 00000B4F B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   876                              <1> 					; interrupts disabled
   877 00000B51 E8DDFF              <1> 	call	rtc_write		; write control register B
   878                              <1> 
   879 00000B54 B00C                <1> 	mov	al,cmos_control_c
   880 00000B56 E8C9FF              <1> 	call	rtc_read		; read control register C - reset
   881                              <1> 					; interrupt flags
   882                              <1> 
   883 00000B59 B00D                <1> 	mov	al,cmos_control_d
   884 00000B5B E8C4FF              <1> 	call	rtc_read		; read control register D
   885 00000B5E A880                <1> 	test	al,cmos_vrt
   886 00000B60 7518                <1> 	jnz	.1			; RTC battery is OK
   887 00000B62 BE[0904]            <1> 	mov	si,msg_rtc_bad
   888 00000B65 E8A41A              <1> 	call	print
   889                              <1> ; RTC is bad, set initial time
   890 00000B68 B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   891 00000B6A 31C9                <1> 	xor	cx,cx
   892 00000B6C 31D2                <1> 	xor	dx,dx
   893 00000B6E CD1A                <1> 	int	1Ah
   894 00000B70 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   895 00000B72 B91020              <1> 	mov	cx,2010h		; year 2010
   896 00000B75 BA0101              <1> 	mov	dx,0101h		; January 1st
   897 00000B78 CD1A                <1> 	int	1Ah
   898                              <1> 
   899                              <1> .1:
   900                              <1> ; set timer variables to RTC time
   901 00000B7A B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   902 00000B7C CD1A                <1> 	int	1Ah
   903                              <1> 
   904                              <1> ; convert time to ticks * 2^11
   905                              <1> 
   906                              <1> ; ticks = seconds * 37287
   907 00000B7E 88F0                <1> 	mov	al,dh
   908 00000B80 E8AE00              <1> 	call	bcd_to_binary		; convert seconds to binary
   909                              <1> 
   910 00000B83 BAA791              <1> 	mov	dx,37287
   911 00000B86 F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   912                              <1> 
   913 00000B88 89C6                <1> 	mov	si,ax
   914 00000B8A 89D7                <1> 	mov	di,dx
   915                              <1> 
   916                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   917 00000B8C 88C8                <1> 	mov	al,cl
   918 00000B8E E8A000              <1> 	call	bcd_to_binary		; convert minutes to binary
   919                              <1> 
   920 00000B91 89C3                <1> 	mov	bx,ax
   921 00000B93 BA2023              <1> 	mov	dx,8992
   922 00000B96 F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   923                              <1> 
   924 00000B98 01C6                <1> 	add	si,ax
   925 00000B9A 11D7                <1> 	adc	di,dx
   926                              <1> 
   927 00000B9C 89D8                <1> 	mov	ax,bx
   928 00000B9E BA2200              <1> 	mov	dx,34
   929 00000BA1 F7E2                <1> 	mul	dx
   930                              <1> 
   931 00000BA3 01C7                <1> 	add	di,ax
   932                              <1> 
   933                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   934 00000BA5 88E8                <1> 	mov	al,ch
   935 00000BA7 E88700              <1> 	call	bcd_to_binary		; convert hours to binary
   936                              <1> 
   937 00000BAA 89C3                <1> 	mov	bx,ax
   938 00000BAC BA6A3B              <1> 	mov	dx,15210
   939 00000BAF F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   940                              <1> 
   941 00000BB1 01C6                <1> 	add	si,ax
   942 00000BB3 11D7                <1> 	adc	di,dx
   943                              <1> 
   944 00000BB5 89D8                <1> 	mov	ax,bx
   945 00000BB7 BA0008              <1> 	mov	dx,2048
   946 00000BBA F7E2                <1> 	mul	dx			; AX = hours * 2048
   947                              <1> 
   948 00000BBC 01C7                <1> 	add	di,ax
   949                              <1> 
   950                              <1> ; CX:DX = DI:SI / 2048
   951 00000BBE B10B                <1> 	mov	cl,11
   952 00000BC0 D3EE                <1> 	shr	si,cl
   953 00000BC2 89FA                <1> 	mov	dx,di
   954 00000BC4 B105                <1> 	mov	cl,5
   955 00000BC6 D3E2                <1> 	shl	dx,cl
   956 00000BC8 09F2                <1> 	or	dx,si
   957                              <1> 
   958 00000BCA B10B                <1> 	mov	cl,11
   959 00000BCC D3EF                <1> 	shr	di,cl
   960 00000BCE 89F9                <1> 	mov	cx,di
   961                              <1> 
   962                              <1> 					; CX = high word of tick count
   963                              <1> 					; DX = low word of tick count
   964                              <1> 	
   965 00000BD0 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   966 00000BD2 CD1A                <1> 	int	1Ah	
   967                              <1> 
   968                              <1> 
   969                              <1> ; compare NVRAM checksum with stored value
   970                              <1> 
   971 00000BD4 E86C00              <1> 	call	rtc_checksum
   972                              <1> 
   973 00000BD7 B02E                <1> 	mov	al,cmos_sum_hi
   974 00000BD9 E846FF              <1> 	call	rtc_read
   975 00000BDC 88C4                <1> 	mov	ah,al
   976 00000BDE B02F                <1> 	mov	al,cmos_sum_lo
   977 00000BE0 E83FFF              <1> 	call	rtc_read
   978 00000BE3 39C3                <1> 	cmp	bx,ax
   979 00000BE5 742F                <1> 	je	.update_equipment
   980                              <1> 
   981 00000BE7 BE[2504]            <1> 	mov	si,msg_rtc_sum
   982 00000BEA E81F1A              <1> 	call	print
   983                              <1> 
   984                              <1> ; clear NVRAM
   985                              <1> 
   986 00000BED B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   987                              <1> 
   988                              <1> .nvram_clear_loop:
   989 00000BF0 E83EFF              <1> 	call	rtc_write
   990 00000BF3 FEC0                <1> 	inc	al
   991 00000BF5 3C20                <1> 	cmp	al,20h			; last address is 20h
   992 00000BF7 76F7                <1> 	jbe	.nvram_clear_loop
   993                              <1> 
   994 00000BF9 B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   995 00000BFC E832FF              <1> 	call	rtc_write
   996                              <1> 
   997 00000BFF B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
   998 00000C02 E82CFF              <1> 	call	rtc_write
   999                              <1> 
  1000                              <1> ; update checksum
  1001                              <1> 
  1002 00000C05 E83B00              <1> 	call	rtc_checksum
  1003                              <1> 
  1004 00000C08 B02E                <1> 	mov	al,cmos_sum_hi
  1005 00000C0A 88FC                <1> 	mov	ah,bh
  1006 00000C0C E822FF              <1> 	call	rtc_write
  1007                              <1> 
  1008 00000C0F FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1009 00000C11 88DC                <1> 	mov	ah,bl
  1010 00000C13 E81BFF              <1> 	call	rtc_write
  1011                              <1> 
  1012                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
  1013                              <1> 
  1014                              <1> .update_equipment:
  1015 00000C16 B014                <1> 	mov	al,cmos_equip
  1016 00000C18 E807FF              <1> 	call	rtc_read
  1017 00000C1B 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
  1018 00000C1D 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
  1019 00000C22 08061000            <1> 	or	byte [equipment_list],al
  1020                              <1> 
  1021 00000C26 B020                <1> 	mov	al,e_rtc_init_ok	; RTC initialzied successfully
  1022 00000C28 E680                <1> 	out	post_reg,al
  1023                              <1> 
  1024 00000C2A 5F                  <1> 	pop	di
  1025 00000C2B 5E                  <1> 	pop	si
  1026 00000C2C 5A                  <1> 	pop	dx
  1027 00000C2D 59                  <1> 	pop	cx
  1028 00000C2E 5B                  <1> 	pop	bx
  1029 00000C2F 58                  <1> 	pop	ax
  1030 00000C30 C3                  <1> 	ret
  1031                              <1> 
  1032                              <1> bcd_to_binary:
  1033 00000C31 51                  <1> 	push	cx
  1034 00000C32 88C5                <1> 	mov	ch,al
  1035 00000C34 80E50F              <1> 	and	ch,0Fh
  1036 00000C37 B104                <1> 	mov	cl,4
  1037 00000C39 D2E8                <1> 	shr	al,cl
  1038 00000C3B B10A                <1> 	mov	cl,10
  1039 00000C3D F6E1                <1> 	mul	cl
  1040 00000C3F 00E8                <1> 	add	al,ch
  1041 00000C41 59                  <1> 	pop	cx
  1042 00000C42 C3                  <1> 	ret
  1043                              <1> 
  1044                              <1> ;=========================================================================
  1045                              <1> ; rtc_checksum - calculate NVRAM checksum
  1046                              <1> ; Input:
  1047                              <1> ;	none
  1048                              <1> ; Output:
  1049                              <1> ;	BX = NVRAM checksum
  1050                              <1> ;-------------------------------------------------------------------------
  1051                              <1> rtc_checksum:
  1052 00000C43 50                  <1> 	push	ax
  1053 00000C44 31DB                <1> 	xor	bx,bx
  1054 00000C46 B410                <1> 	mov	ah,10h			; start from 10h
  1055                              <1> 
  1056                              <1> .checksum_loop:
  1057 00000C48 88E0                <1> 	mov	al,ah
  1058 00000C4A E8D5FE              <1> 	call	rtc_read
  1059 00000C4D 00C3                <1> 	add	bl,al			; BX += AL
  1060 00000C4F 80D700              <1> 	adc	bh,0
  1061 00000C52 FEC4                <1> 	inc	ah
  1062 00000C54 80FC20              <1> 	cmp	ah,20h			; last address is 20h
  1063 00000C57 76EF                <1> 	jbe	.checksum_loop
  1064 00000C59 58                  <1> 	pop	ax
  1065 00000C5A C3                  <1> 	ret
  1066                              <1> 
  1067                              <1> ;=========================================================================
  1068                              <1> ; rtc_setup - NVRAM configuration utility
  1069                              <1> ; Input:
  1070                              <1> ;	none
  1071                              <1> ; Output:
  1072                              <1> ;	none
  1073                              <1> ;-------------------------------------------------------------------------
  1074                              <1> rtc_setup:
  1075 00000C5B 50                  <1> 	push	ax
  1076 00000C5C 53                  <1> 	push	bx
  1077 00000C5D 51                  <1> 	push	cx
  1078 00000C5E 52                  <1> 	push	dx
  1079 00000C5F 56                  <1> 	push	si
  1080                              <1> 
  1081 00000C60 B010                <1> 	mov	al,cmos_floppy
  1082 00000C62 E8BDFE              <1> 	call	rtc_read		; read currently configured floppies
  1083 00000C65 88C1                <1> 	mov	cl,al			; save it to CL
  1084 00000C67 BE[8C04]            <1> 	mov	si,msg_set_welcome
  1085 00000C6A E89F19              <1> 	call	print
  1086                              <1> 
  1087                              <1> .menu_loop:
  1088 00000C6D BE[9C05]            <1> 	mov	si,msg_set_prompt
  1089 00000C70 E89919              <1> 	call	print
  1090                              <1> 
  1091                              <1> .menu_input:
  1092 00000C73 B400                <1> 	mov	ah,00h
  1093 00000C75 CD16                <1> 	int	16h
  1094 00000C77 0C20                <1> 	or	al,20h			; convert to lower case
  1095 00000C79 B200                <1> 	mov	dl,0			; floppy 0
  1096 00000C7B 3C66                <1> 	cmp	al,'f'
  1097 00000C7D 743E                <1> 	je	.set_floppy
  1098 00000C7F FEC2                <1> 	inc	dl			; floppy 1
  1099 00000C81 3C67                <1> 	cmp	al,'g'
  1100 00000C83 7438                <1> 	je	.set_floppy
  1101 00000C85 3C70                <1> 	cmp	al,'p'
  1102 00000C87 7503E99100          <1> 	je	.print_settings
  1103 00000C8C 3C74                <1> 	cmp	al,'t'
  1104 00000C8E 7503E9A200          <1> 	je	.set_time
  1105 00000C93 3C64                <1> 	cmp	al,'d'
  1106 00000C95 7503E91301          <1> 	je	.set_date
  1107 00000C9A 3C77                <1> 	cmp	al,'w'
  1108 00000C9C 7503E9D401          <1> 	je	.save
  1109 00000CA1 3C71                <1> 	cmp	al,'q'
  1110 00000CA3 7503E90702          <1> 	je	.exit
  1111 00000CA8 3C68                <1> 	cmp	al,'h'
  1112 00000CAA 7402                <1> 	je	.help
  1113 00000CAC EBC5                <1> 	jmp	.menu_input
  1114                              <1> 
  1115                              <1> .help:
  1116 00000CAE B40E                <1> 	mov	ah,0Eh			; echo
  1117 00000CB0 BB0700              <1> 	mov	bx,0007h
  1118 00000CB3 CD10                <1> 	int	10h
  1119 00000CB5 BE[B104]            <1> 	mov	si,msg_set_help
  1120 00000CB8 E85119              <1> 	call	print
  1121 00000CBB EBB0                <1> 	jmp	.menu_loop
  1122                              <1> 
  1123                              <1> .set_floppy:
  1124 00000CBD B40E                <1> 	mov	ah,0Eh			; echo
  1125 00000CBF BB0700              <1> 	mov	bx,0007h
  1126 00000CC2 CD10                <1> 	int	10h
  1127                              <1> 
  1128                              <1> .set_floppy_prompt:
  1129 00000CC4 BE[E906]            <1> 	mov	si,msg_set_fd_prmt
  1130 00000CC7 E84219              <1> 	call	print
  1131                              <1> 
  1132                              <1> .floppy_input:
  1133 00000CCA B400                <1> 	mov	ah,00h
  1134 00000CCC CD16                <1> 	int	16h
  1135 00000CCE 0C20                <1> 	or	al,20h			; convert to lower case
  1136 00000CD0 3C72                <1> 	cmp	al,'r'
  1137 00000CD2 7430                <1> 	je	.floppy_exit
  1138 00000CD4 3C68                <1> 	cmp	al,'h'
  1139 00000CD6 7436                <1> 	je	.floppy_help
  1140 00000CD8 3C30                <1> 	cmp	al,'0'
  1141 00000CDA 72EE                <1> 	jb	.floppy_input
  1142 00000CDC 3C36                <1> 	cmp	al,'6'
  1143 00000CDE 77EA                <1> 	ja	.floppy_input
  1144 00000CE0 3C35                <1> 	cmp	al,'5'
  1145 00000CE2 74E6                <1> 	je	.floppy_input
  1146 00000CE4 B40E                <1> 	mov	ah,0Eh			; echo
  1147 00000CE6 BB0700              <1> 	mov	bx,0007h
  1148 00000CE9 CD10                <1> 	int	10h
  1149 00000CEB 2C30                <1> 	sub	al,'0'
  1150 00000CED B6F0                <1> 	mov	dh,0F0h
  1151 00000CEF 08D2                <1> 	or	dl,dl			; drive	0?
  1152 00000CF1 750A                <1> 	jnz	.drive_1
  1153 00000CF3 D0E0                <1> 	shl	al,1
  1154 00000CF5 D0E0                <1> 	shl	al,1
  1155 00000CF7 D0E0                <1> 	shl	al,1
  1156 00000CF9 D0E0                <1> 	shl	al,1
  1157 00000CFB B60F                <1> 	mov	dh,0Fh
  1158                              <1> .drive_1:
  1159 00000CFD 20F1                <1> 	and	cl,dh
  1160 00000CFF 08C1                <1> 	or	cl,al
  1161 00000D01 E969FF              <1> 	jmp	.menu_loop
  1162                              <1> 
  1163                              <1> .floppy_exit:
  1164 00000D04 B40E                <1> 	mov	ah,0Eh			; echo
  1165 00000D06 BB0700              <1> 	mov	bx,0007h
  1166 00000D09 CD10                <1> 	int	10h
  1167 00000D0B E95FFF              <1> 	jmp	.menu_loop
  1168                              <1> 
  1169                              <1> .floppy_help:
  1170 00000D0E B40E                <1> 	mov	ah,0Eh			; echo
  1171 00000D10 BB0700              <1> 	mov	bx,0007h
  1172 00000D13 CD10                <1> 	int	10h
  1173 00000D15 BE[1B06]            <1> 	mov	si,msg_set_fd_help
  1174 00000D18 E8F118              <1> 	call	print
  1175 00000D1B EBA7                <1> 	jmp	.set_floppy_prompt
  1176                              <1> 
  1177                              <1> .print_settings:
  1178 00000D1D B40E                <1> 	mov	ah,0Eh			; echo
  1179 00000D1F BB0700              <1> 	mov	bx,0007h
  1180 00000D22 CD10                <1> 	int	10h
  1181 00000D24 BE[8800]            <1> 	mov	si,msg_crlf
  1182 00000D27 E8E218              <1> 	call	print
  1183 00000D2A E89501              <1> 	call	print_rtc		; print current RTC time
  1184 00000D2D 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1185 00000D2F E8580B              <1> 	call	print_floppy
  1186 00000D32 E938FF              <1> 	jmp	.menu_loop
  1187                              <1> 
  1188                              <1> .set_time:
  1189 00000D35 51                  <1> 	push	cx
  1190 00000D36 57                  <1> 	push	di
  1191 00000D37 06                  <1> 	push	es
  1192 00000D38 B40E                <1> 	mov	ah,0Eh			; echo
  1193 00000D3A BB0700              <1> 	mov	bx,0007h
  1194 00000D3D CD10                <1> 	int	10h
  1195 00000D3F BE[8800]            <1> 	mov	si,msg_crlf
  1196 00000D42 E8C718              <1> 	call	print
  1197                              <1> 
  1198 00000D45 BE[BB05]            <1> 	mov	si,msg_set_time
  1199 00000D48 E8C118              <1> 	call	print
  1200                              <1> 
  1201 00000D4B B402                <1> 	mov	ah,02h
  1202 00000D4D CD1A                <1> 	int	1Ah			; get current time
  1203                              <1> 
  1204 00000D4F B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1205 00000D52 8EC0                <1> 	mov	es,ax
  1206 00000D54 31FF                <1> 	xor	di,di
  1207 00000D56 B80800              <1> 	mov	ax,8			; length of the time string
  1208                              <1> 
  1209 00000D59 E8F817              <1> 	call	get_line
  1210                              <1> 
  1211 00000D5C 09C0                <1> 	or	ax,ax			; empty string?
  1212 00000D5E 743F                <1> 	jz	.set_time_exit
  1213                              <1> 
  1214 00000D60 E86318              <1> 	call	atoi
  1215                              <1> 
  1216 00000D63 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
  1217 00000D66 773D                <1> 	ja	.set_time_invalid
  1218                              <1> 
  1219 00000D68 E88018              <1> 	call	bin_to_bcd		; convert to BCD
  1220                              <1> 
  1221 00000D6B 88C5                <1> 	mov	ch,al			; CH = hours
  1222                              <1> 
  1223 00000D6D 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1224 00000D71 7532                <1> 	jne	.set_time_invalid
  1225                              <1> 
  1226 00000D73 47                  <1> 	inc	di
  1227                              <1> 
  1228 00000D74 E84F18              <1> 	call	atoi
  1229                              <1> 
  1230 00000D77 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
  1231 00000D7A 7729                <1> 	ja	.set_time_invalid
  1232                              <1> 
  1233 00000D7C E86C18              <1> 	call	bin_to_bcd
  1234                              <1> 
  1235 00000D7F 88C1                <1> 	mov	cl,al			; CL = minutes
  1236                              <1> 
  1237 00000D81 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1238 00000D85 751E                <1> 	jne	.set_time_invalid
  1239                              <1> 
  1240 00000D87 47                  <1> 	inc	di
  1241                              <1> 
  1242 00000D88 E83B18              <1> 	call	atoi
  1243                              <1> 
  1244 00000D8B 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
  1245 00000D8E 7715                <1> 	ja	.set_time_invalid
  1246                              <1> 
  1247 00000D90 E85818              <1> 	call	bin_to_bcd
  1248                              <1> 
  1249 00000D93 88C6                <1> 	mov	dh,al			; DH = seconds
  1250                              <1> 
  1251 00000D95 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1252 00000D99 750A                <1> 	jne	.set_time_invalid
  1253                              <1> 
  1254 00000D9B B403                <1> 	mov	ah,03h			; set RTC time
  1255 00000D9D CD1A                <1> 	int	1Ah
  1256                              <1> 
  1257                              <1> .set_time_exit:
  1258 00000D9F 07                  <1> 	pop	es
  1259 00000DA0 5F                  <1> 	pop	di
  1260 00000DA1 59                  <1> 	pop	cx
  1261 00000DA2 E9C8FE              <1> 	jmp	.menu_loop
  1262                              <1> 
  1263                              <1> .set_time_invalid:
  1264 00000DA5 BE[ED05]            <1> 	mov	si,msg_time_inval
  1265 00000DA8 E86118              <1> 	call	print
  1266 00000DAB EBF2                <1> 	jmp	.set_time_exit
  1267                              <1> 
  1268                              <1> .set_date:
  1269 00000DAD 51                  <1> 	push	cx
  1270 00000DAE 57                  <1> 	push	di
  1271 00000DAF 06                  <1> 	push	es
  1272 00000DB0 B40E                <1> 	mov	ah,0Eh			; echo
  1273 00000DB2 BB0700              <1> 	mov	bx,0007h
  1274 00000DB5 CD10                <1> 	int	10h
  1275 00000DB7 BE[8800]            <1> 	mov	si,msg_crlf
  1276 00000DBA E84F18              <1> 	call	print
  1277 00000DBD BE[D305]            <1> 	mov	si,msg_set_date
  1278 00000DC0 E84918              <1> 	call	print
  1279                              <1> 
  1280 00000DC3 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1281 00000DC6 8EC0                <1> 	mov	es,ax
  1282 00000DC8 31FF                <1> 	xor	di,di
  1283 00000DCA B80A00              <1> 	mov	ax,10			; length of the date string
  1284                              <1> 
  1285 00000DCD E88417              <1> 	call	get_line
  1286                              <1> 
  1287 00000DD0 09C0                <1> 	or	ax,ax			; empty string?
  1288 00000DD2 7503E99000          <1> 	jz	.set_date_exit
  1289                              <1> 
  1290 00000DD7 E8EC17              <1> 	call	atoi
  1291                              <1> 
  1292 00000DDA 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
  1293 00000DDD 7603E98B00          <1> 	ja	.set_date_invalid
  1294                              <1> 
  1295 00000DE2 89C3                <1> 	mov	bx,ax			; store binary year in BX
  1296                              <1> 
  1297 00000DE4 E80418              <1> 	call	bin_to_bcd		; convert to BCD
  1298                              <1> 
  1299 00000DE7 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
  1300                              <1> 	
  1301 00000DE9 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1302 00000DED 757E                <1> 	jne	.set_date_invalid
  1303                              <1> 
  1304 00000DEF 47                  <1> 	inc	di
  1305                              <1> 
  1306 00000DF0 E8D317              <1> 	call	atoi
  1307                              <1> 
  1308 00000DF3 83F801              <1> 	cmp	ax,1			; month is lower than 1?
  1309 00000DF6 7275                <1> 	jb	.set_date_invalid
  1310                              <1> 
  1311 00000DF8 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
  1312 00000DFB 7770                <1> 	ja	.set_date_invalid
  1313                              <1> 
  1314 00000DFD E8EB17              <1> 	call	bin_to_bcd
  1315                              <1> 
  1316 00000E00 88C6                <1> 	mov	dh,al			; DH = month
  1317                              <1> 
  1318 00000E02 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1319 00000E06 7565                <1> 	jne	.set_date_invalid
  1320                              <1> 
  1321 00000E08 47                  <1> 	inc	di
  1322                              <1> 
  1323 00000E09 E8BA17              <1> 	call	atoi
  1324                              <1> 
  1325 00000E0C 83F801              <1> 	cmp	ax,1			; day is lower than 1?
  1326 00000E0F 725C                <1> 	jb	.set_date_invalid
  1327                              <1> 
  1328 00000E11 80FE02              <1> 	cmp	dh,02h			; February
  1329 00000E14 7430                <1> 	je	.set_date_february
  1330                              <1> 
  1331 00000E16 80FE04              <1> 	cmp	dh,04h			; April
  1332 00000E19 7416                <1> 	je	.set_date_30_days
  1333                              <1> 
  1334 00000E1B 80FE06              <1> 	cmp	dh,06h			; July
  1335 00000E1E 7411                <1> 	je	.set_date_30_days
  1336                              <1> 
  1337 00000E20 80FE09              <1> 	cmp	dh,09h			; September
  1338 00000E23 740C                <1> 	je	.set_date_30_days
  1339                              <1> 
  1340 00000E25 80FE11              <1> 	cmp	dh,11h			; November
  1341 00000E28 7407                <1> 	je	.set_date_30_days
  1342                              <1> 
  1343                              <1> .set_date_31_days:
  1344 00000E2A 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
  1345 00000E2D 773E                <1> 	ja	.set_date_invalid
  1346 00000E2F EB27                <1> 	jmp	.set_date_set_day
  1347                              <1> 
  1348                              <1> .set_date_30_days:
  1349 00000E31 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
  1350 00000E34 7737                <1> 	ja	.set_date_invalid
  1351 00000E36 EB20                <1> 	jmp	.set_date_set_day
  1352                              <1> 
  1353                              <1> .set_date_29_days:
  1354 00000E38 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
  1355 00000E3B 7730                <1> 	ja	.set_date_invalid
  1356 00000E3D EB19                <1> 	jmp	.set_date_set_day
  1357                              <1> 
  1358                              <1> .set_date_28_days:
  1359 00000E3F 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
  1360 00000E42 7729                <1> 	ja	.set_date_invalid
  1361 00000E44 EB12                <1> 	jmp	.set_date_set_day
  1362                              <1> 
  1363                              <1> .set_date_february:
  1364 00000E46 F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
  1365 00000E4A 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
  1366                              <1> 
  1367 00000E4C 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
  1368 00000E4F 75E7                <1> 	jne	.set_date_29_days	; a leap year
  1369                              <1> 
  1370 00000E51 F6C503              <1> 	test	ch,03h			; check if century divides by 4
  1371 00000E54 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
  1372 00000E56 EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
  1373                              <1> 
  1374                              <1> .set_date_set_day:
  1375 00000E58 E89017              <1> 	call	bin_to_bcd
  1376                              <1> 
  1377 00000E5B 88C2                <1> 	mov	dl,al			; DL = date (day of month)
  1378                              <1> 
  1379 00000E5D 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1380 00000E61 750A                <1> 	jne	.set_date_invalid
  1381                              <1> 
  1382 00000E63 B405                <1> 	mov	ah,05h			; set RTC date
  1383 00000E65 CD1A                <1> 	int	1Ah
  1384                              <1> 
  1385                              <1> .set_date_exit:
  1386 00000E67 07                  <1> 	pop	es
  1387 00000E68 5F                  <1> 	pop	di
  1388 00000E69 59                  <1> 	pop	cx
  1389 00000E6A E900FE              <1> 	jmp	.menu_loop
  1390                              <1> 
  1391                              <1> .set_date_invalid:
  1392 00000E6D BE[0406]            <1> 	mov	si,msg_date_inval
  1393 00000E70 E89917              <1> 	call	print
  1394 00000E73 EBF2                <1> 	jmp	.set_date_exit
  1395                              <1> 
  1396                              <1> .save:
  1397 00000E75 50                  <1> 	push	ax
  1398                              <1> 
  1399 00000E76 B010                <1> 	mov	al,cmos_floppy
  1400 00000E78 88CC                <1> 	mov	ah,cl
  1401 00000E7A E8B4FC              <1> 	call	rtc_write
  1402                              <1> 
  1403 00000E7D 8A261000            <1> 	mov	ah,byte [equipment_list]
  1404 00000E81 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1405                              <1> 
  1406 00000E84 F6C170              <1> 	test	cl,70h
  1407 00000E87 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1408 00000E89 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1409                              <1> 
  1410                              <1> .second_floppy:
  1411 00000E8C F6C107              <1> 	test	cl,07h
  1412 00000E8F 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1413 00000E91 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1414                              <1> 					; (even if the first one is missing)
  1415                              <1> 
  1416                              <1> .save_equipment:
  1417 00000E94 88261000            <1> 	mov	byte [equipment_list],ah
  1418 00000E98 B014                <1> 	mov	al,cmos_equip
  1419 00000E9A E894FC              <1> 	call	rtc_write
  1420                              <1> 
  1421 00000E9D E8A3FD              <1> 	call	rtc_checksum
  1422                              <1> 
  1423 00000EA0 B02E                <1> 	mov	al,cmos_sum_hi
  1424 00000EA2 88FC                <1> 	mov	ah,bh
  1425 00000EA4 E88AFC              <1> 	call	rtc_write
  1426                              <1> 
  1427 00000EA7 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1428 00000EA9 88DC                <1> 	mov	ah,bl
  1429 00000EAB E883FC              <1> 	call	rtc_write
  1430                              <1> 	
  1431 00000EAE 58                  <1> 	pop	ax
  1432                              <1> 
  1433                              <1> .exit:
  1434 00000EAF B40E                <1> 	mov	ah,0Eh			; echo
  1435 00000EB1 BB0700              <1> 	mov	bx,0007h
  1436 00000EB4 CD10                <1> 	int	10h
  1437 00000EB6 BE[8800]            <1> 	mov	si,msg_crlf
  1438 00000EB9 E85017              <1> 	call	print
  1439 00000EBC 5E                  <1> 	pop	si
  1440 00000EBD 5A                  <1> 	pop	dx
  1441 00000EBE 59                  <1> 	pop	cx
  1442 00000EBF 5B                  <1> 	pop	bx
  1443 00000EC0 58                  <1> 	pop	ax
  1444 00000EC1 C3                  <1> 	ret
  1445                              <1> 
  1446                              <1> ;=========================================================================
  1447                              <1> ; print_rtc - print current RTC date and time
  1448                              <1> ; Input:
  1449                              <1> ;	none
  1450                              <1> ; Output:
  1451                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
  1452                              <1> ; Notes:
  1453                              <1> ;	There is a slight probability of getting inconsistent printout.
  1454                              <1> ;	In case the function is called just before midnight, it could
  1455                              <1> ;	print the previos day's date and next day's time.
  1456                              <1> ;-------------------------------------------------------------------------
  1457                              <1> print_rtc:
  1458 00000EC2 50                  <1> 	push	ax
  1459 00000EC3 53                  <1> 	push	bx
  1460 00000EC4 51                  <1> 	push	cx
  1461 00000EC5 52                  <1> 	push	dx
  1462 00000EC6 56                  <1> 	push	si
  1463 00000EC7 BE[E501]            <1> 	mov	si,msg_rtc
  1464 00000ECA E83F17              <1> 	call	print
  1465                              <1> 
  1466                              <1> ; print date
  1467 00000ECD B404                <1> 	mov	ah,04h
  1468 00000ECF CD1A                <1> 	int	1Ah			; read RTC date
  1469                              <1> 					; CH = BCD century
  1470                              <1> 					; CL = BCD year
  1471                              <1> 					; DH = BCD month
  1472                              <1> 					; DL = BCD date (day of month)
  1473 00000ED1 89C8                <1> 	mov	ax,cx
  1474 00000ED3 E85117              <1> 	call	print_hex		; print 4-digit year
  1475 00000ED6 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1476 00000ED9 BB0700              <1> 	mov	bx,0007h
  1477 00000EDC CD10                <1> 	int	10h			; print dash (-)
  1478                              <1> 
  1479 00000EDE 88F0                <1> 	mov	al,dh
  1480 00000EE0 E84F17              <1> 	call	print_byte		; print 2-digit month
  1481 00000EE3 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1482 00000EE6 BB0700              <1> 	mov	bx,0007h
  1483 00000EE9 CD10                <1> 	int	10h			; print dash (-)
  1484                              <1> 
  1485 00000EEB 88D0                <1> 	mov	al,dl
  1486 00000EED E84217              <1> 	call	print_byte		; print 2-digit date (day of month)
  1487                              <1> 
  1488 00000EF0 B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
  1489 00000EF3 BB0700              <1> 	mov	bx,0007h
  1490 00000EF6 CD10                <1> 	int	10h			; print space ( )
  1491                              <1> 
  1492                              <1> ; print time
  1493 00000EF8 B402                <1> 	mov	ah,02h
  1494 00000EFA CD1A                <1> 	int	1Ah			; read RTC time
  1495                              <1> 					; CH = BCD hours
  1496                              <1> 					; CL = BCD minutes
  1497                              <1> 					; DH = BCD seconds
  1498                              <1> 					; DL = daylight saving flag (ignored)
  1499 00000EFC 88E8                <1> 	mov	al,ch
  1500 00000EFE E83117              <1> 	call	print_byte		; print 2-digit hours
  1501                              <1> 	
  1502 00000F01 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1503 00000F04 BB0700              <1> 	mov	bx,0007h
  1504 00000F07 CD10                <1> 	int	10h			; print colon (:)
  1505                              <1> 
  1506 00000F09 88C8                <1> 	mov	al,cl
  1507 00000F0B E82417              <1> 	call	print_byte		; print 2-digit minutes
  1508                              <1> 	
  1509 00000F0E B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1510 00000F11 BB0700              <1> 	mov	bx,0007h
  1511 00000F14 CD10                <1> 	int	10h			; print colon (:)
  1512                              <1> 
  1513 00000F16 88F0                <1> 	mov	al,dh
  1514 00000F18 E81717              <1> 	call	print_byte		; print 2-digit seconds
  1515                              <1> 
  1516 00000F1B BE[8800]            <1> 	mov	si,msg_crlf
  1517 00000F1E E8EB16              <1> 	call	print
  1518 00000F21 5E                  <1> 	pop	si
  1519 00000F22 5A                  <1> 	pop	dx
  1520 00000F23 59                  <1> 	pop	cx
  1521 00000F24 5B                  <1> 	pop	bx
  1522 00000F25 58                  <1> 	pop	ax
  1523 00000F26 C3                  <1> 	ret
  1524                              <1> 
  1525                              <1> ;=========================================================================
  1526                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1527                              <1> ; Input:
  1528                              <1> ;	CX = time to delay (in 15 microsecond units)
  1529                              <1> ; Notes:
  1530                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1531                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1532                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1533                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1534                              <1> ;-------------------------------------------------------------------------
  1535                              <1> delay_15us:
  1536 00000F27 50                  <1> 	push	ax
  1537 00000F28 51                  <1> 	push	cx
  1538                              <1> .zero:
  1539 00000F29 E461                <1> 	in	al,port_b_reg
  1540 00000F2B A810                <1> 	test	al,refresh_flag
  1541 00000F2D 74FA                <1> 	jz	.zero
  1542 00000F2F 49                  <1> 	dec	cx
  1543 00000F30 7409                <1> 	jz	.exit
  1544                              <1> .one:
  1545 00000F32 E461                <1> 	in	al,port_b_reg
  1546 00000F34 A810                <1> 	test	al,refresh_flag
  1547 00000F36 75FA                <1> 	jnz	.one
  1548 00000F38 49                  <1> 	dec	cx
  1549 00000F39 75EE                <1> 	jnz	.zero
  1550                              <1> .exit:
  1551 00000F3B 59                  <1> 	pop	cx
  1552 00000F3C 58                  <1> 	pop	ax
  1553 00000F3D C3                  <1> 	ret
  1554                              <1> 
  1555                              <1> %if 0
  1556                              <1> ;=========================================================================
  1557                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1558                              <1> ; Input:
  1559                              <1> ;	DX:AX	- dividend
  1560                              <1> ;	CX	- divisor
  1561                              <1> ; Output:
  1562                              <1> ;	DX:AX	- quotient
  1563                              <1> ;-------------------------------------------------------------------------
  1564                              <1> divide_32:
  1565                              <1> 	or	dx,dx
  1566                              <1> 	jnz	.1
  1567                              <1> 	div	cx
  1568                              <1> 	xor	dx,dx
  1569                              <1> 	ret
  1570                              <1> .1:
  1571                              <1> 	push	bx
  1572                              <1> 	mov	bx,ax
  1573                              <1> 	mov	ax,dx
  1574                              <1> 	xor	dx,dx
  1575                              <1> 	div	cx
  1576                              <1> 	xchg	bx,ax
  1577                              <1> 	div	cx
  1578                              <1> 	mov	dx,bx
  1579                              <1> 	pop	bx
  1580                              <1> 	ret
  1581                              <1> %endif ; 0
  1582                                  %include	"time1.inc"		; time services
  1583                              <1> ;=========================================================================
  1584                              <1> ; time1.inc - BIOS Time Services
  1585                              <1> ;       INT 1Ah - BIOS Time Services
  1586                              <1> ;		functions AH=00h to AH=07h
  1587                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1588                              <1> ;-------------------------------------------------------------------------
  1589                              <1> ;
  1590                              <1> ; Compiles with NASM 2.07, might work with other versions
  1591                              <1> ;
  1592                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1593                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1594                              <1> ;
  1595                              <1> ; This program is free software: you can redistribute it and/or modify
  1596                              <1> ; it under the terms of the GNU General Public License as published by
  1597                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1598                              <1> ; (at your option) any later version.
  1599                              <1> ;
  1600                              <1> ; This program is distributed in the hope that it will be useful,
  1601                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1602                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1603                              <1> ; GNU General Public License for more details.
  1604                              <1> ;
  1605                              <1> ; You should have received a copy of the GNU General Public License
  1606                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1607                              <1> ;
  1608                              <1> ;=========================================================================
  1609                              <1> 
  1610                              <1> ;=========================================================================
  1611                              <1> ; int_1A_fn00 - Read current time
  1612                              <1> ; Input:
  1613                              <1> ;	AH = 0 - read current time
  1614                              <1> ; Output:
  1615                              <1> ;	CX = high word of tick count
  1616                              <1> ;	DX = low word of tick count
  1617                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1618                              <1> ;-------------------------------------------------------------------------
  1619                              <1> int_1A_fn00:
  1620 00000F3E 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1621 00000F42 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1622 00000F46 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1623 00000F49 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1624 00000F4D E9456F              <1> 	jmp	int_1A_exit
  1625                              <1> 
  1626                              <1> ;=========================================================================
  1627                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1628                              <1> ; Input:
  1629                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1630                              <1> ;	CX = high word of tick count
  1631                              <1> ;	DX = low word of tick count
  1632                              <1> ; Output:
  1633                              <1> ;	None
  1634                              <1> ;-------------------------------------------------------------------------
  1635                              <1> int_1A_fn01:
  1636 00000F50 89166C00            <1> 	mov	word [ticks_lo],dx
  1637 00000F54 890E6E00            <1> 	mov	word [ticks_hi],cx
  1638 00000F58 C606700000          <1> 	mov	byte [new_day],00h
  1639 00000F5D E9356F              <1> 	jmp	int_1A_exit
  1640                              <1> 
  1641                              <1> ;=========================================================================
  1642                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1643                              <1> ; Input:
  1644                              <1> ;	AH = 02h - function 02h - read RTC time
  1645                              <1> ; Output:
  1646                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1647                              <1> ;	CH = BCD hours
  1648                              <1> ;	CL = BCD minutes
  1649                              <1> ;	DH = BCD seconds
  1650                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1651                              <1> ;-------------------------------------------------------------------------
  1652                              <1> int_1A_fn02:
  1653 00000F60 50                  <1> 	push	ax
  1654 00000F61 B00A                <1> 	mov	al,cmos_control_a
  1655 00000F63 E8BCFB              <1> 	call	rtc_read		; read control A register
  1656 00000F66 A880                <1> 	test	al,cmos_uip
  1657 00000F68 7405                <1> 	jz	.1			; no update in progess
  1658 00000F6A F9                  <1> 	stc
  1659 00000F6B 58                  <1> 	pop	ax
  1660 00000F6C E9296F              <1> 	jmp	int_1A_exitf
  1661                              <1> .1:
  1662 00000F6F B00B                <1> 	mov	al,cmos_control_b
  1663 00000F71 E8AEFB              <1> 	call	rtc_read		; read control B register
  1664 00000F74 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1665 00000F76 88C2                <1> 	mov	dl,al
  1666 00000F78 B000                <1> 	mov	al,cmos_seconds
  1667 00000F7A E8A5FB              <1> 	call	rtc_read		; read seconds
  1668 00000F7D 88C6                <1> 	mov	dh,al
  1669 00000F7F B002                <1> 	mov	al,cmos_minutes
  1670 00000F81 E89EFB              <1> 	call	rtc_read		; read minutes
  1671 00000F84 88C1                <1> 	mov	cl,al
  1672 00000F86 B004                <1> 	mov	al,cmos_hours
  1673 00000F88 E897FB              <1> 	call	rtc_read		; read hours
  1674 00000F8B 88C5                <1> 	mov	ch,al
  1675 00000F8D F8                  <1> 	clc
  1676 00000F8E 58                  <1> 	pop	ax
  1677 00000F8F E9066F              <1> 	jmp	int_1A_exitf
  1678                              <1> 
  1679                              <1> ;=========================================================================
  1680                              <1> ; int_1A_fn03 - Set real time clock
  1681                              <1> ; Input:
  1682                              <1> ;	AH = 03h - function 03h - set RTC time
  1683                              <1> ;	CH = BCD hours
  1684                              <1> ;	CL = BCD minutes
  1685                              <1> ;	DH = BCD seconds
  1686                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1687                              <1> ; Output:
  1688                              <1> ;	None
  1689                              <1> ;-------------------------------------------------------------------------
  1690                              <1> int_1A_fn03:
  1691 00000F92 50                  <1> 	push	ax
  1692 00000F93 B00B                <1> 	mov	al,cmos_control_b
  1693 00000F95 E88AFB              <1> 	call	rtc_read		; read control B register
  1694 00000F98 88C4                <1> 	mov	ah,al
  1695 00000F9A 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1696 00000F9D B00B                <1> 	mov	al,cmos_control_b
  1697 00000F9F E88FFB              <1> 	call	rtc_write		; write control B register
  1698                              <1> 
  1699 00000FA2 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1700 00000FA5 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1701 00000FA8 08D4                <1> 	or	ah,dl			; add it from the input
  1702 00000FAA B00B                <1> 	mov	al,cmos_control_b
  1703 00000FAC E882FB              <1> 	call	rtc_write		; write control B register
  1704                              <1> 
  1705 00000FAF B000                <1> 	mov	al,cmos_seconds
  1706 00000FB1 88F4                <1> 	mov	ah,dh
  1707 00000FB3 E87BFB              <1> 	call	rtc_write		; write seconds
  1708 00000FB6 B002                <1> 	mov	al,cmos_minutes
  1709 00000FB8 88CC                <1> 	mov	ah,cl
  1710 00000FBA E874FB              <1> 	call	rtc_write		; write minutes
  1711 00000FBD B004                <1> 	mov	al,cmos_hours
  1712 00000FBF 88EC                <1> 	mov	ah,ch
  1713 00000FC1 E86DFB              <1> 	call	rtc_write		; write hours
  1714                              <1> 
  1715 00000FC4 B00B                <1> 	mov	al,cmos_control_b
  1716 00000FC6 E859FB              <1> 	call	rtc_read		; read control B register
  1717 00000FC9 88C4                <1> 	mov	ah,al
  1718 00000FCB 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1719 00000FCE B00B                <1> 	mov	al,cmos_control_b
  1720 00000FD0 E85EFB              <1> 	call	rtc_write		; write control B register
  1721 00000FD3 58                  <1> 	pop	ax
  1722 00000FD4 E9BE6E              <1> 	jmp	int_1A_exit
  1723                              <1> 
  1724                              <1> ;=========================================================================
  1725                              <1> ; int_1A_fn04 - Read date from real time clock
  1726                              <1> ; Input:
  1727                              <1> ;	AH = 04h - function 04h - read RTC date
  1728                              <1> ; Output:
  1729                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1730                              <1> ;	CH = BCD century
  1731                              <1> ;	CL = BCD year
  1732                              <1> ;	DH = BCD month
  1733                              <1> ;	DL = BCD date
  1734                              <1> ;-------------------------------------------------------------------------
  1735                              <1> int_1A_fn04:
  1736 00000FD7 50                  <1> 	push	ax
  1737 00000FD8 B00A                <1> 	mov	al,cmos_control_a
  1738 00000FDA E845FB              <1> 	call	rtc_read		; read control A register
  1739 00000FDD A880                <1> 	test	al,cmos_uip
  1740 00000FDF 7405                <1> 	jz	.1			; no update in progess
  1741 00000FE1 F9                  <1> 	stc
  1742 00000FE2 58                  <1> 	pop	ax
  1743 00000FE3 E9B26E              <1> 	jmp	int_1A_exitf
  1744                              <1> .1:
  1745 00000FE6 B007                <1> 	mov	al,cmos_date
  1746 00000FE8 E837FB              <1> 	call	rtc_read		; read date
  1747 00000FEB 88C2                <1> 	mov	dl,al
  1748 00000FED B008                <1> 	mov	al,cmos_month
  1749 00000FEF E830FB              <1> 	call	rtc_read		; read month
  1750 00000FF2 88C6                <1> 	mov	dh,al
  1751 00000FF4 B009                <1> 	mov	al,cmos_year
  1752 00000FF6 E829FB              <1> 	call	rtc_read		; read year
  1753 00000FF9 88C1                <1> 	mov	cl,al
  1754 00000FFB B032                <1> 	mov	al,cmos_century
  1755 00000FFD E822FB              <1> 	call	rtc_read		; read century
  1756 00001000 88C5                <1> 	mov	ch,al
  1757 00001002 F8                  <1> 	clc
  1758 00001003 58                  <1> 	pop	ax
  1759 00001004 E9916E              <1> 	jmp	int_1A_exitf
  1760                              <1> 
  1761                              <1> ;=========================================================================
  1762                              <1> ; int_1A_fn05 - Set date in real time clock
  1763                              <1> ; Input:
  1764                              <1> ;	AH = 05h - function 05h - set RTC date
  1765                              <1> ;	CH = BCD century
  1766                              <1> ;	CL = BCD year
  1767                              <1> ;	DH = BCD month
  1768                              <1> ;	DL = BCD date
  1769                              <1> ; Output:
  1770                              <1> ;	None
  1771                              <1> ;-------------------------------------------------------------------------
  1772                              <1> int_1A_fn05:
  1773 00001007 50                  <1> 	push	ax
  1774 00001008 B00B                <1> 	mov	al,cmos_control_b
  1775 0000100A E815FB              <1> 	call	rtc_read		; read control B register
  1776 0000100D 88C4                <1> 	mov	ah,al
  1777 0000100F 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1778 00001012 B00B                <1> 	mov	al,cmos_control_b
  1779 00001014 E81AFB              <1> 	call	rtc_write		; write control B register
  1780                              <1> 
  1781 00001017 B007                <1> 	mov	al,cmos_date
  1782 00001019 88D4                <1> 	mov	ah,dl
  1783 0000101B E813FB              <1> 	call	rtc_write		; write date
  1784                              <1> 
  1785 0000101E B008                <1> 	mov	al,cmos_month
  1786 00001020 88F4                <1> 	mov	ah,dh
  1787 00001022 E80CFB              <1> 	call	rtc_write		; write month
  1788 00001025 B009                <1> 	mov	al,cmos_year
  1789 00001027 88CC                <1> 	mov	ah,cl
  1790 00001029 E805FB              <1> 	call	rtc_write		; write year
  1791 0000102C B032                <1> 	mov	al,cmos_century
  1792 0000102E 88EC                <1> 	mov	ah,ch
  1793 00001030 E8FEFA              <1> 	call	rtc_write		; write centry
  1794                              <1> 
  1795 00001033 B00B                <1> 	mov	al,cmos_control_b
  1796 00001035 E8EAFA              <1> 	call	rtc_read		; read control B register
  1797 00001038 88C4                <1> 	mov	ah,al
  1798 0000103A 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1799 0000103D B00B                <1> 	mov	al,cmos_control_b
  1800 0000103F E8EFFA              <1> 	call	rtc_write		; write control B register
  1801 00001042 58                  <1> 	pop	ax
  1802 00001043 E94F6E              <1> 	jmp	int_1A_exit
  1803                              <1> 
  1804                              <1> ;=========================================================================
  1805                              <1> ; int_1A_fn06 - Set real time clock alarm
  1806                              <1> ; Input:
  1807                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1808                              <1> ;	CH = BCD hours
  1809                              <1> ;	CL = BCD minutes
  1810                              <1> ;	DH = BCD seconds
  1811                              <1> ; Output:
  1812                              <1> ;	CF = 1 - alarm already set
  1813                              <1> ;-------------------------------------------------------------------------
  1814                              <1> int_1A_fn06:
  1815 00001046 50                  <1> 	push	ax
  1816 00001047 B00B                <1> 	mov	al,cmos_control_b
  1817 00001049 E8D6FA              <1> 	call	rtc_read		; read control B register
  1818 0000104C A820                <1> 	test	al,cmos_aie
  1819 0000104E 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1820 00001050 F9                  <1> 	stc
  1821 00001051 58                  <1> 	pop	ax
  1822 00001052 E9436E              <1> 	jmp	int_1A_exitf
  1823                              <1> .1:
  1824 00001055 88C4                <1> 	mov	ah,al
  1825 00001057 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1826 0000105A B00B                <1> 	mov	al,cmos_control_b
  1827 0000105C E8D2FA              <1> 	call	rtc_write		; write control B register
  1828                              <1> 
  1829 0000105F B001                <1> 	mov	al,cmos_alarm_secs
  1830 00001061 88F4                <1> 	mov	ah,dh
  1831 00001063 E8CBFA              <1> 	call	rtc_write		; write alarm seconds
  1832 00001066 B003                <1> 	mov	al,cmos_alarm_mins
  1833 00001068 88CC                <1> 	mov	ah,cl
  1834 0000106A E8C4FA              <1> 	call	rtc_write		; write alarm minutes
  1835 0000106D B005                <1> 	mov	al,cmos_alarm_hrs
  1836 0000106F 88EC                <1> 	mov	ah,ch
  1837 00001071 E8BDFA              <1> 	call	rtc_write		; write alarm hours
  1838                              <1> 
  1839 00001074 B00B                <1> 	mov	al,cmos_control_b
  1840 00001076 E8A9FA              <1> 	call	rtc_read		; read control B register
  1841 00001079 88C4                <1> 	mov	ah,al
  1842 0000107B 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1843 0000107E B00B                <1> 	mov	al,cmos_control_b
  1844 00001080 E8AEFA              <1> 	call	rtc_write		; write control B register
  1845                              <1> 
  1846 00001083 B00B                <1> 	mov	al,cmos_control_b
  1847 00001085 E89AFA              <1> 	call	rtc_read		; read control B register
  1848 00001088 88C4                <1> 	mov	ah,al
  1849 0000108A 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1850 0000108D B00B                <1> 	mov	al,cmos_control_b
  1851 0000108F E89FFA              <1> 	call	rtc_write		; write control B register with AIE set
  1852                              <1> 
  1853 00001092 58                  <1> 	pop	ax
  1854 00001093 F8                  <1> 	clc
  1855 00001094 E9016E              <1> 	jmp	int_1A_exitf
  1856                              <1> 
  1857                              <1> ;=========================================================================
  1858                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1859                              <1> ; Input:
  1860                              <1> ;	AH = 07h - function 07h - set RTC time
  1861                              <1> ; Output:
  1862                              <1> ;	None
  1863                              <1> ;-------------------------------------------------------------------------
  1864                              <1> int_1A_fn07:
  1865 00001097 50                  <1> 	push	ax
  1866                              <1> 
  1867 00001098 B00B                <1> 	mov	al,cmos_control_b
  1868 0000109A E885FA              <1> 	call	rtc_read		; read control B register
  1869 0000109D 88C4                <1> 	mov	ah,al
  1870 0000109F 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1871 000010A2 B00B                <1> 	mov	al,cmos_control_b
  1872 000010A4 E88AFA              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1873                              <1> 
  1874 000010A7 58                  <1> 	pop	ax
  1875 000010A8 E9EA6D              <1> 	jmp	int_1A_exit
  1876                              <1> 	
  1877                              <1> ;=========================================================================
  1878                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1879                              <1> ; Notes:
  1880                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1881                              <1> ;-------------------------------------------------------------------------
  1882                              <1> int_70:
  1883 000010AB 50                  <1> 	push	ax
  1884 000010AC B020                <1> 	mov	al,20h
  1885 000010AE E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1886 000010B0 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1887 000010B2 B00C                <1> 	mov	al,cmos_control_c
  1888 000010B4 E86BFA              <1> 	call	rtc_read		; read control C register
  1889 000010B7 A840                <1> 	test	al,cmos_af		; check for alarm flag
  1890 000010B9 7402                <1> 	jz	.1
  1891 000010BB CD4A                <1> 	int	4Ah			; call INT 4Ah
  1892                              <1> .1:
  1893 000010BD 58                  <1> 	pop	ax
  1894 000010BE CF                  <1> 	iret
  1895                                  %include	"floppy1.inc"		; floppy services
  1896                              <1> ;=========================================================================
  1897                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
  1898                              <1> ;       INT 13h, function AH=00h
  1899                              <1> ;       INT 13h, function AH=01h
  1900                              <1> ;       INT 13h, function AH=08h
  1901                              <1> ;       INT 13h, function AH=15h
  1902                              <1> ;       INT 13h, function AH=16h
  1903                              <1> ;       INT 13h, function AH=17h
  1904                              <1> ;       INT 13h, function AH=18h
  1905                              <1> ;       INT 13h, function AH=08h
  1906                              <1> ;	- see floppy2.inc for other INT 13h functions
  1907                              <1> ;-------------------------------------------------------------------------
  1908                              <1> ;
  1909                              <1> ; Compiles with NASM 2.07, might work with other versions
  1910                              <1> ;
  1911                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1912                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1913                              <1> ;
  1914                              <1> ; This program is free software: you can redistribute it and/or modify
  1915                              <1> ; it under the terms of the GNU General Public License as published by
  1916                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1917                              <1> ; (at your option) any later version.
  1918                              <1> ;
  1919                              <1> ; This program is distributed in the hope that it will be useful,
  1920                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1921                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1922                              <1> ; GNU General Public License for more details.
  1923                              <1> ;
  1924                              <1> ; You should have received a copy of the GNU General Public License
  1925                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1926                              <1> ;
  1927                              <1> ;=========================================================================
  1928                              <1> 
  1929                              <1> ;-------------------------------------------------------------------------
  1930                              <1> ; FDC registers
  1931                              <1> 
  1932                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1933                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1934                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1935                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1936                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1937                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1938                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1939                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1940                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1941                              <1> 
  1942                              <1> ;-------------------------------------------------------------------------
  1943                              <1> ; DMAC registers
  1944                              <1> 
  1945                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1946                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1947                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1948                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1949                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1950                              <1> 					; first / last flip-flop
  1951                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1952                              <1> 
  1953                              <1> ;-------------------------------------------------------------------------
  1954                              <1> ; Floppy disk services - error codes
  1955                              <1> 
  1956                              <1> fdc_e_success	equ	00h		; successful completion
  1957                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1958                              <1> fdc_e_address	equ	02h		; address mark not found
  1959                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1960                              <1> fdc_e_notfound	equ	04h		; sector not found
  1961                              <1> fdc_e_changed	equ	06h		; disk changed
  1962                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1963                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1964                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1965                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1966                              <1> fdc_e_failure	equ	20h		; controller failure
  1967                              <1> fdc_e_seek	equ	40h		; seek failed
  1968                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1969                              <1> 
  1970                              <1> ;-------------------------------------------------------------------------
  1971                              <1> ; Drive media state for fdc_media_state
  1972                              <1> 
  1973                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1974                              <1> 					; 00b = 500 Kbit/sec
  1975                              <1> 					; 01b = 300 Kbit/sec
  1976                              <1> 					; 10b = 250 Kbit/sec
  1977                              <1> 					; 11b = 1 Mbit/sec
  1978                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
  1979                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
  1980                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1981                              <1> 					; 000b = trying 360K in 360K drive
  1982                              <1> 					; 001b = trying 360K in 1.2M drive
  1983                              <1> 					; 010b = trying 1.2M in 1.2M drive
  1984                              <1> 					; 011b = known 360K in 360K drive
  1985                              <1> 					; 100b = known 360K in 1.2M drive
  1986                              <1> 					; 101b = known 1.2M in 1.2M drive
  1987                              <1> 					; 110b = not used
  1988                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
  1989                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1990                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1991                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
  1992                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1993                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1994                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1995                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1996                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1997                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  1998                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  1999                              <1> 
  2000                              <1> ;-------------------------------------------------------------------------
  2001                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  2002                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  2003                              <1> 
  2004                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  2005                              <1> 
  2006                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  2007                              <1> ;	       unset for read or verify
  2008                              <1> 
  2009                              <1> fdc_write_flag	equ	80h		; write or format operation
  2010                              <1> 
  2011                              <1> ;-------------------------------------------------------------------------
  2012                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  2013                              <1> 
  2014                              <1> cmos_no_floppy	equ	00h
  2015                              <1> cmos_360	equ	01h
  2016                              <1> cmos_1200	equ	02h
  2017                              <1> cmos_720	equ	03h
  2018                              <1> cmos_1440	equ	04h
  2019                              <1> cmos_2880	equ	06h
  2020                              <1> 
  2021                              <1> ;=========================================================================
  2022                              <1> ; int_13_fn00: Reset disk system
  2023                              <1> ; Input:
  2024                              <1> ;	AH = 00h
  2025                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2026                              <1> ; Output:
  2027                              <1> ;	CF clear if successful
  2028                              <1> ;		AH = 00h - successful completion
  2029                              <1> ;	CF set on error
  2030                              <1> ;		AH = 20h - controller failure
  2031                              <1> ;		AH = 80h - timeout / device not ready
  2032                              <1> ; Note:
  2033                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2034                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2035                              <1> ;-------------------------------------------------------------------------
  2036                              <1> int_13_fn00:
  2037 000010BF E80700              <1> 	call	fdc_init
  2038 000010C2 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2039 000010C6 E90D5C              <1> 	jmp	int_13_exit
  2040                              <1> 
  2041                              <1> ;=========================================================================
  2042                              <1> ; fdc_init - Initialize floppy disk controller
  2043                              <1> ; Input:
  2044                              <1> ;	none
  2045                              <1> ; Output:
  2046                              <1> ;	CF clear on success
  2047                              <1> ;		AH = 00h - successful completion
  2048                              <1> ;	CF set if error
  2049                              <1> ;		AH = 20h - controller failure
  2050                              <1> ;		AH = 80h - timeout / device not ready
  2051                              <1> ;-------------------------------------------------------------------------
  2052                              <1> fdc_init:
  2053 000010C9 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  2054 000010CE E80906              <1> 	call	fdc_reset		; reset FDC
  2055 000010D1 7257                <1> 	jc	fdc_init_error
  2056 000010D3 BAF403              <1> 	mov	dx,fdc_status_reg
  2057 000010D6 EC                  <1> 	in	al,dx
  2058 000010D7 A880                <1> 	test	al,80h
  2059 000010D9 7404                <1> 	jz	.try_again		; try again if FDC not ready
  2060 000010DB A840                <1> 	test	al,40h
  2061 000010DD 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  2062                              <1> .try_again:
  2063 000010DF E8F805              <1> 	call	fdc_reset
  2064 000010E2 BAF403              <1> 	mov	dx,fdc_status_reg
  2065 000010E5 EC                  <1> 	in	al,dx
  2066 000010E6 A880                <1> 	test	al,80h
  2067 000010E8 7440                <1> 	jz	fdc_init_error
  2068 000010EA A840                <1> 	test	al,40h
  2069 000010EC 753C                <1> 	jnz	fdc_init_error
  2070                              <1> .fdc_ready:
  2071 000010EE B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2072 000010F0 E83905              <1> 	call	fdc_write		; send the command
  2073 000010F3 7235                <1> 	jc	fdc_init_error
  2074 000010F5 E88105              <1> 	call	fdc_read		; read ST0
  2075 000010F8 7230                <1> 	jc	fdc_init_error
  2076 000010FA A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  2077 000010FD 88C4                <1> 	mov	ah,al			; save AL to AH
  2078 000010FF E87705              <1> 	call	fdc_read		; read current cylinder
  2079 00001102 7226                <1> 	jc	fdc_init_error
  2080 00001104 A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  2081 00001107 80E4C0              <1> 	and	ah,0C0h
  2082 0000110A 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  2083 0000110D 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  2084                              <1> 
  2085                              <1> ; fall through to fdc_send_specify
  2086                              <1> 
  2087                              <1> ;=========================================================================
  2088                              <1> ; fdc_send_specify - Send specify command to FDC
  2089                              <1> ; Input:
  2090                              <1> ;	none
  2091                              <1> ; Output:
  2092                              <1> ;	CF clear on success
  2093                              <1> ;		AH = 00 - successful completion
  2094                              <1> ;	CF set if error
  2095                              <1> ;		AH = 20h - controller failure
  2096                              <1> ;	AX,CL,SI trashed
  2097                              <1> ; Note:
  2098                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  2099                              <1> ;-------------------------------------------------------------------------
  2100                              <1> fdc_send_specify:
  2101                              <1> 
  2102 0000110F 1E                  <1> 	push	ds
  2103 00001110 31C0                <1> 	xor	ax,ax
  2104 00001112 8ED8                <1> 	mov	ds,ax
  2105 00001114 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2106 00001118 B003                <1> 	mov	al,3		 	; FDC Specify command
  2107 0000111A 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  2108 0000111C 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  2109 0000111F B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  2110 00001121 1F                  <1> 	pop	ds
  2111 00001122 E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  2112 00001125 7203                <1> 	jc	fdc_init_error
  2113 00001127 B400                <1> 	mov	ah,fdc_e_success	; successful completion
  2114 00001129 C3                  <1> 	ret
  2115                              <1> 
  2116                              <1> fdc_init_error:
  2117 0000112A B420                <1> 	mov	ah,fdc_e_failure
  2118 0000112C F9                  <1> 	stc
  2119 0000112D C3                  <1> 	ret
  2120                              <1> 
  2121                              <1> ;=========================================================================
  2122                              <1> ; int_13_fn01 - Get status of last operation
  2123                              <1> ; Input:
  2124                              <1> ;	AH = 01h
  2125                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2126                              <1> ; Output:
  2127                              <1> ;	CF clear if last operation was successful
  2128                              <1> ;		AH = 00h - successful completion
  2129                              <1> ;	CF set on error
  2130                              <1> ;		AH - error code of the last operation
  2131                              <1> ; Note:
  2132                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2133                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2134                              <1> ;-------------------------------------------------------------------------
  2135                              <1> int_13_fn01:
  2136 0000112E 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  2137 00001132 08E4                <1> 	or	ah,ah
  2138 00001134 7401                <1> 	jz	.no_error
  2139 00001136 F9                  <1> 	stc
  2140                              <1> .no_error:
  2141 00001137 E99C5B              <1> 	jmp	int_13_exit
  2142                              <1> 
  2143                              <1> ;=========================================================================
  2144                              <1> ; int_13_fn08: Get drive parameters
  2145                              <1> ; Input:
  2146                              <1> ;	AH = 08h
  2147                              <1> ;	DL = drive number (0 - 7Fh)
  2148                              <1> ; Output:
  2149                              <1> ;	CF clear if successful
  2150                              <1> ;		AX = 0000h
  2151                              <1> ;		BH = 00h
  2152                              <1> ;		BL = CMOS drive type
  2153                              <1> ;		CH = maximal cylinder number - 1
  2154                              <1> ;		CL = maximal sector number
  2155                              <1> ;		DH = maximal head number
  2156                              <1> ;		DL = number of drives
  2157                              <1> ;		ES:DI -> diskette parameter table
  2158                              <1> ;	CF set on error
  2159                              <1> ;		AH = 01h - drive number is greater than 7Fh
  2160                              <1> ; Notes:
  2161                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  2162                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  2163                              <1> ;	- If media type is not established function sets media parameters 
  2164                              <1> ;	based on CMOS drive type
  2165                              <1> ;-------------------------------------------------------------------------
  2166                              <1> int_13_fn08:
  2167 0000113A 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  2168 0000113D 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  2169 00001142 A01000              <1> 	mov	al,byte [equipment_list]
  2170 00001145 2441                <1> 	and	al,equip_floppies|equip_floppy2
  2171 00001147 B402                <1> 	mov	ah,2			; assume two floppy drives
  2172 00001149 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  2173 0000114B 7406                <1> 	je	.check_drive_number
  2174 0000114D FECC                <1> 	dec	ah			; assume one floppy drive
  2175 0000114F 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  2176 00001151 757C                <1> 	jne	.no_drives
  2177                              <1> 
  2178                              <1> .check_drive_number:
  2179 00001153 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  2180 00001156 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  2181                              <1> 					; than number of disks?
  2182 00001158 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  2183 0000115A E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  2184 0000115D 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  2185                              <1> 
  2186 0000115F C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  2187 00001163 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  2188 00001166 8CC9                <1> 	mov	cx,cs
  2189 00001168 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  2190                              <1> 
  2191 0000116A 3C01                <1> 	cmp	al,cmos_360
  2192 0000116C 7417                <1> 	je	.set_360
  2193 0000116E 3C03                <1> 	cmp	al,cmos_720
  2194 00001170 741E                <1> 	je	.set_720
  2195 00001172 3C02                <1> 	cmp	al,cmos_1200
  2196 00001174 7425                <1> 	je	.set_1200
  2197 00001176 3C04                <1> 	cmp	al,cmos_1440
  2198 00001178 742C                <1> 	je	.set_1440
  2199                              <1> 
  2200                              <1> .set_2880:
  2201 0000117A B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  2202 0000117C 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  2203 00001180 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  2204 00001183 EB2A                <1> 	jmp	.set_media_type
  2205                              <1> 
  2206                              <1> .set_360:
  2207 00001185 B093                <1> 	mov	al,fdc_m_360in360
  2208 00001187 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2209 0000118B B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  2210 0000118E EB1F                <1> 	jmp	.set_media_type
  2211                              <1> 
  2212                              <1> .set_720:
  2213 00001190 B097                <1> 	mov	al,fdc_m_720
  2214 00001192 8D3E[896F]          <1> 	lea	di,[media_720]
  2215 00001196 B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  2216 00001199 EB14                <1> 	jmp	.set_media_type
  2217                              <1> 
  2218                              <1> .set_1200:
  2219 0000119B B002                <1> 	mov	al,fdc_m_try_1200in1200
  2220 0000119D 8D3E[7C6F]          <1> 	lea	di,[media_1200]
  2221 000011A1 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  2222 000011A4 EB09                <1> 	jmp	.set_media_type
  2223                              <1> 
  2224                              <1> .set_1440:
  2225 000011A6 B007                <1> 	mov	al,fdc_m_try_1440
  2226 000011A8 8D3E[966F]          <1> 	lea	di,[media_1440]
  2227 000011AC B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  2228                              <1> 
  2229                              <1> .set_media_type:
  2230 000011AF BB9000              <1> 	mov	bx,fdc_media_state
  2231 000011B2 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2232 000011B4 F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  2233 000011B7 7502                <1> 	jnz	.set_parameters		; no need to update if established
  2234 000011B9 8807                <1> 	mov	[bx],al
  2235                              <1> 
  2236                              <1> .set_parameters:
  2237 000011BB 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  2238 000011BD 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  2239 000011C0 A24100              <1> 	mov	byte [fdc_last_error],al
  2240 000011C3 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  2241 000011C6 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  2242 000011C9 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  2243 000011CC E9075B              <1> 	jmp	int_13_exit
  2244                              <1> 
  2245                              <1> .no_drives:
  2246 000011CF C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  2247                              <1> 
  2248                              <1> .non_existent_drive:
  2249 000011D3 31C9                <1> 	xor	cx,cx
  2250 000011D5 31FF                <1> 	xor	di,di
  2251 000011D7 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  2252 000011DA 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  2253 000011DD 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  2254 000011DF EBDA                <1> 	jmp	.set_parameters
  2255                              <1> 
  2256                              <1> .invalid_drive:
  2257 000011E1 B401                <1> 	mov	ah,fdc_e_invalid
  2258 000011E3 F9                  <1> 	stc
  2259 000011E4 E9EF5A              <1> 	jmp	int_13_exit
  2260                              <1> 
  2261                              <1> ;=========================================================================
  2262                              <1> ; int_13_fn15: Get disk type
  2263                              <1> ; Input:
  2264                              <1> ;	AH = 15h
  2265                              <1> ;	DL = drive number (0 or 1)
  2266                              <1> ; Output:
  2267                              <1> ;	AH = type code:
  2268                              <1> ;		00h - no such drive (invalid drive specified)
  2269                              <1> ;		01h - floppy without change-line support
  2270                              <1> ;		02h - floppy with change-line support
  2271                              <1> ;-------------------------------------------------------------------------
  2272                              <1> int_13_fn15:
  2273 000011E7 B400                <1> 	mov	ah,00h			; assume no drive
  2274 000011E9 80FA01              <1> 	cmp	dl,1
  2275 000011EC 7711                <1> 	ja	.exit			; jump if invalid drive number
  2276 000011EE E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  2277 000011F1 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  2278 000011F3 B401                <1> 	mov	ah,01h			; assume no change-line support
  2279 000011F5 3C01                <1> 	cmp	al,cmos_360
  2280 000011F7 7406                <1> 	je	.exit
  2281 000011F9 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  2282 000011FB 7402                <1> 	je	.exit
  2283 000011FD B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  2284                              <1> 
  2285                              <1> .exit:
  2286 000011FF F8                  <1> 	clc
  2287 00001200 C606410000          <1> 	mov	byte [fdc_last_error],0
  2288 00001205 E9CE5A              <1> 	jmp	int_13_exit
  2289                              <1> 
  2290                              <1> ;=========================================================================
  2291                              <1> ; int_13_fn16 - Detect disk change
  2292                              <1> ; Input:
  2293                              <1> ;	AH = 16h
  2294                              <1> ;	DL = drive number (0 or 1)
  2295                              <1> ; Output:
  2296                              <1> ;	CF clear if change line inactive
  2297                              <1> ;		AH = 00h - disk not changed
  2298                              <1> ;	CF set if change line active or error
  2299                              <1> ;		AH = 01h - invalid drive number
  2300                              <1> ;		AH = 06h - disk changed or change line not supported
  2301                              <1> ;		AH = 80h - timeout / device not ready
  2302                              <1> ;-------------------------------------------------------------------------
  2303                              <1> int_13_fn16:
  2304 00001208 80FA01              <1> 	cmp	dl,1
  2305 0000120B 7741                <1> 	ja	.invalid_drive
  2306 0000120D E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  2307 00001210 723C                <1> 	jc	.invalid_drive
  2308                              <1> 
  2309 00001212 3C01                <1> 	cmp	al,cmos_360
  2310 00001214 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  2311 00001216 3C03                <1> 	cmp	al,cmos_720
  2312 00001218 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  2313                              <1> 
  2314 0000121A E86302              <1> 	call	fdc_motor_on		; turn motor on
  2315 0000121D 30E4                <1> 	xor	ah,ah			; assume disk not changed
  2316 0000121F BAF703              <1> 	mov	dx,fdc_dir_reg
  2317 00001222 EC                  <1> 	in	al,dx			; read disk change line
  2318 00001223 D0E0                <1> 	shl	al,1			; bit 7 to CF
  2319 00001225 7303                <1> 	jnc	.exit
  2320 00001227 B406                <1> 	mov	ah,fdc_e_changed
  2321 00001229 F9                  <1> 	stc
  2322                              <1> 
  2323                              <1> .exit:
  2324 0000122A 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2325 0000122E 9C                  <1> 	pushf
  2326 0000122F 1E                  <1> 	push	ds
  2327 00001230 31F6                <1> 	xor	si,si
  2328 00001232 8EDE                <1> 	mov	ds,si
  2329 00001234 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2330 00001238 8A4C02              <1> 	mov	cl,byte [si+2]
  2331 0000123B 1F                  <1> 	pop	ds
  2332 0000123C 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  2333 00001240 9D                  <1> 	popf
  2334 00001241 E9925A              <1> 	jmp	int_13_exit
  2335                              <1> 
  2336                              <1> 
  2337                              <1> .no_change_line:
  2338 00001244 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  2339 00001246 F9                  <1> 	stc
  2340 00001247 88264100            <1> 	mov	byte [fdc_last_error],ah
  2341 0000124B E9885A              <1> 	jmp	int_13_exit
  2342                              <1> 
  2343                              <1> .invalid_drive:
  2344 0000124E B401                <1> 	mov	ah,fdc_e_invalid
  2345 00001250 F9                  <1> 	stc
  2346 00001251 E9825A              <1> 	jmp	int_13_exit
  2347                              <1> 
  2348                              <1> ;=========================================================================
  2349                              <1> ; int_13_fn17 - Set disk type for format
  2350                              <1> ; Input:
  2351                              <1> ;	AH = 17h
  2352                              <1> ;	AL = format type
  2353                              <1> ;		01h - 320K / 360K disk in 360K drive
  2354                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  2355                              <1> ;		03h - 1.2M disk in 1.2M drive
  2356                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  2357                              <1> ;	DL = drive number (0 or 1)
  2358                              <1> ; Output:
  2359                              <1> ;	CF clear if successful
  2360                              <1> ;		AH = 00h - successful completion
  2361                              <1> ;	CF set on error
  2362                              <1> ;		AH = 01h - invalid drive number
  2363                              <1> ;		AH = 06h - disk changed
  2364                              <1> ;		AH = 80h - timeout / device not ready
  2365                              <1> ;-------------------------------------------------------------------------
  2366                              <1> int_13_fn17:
  2367 00001254 80FA01              <1> 	cmp	dl,1
  2368 00001257 7762                <1> 	ja	.invalid_parameters
  2369 00001259 E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  2370 0000125C 725D                <1> 	jc	.invalid_parameters
  2371 0000125E 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  2372 00001261 80F900              <1> 	cmp	cl,0			; validate parameters
  2373 00001264 7455                <1> 	je	.invalid_parameters
  2374 00001266 80F904              <1> 	cmp	cl,4
  2375 00001269 7750                <1> 	ja	.invalid_parameters
  2376 0000126B BB9000              <1> 	mov	bx,fdc_media_state
  2377 0000126E 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2378 00001270 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  2379 00001273 7507                <1> 	jne	.not_360in360
  2380 00001275 C60793              <1> 	mov	byte [bx],fdc_m_360in360
  2381 00001278 B400                <1> 	mov	ah,0			; no error
  2382 0000127A EB33                <1> 	jmp	.exit_check_error
  2383                              <1> 
  2384                              <1> .not_360in360:
  2385 0000127C E80102              <1> 	call	fdc_motor_on
  2386 0000127F 89DE                <1> 	mov	si,bx
  2387 00001281 E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  2388 00001284 80FC06              <1> 	cmp	ah,fdc_e_changed
  2389 00001287 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  2390 00001289 80FC80              <1> 	cmp	ah,fdc_e_timeout
  2391 0000128C 750A                <1> 	jne	.set_type		; floppy disk is installed
  2392 0000128E 803F97              <1> 	cmp	byte [bx],fdc_m_720	; 250 Kbps and not 5.25?
  2393 00001291 741C                <1> 	je	.exit_check_error
  2394 00001293 C60761              <1> 	mov	byte [bx],fdc_m_try_360in1200 ; 300 Kpbs, try 360 in 1.2M
  2395 00001296 EB17                <1> 	jmp	.exit_check_error
  2396                              <1> 
  2397                              <1> .set_type:
  2398 00001298 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  2399 0000129B 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  2400 0000129D C60797              <1> 	mov	byte [bx],fdc_m_720
  2401 000012A0 EB0D                <1> 	jmp	.exit_check_error
  2402                              <1> 
  2403                              <1> .check_360in1200:
  2404 000012A2 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  2405 000012A5 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  2406 000012A7 C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  2407 000012AA EB03                <1> 	jmp	.exit_check_error
  2408                              <1> 
  2409                              <1> .set_1200in1200:
  2410 000012AC C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  2411                              <1> 
  2412                              <1> .exit_check_error:
  2413 000012AF 88264100            <1> 	mov	byte [fdc_last_error],ah
  2414 000012B3 08E4                <1> 	or	ah,ah
  2415 000012B5 7401                <1> 	jz	.exit			; jump if no error
  2416 000012B7 F9                  <1> 	stc				; indicate error
  2417                              <1> 
  2418                              <1> .exit:
  2419 000012B8 E9FA59              <1> 	jmp	int_13_upd_exit
  2420                              <1> 
  2421                              <1> .invalid_parameters:
  2422 000012BB B401                <1> 	mov	ah,fdc_e_invalid
  2423 000012BD EBF9                <1> 	jmp	.exit
  2424                              <1> 
  2425                              <1> ;=========================================================================
  2426                              <1> ; int_13_fn18 - Set media type for format
  2427                              <1> ; Input:
  2428                              <1> ;	AH = 18h
  2429                              <1> ;	DL = drive number (0 or 1)
  2430                              <1> ;	CH = number of cylinders - 1
  2431                              <1> ;	CL = sectors per track
  2432                              <1> ; Output:
  2433                              <1> ;	CF = clear if successful
  2434                              <1> ;		AH = 00h - requested format is supported
  2435                              <1> ;		ES:DI -> diskette parameter table
  2436                              <1> ;	CF = set on error
  2437                              <1> ;		AH = 01h - invalid drive number specified
  2438                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  2439                              <1> ;-------------------------------------------------------------------------
  2440                              <1> int_13_fn18:
  2441 000012BF 80FA01              <1> 	cmp	dl,1
  2442 000012C2 7603E99900          <1> 	ja	.invalid_drive
  2443 000012C7 E84504              <1> 	call	read_cmos_type		; get drive type in AL
  2444 000012CA 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  2445                              <1> 
  2446 000012CF BB9000              <1> 	mov	bx,fdc_media_state
  2447 000012D2 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2448                              <1> 
  2449 000012D4 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  2450 000012D6 7511                <1> 	jne	.try_drive_1200
  2451 000012D8 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  2452 000012DC 7403E98300          <1> 	jnz	.unsupported_format
  2453 000012E1 B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
  2454 000012E3 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2455 000012E7 EB54                <1> 	jmp	.set_media
  2456                              <1> 
  2457                              <1> .try_drive_1200:
  2458 000012E9 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2459 000012EB 751C                <1> 	jne	.try_drive_2880
  2460 000012ED 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2461 000012F1 7508                <1> 	jne	.try_media_360_in_1200
  2462 000012F3 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
  2463 000012F5 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
  2464 000012F9 EB42                <1> 	jmp	.set_media
  2465                              <1> 
  2466                              <1> .try_media_360_in_1200:
  2467 000012FB 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2468 000012FF 7563                <1> 	jne	.unsupported_format
  2469 00001301 B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
  2470 00001303 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2471 00001307 EB34                <1> 	jmp	.set_media
  2472                              <1> 
  2473                              <1> .try_drive_2880:
  2474 00001309 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2475 0000130B 750E                <1> 	jne	.try_drive_1440
  2476 0000130D 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2477 00001311 750C                <1> 	jne	.try_media_1440
  2478 00001313 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2479 00001315 8D3E[B06F]          <1> 	lea	di,[media_2880]
  2480 00001319 EB22                <1> 	jmp	.set_media
  2481                              <1> 
  2482                              <1> .try_drive_1440:
  2483 0000131B 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2484 0000131D 750E                <1> 	jne	.try_drive_720
  2485                              <1> 
  2486                              <1> .try_media_1440:
  2487 0000131F 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2488 00001323 750C                <1> 	jne	.try_media_720
  2489 00001325 B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2490 00001327 8D3E[966F]          <1> 	lea	di,[media_1440]
  2491 0000132B EB10                <1> 	jmp	.set_media
  2492                              <1> 
  2493                              <1> .try_drive_720:
  2494 0000132D 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2495 0000132F 7533                <1> 	jne	.unsupported_format	; should never happen...
  2496                              <1> 
  2497                              <1> .try_media_720:	
  2498 00001331 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2499 00001335 752D                <1> 	jne	.unsupported_format
  2500 00001337 B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
  2501 00001339 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
  2502                              <1> 
  2503                              <1> .set_media:
  2504 0000133D 8807                <1> 	mov	byte [bx],al		; set physical media
  2505 0000133F E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2506 00001342 D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2507 00001344 D0C8                <1> 	ror	al,1
  2508 00001346 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2509 0000134B 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2510 0000134F 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2511 00001352 8CC9                <1> 	mov	cx,cs
  2512 00001354 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2513 00001356 C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2514 0000135B 30E4                <1> 	xor	ah,ah
  2515 0000135D E95559              <1> 	jmp	int_13_upd_exit
  2516                              <1> 
  2517                              <1> .invalid_drive:
  2518 00001360 B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2519 00001362 EB02                <1> 	jmp	.error
  2520                              <1> 
  2521                              <1> .unsupported_format:
  2522 00001364 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2523                              <1> 
  2524                              <1> .error:
  2525 00001366 F9                  <1> 	stc
  2526 00001367 E94B59              <1> 	jmp	int_13_upd_exit
  2527                              <1> 
  2528                              <1> ;=========================================================================
  2529                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2530                              <1> ; Input:
  2531                              <1> ;	DL = drive number (0 or 1)
  2532                              <1> ; Output:
  2533                              <1> ;	CF clear if successful
  2534                              <1> ;		AH = 00h - successful completion
  2535                              <1> ;	CF set on error
  2536                              <1> ;		AH = 20h - controller failure
  2537                              <1> ;		AH = 20h - timeout
  2538                              <1> ;	AH trashed
  2539                              <1> ;-------------------------------------------------------------------------
  2540                              <1> fdc_recalibrate:
  2541 0000136A 56                  <1> 	push	si
  2542 0000136B 51                  <1> 	push	cx
  2543 0000136C 52                  <1> 	push	dx
  2544 0000136D B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2545 0000136F 88D4                <1> 	mov	ah,dl			; drive number
  2546 00001371 B102                <1> 	mov	cl,2			; 2 bytes command
  2547 00001373 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2548 00001378 E86502              <1> 	call	fdc_send_cmd
  2549 0000137B 7244                <1> 	jc	recal_end		; failure
  2550 0000137D E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2551 00001380 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2552 00001382 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2553 00001384 B101                <1> 	mov	cl,1			; 1 byte command
  2554 00001386 E85702              <1> 	call	fdc_send_cmd
  2555 00001389 7236                <1> 	jc	recal_end		; failure
  2556 0000138B B90200              <1> 	mov	cx,2			; 2 bytes result
  2557 0000138E E8B402              <1> 	call	fdc_get_result		; store result
  2558 00001391 722E                <1> 	jc	recal_end		; failure
  2559 00001393 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2560 00001396 B440                <1> 	mov	ah,fdc_e_seek
  2561 00001398 8A17                <1> 	mov	dl,[bx]			; ST0
  2562 0000139A 80E260              <1> 	and	dl,60h
  2563 0000139D 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2564 000013A0 F9                  <1> 	stc				; indicate error
  2565 000013A1 741E                <1> 	je	recal_end		; failure
  2566 000013A3 5A                  <1> 	pop	dx
  2567 000013A4 52                  <1> 	push	dx
  2568 000013A5 30F6                <1> 	xor	dh,dh				 
  2569 000013A7 BB9400              <1> 	mov	bx,fdc_cylinder
  2570 000013AA 01D3                <1> 	add	bx,dx
  2571 000013AC C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2572 000013AF 88D1                <1> 	mov	cl,dl
  2573 000013B1 B201                <1> 	mov	dl,1
  2574 000013B3 D2E2                <1> 	shl	dl,cl
  2575 000013B5 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2576 000013B9 B94300              <1> 	mov	cx,43h
  2577 000013BC E868FB              <1> 	call	delay_15us		; 1 ms delay
  2578 000013BF 30E4                <1> 	xor	ah,ah
  2579                              <1> 
  2580                              <1> recal_end:
  2581 000013C1 88264100            <1> 	mov	byte [fdc_last_error],ah
  2582 000013C5 5A                  <1> 	pop	dx
  2583 000013C6 59                  <1> 	pop	cx
  2584 000013C7 5E                  <1> 	pop	si
  2585 000013C8 C3                  <1> 	ret
  2586                              <1> 
  2587                              <1> ;=========================================================================
  2588                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2589                              <1> ; Input:
  2590                              <1> ;	DL = drive number
  2591                              <1> ;	DH = head number
  2592                              <1> ;	CH = cylinder
  2593                              <1> ; Output:
  2594                              <1> ;	CF clear if successful
  2595                              <1> ;		AH = 00h - successful completion
  2596                              <1> ;	CF set on error
  2597                              <1> ;		AH = 20h - controller failure
  2598                              <1> ;		AH = 40h - seek failed
  2599                              <1> ;		AH = 80h - timeout / device not ready
  2600                              <1> ;-------------------------------------------------------------------------
  2601                              <1> fdc_seek:
  2602 000013C9 53                  <1> 	push	bx
  2603 000013CA 51                  <1> 	push	cx
  2604 000013CB 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2605 000013CF 88D1                <1> 	mov	cl,dl
  2606 000013D1 FEC1                <1> 	inc	cl
  2607 000013D3 D2EC                <1> 	shr	ah,cl
  2608 000013D5 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2609 000013D7 E890FF              <1> 	call	fdc_recalibrate
  2610 000013DA 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2611 000013DC E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2612 000013DF 727F                <1> 	jc	.exit			; no luck...
  2613                              <1> 
  2614                              <1> .skip_recalibrate:
  2615 000013E1 B700                <1> 	mov	bh,00h
  2616 000013E3 88D3                <1> 	mov	bl,dl			; BX = drive number
  2617 000013E5 F687900020          <1> 	test	byte [fdc_media_state+bx],fdc_m_double_step ; check double
  2618                              <1> 					; steppig bit
  2619 000013EA 7402                <1> 	jz	.no_double_stepping
  2620 000013EC D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2621                              <1> 
  2622                              <1> .no_double_stepping:
  2623 000013EE 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2624 000013F2 750B                <1> 	jne	.do_seek		; jump if seek is required
  2625 000013F4 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2626 000013F9 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2627 000013FB 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2628 000013FD EB61                <1> 	jmp	.exit
  2629                              <1> 
  2630                              <1> .do_seek:
  2631 000013FF 88E8                <1> 	mov	al,ch			; cylinder
  2632 00001401 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2633 00001403 B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2634 00001405 88F4                <1> 	mov	ah,dh			; head
  2635 00001407 D0E4                <1> 	shl	ah,1
  2636 00001409 D0E4                <1> 	shl	ah,1
  2637 0000140B 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2638 0000140D B103                <1> 	mov	cl,3			; 3 bytes command
  2639 0000140F 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2640 00001414 E8C901              <1> 	call	fdc_send_cmd
  2641 00001417 7243                <1> 	jc	.set_result		; seek error
  2642 00001419 E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2643 0000141C 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2644                              <1> 
  2645 0000141E B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2646 00001420 B101                <1> 	mov	cl,1			; 1 byte command
  2647 00001422 E8BB01              <1> 	call	fdc_send_cmd
  2648 00001425 7235                <1> 	jc	.set_result		; failure
  2649 00001427 B102                <1> 	mov	cl,2
  2650 00001429 53                  <1> 	push	bx
  2651 0000142A E81802              <1> 	call	fdc_get_result		; read result bytes
  2652 0000142D 5B                  <1> 	pop	bx
  2653 0000142E 722C                <1> 	jc	.set_result		; error
  2654 00001430 B440                <1> 	mov	ah,fdc_e_seek
  2655 00001432 A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2656 00001435 2460                <1> 	and	al,60h
  2657 00001437 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2658 00001439 F9                  <1> 	stc
  2659 0000143A 7420                <1> 	je	.set_result		; seek error
  2660 0000143C 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2661                              <1> 
  2662 00001440 1E                  <1> 	push	ds
  2663 00001441 31F6                <1> 	xor	si,si
  2664 00001443 8EDE                <1> 	mov	ds,si
  2665 00001445 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2666 00001449 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2667 0000144C 1F                  <1> 	pop	ds
  2668                              <1> 
  2669 0000144D 08C0                <1> 	or	al,al			; head settle time is zero?!
  2670 0000144F 7412                <1> 	jz	.get_settle_time
  2671                              <1> 
  2672 00001451 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2673 00001453 F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2674 00001455 89C1                <1> 	mov	cx,ax
  2675                              <1> 
  2676                              <1> .wait:
  2677 00001457 E8CDFA              <1> 	call	delay_15us
  2678                              <1> 
  2679                              <1> .wait_end:
  2680 0000145A 30E4                <1> 	xor	ah,ah
  2681                              <1> 
  2682                              <1> .set_result:
  2683 0000145C 88264100            <1> 	mov	byte [fdc_last_error],ah
  2684                              <1> 
  2685                              <1> .exit:
  2686 00001460 59                  <1> 	pop	cx
  2687 00001461 5B                  <1> 	pop	bx
  2688 00001462 C3                  <1> 	ret
  2689                              <1> 
  2690                              <1> .get_settle_time:
  2691 00001463 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2692 00001468 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2693                              <1> 	
  2694 0000146A 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2695 0000146E 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2696 00001471 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2697 00001474 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2698 00001476 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2699 00001479 74DC                <1> 	je	.wait			; jump if 360K, media established
  2700 0000147B B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2701 0000147E EBD7                <1> 	jmp	.wait
  2702                              <1> 
  2703                              <1> ;=========================================================================
  2704                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2705                              <1> ; Input:
  2706                              <1> ;	DL = drive number (0 or 1)
  2707                              <1> ; Output:
  2708                              <1> ;	none
  2709                              <1> ;-------------------------------------------------------------------------
  2710                              <1> fdc_motor_on:
  2711 00001480 50                  <1> 	push	ax
  2712 00001481 51                  <1> 	push	cx
  2713 00001482 52                  <1> 	push	dx
  2714 00001483 FA                  <1> 	cli				; entering critical section
  2715 00001484 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2716 00001489 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2717 0000148E 88D1                <1> 	mov	cl,dl			; CL = drive number
  2718 00001490 D0E2                <1> 	shl	dl,1
  2719 00001492 D0E2                <1> 	shl	dl,1
  2720 00001494 D0E2                <1> 	shl	dl,1
  2721 00001496 D0E2                <1> 	shl	dl,1
  2722 00001498 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2723 0000149C FEC1                <1> 	inc	cl
  2724 0000149E 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2725 000014A2 D2EA                <1> 	shr	dl,cl
  2726 000014A4 7255                <1> 	jc	.already_on
  2727 000014A6 B201                <1> 	mov	dl,1
  2728 000014A8 FEC9                <1> 	dec	cl
  2729 000014AA D2E2                <1> 	shl	dl,cl
  2730 000014AC 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2731 000014B0 FB                  <1> 	sti				; end of critical section
  2732 000014B1 A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2733 000014B4 D0C8                <1> 	ror	al,1
  2734 000014B6 D0C8                <1> 	ror	al,1
  2735 000014B8 D0C8                <1> 	ror	al,1
  2736 000014BA D0C8                <1> 	ror	al,1
  2737 000014BC 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2738 000014BE BAF203              <1> 	mov	dx,fdc_dor_reg
  2739 000014C1 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2740 000014C2 B8FD90              <1> 	mov	ax,90FDh
  2741 000014C5 CD15                <1> 	int	15h			; call OS hook
  2742 000014C7 722E                <1> 	jc	.exit
  2743 000014C9 1E                  <1> 	push	ds
  2744 000014CA 56                  <1> 	push	si
  2745 000014CB 31F6                <1> 	xor	si,si
  2746 000014CD 8EDE                <1> 	mov	ds,si
  2747 000014CF C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2748 000014D3 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2749 000014D6 5E                  <1> 	pop	si
  2750 000014D7 1F                  <1> 	pop	ds
  2751                              <1> 
  2752 000014D8 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2753 000014DD 7408                <1> 	jz	.read_verify		; jump if not write operation
  2754 000014DF 3C08                <1> 	cmp	al,8
  2755 000014E1 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2756 000014E3 B008                <1> 	mov	al,8			; wait at least 1 second for write
  2757 000014E5 EB06                <1> 	jmp	.wait_loop
  2758                              <1> 
  2759                              <1> .read_verify:
  2760 000014E7 3C05                <1> 	cmp	al,5
  2761 000014E9 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2762 000014EB B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2763                              <1> 
  2764                              <1> .wait_loop:
  2765 000014ED B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2766 000014F0 E834FA              <1> 	call	delay_15us		; wait 125 ms
  2767 000014F3 FEC8                <1> 	dec	al
  2768 000014F5 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2769                              <1> 
  2770                              <1> .exit:
  2771 000014F7 59                  <1> 	pop	cx
  2772 000014F8 5A                  <1> 	pop	dx
  2773 000014F9 58                  <1> 	pop	ax
  2774 000014FA C3                  <1> 	ret
  2775                              <1> 
  2776                              <1> .already_on:
  2777 000014FB FB                  <1> 	sti
  2778 000014FC A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2779 000014FF D0C8                <1> 	ror	al,1
  2780 00001501 D0C8                <1> 	ror	al,1
  2781 00001503 D0C8                <1> 	ror	al,1
  2782 00001505 D0C8                <1> 	ror	al,1
  2783 00001507 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2784 00001509 BAF203              <1> 	mov	dx,fdc_dor_reg
  2785 0000150C EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2786 0000150D EBE8                <1> 	jmp	.exit
  2787                              <1> 
  2788                              <1> ;=========================================================================
  2789                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2790                              <1> ; Input:
  2791                              <1> ;	CH = cylinder
  2792                              <1> ;	DH = head
  2793                              <1> ; Output:
  2794                              <1> ;	BL = next sector to be transferred
  2795                              <1> ;-------------------------------------------------------------------------	
  2796                              <1> 
  2797                              <1> fdc_end_io:
  2798 0000150F 50                  <1> 	push	ax
  2799 00001510 1E                  <1> 	push	ds
  2800 00001511 31DB                <1> 	xor	bx,bx
  2801 00001513 8EDB                <1> 	mov	ds,bx
  2802 00001515 C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2803 00001519 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2804 0000151C 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2805 0000151F FEC0                <1> 	inc	al
  2806 00001521 1F                  <1> 	pop	ds
  2807 00001522 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2808 00001525 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2809 00001528 7508                <1> 	jne	.exit
  2810 0000152A 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2811 0000152D 7503                <1> 	jne	.exit
  2812 0000152F 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2813                              <1> .exit:
  2814 00001532 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2815 00001536 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2816 00001538 58                  <1> 	pop	ax
  2817 00001539 C3                  <1> 	ret
  2818                              <1> 
  2819                              <1> ;========================================================================
  2820                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2821                              <1> ; Input:
  2822                              <1> ;	AL = CMOS drive type
  2823                              <1> ;	DS:SI -> drive media type
  2824                              <1> ; Output:
  2825                              <1> ;	CF clear if disk not changed
  2826                              <1> ;		AH = 00h - disk not changed
  2827                              <1> ;	CF set if disk changed or on error
  2828                              <1> ;		AH = 06h - disk changed
  2829                              <1> ;		AH = error code
  2830                              <1> ; Note:
  2831                              <1> ;	Motor needs to be turned on before calling this function
  2832                              <1> ;------------------------------------------------------------------------
  2833                              <1> fdc_disk_change:
  2834 0000153A 51                  <1> 	push	cx
  2835 0000153B B400                <1> 	mov	ah,0
  2836 0000153D 3C01                <1> 	cmp	al,cmos_360
  2837 0000153F 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2838 00001541 3C03                <1> 	cmp	al,cmos_720
  2839 00001543 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2840                              <1> .cmos_invalid:
  2841 00001545 8A04                <1> 	mov	al,[si]			; media type
  2842 00001547 2407                <1> 	and	al,fdc_m_state_bits
  2843 00001549 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2844 0000154B 3C03                <1> 	cmp	al,3
  2845 0000154D 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2846 0000154F BAF703              <1> 	mov	dx,fdc_dir_reg
  2847 00001552 EC                  <1> 	in	al,dx			; read disk change line
  2848 00001553 D0E0                <1> 	shl	al,1
  2849 00001555 7326                <1> 	jnc	.exit			; no disk change
  2850 00001557 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2851 0000155A E86CFB              <1> 	call	fdc_init		; full initialization
  2852 0000155D 721E                <1> 	jc	.exit
  2853 0000155F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2854 00001562 B501                <1> 	mov	ch,1
  2855 00001564 E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2856 00001567 7214                <1> 	jc	.exit
  2857 00001569 B500                <1> 	mov	ch,0
  2858 0000156B E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2859 0000156E 720D                <1> 	jc	.exit
  2860 00001570 B406                <1> 	mov	ah,fdc_e_changed
  2861 00001572 BAF703              <1> 	mov	dx,fdc_dir_reg
  2862 00001575 EC                  <1> 	in	al,dx			; read disk change line
  2863 00001576 D0E0                <1> 	shl	al,1
  2864 00001578 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2865 0000157A B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2866                              <1> 
  2867                              <1> .changed_or_error:
  2868 0000157C F9                  <1> 	stc
  2869                              <1> 
  2870                              <1> .exit:
  2871 0000157D 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2872 00001580 59                  <1> 	pop	cx
  2873 00001581 C3                  <1> 	ret
  2874                              <1> 
  2875                              <1> ;=========================================================================
  2876                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2877                              <1> ; Input:
  2878                              <1> ;	AL = DMA mode byte
  2879                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2880                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2881                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2882                              <1> ;	CX = byte count (minus 1)
  2883                              <1> ;	ES:BX -> buffer address for DMA operation
  2884                              <1> ; Output:
  2885                              <1> ;	CF clear on success
  2886                              <1> ;	CF set if error
  2887                              <1> ;		AH = 08h - DMA overrun
  2888                              <1> ;	AX,BX trashed
  2889                              <1> ; Note:
  2890                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2891                              <1> ;-------------------------------------------------------------------------
  2892                              <1> fdc_configure_dma:
  2893 00001582 52                  <1> 	push	dx
  2894 00001583 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2895 00001585 D1C2                <1> 	rol	dx,1
  2896 00001587 D1C2                <1> 	rol	dx,1
  2897 00001589 D1C2                <1> 	rol	dx,1
  2898 0000158B D1C2                <1> 	rol	dx,1
  2899 0000158D 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2900 0000158F 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2901 00001592 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2902 00001595 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2903 00001597 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2904                              <1> 
  2905 0000159A 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2906 0000159C 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2907 0000159E 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2908                              <1> 
  2909 000015A0 FA                  <1> 	cli
  2910 000015A1 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2911 000015A3 EB00                <1> 	jmp	$+2
  2912 000015A5 EB00                <1> 	jmp	$+2
  2913 000015A7 E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2914 000015A9 EB00                <1> 	jmp	$+2
  2915 000015AB EB00                <1> 	jmp	$+2
  2916 000015AD 88C8                <1> 	mov	al,cl
  2917 000015AF E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2918 000015B1 EB00                <1> 	jmp	$+2
  2919 000015B3 EB00                <1> 	jmp	$+2
  2920 000015B5 88E8                <1> 	mov	al,ch
  2921 000015B7 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2922 000015B9 EB00                <1> 	jmp	$+2
  2923 000015BB EB00                <1> 	jmp	$+2
  2924 000015BD 88D0                <1> 	mov	al,dl
  2925 000015BF E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2926 000015C1 EB00                <1> 	jmp	$+2
  2927 000015C3 EB00                <1> 	jmp	$+2
  2928 000015C5 88F0                <1> 	mov	al,dh
  2929 000015C7 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2930 000015C9 EB00                <1> 	jmp	$+2
  2931 000015CB EB00                <1> 	jmp	$+2
  2932 000015CD 88E0                <1> 	mov	al,ah
  2933 000015CF E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2934 000015D1 EB00                <1> 	jmp	$+2
  2935 000015D3 EB00                <1> 	jmp	$+2
  2936 000015D5 B002                <1> 	mov	al,2
  2937 000015D7 E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2938 000015D9 FB                  <1> 	sti
  2939                              <1> 
  2940                              <1> .exit:
  2941 000015DA 5A                  <1> 	pop	dx
  2942 000015DB C3                  <1> 	ret
  2943                              <1> 
  2944                              <1> .dma_boundary:				; Note: CF is already set
  2945 000015DC B409                <1> 	mov	ah,fdc_e_boundary
  2946 000015DE EBFA                <1> 	jmp	.exit
  2947                              <1> 
  2948                              <1> ;=========================================================================
  2949                              <1> ; fdc_send_cmd - Send a command to FDC
  2950                              <1> ; Input:
  2951                              <1> ;	AL = 1st byte of the command
  2952                              <1> ;	AH = 2nd byte of the command
  2953                              <1> ;	SI = 3rd and 4th bytes of the command
  2954                              <1> ;	DI = 5th and 6th bytes of the command
  2955                              <1> ;	BL = 7th byte of the command
  2956                              <1> ;	BH = 8th byte of the command
  2957                              <1> ;	CH = 9th byte of the command
  2958                              <1> ;	CL = command length (number of bytes)
  2959                              <1> ; Output:
  2960                              <1> ;	CF clear if successful
  2961                              <1> ;		AH = 00h - successful completion
  2962                              <1> ;	CF set on error
  2963                              <1> ;		AH = 20h - controller failure
  2964                              <1> ;		AH = 80h - timeout / device not ready
  2965                              <1> ;	AX trashed
  2966                              <1> ;-------------------------------------------------------------------------
  2967                              <1> fdc_send_cmd:
  2968 000015E0 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2969 000015E3 FEC9                <1> 	dec	cl
  2970 000015E5 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2971 000015E7 88E0                <1> 	mov	al,ah
  2972 000015E9 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2973 000015EC FEC9                <1> 	dec	cl
  2974 000015EE 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2975 000015F0 89F0                <1> 	mov	ax,si
  2976 000015F2 E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2977 000015F5 FEC9                <1> 	dec	cl
  2978 000015F7 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2979 000015F9 88E0                <1> 	mov	al,ah
  2980 000015FB E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2981 000015FE FEC9                <1> 	dec	cl
  2982 00001600 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2983 00001602 89F8                <1> 	mov	ax,di
  2984 00001604 E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2985 00001607 FEC9                <1> 	dec	cl
  2986 00001609 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2987 0000160B 88E0                <1> 	mov	al,ah
  2988 0000160D E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2989 00001610 FEC9                <1> 	dec	cl
  2990 00001612 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2991 00001614 88D8                <1> 	mov	al,bl
  2992 00001616 E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2993 00001619 FEC9                <1> 	dec	cl
  2994 0000161B 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2995 0000161D 88F8                <1> 	mov	al,bh
  2996 0000161F E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2997 00001622 FEC9                <1> 	dec	cl
  2998 00001624 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2999 00001626 88E8                <1> 	mov	al,ch
  3000 00001628 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  3001                              <1> 
  3002                              <1> .send_cmd_exit:
  3003 0000162B C3                  <1> 	ret
  3004                              <1> 
  3005                              <1> ;=========================================================================
  3006                              <1> ; fdc_write - Send byte to FDC
  3007                              <1> ; Input:
  3008                              <1> ;	AL = byte to send
  3009                              <1> ; Output:
  3010                              <1> ;	CF clear if successful
  3011                              <1> ;	CF set if timeout
  3012                              <1> ;		AH = 80h - timeout / device not ready
  3013                              <1> ;-------------------------------------------------------------------------
  3014                              <1> fdc_write:
  3015 0000162C 52                  <1> 	push	dx
  3016 0000162D 50                  <1> 	push	ax
  3017 0000162E E83502              <1> 	call	fdc_wait_ready
  3018 00001631 720D                <1> 	jc	.timeout
  3019 00001633 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  3020 00001635 3C80                <1> 	cmp	al,fdc_stat_ready
  3021 00001637 7507                <1> 	jne	.timeout
  3022 00001639 58                  <1> 	pop	ax
  3023 0000163A BAF503              <1> 	mov	dx,fdc_data_reg
  3024 0000163D EE                  <1> 	out	dx,al			; write byte
  3025                              <1> 
  3026                              <1> .exit:
  3027 0000163E 5A                  <1> 	pop	dx
  3028 0000163F C3                  <1> 	ret
  3029                              <1> 
  3030                              <1> .timeout:
  3031 00001640 58                  <1> 	pop	ax
  3032 00001641 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3033 00001643 EBF9                <1> 	jmp	.exit
  3034                              <1> 
  3035                              <1> ;=========================================================================
  3036                              <1> ; fdc_get_result - Read FDC result
  3037                              <1> ; Input:
  3038                              <1> ;	CL = number of result bytes
  3039                              <1> ; Output:
  3040                              <1> ;	CF clear if successful
  3041                              <1> ;		AH = 00h - operation successful
  3042                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  3043                              <1> ;	CF set on error
  3044                              <1> ;		AH = 20h - controller failure
  3045                              <1> ;		AH = 80h - timeout / device not ready
  3046                              <1> ;	AL,BX - trashed
  3047                              <1> ;-------------------------------------------------------------------------
  3048                              <1> fdc_get_result:
  3049 00001645 52                  <1> 	push	dx
  3050 00001646 BB4200              <1> 	mov	bx,fdc_ctrl_status
  3051                              <1> 
  3052                              <1> .next_byte:
  3053 00001649 E81A02              <1> 	call	fdc_wait_ready
  3054 0000164C 7222                <1> 	jc	.timeout
  3055 0000164E 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  3056 00001650 88C4                <1> 	mov	ah,al
  3057 00001652 80E4EF              <1> 	and	ah,~fdc_stat_busy
  3058 00001655 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  3059 00001658 7412                <1> 	je	.done			; jump if finished
  3060 0000165A 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  3061 0000165C 7516                <1> 	jne	.failure		; jump on invalid controller status
  3062 0000165E 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  3063 00001661 7311                <1> 	jnb	.failure		; controller error if so
  3064 00001663 BAF503              <1> 	mov	dx,fdc_data_reg
  3065 00001666 EC                  <1> 	in	al,dx
  3066 00001667 8807                <1> 	mov	byte [bx],al
  3067 00001669 43                  <1> 	inc	bx
  3068 0000166A EBDD                <1> 	jmp	.next_byte
  3069                              <1> 
  3070                              <1> .done:
  3071 0000166C 30E4                <1> 	xor	ah,ah			; operation successful
  3072                              <1> 
  3073                              <1> .exit:
  3074 0000166E 5A                  <1> 	pop	dx
  3075 0000166F C3                  <1> 	ret
  3076                              <1> 
  3077                              <1> .timeout:
  3078 00001670 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3079 00001672 EBFA                <1> 	jmp	.exit
  3080                              <1> 
  3081                              <1> .failure:
  3082 00001674 B420                <1> 	mov	ah,fdc_e_failure
  3083 00001676 F9                  <1> 	stc
  3084 00001677 EBF5                <1> 	jmp	.exit
  3085                              <1> 
  3086                              <1> ;=========================================================================
  3087                              <1> ; fdc_read - Read byte from FDC
  3088                              <1> ; Input:
  3089                              <1> ;	none
  3090                              <1> ; Output:
  3091                              <1> ;	CF clear if successful
  3092                              <1> ;		AL = byte read from FDC
  3093                              <1> ;		AH - unchanged
  3094                              <1> ;	CF set on error
  3095                              <1> ;		AH = 20h - controller failure
  3096                              <1> ;		AH = 80h - timeout / device not ready
  3097                              <1> ;	CX trashed
  3098                              <1> ;-------------------------------------------------------------------------
  3099                              <1> fdc_read:
  3100 00001679 52                  <1> 	push	dx
  3101 0000167A BAF403              <1> 	mov	dx,fdc_status_reg
  3102 0000167D E8E601              <1> 	call	fdc_wait_ready
  3103 00001680 720F                <1> 	jc	.timeout
  3104 00001682 EC                  <1> 	in	al,dx
  3105 00001683 A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  3106 00001685 740E                <1> 	jz	.failure		; jump if not ready
  3107 00001687 EB00                <1> 	jmp	short $+2		; I/O delay
  3108 00001689 EB00                <1> 	jmp	short $+2
  3109 0000168B BAF503              <1> 	mov	dx,fdc_data_reg
  3110 0000168E EC                  <1> 	in	al,dx			; read the byte
  3111                              <1> 
  3112                              <1> .exit:
  3113 0000168F 5A                  <1> 	pop	dx
  3114 00001690 C3                  <1> 	ret
  3115                              <1> 
  3116                              <1> .timeout:
  3117 00001691 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3118 00001693 EBFA                <1> 	jmp	.exit
  3119                              <1> 
  3120                              <1> .failure:
  3121 00001695 B420                <1> 	mov	ah,fdc_e_failure
  3122 00001697 F9                  <1> 	stc
  3123 00001698 EBF5                <1> 	jmp	.exit
  3124                              <1> 
  3125                              <1> ;=========================================================================
  3126                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  3127                              <1> ; Input:
  3128                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  3129                              <1> ; Output:
  3130                              <1> ;	AH = error code
  3131                              <1> ;-------------------------------------------------------------------------
  3132                              <1> 
  3133                              <1> fdc_get_error:
  3134 0000169A BB4200              <1> 	mov	bx,fdc_ctrl_status
  3135 0000169D 8B1F                <1> 	mov	bx,[bx]
  3136 0000169F F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  3137 000016A2 B400                <1> 	mov	ah,fdc_e_success
  3138 000016A4 7433                <1> 	jz	.exit			; jump if successful completion
  3139 000016A6 F6C340              <1> 	test	bl,40h			; abnormal termination?
  3140 000016A9 B420                <1> 	mov	ah,fdc_e_failure
  3141 000016AB 742C                <1> 	jz	.exit
  3142 000016AD F6C701              <1> 	test	bh,1			; address mark not found?
  3143 000016B0 B402                <1> 	mov	ah,fdc_e_address
  3144 000016B2 7525                <1> 	jnz	.exit
  3145 000016B4 F6C702              <1> 	test	bh,2			; disk write protected?
  3146 000016B7 B403                <1> 	mov	ah,fdc_e_wprotect
  3147 000016B9 751E                <1> 	jnz	.exit
  3148 000016BB F6C704              <1> 	test	bh,4			; sector not found?
  3149 000016BE B404                <1> 	mov	ah,fdc_e_notfound
  3150 000016C0 7517                <1> 	jnz	.exit
  3151 000016C2 F6C710              <1> 	test	bh,10H			; DMA overrun?
  3152 000016C5 B408                <1> 	mov	ah,fdc_e_dma
  3153 000016C7 7510                <1> 	jnz	.exit
  3154 000016C9 F6C720              <1> 	test	bh,20H			; CRC error?
  3155 000016CC B410                <1> 	mov	ah,fdc_e_crc
  3156 000016CE 7509                <1> 	jnz	.exit
  3157 000016D0 F6C780              <1> 	test	bh,80h			; access after last sector?
  3158 000016D3 B404                <1> 	mov	ah,fdc_e_notfound
  3159 000016D5 7502                <1> 	jnz	.exit
  3160 000016D7 B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  3161                              <1> 
  3162                              <1> .exit:
  3163 000016D9 C3                  <1> 	ret
  3164                              <1> 
  3165                              <1> ;=========================================================================
  3166                              <1> ; fdc_reset - Reset FDC
  3167                              <1> ; Input:
  3168                              <1> ;	none
  3169                              <1> ; Output:
  3170                              <1> ;	Resets FDC flags in BIOS area
  3171                              <1> ;	AX,CX,DX - trashed 
  3172                              <1> ;-------------------------------------------------------------------------
  3173                              <1> 
  3174                              <1> fdc_reset:
  3175 000016DA FA                  <1> 	cli
  3176 000016DB 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  3177 000016E0 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3178 000016E5 A03F00              <1> 	mov	al,byte [fdc_motor_state]
  3179 000016E8 D0C0                <1> 	rol	al,1			; after rol:
  3180 000016EA D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  3181 000016EC D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  3182 000016EE D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  3183 000016F0 24FB                <1> 	and	al,0FBh			; clear reserved bit
  3184 000016F2 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  3185 000016F4 BAF203              <1> 	mov	dx,fdc_dor_reg
  3186 000016F7 EE                  <1> 	out	dx,al			; send it to FDC
  3187 000016F8 B90300              <1> 	mov	cx,3
  3188 000016FB E829F8              <1> 	call	delay_15us		; 30-45 us delay
  3189 000016FE 0C0C                <1> 	or	al,0Ch
  3190 00001700 EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  3191 00001701 FB                  <1> 	sti
  3192 00001702 E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3193 00001705 7207                <1> 	jc	.exit
  3194 00001707 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  3195 0000170C 30E4                <1> 	xor	ah,ah			; no errors
  3196                              <1> .exit:
  3197 0000170E C3                  <1> 	ret
  3198                              <1> 
  3199                              <1> ;=========================================================================
  3200                              <1> ; read_cmos_type - Read drive type from CMOS
  3201                              <1> ; Input:
  3202                              <1> ;	DL = drive number (0 or 1)
  3203                              <1> ; Output:
  3204                              <1> ;	CF clear if successful
  3205                              <1> ;		AL = drive type
  3206                              <1> ;	CF set on error (invalid drive type)
  3207                              <1> ;=========================================================================
  3208                              <1> 
  3209                              <1> read_cmos_type:
  3210 0000170F B010                <1> 	mov	al,cmos_floppy
  3211 00001711 E80EF4              <1> 	call	rtc_read		; read drive type
  3212 00001714 08D2                <1> 	or	dl,dl			; drive 0?
  3213 00001716 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  3214 00001718 D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  3215 0000171A D0E8                <1> 	shr	al,1
  3216 0000171C D0E8                <1> 	shr	al,1
  3217 0000171E D0E8                <1> 	shr	al,1
  3218                              <1> .drive_1:
  3219 00001720 240F                <1> 	and	al,0Fh			; mask drive bits
  3220 00001722 3C00                <1> 	cmp	al,cmos_no_floppy
  3221 00001724 740A                <1> 	je	.error
  3222 00001726 3C05                <1> 	cmp	al,5			; invalid value
  3223 00001728 7406                <1> 	je	.error
  3224 0000172A 3C06                <1> 	cmp	al,cmos_2880
  3225 0000172C 7702                <1> 	ja	.error
  3226 0000172E F8                  <1> 	clc
  3227 0000172F C3                  <1> 	ret
  3228                              <1> 
  3229                              <1> .error:
  3230 00001730 F9                  <1> 	stc
  3231 00001731 C3                  <1> 	ret
  3232                              <1> 
  3233                              <1> ;=========================================================================
  3234                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  3235                              <1> ; Input:
  3236                              <1> ;	none, expects drive number in [bp+int_13_dl]
  3237                              <1> ; Output:
  3238                              <1> ;	CF clear if successful
  3239                              <1> ;		AH = 00h
  3240                              <1> ;	CF set on error
  3241                              <1> ;		AH = 20h - invalid CMOS
  3242                              <1> ;-------------------------------------------------------------------------
  3243                              <1> fdc_detect_media:
  3244 00001732 52                  <1> 	push	dx
  3245 00001733 51                  <1> 	push	cx
  3246 00001734 53                  <1> 	push	bx
  3247 00001735 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  3248 00001738 BB9000              <1> 	mov	bx,fdc_media_state
  3249 0000173B 00D3                <1> 	add	bl,dl
  3250 0000173D E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  3251 00001740 B400                <1> 	mov	ah,0
  3252 00001742 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  3253                              <1> 
  3254 00001744 3C03                <1> 	cmp	al,cmos_720
  3255 00001746 7410                <1> 	je	.set_720
  3256 00001748 3C02                <1> 	cmp	al,cmos_1200
  3257 0000174A 7415                <1> 	je	.detect_1200
  3258 0000174C 3C04                <1> 	cmp	al,cmos_1440
  3259 0000174E 7427                <1> 	je	.detect_1440
  3260 00001750 3C06                <1> 	cmp	al,cmos_2880
  3261 00001752 7439                <1> 	je	.detect_2880
  3262                              <1> 	
  3263 00001754 B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  3264 00001756 EB02                <1> 	jmp	.set_rate
  3265                              <1> 
  3266                              <1> .set_720:
  3267 00001758 B097                <1> 	mov	al,fdc_m_720
  3268                              <1> 
  3269                              <1> .set_rate:
  3270 0000175A 50                  <1> 	push	ax
  3271 0000175B E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  3272 0000175E 58                  <1> 	pop	ax
  3273 0000175F EB49                <1> 	jmp	.exit_set_media
  3274                              <1> 
  3275                              <1> .detect_1200:
  3276 00001761 B000                <1> 	mov	al,0			; try 500 Kbps
  3277 00001763 E85300              <1> 	call	fdc_read_id
  3278 00001766 B015                <1> 	mov	al,fdc_m_1200in1200
  3279 00001768 7340                <1> 	jnc	.exit_set_media		; jump if successful
  3280 0000176A B040                <1> 	mov	al,40h			; try 300 Kbps
  3281 0000176C E84A00              <1> 	call	fdc_read_id
  3282 0000176F B074                <1> 	mov	al,fdc_m_360in1200
  3283 00001771 7337                <1> 	jnc	.exit_set_media		; jump if successful
  3284 00001773 B002                <1> 	mov	al,fdc_m_try_1200in1200
  3285 00001775 EB33                <1> 	jmp	.exit_set_media
  3286                              <1> 
  3287                              <1> .detect_1440:
  3288 00001777 B000                <1> 	mov	al,0			; try 500 Kbps
  3289 00001779 E83D00              <1> 	call	fdc_read_id
  3290 0000177C B017                <1> 	mov	al,fdc_m_1440
  3291 0000177E 732A                <1> 	jnc	.exit_set_media		; jump if successful
  3292 00001780 B080                <1> 	mov	al,80h			; try 250 Kbps
  3293 00001782 E83400              <1> 	call	fdc_read_id
  3294 00001785 B097                <1> 	mov	al,fdc_m_720
  3295 00001787 7321                <1> 	jnc	.exit_set_media		; jump if successful
  3296 00001789 B007                <1> 	mov	al,fdc_m_try_1440
  3297 0000178B EB1D                <1> 	jmp	.exit_set_media
  3298                              <1> 
  3299                              <1> .detect_2880:
  3300 0000178D B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  3301 0000178F E82700              <1> 	call	fdc_read_id
  3302 00001792 B0D7                <1> 	mov	al,fdc_m_2880
  3303 00001794 7314                <1> 	jnc	.exit_set_media		; jump if successful
  3304 00001796 B000                <1> 	mov	al,0			; try 500 Kbps
  3305 00001798 E81E00              <1> 	call	fdc_read_id
  3306 0000179B B017                <1> 	mov	al,fdc_m_1440
  3307 0000179D 730B                <1> 	jnc	.exit_set_media		; jump if successful
  3308 0000179F B080                <1> 	mov	al,80h			; try 250 Kbps
  3309 000017A1 E81500              <1> 	call	fdc_read_id
  3310 000017A4 B097                <1> 	mov	al,fdc_m_720
  3311 000017A6 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  3312 000017A8 B0C7                <1> 	mov	al,fdc_m_try_2880
  3313                              <1> 
  3314                              <1> .exit_set_media:
  3315 000017AA 8807                <1> 	mov	byte [bx],al		; set media type
  3316                              <1> 
  3317                              <1> .exit:
  3318 000017AC 88264100            <1> 	mov	byte [fdc_last_error],ah
  3319 000017B0 5B                  <1> 	pop	bx
  3320 000017B1 59                  <1> 	pop	cx
  3321 000017B2 5A                  <1> 	pop	dx
  3322 000017B3 C3                  <1> 	ret
  3323                              <1> 
  3324                              <1> .invalid_cmos:
  3325 000017B4 B420                <1> 	mov	ah,fdc_e_failure
  3326 000017B6 F9                  <1> 	stc
  3327 000017B7 EBF3                <1> 	jmp	.exit
  3328                              <1> 
  3329                              <1> ;=========================================================================
  3330                              <1> ; fdc_read_id - Read ID
  3331                              <1> ; Input:
  3332                              <1> ;	AL = data transfer rate (bits 7-6)
  3333                              <1> ; Output:
  3334                              <1> ;	CF clear if successful
  3335                              <1> ;		AH = 0 - successful completion
  3336                              <1> ;		AL = ID (bits 7-6)
  3337                              <1> ;	CF set on error
  3338                              <1> ;		AH = error code
  3339                              <1> ;-------------------------------------------------------------------------
  3340                              <1> fdc_read_id:
  3341 000017B9 53                  <1> 	push	bx
  3342 000017BA C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  3343 000017BF E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  3344 000017C2 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  3345 000017C5 E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  3346 000017C8 7305                <1> 	jnc	.do_read_id
  3347 000017CA E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  3348 000017CD 722D                <1> 	jc	.error
  3349                              <1> 
  3350                              <1> .do_read_id:
  3351 000017CF B90300              <1> 	mov	cx,3			; 3 attempts
  3352                              <1> 
  3353                              <1> .read_id_loop:
  3354 000017D2 51                  <1> 	push	cx
  3355 000017D3 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  3356 000017D5 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  3357 000017D7 B102                <1> 	mov	cl,2			; 2 byte commands
  3358 000017D9 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3359 000017DE E8FFFD              <1> 	call	fdc_send_cmd
  3360 000017E1 7218                <1> 	jc	.error_cmd
  3361 000017E3 E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3362 000017E6 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  3363 000017E8 B107                <1> 	mov	cl,7
  3364 000017EA E858FE              <1> 	call	fdc_get_result		; read result bytes
  3365 000017ED 720C                <1> 	jc	.error_cmd
  3366 000017EF E8A8FE              <1> 	call	fdc_get_error		; get error code
  3367 000017F2 59                  <1> 	pop	cx
  3368 000017F3 08E4                <1> 	or	ah,ah
  3369 000017F5 7406                <1> 	jz	.exit			; if no errors
  3370 000017F7 E2D9                <1> 	loop	.read_id_loop		; retry
  3371 000017F9 EB01                <1> 	jmp	.error
  3372                              <1> 
  3373                              <1> .error_cmd:
  3374 000017FB 59                  <1> 	pop	cx
  3375                              <1> 
  3376                              <1> .error:
  3377 000017FC F9                  <1> 	stc
  3378                              <1> 
  3379                              <1> .exit:
  3380 000017FD 5B                  <1> 	pop	bx
  3381 000017FE C3                  <1> 	ret
  3382                              <1> 
  3383                              <1> ;=========================================================================
  3384                              <1> ; fdc_select_rate - Select FDC transfer rate
  3385                              <1> ; Input:
  3386                              <1> ;	none
  3387                              <1> ; Output:
  3388                              <1> ;	AL = data transfer rate (bits 7-6)
  3389                              <1> ;-------------------------------------------------------------------------
  3390                              <1> fdc_select_rate:
  3391 000017FF 53                  <1> 	push	bx
  3392 00001800 BB9000              <1> 	mov	bx,fdc_media_state
  3393 00001803 00D3                <1> 	add	bl,dl			; SI -> drive media state
  3394 00001805 8A37                <1> 	mov	dh,byte [bx]		; new media status
  3395 00001807 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  3396 0000180B 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  3397 0000180F 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  3398 00001811 740E                <1> 	je	.exit			; exit if rate is already selected
  3399 00001813 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  3400 00001818 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  3401 0000181C 88F0                <1> 	mov	al,dh
  3402 0000181E E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  3403                              <1> 
  3404                              <1> .exit:
  3405 00001821 5B                  <1> 	pop	bx
  3406 00001822 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  3407 00001825 C3                  <1> 	ret
  3408                              <1> 
  3409                              <1> ;=========================================================================
  3410                              <1> ; fdc_set_rate - Set transfer rate
  3411                              <1> ; Input:
  3412                              <1> ;	AL = transfer rate (bits 7 and 6)
  3413                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  3414                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  3415                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  3416                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  3417                              <1> ; Output:
  3418                              <1> ;	AL = transfer rate (bits 1 and 0)
  3419                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  3420                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  3421                              <1> ;	DX = 3F7h - FDC CCR
  3422                              <1> ;-------------------------------------------------------------------------
  3423                              <1> fdc_set_rate:
  3424 00001826 24C0                <1> 	and	al,fdc_m_rate_bits
  3425 00001828 D0C0                <1> 	rol	al,1
  3426 0000182A D0C0                <1> 	rol	al,1
  3427 0000182C BAF703              <1> 	mov	dx,fdc_ccr_reg
  3428 0000182F EE                  <1> 	out	dx,al
  3429 00001830 C3                  <1> 	ret
  3430                              <1> 
  3431                              <1> ;=========================================================================
  3432                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  3433                              <1> ; Input:
  3434                              <1> ;	none
  3435                              <1> ; Output:
  3436                              <1> ;	CF clear if interrupt had occurred
  3437                              <1> ;		AH = 00h - successful completion
  3438                              <1> ;	CF set if no interrupt
  3439                              <1> ;		AH = 80h - timeout
  3440                              <1> ;	BX = fdc_calib_state
  3441                              <1> ;	AL,CX - trashed
  3442                              <1> ;-------------------------------------------------------------------------
  3443                              <1> fdc_wait_irq:
  3444 00001831 FB                  <1> 	sti
  3445 00001832 F8                  <1> 	clc
  3446 00001833 B80190              <1> 	mov	ax,9001h
  3447 00001836 CD15                <1> 	int	15h			; call OS hook
  3448 00001838 7221                <1> 	jc	.timeout
  3449 0000183A BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  3450 0000183D 31C9                <1> 	xor	cx,cx
  3451                              <1> 
  3452                              <1> .zero:
  3453 0000183F F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3454 00001842 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3455                              <1> 
  3456                              <1> .zero_loop:
  3457 00001844 E461                <1> 	in	al,port_b_reg
  3458 00001846 A810                <1> 	test	al,refresh_flag
  3459 00001848 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3460 0000184A E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3461 0000184C EB0D                <1> 	jmp	.timeout
  3462                              <1> 
  3463                              <1> .one:
  3464 0000184E F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3465 00001851 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3466                              <1> 
  3467                              <1> .one_loop:
  3468 00001853 E461                <1> 	in	al,port_b_reg
  3469 00001855 A810                <1> 	test	al,refresh_flag
  3470 00001857 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3471 00001859 E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3472                              <1> 
  3473                              <1> .timeout:
  3474 0000185B B480                <1> 	mov	ah,fdc_e_timeout
  3475 0000185D F9                  <1> 	stc
  3476 0000185E C3                  <1> 	ret
  3477                              <1> 
  3478                              <1> .exit:
  3479 0000185F 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3480 00001862 B400                <1> 	mov	ah,fdc_e_success
  3481 00001864 F8                  <1> 	clc				; DEBUG - remove after debug
  3482 00001865 C3                  <1> 	ret
  3483                              <1> 
  3484                              <1> ;=========================================================================
  3485                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3486                              <1> ;		   but no more than one second
  3487                              <1> ; Input:
  3488                              <1> ; Output:
  3489                              <1> ;	CF clear if FDC is ready
  3490                              <1> ;		AL = FDC main status register
  3491                              <1> ;	CF set on timeout
  3492                              <1> ;		AL trashed
  3493                              <1> ;	DX - trashed
  3494                              <1> ;-------------------------------------------------------------------------
  3495                              <1> 
  3496                              <1> fdc_wait_ready:
  3497 00001866 51                  <1> 	push	cx
  3498 00001867 BAF403              <1> 	mov	dx,fdc_status_reg
  3499 0000186A 31C9                <1> 	xor	cx,cx
  3500                              <1> 
  3501                              <1> .zero:
  3502 0000186C EC                  <1> 	in	al,dx			; read I/O port
  3503 0000186D A880                <1> 	test	al,fdc_stat_ready
  3504 0000186F 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3505                              <1> 
  3506                              <1> .zero_loop:
  3507 00001871 E461                <1> 	in	al,port_b_reg
  3508 00001873 A810                <1> 	test	al,refresh_flag
  3509 00001875 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3510 00001877 49                  <1> 	dec	cx
  3511 00001878 740D                <1> 	jz	.timeout
  3512 0000187A EC                  <1> 	in	al,dx			; read I/O port again
  3513 0000187B A880                <1> 	test	al,fdc_stat_ready
  3514 0000187D 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3515                              <1> 
  3516                              <1> .one_loop:
  3517 0000187F E461                <1> 	in	al,port_b_reg
  3518 00001881 A810                <1> 	test	al,refresh_flag
  3519 00001883 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3520 00001885 E2E5                <1> 	loop	.zero
  3521                              <1> 
  3522                              <1> .timeout:
  3523 00001887 F9                  <1> 	stc
  3524                              <1> 
  3525                              <1> .exit:
  3526 00001888 59                  <1> 	pop	cx
  3527 00001889 C3                  <1> 	ret
  3528                              <1> 
  3529                              <1> ;=========================================================================
  3530                              <1> ; print_floppy - Print floppy configuration
  3531                              <1> ; Input:
  3532                              <1> ;	AL = NVRAM floppy configuration byte
  3533                              <1> ; Ouput:
  3534                              <1> ;	none
  3535                              <1> ;-------------------------------------------------------------------------
  3536                              <1> print_floppy:
  3537 0000188A 50                  <1> 	push	ax
  3538 0000188B 56                  <1> 	push	si
  3539 0000188C BE[0202]            <1> 	mov	si,msg_floppy
  3540 0000188F E87A0D              <1> 	call	print
  3541 00001892 D0C8                <1> 	ror	al,1
  3542 00001894 D0C8                <1> 	ror	al,1
  3543 00001896 D0C8                <1> 	ror	al,1
  3544 00001898 D0C8                <1> 	ror	al,1
  3545 0000189A 89C6                <1> 	mov	si,ax
  3546 0000189C 83E607              <1> 	and	si,0007h
  3547 0000189F D1E6                <1> 	shl	si,1
  3548 000018A1 2E8BB4[1207]        <1>     cs	mov	si,word [tbl_floppy+si]
  3549 000018A6 E8630D              <1> 	call	print
  3550 000018A9 BE[2802]            <1> 	mov	si,msg_floppy_2
  3551 000018AC E85D0D              <1> 	call	print
  3552 000018AF D0C8                <1> 	ror	al,1
  3553 000018B1 D0C8                <1> 	ror	al,1
  3554 000018B3 D0C8                <1> 	ror	al,1
  3555 000018B5 D0C8                <1> 	ror	al,1
  3556 000018B7 89C6                <1> 	mov	si,ax
  3557 000018B9 83E607              <1> 	and	si,0007h
  3558 000018BC D1E6                <1> 	shl	si,1
  3559 000018BE 2E8BB4[1207]        <1>     cs	mov	si,word [tbl_floppy+si]
  3560 000018C3 E8460D              <1> 	call	print
  3561 000018C6 BE[8800]            <1> 	mov	si,msg_crlf
  3562 000018C9 E8400D              <1> 	call	print
  3563 000018CC 5E                  <1> 	pop	si
  3564 000018CD 58                  <1> 	pop	ax
  3565 000018CE C3                  <1> 	ret
  3566                                  %include	"kbc.inc"		; keyboard controller functions
  3567                              <1> ;=========================================================================
  3568                              <1> ; kbc.inc - Keyboard controller support
  3569                              <1> ;-------------------------------------------------------------------------
  3570                              <1> ;
  3571                              <1> ; Compiles with NASM 2.07, might work with other versions
  3572                              <1> ;
  3573                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  3574                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3575                              <1> ;
  3576                              <1> ; This program is free software: you can redistribute it and/or modify
  3577                              <1> ; it under the terms of the GNU General Public License as published by
  3578                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3579                              <1> ; (at your option) any later version.
  3580                              <1> ;
  3581                              <1> ; This program is distributed in the hope that it will be useful,
  3582                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3583                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3584                              <1> ; GNU General Public License for more details.
  3585                              <1> ;
  3586                              <1> ; You should have received a copy of the GNU General Public License
  3587                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3588                              <1> ;
  3589                              <1> ;=========================================================================
  3590                              <1> 
  3591                              <1> ;=========================================================================
  3592                              <1> ; Keyboard controller defines - ports, commands, and flags
  3593                              <1> ;-------------------------------------------------------------------------
  3594                              <1> kbc_data_reg	equ	60h
  3595                              <1> kbc_input_reg	equ	60h
  3596                              <1> kbc_output_reg	equ	60h
  3597                              <1> ; keyboard controller return codes
  3598                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3599                              <1> ; keyboard controller status register and its bits
  3600                              <1> kbc_status_reg	equ	64h
  3601                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3602                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3603                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3604                              <1> ; keyboard contoller command register and commands
  3605                              <1> kbc_command_reg	equ	64h
  3606                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3607                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3608                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3609                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3610                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3611                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3612                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3613                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3614                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3615                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3616                              <1> ; keyboard controller control register bits
  3617                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3618                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3619                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3620                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3621                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3622                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3623                              <1> ; keyboard controller input port bits
  3624                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3625                              <1> 
  3626                              <1> ;=========================================================================
  3627                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3628                              <1> ; Input:
  3629                              <1> ;	AL = command
  3630                              <1> ; Output:
  3631                              <1> ;	none
  3632                              <1> ;-------------------------------------------------------------------------
  3633                              <1> kbc_kb_send:
  3634 000018CF 50                  <1> 	push	ax
  3635 000018D0 51                  <1> 	push	cx
  3636 000018D1 88C4                <1> 	mov	ah,al			; save command to AH
  3637 000018D3 B90300              <1> 	mov	cx,3			; try 3 times
  3638                              <1> 
  3639                              <1> .1:
  3640 000018D6 51                  <1> 	push	cx
  3641 000018D7 FA                  <1> 	cli
  3642                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3643 000018D8 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3644 000018DD 31C9                <1> 	xor	cx,cx
  3645                              <1> 
  3646                              <1> .2:					; wait for KBC to empty input buffer
  3647 000018DF E464                <1> 	in	al,kbc_status_reg
  3648 000018E1 A802                <1> 	test	al,kbc_stat_ibf
  3649 000018E3 E0FA                <1> 	loopnz	.2
  3650                              <1> 
  3651 000018E5 88E0                <1> 	mov	al,ah
  3652 000018E7 E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3653 000018E9 FB                  <1> 	sti
  3654 000018EA 31C9                <1> 	xor	cx,cx
  3655                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3656 000018EC F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3657 000018F1 E1F9                <1> 	loopz	.3
  3658 000018F3 59                  <1> 	pop	cx
  3659 000018F4 7507                <1> 	jnz	.4
  3660 000018F6 E2DE                <1> 	loop	.1			; try again
  3661                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3662 000018F8 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3663                              <1> .4:
  3664 000018FD 59                  <1> 	pop	cx
  3665 000018FE 58                  <1> 	pop	ax
  3666 000018FF C3                  <1> 	ret
  3667                              <1> 
  3668                              <1> ;=========================================================================
  3669                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3670                              <1> ; Input:
  3671                              <1> ;	AL - command byte
  3672                              <1> ;	AH = argument
  3673                              <1> ; Output:
  3674                              <1> ;	ZF == 0 - success
  3675                              <1> ;	ZF == 1 - error
  3676                              <1> ;-------------------------------------------------------------------------
  3677                              <1> kbc_send_cmd:
  3678 00001900 51                  <1> 	push	cx
  3679 00001901 88C5                <1> 	mov	ch,al			; save command byte to CH
  3680 00001903 B11E                <1> 	mov	cl,30			; 30 retries
  3681                              <1> .1:
  3682 00001905 FA                  <1> 	cli
  3683 00001906 88E8                <1> 	mov	al,ch
  3684 00001908 E82800              <1> 	call	kbc_send_cmd_byte
  3685 0000190B 7522                <1> 	jnz	.exit			; time out
  3686 0000190D E464                <1> 	in	al,kbc_status_reg
  3687 0000190F A801                <1> 	test	al,kbc_stat_obf
  3688 00001911 7414                <1> 	jz	.3			; output buffer is empty
  3689 00001913 A820                <1> 	test	al,kbc_stat_aobf
  3690 00001915 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3691 00001917 E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3692                              <1> %ifdef PS2_MOUSE
  3693 00001919 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3694                              <1> %endif ; PS2_MOUSE
  3695 0000191E EB07                <1> 	jmp	.3
  3696                              <1> .2:
  3697 00001920 FB                  <1> 	sti
  3698 00001921 FEC9                <1> 	dec	cl
  3699 00001923 75E0                <1> 	jnz	.1
  3700 00001925 EB08                <1> 	jmp	.exit			; note: ZF=1
  3701                              <1> .3:
  3702 00001927 88E0                <1> 	mov	al,ah
  3703 00001929 E660                <1> 	out	kbc_input_reg,al
  3704 0000192B FB                  <1> 	sti
  3705 0000192C 80C901              <1> 	or	cl,1			; set ZF=0
  3706                              <1> .exit:
  3707 0000192F 88E8                <1> 	mov	al,ch			; restore AL
  3708 00001931 59                  <1> 	pop	cx
  3709 00001932 C3                  <1> 	ret
  3710                              <1> 
  3711                              <1> ;=========================================================================
  3712                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3713                              <1> ; Input:
  3714                              <1> ;	AL - command byte
  3715                              <1> ; Output:
  3716                              <1> ;	ZF == 1 - success
  3717                              <1> ;	ZF == 0 - time out
  3718                              <1> ; Note:
  3719                              <1> ;	XXX - function should be reused in keyboard code
  3720                              <1> ;-------------------------------------------------------------------------
  3721                              <1> kbc_send_cmd_byte:
  3722 00001933 51                  <1> 	push	cx
  3723 00001934 50                  <1> 	push	ax
  3724 00001935 31C9                <1> 	xor	cx,cx
  3725                              <1> 				; wait for KBC to empty input buffer
  3726                              <1> .1:
  3727 00001937 E464                <1> 	in	al,kbc_status_reg
  3728 00001939 A802                <1> 	test	al,kbc_stat_ibf
  3729 0000193B E0FA                <1> 	loopnz	.1
  3730 0000193D 750C                <1> 	jnz	.exit		; time out
  3731                              <1> 
  3732 0000193F 58                  <1> 	pop	ax
  3733 00001940 E664                <1> 	out	kbc_command_reg,al
  3734                              <1> 
  3735 00001942 50                  <1> 	push	ax
  3736 00001943 31C9                <1> 	xor	cx,cx
  3737                              <1> 				; wait for KBC to empty input buffer
  3738                              <1> .2:
  3739 00001945 E464                <1> 	in	al,kbc_status_reg
  3740 00001947 A802                <1> 	test	al,kbc_stat_ibf
  3741 00001949 E0FA                <1> 	loopnz	.2
  3742                              <1> .exit:
  3743 0000194B 58                  <1> 	pop	ax
  3744 0000194C 59                  <1> 	pop	cx
  3745 0000194D C3                  <1> 	ret
  3746                              <1> 
  3747                              <1> ;=========================================================================
  3748                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3749                              <1> ; Input:
  3750                              <1> ;	none
  3751                              <1> ; Output:
  3752                              <1> ;	AL = keyboard status register
  3753                              <1> ;	ZF == 0 - data is available
  3754                              <1> ;	ZF == 1 - timed out
  3755                              <1> ; Note:
  3756                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3757                              <1> ;	      be merged with kbc_wait_aux_full
  3758                              <1> ;-------------------------------------------------------------------------
  3759                              <1> kbc_wait_output_full:
  3760 0000194E 51                  <1> 	push	cx
  3761 0000194F 31C9                <1> 	xor	cx,cx
  3762                              <1> .1:
  3763 00001951 E464                <1> 	in	al,kbc_status_reg
  3764 00001953 A801                <1> 	test	al,kbc_stat_obf
  3765 00001955 E1FA                <1> 	loopz	.1
  3766 00001957 09C9                <1> 	or	cx,cx
  3767 00001959 59                  <1> 	pop	cx
  3768 0000195A C3                  <1> 	ret
  3769                              <1> 
  3770                              <1> %ifdef PS2_MOUSE
  3771                              <1> ;=========================================================================
  3772                              <1> ; kbc_aux_read - read data from auxiliary device
  3773                              <1> ; Input:
  3774                              <1> ;	none
  3775                              <1> ; Output:
  3776                              <1> ;	AL = data
  3777                              <1> ;	CF == 0 - data is available
  3778                              <1> ;	CF == 1 - time out
  3779                              <1> ;-------------------------------------------------------------------------
  3780                              <1> kbc_aux_read:
  3781 0000195B 51                  <1> 	push	cx
  3782                              <1> ;	xor	cx,cx			; XXX too much?!
  3783 0000195C B91400              <1> 	mov	cx,20			; retry 20 times
  3784                              <1> .1:
  3785 0000195F E86000              <1> 	call	kbc_wait_aux_full
  3786 00001962 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3787 00001964 E1F9                <1> 	loopz	.1
  3788 00001966 EB0B                <1> 	jmp	.error			; time out
  3789                              <1> .2:
  3790 00001968 B90100              <1> 	mov	cx,1
  3791 0000196B E8B9F5              <1> 	call	delay_15us
  3792 0000196E E460                <1> 	in	al,kbc_output_reg
  3793 00001970 F8                  <1> 	clc
  3794 00001971 EB01                <1> 	jmp	.exit
  3795                              <1> .error:
  3796 00001973 F9                  <1> 	stc
  3797                              <1> .exit:
  3798 00001974 59                  <1> 	pop	cx
  3799 00001975 C3                  <1> 	ret
  3800                              <1> 
  3801                              <1> ;=========================================================================
  3802                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3803                              <1> ; Input:
  3804                              <1> ;	AL = command
  3805                              <1> ; Output:
  3806                              <1> ;	AH - status:
  3807                              <1> ;		00h - success
  3808                              <1> ;		03h - interface error (time out)
  3809                              <1> ;		04h - resend requested
  3810                              <1> ;	CF == 0 - no error
  3811                              <1> ;	CF == 1 - error
  3812                              <1> ;-------------------------------------------------------------------------
  3813                              <1> kbc_aux_send:
  3814 00001976 51                  <1> 	push	cx
  3815 00001977 88C4                <1> 	mov	ah,al			; store command to AH
  3816 00001979 B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3817 0000197B E882FF              <1> 	call	kbc_send_cmd
  3818 0000197E 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3819                              <1> 
  3820                              <1> 					; wait for acknowledge
  3821 00001980 B90A00              <1> 	mov	cx,10			; retry 10 times
  3822                              <1> .1:
  3823 00001983 E83C00              <1> 	call	kbc_wait_aux_full
  3824 00001986 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3825 00001988 E2F9                <1> 	loop	.1
  3826 0000198A EB17                <1> 	jmp	.timeout		; no reply - timeout
  3827                              <1> .2:
  3828 0000198C E460                <1> 	in	al,kbc_output_reg
  3829 0000198E 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3830 00001990 740C                <1> 	je	.ok
  3831 00001992 3CFE                <1> 	cmp	al,0FEh			; resend?
  3832 00001994 7411                <1> 	je	.resend
  3833 00001996 3CFC                <1> 	cmp	al,0FCh			; error?
  3834 00001998 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3835 0000199A E2E7                <1> 	loop	.1
  3836 0000199C EB05                <1> 	jmp	.timeout
  3837                              <1> 
  3838                              <1> .ok:
  3839 0000199E 30C0                <1> 	xor	al,al			; success - ACK received
  3840 000019A0 F8                  <1> 	clc
  3841 000019A1 EB07                <1> 	jmp	.exit
  3842                              <1> 
  3843                              <1> .timeout:
  3844 000019A3 B003                <1> 	mov	al,03h			; interface error
  3845 000019A5 EB02                <1> 	jmp	.error
  3846                              <1> 
  3847                              <1> .resend:
  3848 000019A7 B004                <1> 	mov	al,04h			; resend
  3849                              <1> 
  3850                              <1> .error:
  3851 000019A9 F9                  <1> 	stc
  3852                              <1> 
  3853                              <1> .exit:
  3854 000019AA 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3855 000019AC 59                  <1> 	pop	cx
  3856 000019AD C3                  <1> 	ret
  3857                              <1> 
  3858                              <1> ;=========================================================================
  3859                              <1> ; kbc_aux_enable - enable auxiliary device
  3860                              <1> ; Input:
  3861                              <1> ;	none
  3862                              <1> ; Output:
  3863                              <1> ;	ZF = 0 - no error
  3864                              <1> ;	ZF = 1 - error
  3865                              <1> ;-------------------------------------------------------------------------
  3866                              <1> kbc_aux_enable:
  3867 000019AE 50                  <1> 	push	ax
  3868 000019AF B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3869 000019B1 B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3870                              <1> 					; enable keyboard, enable aux obf
  3871                              <1> 					; interrupt, enable obf interrupt
  3872 000019B3 E84AFF              <1> 	call	kbc_send_cmd
  3873 000019B6 58                  <1> 	pop	ax
  3874 000019B7 C3                  <1> 	ret
  3875                              <1> 
  3876                              <1> ;=========================================================================
  3877                              <1> ; kbc_aux_disable - disable auxiliary device
  3878                              <1> ; Input:
  3879                              <1> ;	none
  3880                              <1> ; Output:
  3881                              <1> ;	ZF = 0 - no error
  3882                              <1> ;	ZF = 1 - error
  3883                              <1> ;-------------------------------------------------------------------------
  3884                              <1> kbc_aux_disable:
  3885 000019B8 50                  <1> 	push	ax
  3886 000019B9 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3887 000019BB B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3888                              <1> 					; enable keyboard, disable aux obf
  3889                              <1> 					; interrupt, enable obf interrupt
  3890 000019BD E840FF              <1> 	call	kbc_send_cmd
  3891 000019C0 58                  <1> 	pop	ax
  3892 000019C1 C3                  <1> 	ret
  3893                              <1> 
  3894                              <1> ;=========================================================================
  3895                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3896                              <1> ; Input:
  3897                              <1> ;	none
  3898                              <1> ; Output:
  3899                              <1> ;	AL = keyboard status register
  3900                              <1> ;	ZF == 0 - data is available
  3901                              <1> ;	ZF == 1 - timed out
  3902                              <1> ;-------------------------------------------------------------------------
  3903                              <1> kbc_wait_aux_full:
  3904 000019C2 E889FF              <1> 	call	kbc_wait_output_full
  3905 000019C5 7402                <1> 	jz	.error
  3906 000019C7 A820                <1> 	test	al,kbc_stat_aobf
  3907                              <1> .error:
  3908 000019C9 C3                  <1> 	ret
  3909                              <1> 
  3910                              <1> %endif ; PS2_MOUSE
  3911                              <1> 
  3912                              <1> ;=========================================================================
  3913                              <1> ; kbc_flush - flush all data from i8042 buffers
  3914                              <1> ; Input:
  3915                              <1> ;	none
  3916                              <1> ; Output:
  3917                              <1> ;	CF = 0 - flushed successfully
  3918                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3919                              <1> ;-------------------------------------------------------------------------
  3920                              <1> kbc_flush:
  3921 000019CA 50                  <1> 	push	ax
  3922 000019CB 51                  <1> 	push	cx
  3923 000019CC B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3924                              <1> .flush_next_byte:
  3925 000019CF E464                <1> 	in	al,kbc_status_reg
  3926 000019D1 A801                <1> 	test	al,kbc_stat_obf
  3927 000019D3 740F                <1> 	jz	.flushed
  3928 000019D5 51                  <1> 	push	cx
  3929 000019D6 B90400              <1> 	mov	cx,4
  3930 000019D9 E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3931 000019DC 59                  <1> 	pop	cx
  3932 000019DD E460                <1> 	in	al,kbc_data_reg
  3933 000019DF E2EE                <1> 	loop	.flush_next_byte
  3934 000019E1 F9                  <1> 	stc				; unable to flush it
  3935 000019E2 EB01                <1> 	jmp	.exit
  3936                              <1> .flushed:
  3937 000019E4 F8                  <1> 	clc
  3938                              <1> .exit:
  3939 000019E5 59                  <1> 	pop	cx
  3940 000019E6 58                  <1> 	pop	ax
  3941 000019E7 C3                  <1> 	ret
  3942                              <1> 
  3943                              <1> ;=========================================================================
  3944                              <1> ; kbc_init - Initialize keyboard controller
  3945                              <1> ;-------------------------------------------------------------------------
  3946                              <1> kbc_init:
  3947 000019E8 50                  <1> 	push	ax
  3948 000019E9 51                  <1> 	push	cx
  3949 000019EA 52                  <1> 	push	dx
  3950                              <1> 
  3951                              <1> ;-------------------------------------------------------------------------
  3952                              <1> ; test keyboard controller
  3953                              <1> 
  3954 000019EB E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3955                              <1> 
  3956 000019EE B90A00              <1> 	mov	cx,10			; try 10 times
  3957                              <1> 
  3958                              <1> .kbc_reset_retry:
  3959 000019F1 B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3960 000019F3 E83DFF              <1> 	call 	kbc_send_cmd_byte
  3961 000019F6 E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3962                              <1> 
  3963 000019F9 E460                <1> 	in	al,kbc_output_reg
  3964 000019FB 3C55                <1> 	cmp	al,55h			; check for success
  3965 000019FD E0F2                <1> 	loopne	.kbc_reset_retry
  3966 000019FF 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3967                              <1> 
  3968 00001A04 B90A00              <1> 	mov	cx,10			; try 10 times
  3969                              <1> 
  3970                              <1> .kbc_test_retry:
  3971 00001A07 B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3972 00001A09 E827FF              <1> 	call	kbc_send_cmd_byte
  3973 00001A0C E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3974                              <1> 
  3975 00001A0F E460                <1> 	in	al,kbc_output_reg
  3976 00001A11 3C00                <1> 	cmp	al,0			; check for success
  3977 00001A13 E0F2                <1> 	loopne	.kbc_test_retry
  3978 00001A15 7403E98E00          <1> 	jne	kbd_int_fail
  3979                              <1> 
  3980                              <1> ;-------------------------------------------------------------------------
  3981                              <1> ; read display type and set equipment bits accordingly
  3982                              <1> 
  3983 00001A1A B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3984 00001A1C E814FF              <1> 	call	kbc_send_cmd_byte
  3985 00001A1F E82CFF              <1> 	call	kbc_wait_output_full
  3986                              <1> 
  3987 00001A22 E460                <1> 	in	al,kbc_output_reg
  3988 00001A24 A840                <1> 	test	al,kbc_in_display
  3989 00001A26 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3990 00001A28 830E100030          <1> 	or	word [equipment_list],equip_mono
  3991 00001A2D EB05                <1> 	jmp	.get_disp_done
  3992                              <1> .get_disp_color:
  3993 00001A2F 830E100020          <1> 	or	word [equipment_list],equip_color
  3994                              <1> .get_disp_done:
  3995                              <1> 
  3996                              <1> ;-------------------------------------------------------------------------
  3997                              <1> ; initialize keyboard controller
  3998                              <1> 
  3999 00001A34 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  4000 00001A36 E8FAFE              <1> 	call	kbc_send_cmd_byte
  4001                              <1> 
  4002 00001A39 B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  4003 00001A3B E8F5FE              <1> 	call	kbc_send_cmd_byte
  4004                              <1> 
  4005 00001A3E B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  4006 00001A40 B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  4007                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  4008                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  4009                              <1> 					; Bit 4 = 0 - Enable keyboard
  4010                              <1> 					; Bit 3 = 1 - Disable inhibit
  4011                              <1> 					; Bit 2 = 0 - system flag = 0
  4012                              <1> 					; Bit 1 = 0 - reserved
  4013                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  4014 00001A42 E8BBFE              <1> 	call	kbc_send_cmd
  4015                              <1> 
  4016 00001A45 B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  4017 00001A47 E8E9FE              <1> 	call	kbc_send_cmd_byte
  4018                              <1> 
  4019 00001A4A B90010              <1> 	mov	cx,1000h
  4020 00001A4D E8D7F4              <1> 	call	delay_15us
  4021                              <1> 
  4022 00001A50 E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  4023 00001A53 E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  4024                              <1> 
  4025                              <1> 
  4026                              <1> %ifdef PS2_MOUSE
  4027                              <1> ;-------------------------------------------------------------------------
  4028                              <1> ; check for PS/2 mouse presence
  4029                              <1> 
  4030 00001A55 B90A00              <1> 	mov	cx,10			; try 10 times
  4031                              <1> .mouse_reset_retry:
  4032 00001A58 B0FF                <1> 	mov	al,0FFh
  4033 00001A5A E819FF              <1> 	call	kbc_aux_send
  4034 00001A5D 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  4035 00001A5F 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4036 00001A62 E1F4                <1> 	loopz	.mouse_reset_retry
  4037 00001A64 EB13                <1> 	jmp	.no_mouse
  4038                              <1> .mouse_reset_ok:
  4039 00001A66 E8F2FE              <1> 	call	kbc_aux_read
  4040 00001A69 720E                <1> 	jc	.no_mouse
  4041 00001A6B 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  4042 00001A6D 750A                <1> 	jne	.no_mouse
  4043 00001A6F E8E9FE              <1> 	call	kbc_aux_read
  4044 00001A72 7205                <1> 	jc	.no_mouse
  4045                              <1> ; mouse reset successful, update equipment word accordingly
  4046 00001A74 830E100004          <1> 	or      word [equipment_list],equip_mouse
  4047                              <1> .no_mouse:
  4048                              <1> %endif ; PS2_MOUSE
  4049                              <1> 
  4050                              <1> ;-------------------------------------------------------------------------
  4051                              <1> ; setup keyboard buffer
  4052                              <1> 
  4053 00001A79 B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  4054 00001A7C A38000              <1>         mov     word [kbd_buffer_start],ax
  4055 00001A7F A31A00              <1>         mov     word [kbd_buffer_head],ax
  4056 00001A82 A31C00              <1>         mov     word [kbd_buffer_tail],ax
  4057 00001A85 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  4058 00001A88 A38200              <1>         mov     word [kbd_buffer_end],ax
  4059 00001A8B 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  4060 00001A8D A31700              <1>         mov     word [kbd_flags_1],ax
  4061 00001A90 A31800              <1>         mov     word [kbd_flags_2],ax
  4062 00001A93 A39600              <1>         mov     word [kbd_flags_3],ax
  4063 00001A96 A39700              <1>         mov     word [kbd_flags_4],ax
  4064 00001A99 B010                <1> 	mov	al,e_kbd_ok
  4065 00001A9B E680                <1> 	out	post_reg,al
  4066 00001A9D 5A                  <1> 	pop	dx
  4067 00001A9E 59                  <1> 	pop	cx
  4068 00001A9F 58                  <1> 	pop	ax
  4069 00001AA0 C3                  <1> 	ret
  4070                              <1> 
  4071                              <1> kbd_ctrl_fail:
  4072 00001AA1 B060                <1> 	mov	al,e_kbd_ctrl_fail
  4073 00001AA3 E680                <1> 	out	post_reg,al
  4074                              <1> .1:
  4075 00001AA5 F4                  <1> 	hlt
  4076 00001AA6 EBFD                <1> 	jmp	.1
  4077                              <1> 
  4078                              <1> kbd_int_fail:
  4079 00001AA8 240F                <1> 	and	al,0Fh
  4080 00001AAA 0463                <1> 	add	al,e_kbd_int_fail
  4081 00001AAC E680                <1> 	out	post_reg,al
  4082                              <1> .1:
  4083 00001AAE F4                  <1> 	hlt
  4084 00001AAF EBFD                <1> 	jmp	.1
  4085                              <1> 
  4086                              <1> kbd_key_fail:
  4087 00001AB1 B061                <1> 	mov	al,e_kbd_key_fail
  4088 00001AB3 E680                <1> 	out	post_reg,al
  4089                              <1> .1:
  4090 00001AB5 F4                  <1> 	hlt
  4091 00001AB6 EBFD                <1> 	jmp	.1
  4092                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  4093                              <1> ;=========================================================================
  4094                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  4095                              <1> ;		 and related INT 16h functions:
  4096                              <1> ;	INT 16h - BIOS Keyboard Services
  4097                              <1> ;		- function AH=00h
  4098                              <1> ;		- function AH=01h
  4099                              <1> ;		- function AH=10h
  4100                              <1> ;		- function AH=11h
  4101                              <1> ;-------------------------------------------------------------------------
  4102                              <1> ;
  4103                              <1> ; Compiles with NASM 2.07, might work with other versions
  4104                              <1> ;
  4105                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4106                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4107                              <1> ;
  4108                              <1> ; This program is free software: you can redistribute it and/or modify
  4109                              <1> ; it under the terms of the GNU General Public License as published by
  4110                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4111                              <1> ; (at your option) any later version.
  4112                              <1> ;
  4113                              <1> ; This program is distributed in the hope that it will be useful,
  4114                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4115                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4116                              <1> ; GNU General Public License for more details.
  4117                              <1> ;
  4118                              <1> ; You should have received a copy of the GNU General Public License
  4119                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4120                              <1> ;
  4121                              <1> ;=========================================================================
  4122                              <1> 
  4123                              <1> ;=========================================================================
  4124                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  4125                              <1> ;                   BIOS scan code translation table
  4126                              <1> ; Note 1: Table starts with scancode == 1
  4127                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  4128                              <1> ;	00 - no flags
  4129                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  4130                              <1> ;	     x in this case equals digit value
  4131                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  4132                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  4133                              <1> ;	8x - F11, F12 BIOS scan codes
  4134                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  4135                              <1> ;-------------------------------------------------------------------------
  4136                              <1> 
  4137                              <1> scan_xlat_table:
  4138                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4139 00001AB8 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  4140 00001AC0 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  4141 00001AC8 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  4142 00001AD0 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  4143 00001AD8 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  4144 00001AE0 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  4145 00001AE8 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  4146 00001AF0 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  4147 00001AF8 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  4148 00001B00 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  4149 00001B08 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  4150 00001B10 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  4151 00001B18 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  4152 00001B20 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  4153 00001B28 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  4154 00001B30 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  4155                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4156 00001B38 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  4157 00001B40 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  4158 00001B48 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  4159 00001B50 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  4160 00001B58 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  4161 00001B60 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  4162 00001B68 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  4163 00001B70 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  4164 00001B78 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  4165 00001B80 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  4166 00001B88 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  4167 00001B90 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  4168 00001B98 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  4169 00001BA0 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  4170 00001BA8 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  4171 00001BB0 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  4172                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4173 00001BB8 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  4174 00001BC0 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  4175 00001BC8 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  4176 00001BD0 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  4177 00001BD8 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  4178 00001BE0 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  4179 00001BE8 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  4180 00001BF0 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  4181 00001BF8 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  4182 00001C00 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  4183 00001C08 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  4184 00001C10 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  4185 00001C18 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  4186 00001C20 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  4187 00001C28 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  4188 00001C30 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  4189                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4190 00001C38 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  4191 00001C40 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  4192 00001C48 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  4193 00001C50 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  4194 00001C58 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  4195 00001C60 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  4196 00001C68 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  4197 00001C70 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  4198 00001C78 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  4199 00001C80 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  4200 00001C88 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  4201 00001C90 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  4202 00001C98 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  4203 00001CA0 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  4204 00001CA8 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  4205 00001CB0 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  4206                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4207 00001CB8 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  4208 00001CC0 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  4209 00001CC8 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  4210 00001CD0 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  4211 00001CD8 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  4212 00001CE0 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  4213 00001CE8 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  4214 00001CF0 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  4215 00001CF8 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  4216 00001D00 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  4217 00001D08 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  4218 00001D10 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  4219 00001D18 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  4220 00001D20 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  4221 00001D28 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  4222 00001D30 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  4223                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  4224 00001D38 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  4225 00001D40 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  4226 00001D48 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  4227 00001D50 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  4228 00001D58 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  4229 00001D60 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  4230 00001D68 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  4231 00001D70 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  4232                              <1> .end:
  4233                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  4234                              <1> 
  4235                              <1> ;=========================================================================
  4236                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  4237                              <1> ; Input:
  4238                              <1> ;	AL - scan code
  4239                              <1> ; Output:
  4240                              <1> ;	AX - ASCII character / scan code pair
  4241                              <1> ;-------------------------------------------------------------------------
  4242                              <1> scan_xlat:
  4243 00001D78 53                  <1> 	push	bx
  4244 00001D79 FEC8                <1> 	dec	al
  4245 00001D7B 3C58                <1> 	cmp	al,scan_xlat_table_size
  4246 00001D7D 7205                <1> 	jb	.1
  4247 00001D7F 31C0                <1> 	xor	ax,ax
  4248 00001D81 E9AB00              <1> 	jmp	.exit
  4249                              <1> 
  4250                              <1> .1:
  4251 00001D84 B700                <1> 	mov	bh,00h				; calculate offset of the key
  4252 00001D86 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  4253 00001D88 D1E3                <1> 	shl	bx,1				; BX = AL * 8
  4254 00001D8A D1E3                <1> 	shl	bx,1
  4255 00001D8C D1E3                <1> 	shl	bx,1
  4256                              <1> 
  4257 00001D8E F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  4258 00001D93 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  4259 00001D95 2E8B87[BE1A]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  4260                              <1> 	; check for numeric Keypad keys
  4261 00001D9A 2EF687[B91A]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  4262 00001DA0 7474                <1> 	jz	.check_extended
  4263 00001DA2 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4264 00001DA7 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  4265                              <1> 						; and so it is not a keypad key
  4266                              <1> 
  4267 00001DA9 2E8A87[B91A]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  4268 00001DAE 240F                <1> 	and	al,0Fh				; get the numeric value
  4269 00001DB0 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  4270 00001DB4 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  4271 00001DB6 A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  4272                              <1> 
  4273 00001DB9 31C0                <1> 	xor	ax,ax				; return nothing
  4274 00001DBB EB72                <1> 	jmp	.exit
  4275                              <1> 
  4276                              <1> .check_ctrl:
  4277 00001DBD F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  4278 00001DC2 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  4279 00001DC4 2E8B87[BC1A]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  4280 00001DC9 EB4B                <1> 	jmp	.check_extended
  4281                              <1> 
  4282                              <1> .check_locks:
  4283 00001DCB 2EF687[B91A]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  4284 00001DD1 741D                <1> 	jz	.check_shift			; not affected by Locks
  4285                              <1> 
  4286 00001DD3 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  4287 00001DD5 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  4288                              <1> 
  4289 00001DD7 F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  4290 00001DDC 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  4291 00001DDE EB07                <1> 	jmp	.lock_active
  4292                              <1> 
  4293                              <1> .check_num_lock:
  4294 00001DE0 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  4295 00001DE5 7409                <1> 	jz	.check_shift			; Num Lock is not active
  4296                              <1> .lock_active:
  4297                              <1> 	; are any of Shift keys active?
  4298 00001DE7 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4299 00001DEC 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  4300 00001DEE EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  4301                              <1> 
  4302                              <1> .check_shift:
  4303                              <1> 	; are any of Shift keys active?
  4304 00001DF0 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4305 00001DF5 7407                <1> 	jz	.no_shift
  4306                              <1> .shift:
  4307 00001DF7 2E8B87[BA1A]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  4308 00001DFC EB18                <1> 	jmp	.check_extended
  4309                              <1> 
  4310                              <1> .no_shift:
  4311 00001DFE 88C4                <1> 	mov	ah,al				; Move scan code to AH
  4312 00001E00 FEC4                <1> 	inc	ah
  4313 00001E02 2E8A87[B81A]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  4314 00001E07 2EF687[B91A]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  4315 00001E0D 7407                <1> 	jz	.check_extended			; not F11 or F12
  4316 00001E0F 2E8AA7[B91A]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  4317 00001E14 EB19                <1> 	jmp	.exit
  4318                              <1> 
  4319                              <1> .check_extended:
  4320 00001E16 2EF687[B91A]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  4321 00001E1C 7411                <1> 	jz	.exit				; no extended key
  4322 00001E1E F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4323 00001E23 740A                <1> 	jz	.exit				; ... not a 0E0h
  4324 00001E25 3C00                <1> 	cmp	al,00h
  4325 00001E27 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  4326 00001E29 B0E0                <1> 	mov	al,0E0h				; indicate extended key
  4327 00001E2B EB02                <1> 	jmp	.exit
  4328                              <1> 
  4329                              <1> .ascii_code:
  4330 00001E2D B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  4331                              <1> 						; key with valid ASCII code
  4332                              <1> 						; (Keypad Enter, *, and /)
  4333                              <1> 
  4334                              <1> .exit:
  4335 00001E2F 5B                  <1> 	pop	bx
  4336 00001E30 C3                  <1> 	ret
  4337                              <1> 
  4338                              <1> ;=========================================================================
  4339                              <1> ; int_16_fn00 - get keystroke
  4340                              <1> ; Input:
  4341                              <1> ;	AH = 00h
  4342                              <1> ; Output:
  4343                              <1> ;	AH = BIOS scan code
  4344                              <1> ;	AL = ASCII character
  4345                              <1> ; Notes:
  4346                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4347                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4348                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4349                              <1> ;	- Use function AH=10h for extended keystrokes handling
  4350                              <1> ;-------------------------------------------------------------------------
  4351                              <1> int_16_fn00:
  4352 00001E31 FB                  <1> 	sti
  4353                              <1> .1:
  4354 00001E32 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4355 00001E36 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4356 00001E3A 74F6                <1> 	jz	.1			; wait or keystroke
  4357 00001E3C 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4358 00001E3E 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4359                              <1> 					;   location
  4360 00001E41 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4361 00001E45 7504                <1> 	jne	.2
  4362 00001E47 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4363                              <1> .2:
  4364 00001E4B 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4365 00001E4F 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4366                              <1> 					;   extended key?
  4367 00001E51 7504                <1> 	jne	.3			; not a convertible key
  4368 00001E53 B000                <1> 	mov	al,00h			; convert to a standard key
  4369 00001E55 EB2C                <1> 	jmp	.exit
  4370                              <1> .3:
  4371 00001E57 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4372 00001E59 74D7                <1> 	je	.1			; an ignored extended key, get next key
  4373 00001E5B 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4374                              <1> 					;   (scancode above 84h)
  4375 00001E5E 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  4376 00001E60 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4377 00001E63 751E                <1> 	jne	.exit
  4378 00001E65 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4379 00001E67 7504                <1> 	jne	.4
  4380 00001E69 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4381 00001E6B EB16                <1> 	jmp	.exit
  4382                              <1> .4:
  4383 00001E6D 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4384 00001E6F 7504                <1> 	jne	.5
  4385 00001E71 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4386 00001E73 EB0E                <1> 	jmp	.exit
  4387                              <1> .5:
  4388 00001E75 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4389 00001E77 7504                <1> 	jne	.6
  4390 00001E79 B435                <1> 	mov	ah,35h			; standard / scancode
  4391 00001E7B EB06                <1> 	jmp	.exit
  4392                              <1> .6:
  4393 00001E7D 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4394 00001E7F 7502                <1> 	jne	.exit
  4395 00001E81 B437                <1> 	mov	ah,37h			; standard * scancode
  4396                              <1> .exit:
  4397 00001E83 E9E549              <1> 	jmp	int_16_exit
  4398                              <1> 
  4399                              <1> ;=========================================================================
  4400                              <1> ; int_16_fn01 - check for keystroke
  4401                              <1> ; Input:
  4402                              <1> ;	AH = 01h
  4403                              <1> ; Output:
  4404                              <1> ;	ZF = 1 - no keystroke available
  4405                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4406                              <1> ;		AH = BIOS scan code
  4407                              <1> ;		AL = ASCII character
  4408                              <1> ; Notes:
  4409                              <1> ;	- Does not remove keystroke from keyboard buffer
  4410                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4411                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4412                              <1> ;	- Use function AH=11h for extended keystrokes handling
  4413                              <1> ;-------------------------------------------------------------------------
  4414                              <1> int_16_fn01:
  4415 00001E86 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4416 00001E8A 8B07                <1> 	mov	ax,word [bx]
  4417 00001E8C 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4418 00001E90 7436                <1> 	jz	.exit			; no keystroke, exit
  4419 00001E92 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4420                              <1> 					;   extended key?
  4421 00001E94 7504                <1> 	jne	.1			; not a convertible key
  4422 00001E96 B000                <1> 	mov	al,00h			; convert to a standard key
  4423 00001E98 EB2C                <1> 	jmp	.clear_zf
  4424                              <1> .1:
  4425 00001E9A 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4426 00001E9C 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  4427 00001E9E 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4428                              <1> 					;   (scancode above 84h)
  4429 00001EA1 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  4430 00001EA3 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4431 00001EA6 751E                <1> 	jne	.clear_zf
  4432 00001EA8 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4433 00001EAA 7504                <1> 	jne	.2
  4434 00001EAC B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4435 00001EAE EB16                <1> 	jmp	.clear_zf
  4436                              <1> .2:
  4437 00001EB0 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4438 00001EB2 7504                <1> 	jne	.3
  4439 00001EB4 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4440 00001EB6 EB0E                <1> 	jmp	.clear_zf
  4441                              <1> .3:
  4442 00001EB8 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4443 00001EBA 7504                <1> 	jne	.4
  4444 00001EBC B435                <1> 	mov	ah,35h			; standard / scancode
  4445 00001EBE EB06                <1> 	jmp	.clear_zf
  4446                              <1> .4:
  4447 00001EC0 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4448 00001EC2 7502                <1> 	jne	.clear_zf
  4449 00001EC4 B437                <1> 	mov	ah,37h			; standard * scancode
  4450                              <1> 
  4451                              <1> .clear_zf:
  4452 00001EC6 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4453                              <1> .exit:
  4454 00001EC8 E9A349              <1> 	jmp	int_16_exitf
  4455                              <1> 
  4456                              <1> .discard_key:
  4457 00001ECB 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4458                              <1> 					;   location
  4459 00001ECE 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4460 00001ED2 7504                <1> 	jne	.5
  4461 00001ED4 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4462                              <1> .5:
  4463 00001ED8 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4464 00001EDC EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4465                              <1> 	
  4466                              <1> 
  4467                              <1> ;=========================================================================
  4468                              <1> ; int_16_fn10 - get extended keystroke
  4469                              <1> ; Input:
  4470                              <1> ;	AH = 10h
  4471                              <1> ; Output:
  4472                              <1> ;	AH = BIOS scan code
  4473                              <1> ;	AL = ASCII character
  4474                              <1> ; Note:
  4475                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4476                              <1> ;-------------------------------------------------------------------------
  4477                              <1> int_16_fn10:
  4478 00001EDE FB                  <1> 	sti
  4479                              <1> .1:
  4480 00001EDF 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4481 00001EE3 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4482 00001EE7 74F6                <1> 	jz	.1			; wait or keystroke
  4483 00001EE9 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4484 00001EEB 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4485                              <1> 					;   location
  4486 00001EEE 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4487 00001EF2 7504                <1> 	jne	.2
  4488 00001EF4 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4489                              <1> .2:
  4490 00001EF8 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4491 00001EFC 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4492 00001EFE 7502                <1> 	jne	.exit			; not a extended key
  4493 00001F00 B000                <1> 	mov	al,00h			; set scancode to zero
  4494                              <1> 
  4495                              <1> .exit:
  4496 00001F02 E96649              <1> 	jmp	int_16_exit
  4497                              <1> 
  4498                              <1> ;=========================================================================
  4499                              <1> ; int_16_fn11 - check for extended keystroke
  4500                              <1> ; Input:
  4501                              <1> ;	AH = 01h
  4502                              <1> ; Output:
  4503                              <1> ;	ZF = 1 - no keystroke available
  4504                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4505                              <1> ;		AH = BIOS scan code
  4506                              <1> ;		AL = ASCII character
  4507                              <1> ; Note:
  4508                              <1> ;	- Does not remove keystroke from keyboard buffer
  4509                              <1> ;-------------------------------------------------------------------------
  4510                              <1> int_16_fn11:
  4511 00001F05 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4512 00001F09 8B07                <1> 	mov	ax,word [bx]
  4513 00001F0B 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4514 00001F0F 7408                <1> 	jz	.exit			; no keystroke, exit
  4515 00001F11 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4516 00001F13 7502                <1> 	jne	.clear_zf		; not a extended key
  4517 00001F15 B000                <1> 	mov	al,00h			; set scancode to zero
  4518                              <1> .clear_zf:
  4519 00001F17 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4520                              <1> .exit:
  4521 00001F19 E95249              <1> 	jmp	int_16_exitf
  4522                                  %include	"serial1.inc"		; serial port services & detection
  4523                              <1> ;========================================================================
  4524                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
  4525                              <1> ;       INT 14h, function AH=01h
  4526                              <1> ;	INT 14h, function AH=02h
  4527                              <1> ;	detect_serial
  4528                              <1> ;	serial port related definitions and tables
  4529                              <1> ;	- see serial2.inc for other INT 14h functions
  4530                              <1> ;-------------------------------------------------------------------------
  4531                              <1> ;
  4532                              <1> ; Compiles with NASM 2.07, might work with other versions
  4533                              <1> ;
  4534                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4535                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4536                              <1> ;
  4537                              <1> ; This program is free software: you can redistribute it and/or modify
  4538                              <1> ; it under the terms of the GNU General Public License as published by
  4539                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4540                              <1> ; (at your option) any later version.
  4541                              <1> ;
  4542                              <1> ; This program is distributed in the hope that it will be useful,
  4543                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4544                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4545                              <1> ; GNU General Public License for more details.
  4546                              <1> ;
  4547                              <1> ; You should have received a copy of the GNU General Public License
  4548                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4549                              <1> ;
  4550                              <1> ;=========================================================================
  4551                              <1> 
  4552                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
  4553                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
  4554                              <1> 
  4555                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
  4556                              <1> 
  4557                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
  4558                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
  4559                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
  4560                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
  4561                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
  4562                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
  4563                              <1> 
  4564                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
  4565                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
  4566                              <1> uart_mcr_rts	equ	3		; MCR - request to send (RTS)
  4567                              <1> 
  4568                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
  4569                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
  4570                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
  4571                              <1> 
  4572                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
  4573                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
  4574                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
  4575                              <1> 
  4576                              <1> uart_err_timeout equ	80h		; timeout error
  4577                              <1> 
  4578                              <1> num_serial	equ	4		; number of serial ports
  4579                              <1> 
  4580                              <1> ;=========================================================================
  4581                              <1> ; int_14_fn01 - Send character
  4582                              <1> ; Input:
  4583                              <1> ;	AH = 01h - function 01h - send character
  4584                              <1> ;	AL = character to send
  4585                              <1> ;	DX = serial port number (0-3)
  4586                              <1> ; Output:
  4587                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4588                              <1> ;-------------------------------------------------------------------------
  4589                              <1> int_14_fn01:
  4590 00001F1C 50                  <1> 	push	ax
  4591 00001F1D B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4592 00001F1F B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR
  4593 00001F21 B320                <1> 	mov	bl,uart_lsr_thre	; and for THR empty in LSR
  4594 00001F23 E82200              <1> 	call	uart_wait_status
  4595 00001F26 59                  <1> 	pop	cx
  4596 00001F27 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
  4597 00001F29 88C8                <1> 	mov	al,cl
  4598 00001F2B EE                  <1> 	out	dx,al			; sent the character
  4599 00001F2C E93748              <1> 	jmp	int_14_exit
  4600                              <1> 
  4601                              <1> int_14_timeout:
  4602 00001F2F 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
  4603 00001F31 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
  4604 00001F34 E92F48              <1> 	jmp	int_14_exit
  4605                              <1> 
  4606                              <1> ;=========================================================================
  4607                              <1> ; int_14_fn02 - Receive character
  4608                              <1> ; Input:
  4609                              <1> ;	AH = 02h - function 02h - receive character
  4610                              <1> ;	DX = serial port number (0-3)
  4611                              <1> ; Output:
  4612                              <1> ;	AL = character received
  4613                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4614                              <1> ;-------------------------------------------------------------------------
  4615                              <1> int_14_fn02:
  4616 00001F37 50                  <1> 	push	ax
  4617 00001F38 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4618 00001F3A B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR
  4619 00001F3C B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR
  4620 00001F3E E80700              <1> 	call	uart_wait_status
  4621 00001F41 59                  <1> 	pop	cx
  4622 00001F42 75EB                <1> 	jnz	int_14_timeout
  4623 00001F44 EC                  <1> 	in	al,dx			; receive the character
  4624 00001F45 E91E48              <1> 	jmp	int_14_exit
  4625                              <1> 
  4626                              <1> ;=========================================================================
  4627                              <1> ; uart_wait_status - wait for modem and line status
  4628                              <1> ; Input:
  4629                              <1> ;	AL = value to write to MCR (Modem Control Register)
  4630                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
  4631                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
  4632                              <1> ;	DX = UART base address
  4633                              <1> ;	SI = serial port number
  4634                              <1> ; Output:
  4635                              <1> ;	AH = line status
  4636                              <1> ;	ZF = 0 - timeout
  4637                              <1> ;	CX,BX - destroyed
  4638                              <1> ;-------------------------------------------------------------------------
  4639                              <1> uart_wait_status:
  4640 00001F48 52                  <1> 	push	dx
  4641 00001F49 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
  4642 00001F4C EE                  <1> 	out	dx,al			; output MCR value
  4643 00001F4D 42                  <1> 	inc	dx
  4644 00001F4E 42                  <1> 	inc	dx			; DX = UART MSR address
  4645                              <1> 					; OPTIMIZATION:
  4646                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
  4647 00001F4F E80A00              <1> 	call	wait_for_port		; wait for MSR status
  4648 00001F52 7506                <1> 	jnz	.wait_exit
  4649 00001F54 4A                  <1> 	dec	dx			; DX = UART LSR address
  4650                              <1> 					; OPTIMIZATION:
  4651                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
  4652 00001F55 88DF                <1> 	mov	bh,bl			; BH = LSR mask
  4653 00001F57 E80200              <1> 	call	wait_for_port		; wait for LSR status
  4654                              <1> .wait_exit:
  4655 00001F5A 5A                  <1> 	pop	dx
  4656 00001F5B C3                  <1> 	ret
  4657                              <1> 
  4658                              <1> ;=========================================================================
  4659                              <1> ; wait_for_port - wait for set bits in a register
  4660                              <1> ;
  4661                              <1> ; Input:
  4662                              <1> ;	BH = mask to wait for (bits that need to be 1)
  4663                              <1> ;	DX = register address
  4664                              <1> ;	SI = address of the timeout value (in seconds)
  4665                              <1> ; Output:
  4666                              <1> ;	AH = last port reading
  4667                              <1> ;	ZF clear on timeout
  4668                              <1> ;	ZF set on success
  4669                              <1> ;	AL - trashed
  4670                              <1> ;	CX - trashed
  4671                              <1> ;-------------------------------------------------------------------------
  4672                              <1> wait_for_port:
  4673 00001F5C 53                  <1> 	push	bx
  4674 00001F5D 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
  4675                              <1> 
  4676                              <1> .loop_outer:
  4677 00001F5F B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
  4678                              <1> 
  4679                              <1> .loop_inner:
  4680 00001F62 EC                  <1> 	in	al,dx			; read the register
  4681 00001F63 88C4                <1> 	mov	ah,al			; save register in AH
  4682 00001F65 20F8                <1> 	and	al,bh
  4683 00001F67 38F8                <1> 	cmp	al,bh			; required bits are set?
  4684 00001F69 7414                <1> 	je	.exit
  4685                              <1> 
  4686                              <1> .zero_loop:
  4687 00001F6B E461                <1> 	in	al,port_b_reg
  4688 00001F6D A810                <1> 	test	al,refresh_flag
  4689 00001F6F 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  4690                              <1> 
  4691                              <1> .one_loop:
  4692 00001F71 E461                <1> 	in	al,port_b_reg
  4693 00001F73 A810                <1> 	test	al,refresh_flag
  4694 00001F75 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  4695 00001F77 E2E9                <1> 	loop	.loop_inner
  4696                              <1> 
  4697 00001F79 FECB                <1> 	dec	bl
  4698 00001F7B 75E2                <1> 	jnz	.loop_outer
  4699 00001F7D 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
  4700                              <1> 
  4701                              <1> .exit:
  4702 00001F7F 5B                  <1> 	pop	bx
  4703 00001F80 C3                  <1> 	ret
  4704                              <1> 
  4705                              <1> ;=========================================================================
  4706                              <1> ; detect_serial - detect and print serial ports
  4707                              <1> ; Input:
  4708                              <1> ;	none
  4709                              <1> ; Output:
  4710                              <1> ;	none (updates BIOS data area)
  4711                              <1> ;-------------------------------------------------------------------------
  4712                              <1> detect_serial:
  4713 00001F81 50                  <1> 	push	ax
  4714 00001F82 53                  <1> 	push	bx
  4715 00001F83 52                  <1> 	push	dx
  4716 00001F84 56                  <1> 	push	si
  4717 00001F85 BE[A902]            <1> 	mov	si,msg_serial
  4718 00001F88 E88106              <1> 	call	print
  4719 00001F8B BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
  4720 00001F8E 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
  4721 00001F92 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
  4722 00001F96 31DB                <1> 	xor	bx,bx			; BX = 0
  4723                              <1> .detect_loop:
  4724 00001F98 BE[C602]            <1> 	mov	si,msg_serial_com
  4725 00001F9B E86E06              <1> 	call	print
  4726 00001F9E 88D8                <1> 	mov	al,bl
  4727 00001FA0 D0E8                <1> 	shr	al,1
  4728 00001FA2 FEC0                <1> 	inc	al			; AL = COM port number (1..4)
  4729 00001FA4 E8C306              <1> 	call	print_digit
  4730 00001FA7 BE[9000]            <1> 	mov	si,msg_colon
  4731 00001FAA E85F06              <1> 	call	print
  4732 00001FAD 2E8B97[1720]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
  4733 00001FB2 EC                  <1> 	in	al,dx
  4734 00001FB3 B00F                <1> 	mov	al,0Fh
  4735 00001FB5 EE                  <1> 	out	dx,al			; enable interrupts
  4736 00001FB6 B000                <1> 	mov	al,00h
  4737 00001FB8 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
  4738 00001FBA EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4739 00001FBB 3C0F                <1> 	cmp	al,0Fh
  4740 00001FBD 7530                <1> 	jne	.no_port		; no port at this address
  4741 00001FBF B000                <1> 	mov	al,00h
  4742 00001FC1 EE                  <1> 	out	dx,al			; disable interrupts
  4743 00001FC2 B0FF                <1> 	mov	al,0FFh
  4744 00001FC4 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4745 00001FC6 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4746 00001FC7 3C00                <1> 	cmp	al,00h
  4747 00001FC9 7524                <1> 	jne	.no_port		; no port at this address
  4748 00001FCB 4A                  <1> 	dec	dx			; DX = UART base address
  4749                              <1> 					; OPTIMIZATION:
  4750                              <1> 					; uart_base = uart_ier_reg - 1
  4751 00001FCC 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
  4752                              <1> 					; data area
  4753                              <1> 					
  4754                              <1> 	;; SGEO serial port fix
  4755 00001FCE 50                  <1> 	push ax
  4756 00001FCF 51                  <1> 	push cx
  4757                              <1> 	
  4758 00001FD0 A11000              <1> 	mov ax,[equipment_list]
  4759 00001FD3 B109                <1> 	mov cl,9
  4760 00001FD5 D3E8                <1> 	shr ax,cl
  4761 00001FD7 2407                <1> 	and al,0x7
  4762 00001FD9 40                  <1> 	inc ax
  4763 00001FDA D3E0                <1> 	shl ax,cl	
  4764 00001FDC 81261000FFF1        <1> 	and word [equipment_list],0xF1FF
  4765 00001FE2 09061000            <1> 	or [equipment_list],ax
  4766                              <1> 	
  4767 00001FE6 59                  <1> 	pop cx
  4768 00001FE7 58                  <1> 	pop ax
  4769                              <1> 					
  4770 00001FE8 89D0                <1> 	mov	ax,dx
  4771 00001FEA E83A06              <1> 	call	print_hex
  4772 00001FED EB0A                <1> 	jmp	.next
  4773                              <1> 
  4774                              <1> .no_port:
  4775 00001FEF C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
  4776 00001FF3 BE[8B00]            <1> 	mov	si,msg_none
  4777 00001FF6 E81306              <1> 	call	print
  4778                              <1> 	
  4779                              <1> .next:
  4780 00001FF9 43                  <1> 	inc	bx
  4781 00001FFA 43                  <1> 	inc	bx
  4782 00001FFB 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
  4783 00001FFE 7408                <1> 	je	.done
  4784 00002000 BE[9300]            <1> 	mov	si,msg_semicolon
  4785 00002003 E80606              <1> 	call	print
  4786 00002006 EB90                <1> 	jmp	.detect_loop
  4787                              <1> 
  4788                              <1> .done:
  4789 00002008 BE[8800]            <1> 	mov	si,msg_crlf
  4790 0000200B E8FE05              <1> 	call	print
  4791                              <1> 
  4792 0000200E B024                <1> 	mov	al,e_serial_ok		; serial port detection complete
  4793 00002010 E680                <1> 	out	post_reg,al
  4794                              <1> 
  4795 00002012 5E                  <1> 	pop	si
  4796 00002013 5A                  <1> 	pop	dx
  4797 00002014 5B                  <1> 	pop	bx
  4798 00002015 58                  <1> 	pop	ax
  4799 00002016 C3                  <1> 	ret
  4800                              <1> 
  4801                              <1> ;-------------------------------------------------------------------------
  4802                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
  4803 00002017 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
  4804 0000201B E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
  4805                              <1> 
  4806                              <1> ;-------------------------------------------------------------------------
  4807                              <1> ; UART divisor values table
  4808 0000201F 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
  4809 00002021 0003                <1> 		dw	uart_osc/16/150		; 150 bps
  4810 00002023 8001                <1> 		dw	uart_osc/16/300		; 300 bps
  4811 00002025 C000                <1> 		dw	uart_osc/16/600		; 600 bps
  4812 00002027 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
  4813 00002029 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
  4814 0000202B 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
  4815 0000202D 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
  4816 0000202F 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
  4817 00002031 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
  4818 00002033 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
  4819 00002035 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
  4820                              <1> num_divisors	equ ($-uart_divisors)/2
  4821                                  %include	"printer1.inc"		; parallel printer services & detection
  4822                              <1> ;========================================================================
  4823                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
  4824                              <1> ;	INT 17h, function AH=01h 
  4825                              <1> ;	detect_parallel
  4826                              <1> ;	- see printer2.inc for other INT 17h functions
  4827                              <1> ;-------------------------------------------------------------------------
  4828                              <1> ;
  4829                              <1> ; Compiles with NASM 2.07, might work with other versions
  4830                              <1> ;
  4831                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4832                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4833                              <1> ;
  4834                              <1> ; This program is free software: you can redistribute it and/or modify
  4835                              <1> ; it under the terms of the GNU General Public License as published by
  4836                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4837                              <1> ; (at your option) any later version.
  4838                              <1> ;
  4839                              <1> ; This program is distributed in the hope that it will be useful,
  4840                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4841                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4842                              <1> ; GNU General Public License for more details.
  4843                              <1> ;
  4844                              <1> ; You should have received a copy of the GNU General Public License
  4845                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4846                              <1> ;
  4847                              <1> ;=========================================================================
  4848                              <1> 
  4849                              <1> num_parallel	equ	3		; number of parallel ports
  4850                              <1> 
  4851                              <1> prn_data_reg	equ	0		; printer data register (out)
  4852                              <1> 
  4853                              <1> prn_stat_reg	equ	1		; printer status register (in)
  4854                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
  4855                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
  4856                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
  4857                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
  4858                              <1> 
  4859                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
  4860                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
  4861                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
  4862                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
  4863                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
  4864                              <1> 
  4865                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
  4866                              <1> 
  4867                              <1> ;=========================================================================
  4868                              <1> ; int_17_fn01 - Initialize printer port
  4869                              <1> ; Input:
  4870                              <1> ;	AH = 1 - function 01h - initialize printer port
  4871                              <1> ;	DX = printer port number (0-2)
  4872                              <1> ; Output:
  4873                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  4874                              <1> ;-------------------------------------------------------------------------
  4875                              <1> int_17_fn01:
  4876 00002037 42                  <1> 	inc	dx
  4877 00002038 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  4878                              <1> 					; OPTIMIZATION:
  4879                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
  4880 00002039 B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
  4881 0000203B EE                  <1> 	out	dx,al
  4882 0000203C 51                  <1> 	push	cx
  4883 0000203D B9B509              <1> 	mov	cx,prn_init_delay
  4884 00002040 E8E4EE              <1> 	call	delay_15us
  4885 00002043 59                  <1> 	pop	cx
  4886 00002044 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  4887 00002046 EE                  <1> 	out	dx,al			; deactivate init bit
  4888 00002047 4A                  <1> 	dec	dx			; OPTIMIZATION:
  4889                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
  4890 00002048 E9EE4F              <1> 	jmp	int_17_status		; exit returning status
  4891                              <1> 
  4892                              <1> ;=========================================================================
  4893                              <1> ; detect_parallel - detect and print parallel ports
  4894                              <1> ; Input:
  4895                              <1> ;	none
  4896                              <1> ; Output:
  4897                              <1> ;	none (updates BIOS data area)
  4898                              <1> ; Notes:
  4899                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
  4900                              <1> ;	  enumeration is used:
  4901                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
  4902                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
  4903                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
  4904                              <1> ;-------------------------------------------------------------------------
  4905                              <1> detect_parallel:
  4906 0000204B 50                  <1> 	push	ax
  4907 0000204C 53                  <1> 	push	bx
  4908 0000204D 52                  <1> 	push	dx
  4909 0000204E 56                  <1> 	push	si
  4910 0000204F BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
  4911 00002052 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
  4912 00002056 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
  4913 0000205A 31DB                <1> 	xor	bx,bx			; BX = 0
  4914 0000205C 31FF                <1> 	xor	di,di			; DI = 0
  4915                              <1> .detect_loop:
  4916 0000205E 2E8B95[EF20]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
  4917 00002063 B05A                <1> 	mov	al,05Ah			; just some test value
  4918 00002065 EE                  <1> 	out	dx,al			; write it to the printer data register
  4919 00002066 B0FF                <1> 	mov	al,0FFh
  4920 00002068 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4921 0000206A EC                  <1> 	in	al,dx
  4922 0000206B 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
  4923 0000206D 751F                <1> 	jne	.no_port		; no port at this address
  4924 0000206F 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
  4925                              <1> 					; data area
  4926                              <1> 					
  4927                              <1> 	;; SGEO parallel port fix
  4928 00002072 50                  <1> 	push ax
  4929 00002073 51                  <1> 	push cx
  4930 00002074 A11000              <1> 	mov ax,[equipment_list]
  4931 00002077 B10E                <1> 	mov cl,14
  4932 00002079 D3E8                <1> 	shr ax,cl
  4933 0000207B 2403                <1> 	and al,0x3
  4934 0000207D 40                  <1> 	inc ax
  4935 0000207E D3E0                <1> 	shl ax,cl
  4936 00002080 81261000FF3F        <1> 	and word [equipment_list],0x3FFF
  4937 00002086 09061000            <1> 	or [equipment_list],ax
  4938 0000208A 59                  <1> 	pop cx
  4939 0000208B 58                  <1> 	pop ax
  4940 0000208C EB09                <1> 	jmp	.next
  4941                              <1> 
  4942                              <1> .no_port:
  4943 0000208E C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
  4944 00002093 09FF                <1> 	or	di,di			; no printer port at 3BCh?
  4945 00002095 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
  4946                              <1> .next:
  4947 00002097 43                  <1> 	inc	bx
  4948 00002098 43                  <1> 	inc	bx
  4949                              <1> 
  4950                              <1> .next_skip_3BC:
  4951 00002099 47                  <1> 	inc	di
  4952 0000209A 47                  <1> 	inc	di
  4953 0000209B 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
  4954 0000209E 7402                <1> 	je	.print			; done with detection, print findings
  4955 000020A0 EBBC                <1> 	jmp	.detect_loop
  4956                              <1> 
  4957                              <1> .print:
  4958 000020A2 BE[CA02]            <1> 	mov	si,msg_parallel
  4959 000020A5 E86405              <1> 	call	print
  4960 000020A8 31DB                <1> 	xor	bx,bx
  4961                              <1> 
  4962                              <1> .print_loop:
  4963 000020AA BE[E702]            <1> 	mov	si,msg_parallel_lpt
  4964 000020AD E85C05              <1> 	call	print
  4965 000020B0 88D8                <1> 	mov	al,bl
  4966 000020B2 D0E8                <1> 	shr	al,1
  4967 000020B4 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
  4968 000020B6 E8B105              <1> 	call	print_digit
  4969 000020B9 BE[9000]            <1> 	mov	si,msg_colon
  4970 000020BC E84D05              <1> 	call	print
  4971 000020BF 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
  4972 000020C2 09C0                <1> 	or	ax,ax			; parallel interface installed?
  4973 000020C4 7405                <1> 	jz	.print_no_port
  4974 000020C6 E85E05              <1> 	call	print_hex
  4975 000020C9 EB06                <1> 	jmp	.print_next
  4976                              <1> 
  4977                              <1> .print_no_port:
  4978 000020CB BE[8B00]            <1> 	mov	si,msg_none
  4979 000020CE E83B05              <1> 	call	print
  4980                              <1> 
  4981                              <1> .print_next:
  4982 000020D1 43                  <1> 	inc	bx
  4983 000020D2 43                  <1> 	inc	bx
  4984 000020D3 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
  4985 000020D6 7408                <1> 	je	.done
  4986 000020D8 BE[9300]            <1> 	mov	si,msg_semicolon
  4987 000020DB E82E05              <1> 	call	print
  4988 000020DE EBCA                <1> 	jmp	.print_loop
  4989                              <1> 
  4990                              <1> .done:
  4991 000020E0 BE[8800]            <1> 	mov	si,msg_crlf
  4992 000020E3 E82605              <1> 	call	print
  4993                              <1> 
  4994 000020E6 B025                <1> 	mov	al,e_parallel_ok	; parallel port detection complete
  4995 000020E8 E680                <1> 	out	post_reg,al
  4996                              <1> 
  4997 000020EA 5E                  <1> 	pop	si
  4998 000020EB 5A                  <1> 	pop	dx
  4999 000020EC 5B                  <1> 	pop	bx
  5000 000020ED 58                  <1> 	pop	ax
  5001 000020EE C3                  <1> 	ret
  5002                              <1> 
  5003                              <1> ;-------------------------------------------------------------------------
  5004                              <1> ; parallel port base addresses - used for port detection
  5005 000020EF BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
  5006                                  %ifdef PS2_MOUSE
  5007                                  %ifndef AT_COMPAT
  5008                                  %error "PS2_MOUSE depends on AT_COMPAT. Please fix config.inc."
  5009                                  %endif ; AT_COMPAT
  5010                                  %include	"ps2aux.inc"
  5011                              <1> ;=========================================================================
  5012                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  5013                              <1> ;	INT 15h, function AH=0C2h
  5014                              <1> ;	INT 74h - IRQ12 interrupt handler
  5015                              <1> ;-------------------------------------------------------------------------
  5016                              <1> ;
  5017                              <1> ; Compiles with NASM 2.07, might work with other versions
  5018                              <1> ;
  5019                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5020                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5021                              <1> ;
  5022                              <1> ; This program is free software: you can redistribute it and/or modify
  5023                              <1> ; it under the terms of the GNU General Public License as published by
  5024                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5025                              <1> ; (at your option) any later version.
  5026                              <1> ;
  5027                              <1> ; This program is distributed in the hope that it will be useful,
  5028                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5029                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5030                              <1> ; GNU General Public License for more details.
  5031                              <1> ;
  5032                              <1> ; You should have received a copy of the GNU General Public License
  5033                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5034                              <1> ;
  5035                              <1> ;=========================================================================
  5036                              <1> 
  5037                              <1> ;-------------------------------------------------------------------------
  5038                              <1> ; offsets for registers on stack
  5039                              <1> int_15_fnC2_bp	equ	0
  5040                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  5041                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  5042                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  5043                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  5044                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  5045                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  5046                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  5047                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  5048                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  5049                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  5050                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  5051                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  5052                              <1> 
  5053                              <1> ;=========================================================================
  5054                              <1> ; int_15_fnC2 - mouse functions
  5055                              <1> ; Input:
  5056                              <1> ;	AH = 0C2h - mouse functions
  5057                              <1> ;	AL - function:
  5058                              <1> ;		00h - enable / disable PS/2 mouse
  5059                              <1> ;		01h - reset PS/2 mouse
  5060                              <1> ;		02h - set sample rate
  5061                              <1> ;		03h - set resolution
  5062                              <1> ;		04h - read device type
  5063                              <1> ;		05h - initialize PS/2 mouse
  5064                              <1> ;		06h - set scaling or get status
  5065                              <1> ;		07h - set PS/2 mouse driver address
  5066                              <1> ; Output:
  5067                              <1> ;	AH - exit status:
  5068                              <1> ;		00h - no error
  5069                              <1> ;		01h - invalid function call
  5070                              <1> ;		02h - invalid input value
  5071                              <1> ;		03h - interface error
  5072                              <1> ;		04h - request for resend received from 8042
  5073                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  5074                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  5075                              <1> ;-------------------------------------------------------------------------
  5076                              <1> int_15_fnC2:
  5077 000020F5 50                  <1> 	push	ax
  5078 000020F6 53                  <1> 	push	bx
  5079 000020F7 51                  <1> 	push	cx
  5080 000020F8 52                  <1> 	push	dx
  5081 000020F9 1E                  <1> 	push	ds
  5082 000020FA 55                  <1> 	push	bp
  5083 000020FB 89E5                <1> 	mov	bp,sp			; establish stack addressing
  5084 000020FD BB4000              <1> 	mov	bx,biosdseg
  5085 00002100 8EDB                <1> 	mov	ds,bx
  5086 00002102 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  5087 00002106 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  5088 00002108 3C08                <1> 	cmp	al,.num_func
  5089 0000210A 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  5090 0000210C E8A9F8              <1> 	call	kbc_aux_disable		; disable auxiliary device
  5091 0000210F 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  5092 00002111 B700                <1> 	mov	bh,0
  5093 00002113 D1E3                <1> 	shl	bx,1			; address words
  5094 00002115 2EFFA7[1A21]        <1>     cs	jmp	near [.dispatch+bx]
  5095                              <1> 
  5096                              <1> .dispatch:
  5097 0000211A [5321]              <1> 	dw	int_15_fnC200
  5098 0000211C [7421]              <1> 	dw	int_15_fnC201
  5099 0000211E [9721]              <1> 	dw	int_15_fnC202
  5100 00002120 [BE21]              <1> 	dw	int_15_fnC203
  5101 00002122 [E021]              <1> 	dw	int_15_fnC204
  5102 00002124 [F821]              <1> 	dw	int_15_fnC205
  5103 00002126 [3C22]              <1> 	dw	int_15_fnC206
  5104 00002128 [8D22]              <1> 	dw	int_15_fnC207
  5105                              <1> .num_func	equ ($-.dispatch)/2
  5106                              <1> 
  5107                              <1> int_15_fnC2_ok:
  5108 0000212A B400                <1> 	mov	ah,00h			; no error
  5109 0000212C 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  5110 00002130 EB14                <1> 	jmp	int_15_fnC2_exit
  5111                              <1> 
  5112                              <1> int_15_fnC2_err1:
  5113 00002132 B401                <1> 	mov	ah,01h			; invalid function call
  5114 00002134 EB0C                <1> 	jmp	int_15_fnC2_err
  5115                              <1> 
  5116                              <1> int_15_fnC2_err2:
  5117 00002136 B402                <1> 	mov	ah,02h			; invalid input value
  5118 00002138 EB08                <1> 	jmp	int_15_fnC2_err
  5119                              <1> 
  5120                              <1> int_15_fnC2_err3:
  5121 0000213A B403                <1> 	mov	ah,03h			; interface error
  5122 0000213C EB04                <1> 	jmp	int_15_fnC2_err
  5123                              <1> 
  5124                              <1> int_15_fnC2_err5:
  5125 0000213E B405                <1> 	mov	ah,05h			; no driver installed
  5126 00002140 EB00                <1> 	jmp	int_15_fnC2_err
  5127                              <1> 
  5128                              <1> int_15_fnC2_err:
  5129 00002142 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  5130                              <1> 
  5131                              <1> int_15_fnC2_exit:
  5132 00002146 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  5133 00002149 E862F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
  5134 0000214C 5D                  <1> 	pop	bp
  5135 0000214D 1F                  <1> 	pop	ds
  5136 0000214E 5A                  <1> 	pop	dx
  5137 0000214F 59                  <1> 	pop	cx
  5138 00002150 5B                  <1> 	pop	bx
  5139 00002151 58                  <1> 	pop	ax
  5140 00002152 CF                  <1> 	iret
  5141                              <1> 
  5142                              <1> ;=========================================================================
  5143                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  5144                              <1> ; Input:
  5145                              <1> ;	AX = 0C200h
  5146                              <1> ;	BH - sub-function:
  5147                              <1> ;		00h - disable
  5148                              <1> ;		01h - enable
  5149                              <1> ;-------------------------------------------------------------------------
  5150                              <1> int_15_fnC200:
  5151 00002153 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5152 00002156 80FF01              <1> 	cmp	bh,01h
  5153 00002159 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5154                              <1> 
  5155 0000215B F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  5156 00002160 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  5157                              <1> 
  5158 00002162 80FF00              <1> 	cmp	bh,00h
  5159 00002165 7404                <1> 	je	.disable
  5160 00002167 B0F4                <1> 	mov	al,0F4h			; device enable command
  5161 00002169 EB02                <1> 	jmp	.send_it
  5162                              <1> .disable:
  5163 0000216B B0F5                <1> 	mov	al,0F5h			; device disable command
  5164                              <1> 
  5165                              <1> .send_it:
  5166 0000216D E806F8              <1> 	call	kbc_aux_send
  5167 00002170 72D0                <1> 	jc	int_15_fnC2_err		; error
  5168 00002172 EBB6                <1> 	jmp	int_15_fnC2_ok
  5169                              <1> 
  5170                              <1> ;=========================================================================
  5171                              <1> ; int_15_fnC201 - reset PS/2 mouse
  5172                              <1> ; Input:
  5173                              <1> ;	AX = 0C201h
  5174                              <1> ; Output:
  5175                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  5176                              <1> ;	     0AAh - BAT successful XXX test!!!
  5177                              <1> ;	     0FCh - BAT error
  5178                              <1> ;	BH = device ID
  5179                              <1> ;-------------------------------------------------------------------------
  5180                              <1> int_15_fnC201:
  5181 00002174 B90A00              <1> 	mov	cx,10			; try the reset 10 times
  5182                              <1> .1:
  5183 00002177 B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5184 00002179 E8FAF7              <1> 	call	kbc_aux_send
  5185 0000217C 7307                <1> 	jnc	.2			; no error - continue
  5186 0000217E 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5187 00002181 E1F4                <1> 	loopz	.1			; try again
  5188 00002183 EBBD                <1> 	jmp	int_15_fnC2_err		; error
  5189                              <1> .2:
  5190 00002185 E8D3F7              <1> 	call	kbc_aux_read
  5191 00002188 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  5192 0000218A 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5193 0000218D E8CBF7              <1> 	call	kbc_aux_read
  5194 00002190 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  5195 00002192 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5196 00002195 EB93                <1> 	jmp	int_15_fnC2_ok
  5197                              <1> 
  5198                              <1> ;=========================================================================
  5199                              <1> ; int_15_fnC202 - set sample rate
  5200                              <1> ; Input:
  5201                              <1> ;	AX = 0C202h
  5202                              <1> ;	BH - sample rate:
  5203                              <1> ;		00h - 10 samples per second
  5204                              <1> ;		01h - 20 samples per second
  5205                              <1> ;		02h - 40 samples per second
  5206                              <1> ;		03h - 60 samples per second
  5207                              <1> ;		04h - 80 samples per second
  5208                              <1> ;		05h - 100 samples per second
  5209                              <1> ;		06h - 200 samples per second
  5210                              <1> ;-------------------------------------------------------------------------
  5211                              <1> int_15_fnC202:
  5212 00002197 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5213 0000219A 80FF06              <1> 	cmp	bh,06h
  5214 0000219D 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  5215 0000219F 88FB                <1> 	mov	bl,bh
  5216 000021A1 B700                <1> 	mov	bh,00h			; rate index in BX
  5217                              <1> 
  5218 000021A3 B0F3                <1> 	mov	al,0F3h			; set sample rate
  5219 000021A5 E8CEF7              <1> 	call	kbc_aux_send
  5220 000021A8 7298                <1> 	jc	int_15_fnC2_err		; error
  5221                              <1> 
  5222 000021AA 2E8A87[B721]        <1>     cs	mov	al,byte [.rate_table+bx]
  5223 000021AF E8C4F7              <1> 	call	kbc_aux_send
  5224 000021B2 728E                <1> 	jc	int_15_fnC2_err		; error
  5225 000021B4 E973FF              <1> 	jmp	int_15_fnC2_ok
  5226                              <1> 
  5227 000021B7 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  5228                              <1> 	
  5229                              <1> ;=========================================================================
  5230                              <1> ; int_15_fnC203 - set resolution
  5231                              <1> ; Input:
  5232                              <1> ;	AX = 0C203h
  5233                              <1> ;	BH - resolution value:
  5234                              <1> ;		00h - 1 count per millimeter
  5235                              <1> ;		01h - 2 counts per millimeter
  5236                              <1> ;		02h - 4 counts per millimeter
  5237                              <1> ;		03h - 8 counts per millimeter
  5238                              <1> ;-------------------------------------------------------------------------
  5239                              <1> int_15_fnC203:
  5240 000021BE 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5241 000021C1 80FF03              <1> 	cmp	bh,03h
  5242 000021C4 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5243                              <1> 
  5244 000021C9 B0E8                <1> 	mov	al,0E8h			; set resolution
  5245 000021CB E8A8F7              <1> 	call	kbc_aux_send
  5246 000021CE 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  5247                              <1> 
  5248 000021D3 88F8                <1> 	mov	al,bh
  5249 000021D5 E89EF7              <1> 	call	kbc_aux_send
  5250 000021D8 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  5251 000021DD E94AFF              <1> 	jmp	int_15_fnC2_ok
  5252                              <1> 
  5253                              <1> ;=========================================================================
  5254                              <1> ; int_15_fnC204 - read device type
  5255                              <1> ; Input:
  5256                              <1> ;	AX = 0C204h
  5257                              <1> ; Output:
  5258                              <1> ;	BH = device type
  5259                              <1> ;-------------------------------------------------------------------------
  5260                              <1> int_15_fnC204:
  5261 000021E0 B0F2                <1> 	mov	al,0F2h			; read device type
  5262 000021E2 E891F7              <1> 	call	kbc_aux_send
  5263 000021E5 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  5264 000021EA E86EF7              <1> 	call	kbc_aux_read
  5265 000021ED 7303E948FF          <1> 	jc	int_15_fnC2_err3
  5266 000021F2 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5267 000021F5 E932FF              <1> 	jmp	int_15_fnC2_ok
  5268                              <1> 
  5269                              <1> ;=========================================================================
  5270                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  5271                              <1> ; Input:
  5272                              <1> ;	AX = 0C205h
  5273                              <1> ;	BH = data package size in bytes (03h or 04h)
  5274                              <1> ; Output:
  5275                              <1> ;	none
  5276                              <1> ;-------------------------------------------------------------------------
  5277                              <1> int_15_fnC205:
  5278 000021F8 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5279 000021FB 80FF03              <1> 	cmp	bh,03h
  5280 000021FE 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  5281 00002203 80FF04              <1> 	cmp	bh,04h
  5282 00002206 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5283 0000220B FECF                <1> 	dec	bh
  5284                              <1> 
  5285 0000220D A02700              <1> 	mov	al,byte [mouse_flags_2]
  5286 00002210 24F8                <1> 	and	al,0F8h			; mask out package size bits
  5287 00002212 08F8                <1> 	or	al,bh			; add the new package size
  5288 00002214 A22700              <1> 	mov	byte [mouse_flags_2],al
  5289                              <1> 
  5290 00002217 B90500              <1> 	mov	cx,5			; try the reset 5 times
  5291                              <1> .1:
  5292 0000221A B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5293 0000221C E857F7              <1> 	call	kbc_aux_send
  5294 0000221F 7308                <1> 	jnc	.2			; no error - continue
  5295 00002221 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5296 00002224 E1F4                <1> 	loopz	.1			; try again
  5297 00002226 E919FF              <1> 	jmp	int_15_fnC2_err		; error
  5298                              <1> .2:
  5299 00002229 E82FF7              <1> 	call	kbc_aux_read
  5300 0000222C 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5301 00002231 E827F7              <1> 	call	kbc_aux_read
  5302 00002234 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5303 00002239 E9EEFE              <1> 	jmp	int_15_fnC2_ok
  5304                              <1> 
  5305                              <1> ;=========================================================================
  5306                              <1> ; int_15_fnC206 - set scaling or get status
  5307                              <1> ; Input:
  5308                              <1> ;	AX = 0C206h
  5309                              <1> ;	BH - sub-function:
  5310                              <1> ;		00h - return status
  5311                              <1> ;		01h - set scaling factor to 1:1
  5312                              <1> ;		02h - set scaling factor to 2:1
  5313                              <1> ; Output:
  5314                              <1> ;	if BH = 00h on entry:
  5315                              <1> ;		BL - status byte 1:
  5316                              <1> ;			bit 0 = 1 - right button pressed
  5317                              <1> ;			bit 1 = 0 - reserved
  5318                              <1> ;			bit 2 = 1 - left button pressed
  5319                              <1> ;			bit 3 = 0 - reserved
  5320                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  5321                              <1> ;			bit 5 = 0 - disable, 1 - enable
  5322                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  5323                              <1> ;			bit 7 = 0 - reserved
  5324                              <1> ;		CL - status byte 2:
  5325                              <1> ;			00h - 1 count per millimeter
  5326                              <1> ;			01h - 2 counts per millimeter
  5327                              <1> ;			02h - 4 counts per millimeter
  5328                              <1> ;			03h - 8 counts per millimeter
  5329                              <1> ;		DL - status byte 3:
  5330                              <1> ;			0Ah - 10 samples per second
  5331                              <1> ;			14h - 20 samples per second
  5332                              <1> ;			3Ch - 40 samples per second
  5333                              <1> ;			3Ch - 60 samples per second
  5334                              <1> ;			50h - 80 samples per second
  5335                              <1> ;			64h - 100 samples per second
  5336                              <1> ;			0C8h - 200 samples per second
  5337                              <1> ;-------------------------------------------------------------------------
  5338                              <1> int_15_fnC206:
  5339 0000223C 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5340 0000223F 80FF02              <1> 	cmp	bh,02h
  5341 00002242 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5342 00002247 7433                <1> 	je	.scale_2x1
  5343 00002249 80FF01              <1> 	cmp	bh,01h
  5344 0000224C 7432                <1> 	je	.scale_1x1
  5345                              <1> 					; BH == 0, return status
  5346 0000224E B0E9                <1> 	mov	al,0E9h			; request status command
  5347 00002250 E823F7              <1> 	call	kbc_aux_send
  5348 00002253 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  5349 00002258 E800F7              <1> 	call	kbc_aux_read
  5350 0000225B 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5351 00002260 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5352 00002263 E8F5F6              <1> 	call	kbc_aux_read
  5353 00002266 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5354 0000226B 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  5355 0000226E E8EAF6              <1> 	call	kbc_aux_read
  5356 00002271 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  5357 00002276 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  5358 00002279 E9AEFE              <1> 	jmp	int_15_fnC2_ok
  5359                              <1> 
  5360                              <1> .scale_2x1:
  5361 0000227C B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  5362 0000227E EB02                <1> 	jmp	.send_it
  5363                              <1> .scale_1x1:
  5364 00002280 B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  5365                              <1> .send_it:
  5366 00002282 E8F1F6              <1> 	call	kbc_aux_send
  5367 00002285 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  5368 0000228A E99DFE              <1> 	jmp	int_15_fnC2_ok
  5369                              <1> 
  5370                              <1> ;=========================================================================
  5371                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  5372                              <1> ; Input:
  5373                              <1> ;	AX = 0C207h
  5374                              <1> ;	ES:BX - pointer to mouse driver
  5375                              <1> ;-------------------------------------------------------------------------
  5376                              <1> int_15_fnC207:
  5377 0000228D 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  5378 00002290 891E2200            <1> 	mov	word [mouse_driver],bx
  5379 00002294 8CC0                <1> 	mov	ax,es
  5380 00002296 A32400              <1> 	mov	word [mouse_driver+2],ax
  5381 00002299 09C0                <1> 	or	ax,ax
  5382 0000229B 750C                <1> 	jnz	.set_handler
  5383 0000229D 09DB                <1> 	or	bx,bx
  5384 0000229F 7508                <1> 	jnz	.set_handler
  5385                              <1> ; remove handler
  5386 000022A1 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  5387 000022A6 E981FE              <1> 	jmp	int_15_fnC2_ok
  5388                              <1> 
  5389                              <1> .set_handler:
  5390 000022A9 800E270080          <1> 	or	byte [mouse_flags_2],80h
  5391 000022AE E979FE              <1> 	jmp	int_15_fnC2_ok
  5392                              <1> 
  5393                              <1> ;=========================================================================
  5394                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  5395                              <1> ;-------------------------------------------------------------------------
  5396                              <1> int_74:
  5397 000022B1 FB                  <1> 	sti
  5398 000022B2 50                  <1> 	push	ax
  5399 000022B3 53                  <1> 	push	bx
  5400 000022B4 1E                  <1> 	push	ds
  5401 000022B5 B84000              <1> 	mov	ax,biosdseg
  5402 000022B8 8ED8                <1> 	mov	ds,ax
  5403 000022BA A10E00              <1> 	mov	ax,word [ebda_segment]
  5404 000022BD 8ED8                <1> 	mov	ds,ax
  5405                              <1> 
  5406 000022BF E464                <1> 	in	al,kbc_status_reg
  5407 000022C1 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  5408 000022C3 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  5409 000022C5 7561                <1> 	jne	.exit			; no mouse data in the buffer
  5410                              <1> 
  5411 000022C7 E460                <1> 	in	al,kbc_data_reg
  5412 000022C9 88C4                <1> 	mov	ah,al			; save to AH
  5413                              <1> 
  5414 000022CB A02700              <1> 	mov	al,byte [mouse_flags_2]
  5415 000022CE A880                <1> 	test	al,80h
  5416 000022D0 7456                <1> 	jz	.exit			; no mouse driver installed
  5417                              <1> 
  5418 000022D2 A02600              <1> 	mov	al,byte [mouse_flags_1]
  5419 000022D5 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  5420 000022D7 BB2800              <1> 	mov	bx,mouse_data
  5421 000022DA 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  5422 000022DC 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  5423                              <1> 
  5424 000022DE 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  5425 000022E2 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  5426                              <1> 
  5427 000022E5 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  5428 000022E7 7306                <1> 	jae	.call_driver
  5429                              <1> 
  5430 000022E9 FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  5431 000022ED EB39                <1> 	jmp	.exit
  5432                              <1> 
  5433                              <1> .call_driver:
  5434                              <1> 
  5435                              <1> ;-------------------------------------------------------------------------
  5436                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  5437                              <1> ; package sizes.
  5438                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  5439                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  5440                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  5441                              <1> ;-------------------------------------------------------------------------
  5442                              <1> 
  5443 000022EF 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  5444 000022F2 7413                <1> 	jz	.four_bytes
  5445                              <1> 					; put data in stack for 3 bytes format
  5446 000022F4 31C0                <1> 	xor	ax,ax
  5447 000022F6 A02800              <1> 	mov	al,byte [mouse_data]
  5448 000022F9 50                  <1> 	push	ax
  5449 000022FA A02900              <1> 	mov	al,byte [mouse_data+1]
  5450 000022FD 50                  <1> 	push	ax
  5451 000022FE A02A00              <1> 	mov	al,byte [mouse_data+2]
  5452 00002301 50                  <1> 	push	ax
  5453 00002302 B000                <1> 	mov	al,00h
  5454 00002304 50                  <1> 	push	ax
  5455 00002305 EB15                <1> 	jmp	.do_call
  5456                              <1> 
  5457                              <1> .four_bytes:				; put data in stack for 4 bytes format
  5458 00002307 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  5459 0000230B A02800              <1> 	mov	al,byte [mouse_data]
  5460 0000230E 50                  <1> 	push	ax
  5461 0000230F B400                <1> 	mov	ah,00h
  5462 00002311 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5463 00002314 50                  <1> 	push	ax
  5464 00002315 A02B00              <1> 	mov	al,byte [mouse_data+3]
  5465 00002318 50                  <1> 	push	ax
  5466 00002319 B000                <1> 	mov	al,00h
  5467 0000231B 50                  <1> 	push	ax
  5468                              <1> 
  5469                              <1> .do_call:
  5470 0000231C FF1E2200            <1> 	call	far [mouse_driver]
  5471 00002320 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  5472 00002323 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  5473                              <1> 
  5474                              <1> .exit:
  5475 00002328 B020                <1> 	mov	al,20h
  5476 0000232A E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  5477 0000232C E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  5478 0000232E 1F                  <1> 	pop	ds
  5479 0000232F 5B                  <1> 	pop	bx
  5480 00002330 58                  <1> 	pop	ax
  5481 00002331 CF                  <1> 	iret
  5482                                  %endif
  5483                                  %include	"sound.inc"		; sound test
  5484                              <1> ;=========================================================================
  5485                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  5486                              <1> ;-------------------------------------------------------------------------
  5487                              <1> ;
  5488                              <1> ; Compiles with NASM 2.07, might work with other versions
  5489                              <1> ;
  5490                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5491                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5492                              <1> ;
  5493                              <1> ; This program is free software: you can redistribute it and/or modify
  5494                              <1> ; it under the terms of the GNU General Public License as published by
  5495                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5496                              <1> ; (at your option) any later version.
  5497                              <1> ;
  5498                              <1> ; This program is distributed in the hope that it will be useful,
  5499                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5500                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5501                              <1> ; GNU General Public License for more details.
  5502                              <1> ;
  5503                              <1> ; You should have received a copy of the GNU General Public License
  5504                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5505                              <1> ;
  5506                              <1> ;=========================================================================
  5507                              <1> 
  5508 00002332 6908                <1> notes	dw	pic_freq/554		; D flat
  5509 00002334 FFFF                <1> 	dw	-1			; silent
  5510 00002336 8814                <1> 	dw	pic_freq/227		; D flat
  5511 00002338 980C                <1> 	dw	pic_freq/370		; G flat
  5512 0000233A 8814                <1> 	dw	pic_freq/227		; D flat
  5513 0000233C 3B0B                <1> 	dw	pic_freq/415		; A flat
  5514 0000233E 0000                <1> 	dw	0
  5515                              <1> 
  5516                              <1> ;=========================================================================
  5517                              <1> ; sound - Play power-on sound.
  5518                              <1> ; Input:
  5519                              <1> ;	none
  5520                              <1> ; Output:
  5521                              <1> ;	none, destroys some registers
  5522                              <1> ;-------------------------------------------------------------------------
  5523                              <1> sound:
  5524 00002340 FC                  <1> 	cld
  5525 00002341 BE[3223]            <1> 	mov	si,notes		; set SI to notes table
  5526                              <1> 
  5527 00002344 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5528 00002346 E643                <1> 	out	pit_ctl_reg,al
  5529                              <1> 
  5530                              <1> .loop:
  5531 00002348 2EAD                <1>     cs	lodsw				; load next note to AX
  5532 0000234A 83F800              <1> 	cmp	ax,0
  5533 0000234D 7422                <1> 	jz	.exit
  5534 0000234F 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  5535 00002351 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5536 00002353 88E0                <1> 	mov	al,ah
  5537 00002355 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5538                              <1> 
  5539 00002357 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5540 00002359 0C03                <1>         or      al,03h			; turn on the speaker
  5541 0000235B E661                <1>         out     port_b_reg,al		; write the new value
  5542                              <1> 
  5543                              <1> .silent:
  5544 0000235D B90030              <1> 	mov	cx,3000h
  5545 00002360 E8C4EB              <1> 	call	delay_15us		; delay while note is playing
  5546                              <1> 
  5547 00002363 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5548 00002365 24FC                <1> 	and	al,0FCh			; turn off the speaker
  5549 00002367 E661                <1>         out     port_b_reg,al		; write the new value
  5550                              <1> 
  5551 00002369 B90001              <1>         mov     cx,0100h
  5552 0000236C E8B8EB              <1> 	call	delay_15us		; delay after the note
  5553                              <1>         
  5554 0000236F EBD7                <1>         jmp     .loop			; play the next note
  5555                              <1> .exit:
  5556 00002371 C3                  <1> 	ret
  5557                              <1> 
  5558                              <1> ;=========================================================================
  5559                              <1> ; beep - Play a beep sound
  5560                              <1> ; Input:
  5561                              <1> ;	BL - duration in 0.1 second
  5562                              <1> ; Output:
  5563                              <1> ;	BL = 0
  5564                              <1> ;-------------------------------------------------------------------------
  5565                              <1> beep:
  5566 00002372 50                  <1> 	push	ax
  5567 00002373 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5568 00002375 E643                <1> 	out	pit_ctl_reg,al
  5569 00002377 B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  5570 0000237A E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5571 0000237C 88E0                <1> 	mov	al,ah
  5572 0000237E E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5573 00002380 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5574 00002382 0C03                <1> 	or	al,03h			; turn on the speaker
  5575 00002384 E661                <1> 	out	port_b_reg,al		; write the new value
  5576                              <1> .loop:
  5577 00002386 B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  5578 00002389 E89BEB              <1> 	call	delay_15us
  5579 0000238C FECB                <1> 	dec	bl
  5580 0000238E 75F6                <1> 	jnz	.loop
  5581 00002390 3403                <1> 	xor	al,03h			; turn off the speaker
  5582 00002392 E661                <1> 	out	port_b_reg,al		; write the new value
  5583 00002394 58                  <1> 	pop	ax
  5584 00002395 C3                  <1> 	ret
  5585                                  %include	"cpu.inc"		; CPU and FPU detection
  5586                              <1> ;=========================================================================
  5587                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  5588                              <1> ;-------------------------------------------------------------------------
  5589                              <1> ;
  5590                              <1> ; Compiles with NASM 2.07, might work with other versions
  5591                              <1> ;
  5592                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5593                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5594                              <1> ;
  5595                              <1> ; This program is free software: you can redistribute it and/or modify
  5596                              <1> ; it under the terms of the GNU General Public License as published by
  5597                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5598                              <1> ; (at your option) any later version.
  5599                              <1> ;
  5600                              <1> ; This program is distributed in the hope that it will be useful,
  5601                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5602                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5603                              <1> ; GNU General Public License for more details.
  5604                              <1> ;
  5605                              <1> ; You should have received a copy of the GNU General Public License
  5606                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5607                              <1> ;
  5608                              <1> ;=========================================================================
  5609                              <1> 
  5610                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  5611                              <1> 
  5612                              <1> ;=========================================================================
  5613                              <1> ; detect_cpu - detect and print CPU type
  5614                              <1> ; Note:
  5615                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  5616                              <1> ;	  incorrect results if used on other CPU types.
  5617                              <1> ;-------------------------------------------------------------------------
  5618                              <1> detect_cpu:
  5619 00002396 50                  <1> 	push	ax
  5620 00002397 56                  <1> 	push	si
  5621 00002398 BE[9600]            <1> 	mov	si,msg_cpu
  5622 0000239B E86E02              <1> 	call	print
  5623                              <1> 
  5624                              <1> ; test for NEC V20
  5625 0000239E B80101              <1> 	mov	ax,0101h
  5626 000023A1 D510                <1> 	aad	10h			; NEC V20 ignores the argument
  5627 000023A3 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  5628 000023A5 7452                <1> 	je	.nec_v20
  5629                              <1> 
  5630                              <1> ; not NEC V20, test for various 8088 versions
  5631                              <1> .i8088:					; 8088 - NMOS version of 8088
  5632 000023A7 FA                  <1> 	cli				; disable interrupts
  5633 000023A8 1E                  <1> 	push	ds
  5634 000023A9 31C0                <1> 	xor	ax,ax
  5635 000023AB 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  5636 000023AD B8[0624]            <1> 	mov	ax,.int_01		; new int 01h offset
  5637 000023B0 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  5638 000023B4 50                  <1> 	push	ax			; save to stack
  5639 000023B5 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  5640 000023B7 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  5641 000023BB 50                  <1> 	push	ax			; save to stack
  5642 000023BC 9C                  <1> 	pushf				; push flags to stack (save)
  5643 000023BD 9C                  <1> 	pushf				; push flags to stack (modify)
  5644 000023BE 58                  <1> 	pop	ax			; and move them to AX
  5645 000023BF 0D0001              <1> 	or	ax,flags_tf		; set TF
  5646 000023C2 50                  <1> 	push	ax
  5647 000023C3 31C0                <1> 	xor	ax,ax			; AX = 0
  5648 000023C5 9D                  <1> 	popf				; load modified value to FLAGS register
  5649                              <1> 					; enable single-step
  5650 000023C6 90                  <1> 	nop
  5651 000023C7 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  5652                              <1> 					; after PUSH SREG instructions
  5653                              <1> .push_sreg:				; and will not single-step to here
  5654 000023C8 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  5655                              <1> 					; after modifying segment registers
  5656                              <1> .pop_sreg:				; and will not single-step to here
  5657 000023C9 90                  <1> 	nop
  5658 000023CA 9D                  <1> 	popf				; restore original FLAGS, disable
  5659                              <1> 					; single-step
  5660                              <1> 
  5661 000023CB 5E                  <1> 	pop	si			; get original int 01h segment
  5662 000023CC 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  5663 000023D0 5E                  <1> 	pop	si			; get original int 01h offset
  5664 000023D1 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  5665 000023D5 1F                  <1> 	pop	ds
  5666 000023D6 FB                  <1> 	sti				; enable interrupts
  5667 000023D7 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  5668 000023DA 740D                <1> 	jz	.i8088_78
  5669                              <1> 
  5670 000023DC 83F802              <1> 	cmp	ax,0002h
  5671 000023DF 7410                <1> 	jz	.i8088_81
  5672                              <1> 
  5673                              <1> .harris:				; Harris / Intersil 80C88
  5674 000023E1 BE[6201]            <1> 	mov	si,msg_cpu_harris
  5675 000023E4 E82502              <1> 	call	print
  5676 000023E7 EB16                <1> 	jmp	.exit
  5677                              <1> 
  5678                              <1> .i8088_78:
  5679 000023E9 BE[D000]            <1> 	mov	si,msg_cpu_8088_78
  5680 000023EC E81D02              <1> 	call	print
  5681 000023EF EB0E                <1> 	jmp	.exit
  5682                              <1> 
  5683                              <1> .i8088_81:
  5684 000023F1 BE[3101]            <1> 	mov	si,msg_cpu_8088_81
  5685 000023F4 E81502              <1> 	call	print
  5686 000023F7 EB06                <1> 	jmp	.exit
  5687                              <1> 
  5688                              <1> .nec_v20:
  5689 000023F9 BE[7A01]            <1> 	mov	si,msg_cpu_nec_v20
  5690 000023FC E80D02              <1> 	call	print
  5691                              <1> 
  5692                              <1> .exit:
  5693 000023FF B021                <1> 	mov	al,e_cpu_detect_ok	; CPU detection finished
  5694 00002401 E680                <1> 	out	post_reg,al
  5695                              <1> 
  5696 00002403 5E                  <1> 	pop	si
  5697 00002404 58                  <1> 	pop	ax
  5698 00002405 C3                  <1> 	ret
  5699                              <1> 
  5700                              <1> ; stack frame after "push bp"
  5701                              <1> ; BP - word [BP]
  5702                              <1> ; IP - word [BP+2]
  5703                              <1> ; CS - word [BP+4]
  5704                              <1> ; FLAGS - word [BP+6]
  5705                              <1> .int_01:
  5706 00002406 55                  <1> 	push	bp
  5707 00002407 89E5                <1> 	mov	bp,sp
  5708 00002409 817E02[C923]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  5709 0000240E 7504                <1> 	jne	.1
  5710 00002410 B001                <1> 	mov	al,01h			; (C) INTEL '79
  5711 00002412 EB09                <1> 	jmp	.int_01_exit
  5712                              <1> .1:
  5713 00002414 817E02[C823]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  5714 00002419 7502                <1> 	jne	.int_01_exit
  5715 0000241B B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  5716                              <1> .int_01_exit:
  5717 0000241D 5D                  <1> 	pop	bp
  5718 0000241E CF                  <1> 	iret
  5719                              <1> 
  5720                              <1> ;=========================================================================
  5721                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  5722                              <1> ;-------------------------------------------------------------------------
  5723                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  5724                              <1> detect_fpu:
  5725 0000241F 50                  <1> 	push	ax
  5726 00002420 51                  <1> 	push	cx
  5727 00002421 56                  <1> 	push	si
  5728 00002422 BE[B300]            <1> 	mov	si,msg_fpu
  5729 00002425 E8E401              <1> 	call	print
  5730 00002428 DBE3                <1> 	fninit				; initialize coprocessor
  5731 0000242A B90300              <1> 	mov	cx,3
  5732                              <1> .wait:
  5733 0000242D E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  5734                              <1> 					;   (can't use fwait, since it could
  5735                              <1> 					;   be no coprocessor at all)
  5736 0000242F 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  5737 00002433 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  5738 00002439 D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  5739 0000243D 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  5740 00002443 750D                <1> 	jne	.no_fpu			;   after finit
  5741                              <1> 
  5742                              <1> .fpu:
  5743 00002445 BE[8401]            <1> 	mov	si,msg_fpu_present
  5744 00002448 E8C101              <1> 	call	print
  5745 0000244B 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  5746 00002450 EB06                <1> 	jmp	.exit
  5747                              <1> 
  5748                              <1> .no_fpu:
  5749                              <1> 
  5750 00002452 BE[A002]            <1> 	mov	si,msg_absent
  5751 00002455 E8B401              <1> 	call	print
  5752                              <1> 
  5753                              <1> .exit:
  5754 00002458 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  5755                              <1> 
  5756 0000245C B022                <1> 	mov	al,e_fpu_detect_ok	; FPU detection finished
  5757 0000245E E680                <1> 	out	post_reg,al
  5758                              <1> 
  5759 00002460 5E                  <1> 	pop	si
  5760 00002461 59                  <1> 	pop	cx
  5761 00002462 58                  <1> 	pop	ax
  5762 00002463 C3                  <1> 	ret
  5763                                  
  5764                                  %ifdef AT_COMPAT
  5765                                  
  5766                                  ;=========================================================================
  5767                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  5768                                  ;-------------------------------------------------------------------------
  5769                                  int_ignore2:
  5770 00002464 50                      	push	ax
  5771 00002465 B020                    	mov	al,20h
  5772 00002467 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5773 00002469 E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5774 0000246B 58                      	pop	ax
  5775 0000246C CF                      	iret
  5776                                  
  5777                                  ;=========================================================================
  5778                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  5779                                  ;-------------------------------------------------------------------------
  5780                                  int_71:
  5781 0000246D 50                      	push	ax
  5782 0000246E B020                    	mov	al,20h
  5783 00002470 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5784 00002472 58                      	pop	ax
  5785 00002473 CD0A                    	int	0Ah		; call IRQ2 ISR
  5786 00002475 CF                      	iret
  5787                                  
  5788                                  ;=========================================================================
  5789                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  5790                                  ;-------------------------------------------------------------------------
  5791                                  int_75:
  5792 00002476 50                      	push	ax
  5793 00002477 B020                    	mov	al,20h
  5794 00002479 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5795 0000247B E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5796 0000247D 58                      	pop	ax
  5797 0000247E CD02                    	int	02h		; call NMI ISR
  5798 00002480 CF                      	iret
  5799                                  
  5800                                  %endif ; AT_COMPAT
  5801                                  
  5802                                  ;=========================================================================
  5803                                  ; extension_scan - scan for BIOS extensions
  5804                                  ; Input:
  5805                                  ;	DX - start segment
  5806                                  ;	BX - end segment
  5807                                  ; Returns:
  5808                                  ;	DX - address for the continuation of the scan
  5809                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  5810                                  ;-------------------------------------------------------------------------
  5811                                  extension_scan:
  5812 00002481 C70667000000            	mov	word [67h],0
  5813 00002487 C70669000000            	mov	word [69h],0
  5814                                  .scan:
  5815 0000248D 8EC2                    	mov	es,dx
  5816 0000248F 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  5817 00002496 7532                    	jnz	.next			; no signature, check next 2 KiB
  5818 00002498 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  5819 0000249C B400                    	mov	ah,0
  5820 0000249E B105                    	mov	cl,5
  5821 000024A0 D3E0                    	shl	ax,cl			; convert size to paragraphs
  5822 000024A2 01C2                    	add	dx,ax
  5823 000024A4 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  5824 000024A7 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  5825 000024AA B104                    	mov	cl,4
  5826 000024AC D3E0                    	shl	ax,cl			; convert size to bytes
  5827 000024AE 89C1                    	mov	cx,ax
  5828 000024B0 B000                    	mov	al,0
  5829 000024B2 31F6                    	xor	si,si
  5830                                  .checksum:
  5831 000024B4 260204                      es	add	al,byte [si]
  5832 000024B7 46                      	inc	si
  5833 000024B8 E2FA                    	loop	.checksum
  5834 000024BA 08C0                    	or	al,al			; AL == 0?
  5835 000024BC 750C                    	jnz	.next			; AL not zero - bad checksum
  5836 000024BE C70667000300            	mov	word [67h],3		; extension initialization offset
  5837 000024C4 8C066900                	mov	word [69h],es		; extension segment
  5838 000024C8 EB08                    	jmp	.exit
  5839                                  .next:
  5840 000024CA 81C28000                	add	dx,80h			; add 2 KiB
  5841 000024CE 39DA                    	cmp	dx,bx
  5842 000024D0 72BB                    	jb	.scan
  5843                                  .exit:
  5844 000024D2 C3                      	ret
  5845                                  
  5846                                  ;=========================================================================
  5847                                  ; ipl - Initial Program Load - try to read and execute boot sector
  5848                                  ;-------------------------------------------------------------------------
  5849                                  ipl:
  5850 000024D3 FB                      	sti
  5851 000024D4 31C0                    	xor	ax,ax
  5852 000024D6 8ED8                    	mov	ds,ax
  5853 000024D8 C7067800[C76F]          	mov	word [78h],int_1E
  5854 000024DE 8C0E7A00                	mov	word [7Ah],cs
  5855                                  
  5856                                  .retry:
  5857 000024E2 B004                    	mov	al,4			; try booting from floppy 4 times
  5858                                  
  5859                                  .fd_loop:
  5860 000024E4 50                      	push	ax
  5861 000024E5 B400                    	mov	ah,00h			; reset disk system
  5862 000024E7 B200                    	mov	dl,00h			; drive 0
  5863 000024E9 CD13                    	int	13h
  5864 000024EB 722C                    	jb	.fd_failed
  5865 000024ED B408                    	mov	ah,08h			; get drive parameters
  5866 000024EF B200                    	mov	dl,00h			; drive 0
  5867 000024F1 CD13                    	int	13h
  5868 000024F3 7224                    	jc	.fd_failed
  5869 000024F5 80FA00                  	cmp	dl,00h
  5870 000024F8 741F                    	jz	.fd_failed		; jump if zero drives
  5871 000024FA B80102                  	mov	ax,0201h		; read one sector
  5872 000024FD 31D2                    	xor	dx,dx			; head 0, drive 0
  5873 000024FF 8EC2                    	mov	es,dx			; to 0000:7C00
  5874 00002501 BB007C                  	mov	bx,7C00h
  5875 00002504 B90100                  	mov	cx,0001h		; track 0, sector 1
  5876 00002507 CD13                    	int	13h
  5877 00002509 720E                    	jc	.fd_failed
  5878 0000250B 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5879 00002512 7505                    	jnz	.fd_failed
  5880 00002514 EA007C0000              	jmp	0000h:7C00h
  5881                                  
  5882                                  .fd_failed:
  5883 00002519 58                      	pop	ax
  5884 0000251A FEC8                    	dec	al
  5885 0000251C 75C6                    	jnz	.fd_loop
  5886                                  
  5887                                  ; try booting from HDD
  5888                                  
  5889 0000251E B40D                    	mov	ah,0Dh			; reset hard disks
  5890 00002520 B280                    	mov	dl,80h			; drive 80h
  5891 00002522 CD13                    	int	13h
  5892 00002524 7222                    	jc	.hd_failed
  5893 00002526 B80102                  	mov	ax,0201h		; read one sector
  5894 00002529 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  5895 0000252C 31DB                    	xor	bx,bx
  5896 0000252E 8EC3                    	mov	es,bx			; to 0000:7C00
  5897 00002530 BB007C                  	mov	bx,7C00h
  5898 00002533 B90100                  	mov	cx,0001h		; track 0, sector 1
  5899 00002536 CD13                    	int	13h
  5900 00002538 720E                    	jc	.hd_failed
  5901 0000253A 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5902 00002541 7505                    	jnz	.hd_failed
  5903 00002543 EA007C0000              	jmp	0000h:7C00h
  5904                                  
  5905                                  .hd_failed:
  5906 00002548 BE[8B03]                	mov	si,msg_boot_failed
  5907 0000254B E8BE00                  	call	print
  5908 0000254E B400                    	mov	ah,00h
  5909 00002550 CD16                    	int	16h
  5910 00002552 EB8E                    	jmp	.retry
  5911                                  
  5912                                  ;=========================================================================
  5913                                  ; get_line - read an ASCIIZ string from the console
  5914                                  ; Input:
  5915                                  ;	ES:DI - pointer to the buffer
  5916                                  ;	AX - max string length
  5917                                  ; Output:
  5918                                  ;	AX - string length
  5919                                  ; Notes:
  5920                                  ;	Buffer must have size of max string length + 1 to accomodate 00h
  5921                                  ;-------------------------------------------------------------------------
  5922                                  get_line:
  5923 00002554 53                      	push	bx
  5924 00002555 52                      	push	dx
  5925 00002556 56                      	push	si
  5926 00002557 57                      	push	di
  5927                                  
  5928 00002558 FC                      	cld
  5929 00002559 89FE                    	mov	si,di
  5930 0000255B 01C6                    	add	si,ax			; SI = last character position
  5931 0000255D 31D2                    	xor	dx,dx			; DX = 0 - string length
  5932                                  
  5933                                  .read_char_loop:
  5934 0000255F B400                    	mov	ah,00h			; read character from keyboard
  5935 00002561 CD16                    	int	16h
  5936                                  
  5937 00002563 3C08                    	cmp	al,08h			; <Backspace> key
  5938 00002565 741B                    	jz	.backspace
  5939                                  
  5940 00002567 3C0D                    	cmp	al,0Dh			; <Enter> key
  5941 00002569 7441                    	jz	.enter
  5942                                  
  5943 0000256B 3C20                    	cmp	al,20h			; below printable ASCII code?
  5944 0000256D 7233                    	jb	.error_input
  5945                                  
  5946 0000256F 3C7E                    	cmp	al,7Eh			; above printable ASCII code?
  5947 00002571 772F                    	ja	.error_input
  5948                                  
  5949 00002573 39F7                    	cmp	di,si			; end of buffer reached?
  5950 00002575 732B                    	jae	.error_input
  5951                                  
  5952 00002577 AA                      	stosb				; store character in the buffer
  5953 00002578 42                      	inc	dx			; increment strng length
  5954                                  
  5955 00002579 B40E                    	mov	ah,0Eh			; teletype output (echo)
  5956 0000257B BB0700                  	mov	bx,0007h
  5957 0000257E CD10                    	int	10h
  5958                                  
  5959 00002580 EBDD                    	jmp	.read_char_loop
  5960                                  
  5961                                  .backspace:
  5962 00002582 09D2                    	or	dx,dx			; empty string?
  5963 00002584 741C                    	jz	.error_input
  5964                                  
  5965 00002586 4F                      	dec	di			; move pointer back
  5966 00002587 4A                      	dec	dx			; decrement string size
  5967                                  
  5968 00002588 B8080E                  	mov	ax,0E08h		; move the cursor back
  5969 0000258B BB0700                  	mov	bx,0007h
  5970 0000258E CD10                    	int	10h
  5971                                  
  5972 00002590 B8200E                  	mov	ax,0E20h		; erase the character under the cursor
  5973 00002593 BB0700                  	mov	bx,0007h
  5974 00002596 CD10                    	int	10h
  5975                                  
  5976 00002598 B8080E                  	mov	ax,0E08h		; move the cursor back again
  5977 0000259B BB0700                  	mov	bx,0007h
  5978 0000259E CD10                    	int	10h
  5979                                  
  5980 000025A0 EBBD                    	jmp	.read_char_loop
  5981                                  
  5982                                  .error_input:
  5983 000025A2 B8070E                  	mov	ax,0E07h		; beep
  5984 000025A5 BB0700                  	mov	bx,0007h
  5985 000025A8 CD10                    	int	10h
  5986                                  
  5987 000025AA EBB3                    	jmp	.read_char_loop
  5988                                  
  5989                                  .enter:
  5990 000025AC B000                    	mov	al,00h			; store 00h at the end of the string
  5991 000025AE AA                      	stosb
  5992                                  
  5993 000025AF B80D0E                  	mov	ax,0E0Dh		; CR
  5994 000025B2 BB0700                  	mov	bx,0007h
  5995 000025B5 CD10                    	int	10h
  5996                                  
  5997 000025B7 B80A0E                  	mov	ax,0E0Ah		; LF
  5998 000025BA BB0700                  	mov	bx,0007h
  5999 000025BD CD10                    	int	10h
  6000                                  
  6001 000025BF 89D0                    	mov	ax,dx			; string length to AX
  6002                                  
  6003 000025C1 5F                      	pop	di
  6004 000025C2 5E                      	pop	si
  6005 000025C3 5A                      	pop	dx
  6006 000025C4 5B                      	pop	bx
  6007 000025C5 C3                      	ret
  6008                                  
  6009                                  ;=========================================================================
  6010                                  ; atoi - convert ASCIIZ string to an 16-bit integer number
  6011                                  ; Input:
  6012                                  ;	ES:DI - pointer to string
  6013                                  ; Output:
  6014                                  ;	AX - number
  6015                                  ; 	ES:DI - pointer moved to the position following the number
  6016                                  ;-------------------------------------------------------------------------
  6017                                  atoi:
  6018 000025C6 53                      	push	bx
  6019 000025C7 51                      	push	cx
  6020 000025C8 52                      	push	dx
  6021                                  
  6022 000025C9 31C0                    	xor	ax,ax			; zero the result
  6023 000025CB BB0A00                  	mov	bx,10			; multiplier
  6024                                  
  6025                                  .atoi_loop:
  6026 000025CE 268A0D                      es	mov	cl,byte [di]
  6027                                  
  6028 000025D1 80F930                  	cmp	cl,'0'			; ASCII code below '0'
  6029 000025D4 7211                    	jb	.exit
  6030                                  
  6031 000025D6 80F939                  	cmp	cl,'9'			; ASCII code above '9'
  6032 000025D9 770C                    	ja	.exit
  6033                                  
  6034 000025DB 47                      	inc	di			; move to the next character
  6035                                  
  6036 000025DC 80E930                  	sub	cl,'0'			; convert to ASCII to binary
  6037                                  
  6038 000025DF F7E3                    	mul	bx			; DX:AX = AX * 10
  6039 000025E1 B500                    	mov	ch,0
  6040 000025E3 01C8                    	add	ax,cx			; AX = AX + CX
  6041                                  	
  6042 000025E5 EBE7                    	jmp	.atoi_loop
  6043                                  
  6044                                  .exit:
  6045 000025E7 5A                      	pop	dx
  6046 000025E8 59                      	pop	cx
  6047 000025E9 5B                      	pop	bx
  6048 000025EA C3                      	ret
  6049                                  
  6050                                  ;=========================================================================
  6051                                  ; bin_to_bcd - convert binary number to a packed BCD
  6052                                  ; Input:
  6053                                  ;	AX - binary number
  6054                                  ; Output:
  6055                                  ;	AX - packed BCD number
  6056                                  ;-------------------------------------------------------------------------
  6057                                  bin_to_bcd:
  6058 000025EB 53                      	push	bx
  6059 000025EC 51                      	push	cx
  6060 000025ED 52                      	push	dx
  6061 000025EE 56                      	push	si
  6062                                  
  6063 000025EF B100                    	mov	cl,0			; shift amount
  6064 000025F1 31F6                    	xor	si,si			; zero result
  6065 000025F3 BB0A00                  	mov	bx,10			; BX - divisor
  6066                                  
  6067                                  .bin_to_bcd_loop:
  6068 000025F6 31D2                    	xor	dx,dx			; DX - zero for 32-bit div operand
  6069 000025F8 F7F3                    	div	bx
  6070                                  
  6071 000025FA D3E2                    	shl	dx,cl			; shift digit to the required position
  6072 000025FC 80C104                  	add	cl,4			; calculate next position
  6073                                  
  6074 000025FF 01D6                    	add	si,dx			; add reminder to the result
  6075 00002601 09C0                    	or	ax,ax			; quotient is zero?
  6076 00002603 75F1                    	jnz	.bin_to_bcd_loop
  6077                                  
  6078 00002605 89F0                    	mov	ax,si			; result to AX
  6079                                  
  6080 00002607 5E                      	pop	si
  6081 00002608 5A                      	pop	dx
  6082 00002609 59                      	pop	cx
  6083 0000260A 5B                      	pop	bx
  6084 0000260B C3                      	ret
  6085                                  
  6086                                  
  6087                                  ;=========================================================================
  6088                                  ; print - print ASCIIZ string to the console
  6089                                  ; Input:
  6090                                  ;	CS:SI - pointer to string to print
  6091                                  ; Output:
  6092                                  ;	none
  6093                                  ;-------------------------------------------------------------------------
  6094                                  print:
  6095 0000260C 9C                      	pushf
  6096 0000260D 50                      	push	ax
  6097 0000260E 53                      	push	bx
  6098 0000260F 56                      	push	si
  6099 00002610 1E                      	push	ds
  6100 00002611 0E                      	push	cs
  6101 00002612 1F                      	pop	ds
  6102 00002613 FC                      	cld
  6103                                  .1:
  6104 00002614 AC                      	lodsb
  6105 00002615 08C0                    	or	al,al
  6106 00002617 7408                    	jz	.exit
  6107 00002619 B40E                    	mov	ah,0Eh
  6108 0000261B B30F                    	mov	bl,0Fh
  6109 0000261D CD10                    	int	10h
  6110 0000261F EBF3                    	jmp	.1
  6111                                  .exit:
  6112 00002621 1F                      	pop	ds
  6113 00002622 5E                      	pop	si
  6114 00002623 5B                      	pop	bx
  6115 00002624 58                      	pop	ax
  6116 00002625 9D                      	popf
  6117 00002626 C3                      	ret
  6118                                  
  6119                                  ;=========================================================================
  6120                                  ; print_hex - print 16-bit number in hexadecimal
  6121                                  ; Input:
  6122                                  ;	AX - number to print
  6123                                  ; Output:
  6124                                  ;	none
  6125                                  ;-------------------------------------------------------------------------
  6126                                  print_hex:
  6127 00002627 86C4                    	xchg	al,ah
  6128 00002629 E80600                  	call	print_byte		; print the upper byte
  6129 0000262C 86C4                    	xchg	al,ah
  6130 0000262E E80100                  	call	print_byte		; print the lower byte
  6131 00002631 C3                      	ret
  6132                                  
  6133                                  ;=========================================================================
  6134                                  ; print_byte - print a byte in hexadecimal
  6135                                  ; Input:
  6136                                  ;	AL - byte to print
  6137                                  ; Output:
  6138                                  ;	none
  6139                                  ;-------------------------------------------------------------------------
  6140                                  print_byte:
  6141 00002632 D0C0                    	rol	al,1
  6142 00002634 D0C0                    	rol	al,1
  6143 00002636 D0C0                    	rol	al,1
  6144 00002638 D0C0                    	rol	al,1
  6145 0000263A E82D00                  	call	print_digit
  6146 0000263D D0C0                    	rol	al,1
  6147 0000263F D0C0                    	rol	al,1
  6148 00002641 D0C0                    	rol	al,1
  6149 00002643 D0C0                    	rol	al,1
  6150 00002645 E82200                  	call	print_digit
  6151 00002648 C3                      	ret
  6152                                  
  6153                                  ;=========================================================================
  6154                                  ; print_dec - print 16-bit number in decimal
  6155                                  ; Input:
  6156                                  ;	AX - number to print
  6157                                  ; Output:
  6158                                  ;	none
  6159                                  ;-------------------------------------------------------------------------
  6160                                  print_dec:
  6161 00002649 50                      	push	ax
  6162 0000264A 51                      	push	cx
  6163 0000264B 52                      	push	dx
  6164 0000264C B90A00                  	mov	cx,10		; base = 10
  6165 0000264F E80400                  	call	.print_rec
  6166 00002652 5A                      	pop	dx
  6167 00002653 59                      	pop	cx
  6168 00002654 58                      	pop	ax
  6169 00002655 C3                      	ret
  6170                                  
  6171                                  .print_rec:			; print all digits recursively
  6172 00002656 52                      	push	dx
  6173 00002657 31D2                    	xor	dx,dx		; DX = 0
  6174 00002659 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  6175 0000265B 83F800                  	cmp	ax,0
  6176 0000265E 7403                    	je	.below10
  6177 00002660 E8F3FF                  	call	.print_rec	; print number / 10 recursively
  6178                                  .below10:
  6179 00002663 89D0                    	mov	ax,dx		; reminder is in DX
  6180 00002665 E80200                  	call	print_digit	; print reminder
  6181 00002668 5A                      	pop	dx
  6182 00002669 C3                      	ret
  6183                                  
  6184                                  ;=========================================================================
  6185                                  ; print_digit - print hexadecimal digit
  6186                                  ; Input:
  6187                                  ;	AL - bits 3...0 - digit to print (0...F)
  6188                                  ; Output:
  6189                                  ;	none
  6190                                  ;-------------------------------------------------------------------------
  6191                                  print_digit:
  6192 0000266A 50                      	push	ax
  6193 0000266B 53                      	push	bx
  6194 0000266C 240F                    	and	al,0Fh
  6195 0000266E 0430                    	add	al,'0'			; convert to ASCII
  6196 00002670 3C39                    	cmp	al,'9'			; less or equal 9?
  6197 00002672 7602                    	jna	.1
  6198 00002674 0407                    	add	al,'A'-'9'-1		; a hex digit
  6199                                  .1:
  6200 00002676 B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  6201 00002678 B307                    	mov	bl,07h			; just in case we're in graphic mode
  6202 0000267A CD10                    	int	10h
  6203 0000267C 5B                      	pop	bx
  6204 0000267D 58                      	pop	ax
  6205 0000267E C3                      	ret
  6206                                  
  6207                                  ;=========================================================================
  6208                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  6209                                  ; Input:
  6210                                  ;	AX = memory size in KiB
  6211                                  ; Notes:
  6212                                  ;	- Assumes that EBDA memory was cleaned
  6213                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  6214                                  ;-------------------------------------------------------------------------
  6215                                  reserve_ebda:
  6216                                  %ifdef PS2_MOUSE
  6217 0000267F 50                      	push	ax
  6218 00002680 51                      	push	cx
  6219 00002681 F70610000400            	test	word [equipment_list],equip_mouse
  6220 00002687 742B                    	jz	.no_mouse
  6221 00002689 A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  6222 0000268C 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  6223 0000268F A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  6224 00002692 B106                    	mov	cl,6
  6225 00002694 D3E0                    	shl	ax,cl			; convert to segment
  6226 00002696 A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  6227 00002699 1E                      	push	ds
  6228 0000269A 8ED8                    	mov	ds,ax
  6229 0000269C B80100                  	mov	ax,EBDA_SIZE
  6230 0000269F A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  6231 000026A2 1F                      	pop	ds
  6232 000026A3 56                      	push	si
  6233 000026A4 BE[4A03]                	mov	si,msg_ebda
  6234 000026A7 E862FF                  	call	print
  6235 000026AA E89CFF                  	call	print_dec
  6236 000026AD BE[8403]                	mov	si,msg_kib
  6237 000026B0 E859FF                  	call	print
  6238 000026B3 5E                      	pop	si
  6239                                  .no_mouse:
  6240 000026B4 59                      	pop	cx
  6241 000026B5 58                      	pop	ax
  6242                                  %endif ; PS2_MOUSE
  6243 000026B6 C3                      	ret
  6244                                  
  6245                                  ;=========================================================================
  6246                                  ; detect_ram - Determine the size of installed RAM and test it
  6247                                  ; Input:
  6248                                  ;	none
  6249                                  ; Output:
  6250                                  ;	AX = RAM size
  6251                                  ;	CX, SI - trashed
  6252                                  ;-------------------------------------------------------------------------
  6253                                  detect_ram:
  6254 000026B7 B030                    	mov	al,e_ram_start		; RAM scan start
  6255 000026B9 E680                    	out	post_reg,al
  6256                                  
  6257 000026BB 1E                      	push	ds
  6258 000026BC B106                    	mov	cl,6			; for SHL - converting KiB to segment
  6259 000026BE B82000                  	mov	ax,MIN_RAM_SIZE
  6260                                  
  6261                                  .fill_loop:
  6262 000026C1 50                      	push	ax
  6263 000026C2 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6264 000026C4 8ED8                    	mov	ds,ax
  6265 000026C6 A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  6266 000026C9 58                      	pop	ax
  6267 000026CA 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6268 000026CD 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6269 000026D0 75EF                    	jne	.fill_loop
  6270 000026D2 B82000                  	mov	ax,MIN_RAM_SIZE
  6271                                  
  6272                                  .size_loop:
  6273 000026D5 50                      	push	ax
  6274 000026D6 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6275 000026D8 8ED8                    	mov	ds,ax
  6276 000026DA 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  6277 000026DE 750B                    	jne	.size_done
  6278 000026E0 58                      	pop	ax
  6279 000026E1 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6280 000026E4 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6281 000026E7 7303                    	jnb	.size_exit
  6282 000026E9 EBEA                    	jmp	.size_loop
  6283                                  
  6284                                  .size_done:
  6285 000026EB 58                      	pop	ax
  6286                                  
  6287                                  .size_exit:
  6288 000026EC 1F                      	pop	ds
  6289 000026ED A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  6290                                  
  6291                                  ; AX = detected memory size, now test the RAM
  6292                                  
  6293 000026F0 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  6294 000026F6 7474                    	je	.test_done
  6295                                  
  6296 000026F8 BE[EB02]                	mov	si,msg_ram_testing
  6297 000026FB E80EFF                  	call	print
  6298 000026FE B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  6299                                  
  6300                                  .test_loop:
  6301 00002701 50                      	push	ax
  6302 00002702 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  6303 00002704 B700                    	mov	bh,00h			; page 0
  6304 00002706 CD10                    	int	10h			; position returned in DX
  6305 00002708 58                      	pop	ax
  6306 00002709 E83DFF                  	call	print_dec
  6307 0000270C 50                      	push	ax
  6308 0000270D B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  6309 0000270F B700                    	mov	bh,00h			; page 0
  6310 00002711 CD10                    	int	10h
  6311 00002713 B401                    	mov	ah,01h
  6312 00002715 CD16                    	int	16h
  6313 00002717 7412                    	jz	.test_no_key
  6314 00002719 B400                    	mov	ah,00h
  6315 0000271B CD16                    	int	16h			; read the keystroke
  6316 0000271D 3C1B                    	cmp	al,1Bh			; ESC?
  6317 0000271F 7421                    	je	.test_esc
  6318 00002721 3D003B                  	cmp	ax,3B00h		; F1?
  6319 00002724 7505                    	jne	.test_no_key
  6320 00002726 800E120001              	or	byte [post_flags],post_setup
  6321                                  
  6322                                  .test_no_key:
  6323 0000272B 58                      	pop	ax
  6324 0000272C E83E00                  	call	ram_test_block
  6325 0000272F 721D                    	jc	.test_error		; error in last test
  6326 00002731 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  6327 00002734 3B061300                	cmp	ax,word [memory_size]
  6328 00002738 72C7                    	jb	.test_loop
  6329                                  
  6330 0000273A 50                      	push	ax
  6331 0000273B B031                    	mov	al,e_ram_complete	; RAM scan complete
  6332 0000273D E680                    	out	post_reg,al
  6333 0000273F 58                      	pop	ax
  6334                                  
  6335 00002740 EB2A                    	jmp	.test_done
  6336                                  
  6337                                  .test_esc:
  6338 00002742 58                      	pop	ax
  6339 00002743 A11300                  	mov	ax,word [memory_size]
  6340                                  
  6341 00002746 50                      	push	ax
  6342 00002747 B032                    	mov	al,e_ram_esc		; RAM scan canceled
  6343 00002749 E680                    	out	post_reg,al
  6344 0000274B 58                      	pop	ax
  6345                                  
  6346 0000274C EB1E                    	jmp	.test_done
  6347                                  
  6348                                  .test_error:
  6349 0000274E A31300                  	mov	word [memory_size],ax	; store size of good memory
  6350 00002751 BE[0803]                	mov	si,msg_ram_error
  6351 00002754 E8B5FE                  	call	print
  6352 00002757 E8EFFE                  	call	print_dec
  6353 0000275A BE[8403]                	mov	si,msg_kib
  6354 0000275D E8ACFE                  	call	print
  6355 00002760 BE[8800]                	mov	si,msg_crlf
  6356 00002763 E8A6FE                  	call	print
  6357                                  
  6358 00002766 50                      	push	ax
  6359 00002767 B080                    	mov	al,e_ram_fail		; RAM scan failed
  6360 00002769 E680                    	out	post_reg,al
  6361 0000276B 58                      	pop	ax
  6362                                  
  6363                                  .test_done:
  6364 0000276C C3                      	ret
  6365                                  
  6366                                  ;=========================================================================
  6367                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  6368                                  ; Input:
  6369                                  ;	AX = address of the memory to test (in KiB)
  6370                                  ; Output:
  6371                                  ;	CF = status
  6372                                  ;		0 = passed
  6373                                  ;		1 = failed
  6374                                  ;-------------------------------------------------------------------------
  6375                                  ram_test_block:
  6376 0000276D 50                      	push	ax
  6377 0000276E 53                      	push	bx
  6378 0000276F 51                      	push	cx
  6379 00002770 56                      	push	si
  6380 00002771 57                      	push	di
  6381 00002772 1E                      	push	ds
  6382 00002773 06                      	push	es
  6383 00002774 B106                    	mov	cl,6			; convert KiB to segment address
  6384 00002776 D3E0                    	shl	ax,cl			; (multiply by 64)
  6385 00002778 8ED8                    	mov	ds,ax
  6386 0000277A 8EC0                    	mov	es,ax
  6387 0000277C 31F6                    	xor	si,si
  6388 0000277E 31FF                    	xor	di,di
  6389 00002780 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  6390 00002783 B8AA55                  	mov	ax,55AAh		; first test pattern
  6391 00002786 89D9                    	mov	cx,bx
  6392 00002788 F3AB                        rep	stosw				; store test pattern
  6393 0000278A 89D9                    	mov	cx,bx			; RAM test block size
  6394                                  .1:
  6395 0000278C AD                      	lodsw
  6396 0000278D 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6397 00002790 7522                    	jne	.fail
  6398 00002792 E2F8                    	loop	.1
  6399 00002794 31F6                    	xor	si,si
  6400 00002796 31FF                    	xor	di,di
  6401 00002798 B855AA                  	mov	ax,0AA55h		; second test pattern
  6402 0000279B 89D9                    	mov	cx,bx			; RAM test block size
  6403 0000279D F3AB                        rep stosw				; store test pattern
  6404 0000279F 89D9                    	mov	cx,bx			; RAM test block size
  6405                                  .2:
  6406 000027A1 AD                      	lodsw
  6407 000027A2 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6408 000027A5 750D                    	jne	.fail
  6409 000027A7 E2F8                    	loop	.2
  6410 000027A9 31FF                    	xor	di,di
  6411 000027AB 31C0                    	xor	ax,ax			; zero
  6412 000027AD 89D9                    	mov	cx,bx			; RAM test block size
  6413 000027AF F3AB                        rep stosw				; zero the memory
  6414 000027B1 F8                      	clc				; test passed, clear CF
  6415 000027B2 EB01                    	jmp	.exit
  6416                                  
  6417                                  .fail:
  6418 000027B4 F9                      	stc				; test failed, set CF
  6419                                  	
  6420                                  .exit:
  6421 000027B5 07                      	pop	es
  6422 000027B6 1F                      	pop	ds
  6423 000027B7 5F                      	pop	di
  6424 000027B8 5E                      	pop	si
  6425 000027B9 59                      	pop	cx
  6426 000027BA 5B                      	pop	bx
  6427 000027BB 58                      	pop	ax
  6428 000027BC C3                      	ret
  6429                                  
  6430                                  ;=========================================================================
  6431                                  ; print display type
  6432                                  ;-------------------------------------------------------------------------
  6433                                  print_display:
  6434 000027BD BE[9101]                	mov	si,msg_disp
  6435 000027C0 E849FE                  	call	print
  6436 000027C3 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  6437 000027C6 2430                    	and	al,equip_video		; get video adapter type
  6438 000027C8 BE[D301]                	mov	si,msg_disp_mda
  6439 000027CB 3C30                    	cmp	al,equip_mono		; monochrome?
  6440 000027CD 740A                    	jz	.print_disp
  6441 000027CF BE[CD01]                	mov	si,msg_disp_cga
  6442 000027D2 3C20                    	cmp	al,equip_color		; CGA?
  6443 000027D4 7403                    	jz	.print_disp
  6444 000027D6 BE[AE01]                	mov	si,msg_disp_ega		; otherwise EGA or later
  6445                                  .print_disp:
  6446 000027D9 E830FE                  	call	print
  6447 000027DC C3                      	ret
  6448                                  
  6449                                  ;=========================================================================
  6450                                  ; print PS/2 mouse presence
  6451                                  ;-------------------------------------------------------------------------
  6452                                  
  6453                                  print_mouse:
  6454 000027DD BE[7902]                	mov	si,msg_mouse
  6455 000027E0 E829FE                  	call	print
  6456 000027E3 BE[A002]                	mov	si,msg_absent
  6457 000027E6 F606100004              	test	byte [equipment_list],equip_mouse
  6458 000027EB 7403                    	jz	.print_mouse
  6459 000027ED BE[9602]                	mov	si,msg_present
  6460                                  .print_mouse:
  6461 000027F0 E819FE                  	call	print
  6462 000027F3 C3                      	ret
  6463                                  
  6464                                  ;=========================================================================
  6465                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  6466                                  ;-------------------------------------------------------------------------
  6467                                  
  6468                                  detect_rom_ext:
  6469 000027F4 B040                    	mov	al,e_ext_start		; ROM extension scan start
  6470 000027F6 E680                    	out	post_reg,al
  6471                                  
  6472 000027F8 BA00C8                  	mov	dx,0C800h
  6473 000027FB BB00F8                  	mov	bx,0F800h
  6474                                  
  6475                                  .ext_scan_loop:
  6476 000027FE E880FC                  	call	extension_scan
  6477 00002801 833E670000              	cmp	word [67h],0
  6478 00002806 7429                    	jz	.ext_scan_done		; No ROM extension found
  6479 00002808 B041                    	mov	al,e_ext_detect		; ROM extension found
  6480 0000280A E680                    	out	post_reg,al
  6481 0000280C BE[C703]                	mov	si,msg_rom_found
  6482 0000280F E8FAFD                  	call	print
  6483 00002812 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  6484 00002815 E80FFE                  	call	print_hex
  6485 00002818 BE[E403]                	mov	si,msg_rom_init
  6486 0000281B E8EEFD                  	call	print
  6487 0000281E 53                      	push	bx
  6488 0000281F 52                      	push	dx
  6489 00002820 FF1E6700                	call	far [67h]
  6490 00002824 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6491 00002827 8ED8                    	mov	ds,ax
  6492 00002829 B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  6493 0000282B E680                    	out	post_reg,al
  6494 0000282D 5A                      	pop	dx
  6495 0000282E 5B                      	pop	bx
  6496 0000282F EBCD                    	jmp	.ext_scan_loop
  6497                                  
  6498                                  .ext_scan_done:
  6499 00002831 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  6500 00002833 E680                    	out	post_reg,al
  6501                                  
  6502 00002835 C3                      	ret
  6503                                  
  6504                                  ;=========================================================================	
  6505                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  6506                                  ;-------------------------------------------------------------------------
  6507                                  interrupt_table:
  6508 00002836 [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
  6509 00002838 [537F]                  	dw	int_dummy		; INT 01 - Single step
  6510 0000283A [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  6511 0000283C [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  6512 0000283E [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  6513 00002840 [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
  6514 00002842 [537F]                  	dw	int_dummy		; INT 06
  6515 00002844 [537F]                  	dw	int_dummy		; INT 07
  6516 00002846 [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  6517 00002848 [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  6518 0000284A [237F]                  	dw	int_ignore		; INT 0A - IRQ2
  6519 0000284C [237F]                  	dw	int_ignore		; INT 0B - IRQ3
  6520 0000284E [237F]                  	dw	int_ignore		; INT 0C - IRQ4
  6521 00002850 [237F]                  	dw	int_ignore		; INT 0D - IRQ5
  6522 00002852 [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  6523 00002854 [237F]                  	dw	int_ignore		; INT 0F - IRQ7
  6524 00002856 [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
  6525 00002858 [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  6526 0000285A [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  6527 0000285C [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  6528 0000285E [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  6529 00002860 [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  6530 00002862 [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  6531 00002864 [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  6532 00002866 [4D63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  6533 00002868 [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  6534 0000286A [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
  6535 0000286C [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  6536 0000286E [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
  6537 00002870 [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
  6538 00002872 [C76F]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  6539 00002874 [2207]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  6540                                  
  6541                                  %ifdef AT_COMPAT
  6542                                  interrupt_table2:
  6543 00002876 [AB10]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  6544 00002878 [6D24]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  6545 0000287A [6424]                  	dw	int_ignore2		; INT 72 - IRQ10
  6546 0000287C [6424]                  	dw	int_ignore2		; INT 73 - IRQ11
  6547                                  %ifndef PS2_MOUSE
  6548                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  6549                                  %else
  6550 0000287E [B122]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  6551                                  %endif
  6552 00002880 [7624]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  6553 00002882 [6424]                  	dw	int_ignore2		; INT 76 - IRQ14
  6554 00002884 [6424]                  	dw	int_ignore2		; INT 77 - IRQ15
  6555                                  %endif ; AT_COMPAT
  6556                                  
  6557                                  ;=========================================================================
  6558                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  6559                                  ;-------------------------------------------------------------------------	
  6560 00002886 FF<rept>                	setloc	0E05Bh		; POST Entry Point
  6561          ******************       warning: (setloc:7) Inserting 14293 bytes
  6562                                  cold_start:
  6563 0000605B B84000                  	mov	ax,biosdseg
  6564 0000605E 8ED8                    	mov	ds,ax
  6565 00006060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  6566                                  
  6567                                  warm_start:
  6568 00006066 FA                      	cli				; disable interrupts
  6569 00006067 FC                      	cld				; clear direction flag
  6570 00006068 B001                    	mov	al,e_start
  6571 0000606A E680                    	out	post_reg,al		; POST start code
  6572                                  
  6573                                  ;-------------------------------------------------------------------------
  6574                                  ; test CPU's FLAG register
  6575                                  
  6576 0000606C 31C0                    	xor	ax,ax			; AX = 0
  6577 0000606E 724A                    	jb	cpu_fail
  6578 00006070 7048                    	jo	cpu_fail
  6579 00006072 7846                    	js	cpu_fail
  6580 00006074 7544                    	jnz	cpu_fail
  6581 00006076 7B42                    	jpo	cpu_fail
  6582 00006078 83C001                  	add	ax,1			; AX = 1
  6583 0000607B 743D                    	jz	cpu_fail
  6584 0000607D 7A3B                    	jpe	cpu_fail
  6585 0000607F 2D0280                  	sub	ax,8002h
  6586 00006082 7836                    	js	cpu_fail
  6587 00006084 40                      	inc	ax
  6588 00006085 7133                    	jno	cpu_fail
  6589 00006087 D1E0                    	shl	ax,1
  6590 00006089 732F                    	jnb	cpu_fail
  6591 0000608B 752D                    	jnz	cpu_fail
  6592 0000608D D1E0                    	shl	ax,1
  6593 0000608F 7229                    	jb	cpu_fail
  6594                                  
  6595                                  ;-------------------------------------------------------------------------
  6596                                  ; Test CPU registers
  6597                                  
  6598 00006091 B8AAAA                  	mov	ax,0AAAAh
  6599                                  .1:
  6600 00006094 8ED8                    	mov	ds,ax
  6601 00006096 8CDB                    	mov	bx,ds
  6602 00006098 8EC3                    	mov	es,bx
  6603 0000609A 8CC1                    	mov	cx,es
  6604 0000609C 8ED1                    	mov	ss,cx
  6605 0000609E 8CD2                    	mov	dx,ss
  6606 000060A0 89D5                    	mov	bp,dx
  6607 000060A2 89EC                    	mov	sp,bp
  6608 000060A4 89E6                    	mov	si,sp
  6609 000060A6 89F7                    	mov	di,si
  6610 000060A8 81FFAAAA                	cmp	di,0AAAAh
  6611 000060AC 7506                    	jnz	.2
  6612 000060AE 89F8                    	mov	ax,di
  6613 000060B0 F7D0                    	not	ax
  6614 000060B2 EBE0                    	jmp	.1
  6615                                  .2:
  6616 000060B4 81FF5555                	cmp	di,5555h
  6617 000060B8 741A                    	jz	cpu_ok
  6618                                  
  6619                                  cpu_fail:
  6620 000060BA B052                    	mov	al,e_cpu_fail
  6621 000060BC E680                    	out	post_reg,al
  6622                                  
  6623                                  ;-------------------------------------------------------------------------
  6624                                  ; CPU error: continious beep - 400 Hz
  6625                                  
  6626 000060BE B0B6                    	mov	al,0B6h
  6627 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6628 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6629 000060C5 E642                    	out	pit_ch2_reg,al
  6630 000060C7 88E0                    	mov	al,ah
  6631 000060C9 E642                    	out	pit_ch2_reg,al
  6632 000060CB E461                    	in	al,port_b_reg
  6633 000060CD 0C03                    	or	al,3			; turn speaker on and enable
  6634 000060CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6635                                  
  6636                                  .1:
  6637 000060D1 F4                      	hlt
  6638 000060D2 EBFD                    	jmp	.1
  6639                                  
  6640                                  ;-------------------------------------------------------------------------
  6641                                  ; CPU test passed
  6642                                  
  6643                                  cpu_ok:
  6644 000060D4 B002                    	mov	al,e_cpu_ok
  6645 000060D6 E680                    	out	post_reg,al
  6646                                  
  6647                                  ;-------------------------------------------------------------------------
  6648                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  6649                                  
  6650 000060D8 B00D                    	mov	al,0Dh & nmi_disable
  6651 000060DA E670                    	out	rtc_addr_reg,al		; disable NMI
  6652 000060DC EB00                    	jmp	$+2
  6653 000060DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  6654                                  
  6655 000060E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  6656 000060E2 E661                    	out	port_b_reg,al
  6657 000060E4 B000                    	mov	al,00h			; clear turbo bit
  6658 000060E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  6659                                  
  6660 000060E8 BAD803                  	mov	dx,cga_mode_reg
  6661 000060EB EE                      	out	dx,al			; disable video output on CGA
  6662 000060EC FEC0                    	inc	al
  6663 000060EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  6664 000060F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  6665                                  
  6666                                  ;-------------------------------------------------------------------------
  6667                                  ; Initialize DMAC (8237)
  6668                                   
  6669 000060F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  6670 000060F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  6671 000060F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6672 000060F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  6673 000060FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6674 000060FC B042                     	mov	al,42h			; single mode, verify, channel 2
  6675 000060FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6676 00006100 B043                     	mov	al,43h			; single mode, verify, channel 3
  6677 00006102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6678 00006104 B000                     	mov	al,0			; DMA Command register bits:
  6679                                   					; DACK active low, DREQ active high,
  6680                                   					; late write, fixed priority,
  6681                                   					; normal timing, controller enable
  6682                                   					; channel 0 addr hold disable
  6683                                   					; memory to memory disable
  6684 00006106 E608                     	out	08h,al			; DMA Command register
  6685 00006108 E681                     	out	81h,al			; DMA Page, channel 2
  6686 0000610A E682                     	out	82h,al			; DMA Page, channel 3
  6687 0000610C E683                     	out	83h,al			; DMA Page, channels 0,1
  6688 0000610E B003                    	mov	al,e_dmac_ok
  6689 00006110 E680                    	out	post_reg,al
  6690                                  
  6691                                  ;-------------------------------------------------------------------------
  6692                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  6693                                  
  6694                                  low_ram_test:
  6695 00006112 31F6                    	xor	si,si
  6696 00006114 31FF                    	xor	di,di
  6697 00006116 8EDF                    	mov	ds,di
  6698 00006118 8EC7                    	mov	es,di
  6699 0000611A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  6700 0000611E B8AA55                  	mov	ax,55AAh		; first test pattern
  6701 00006121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6702 00006124 F3AB                        rep	stosw				; store test pattern
  6703 00006126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6704                                  .1:
  6705 00006129 AD                      	lodsw
  6706 0000612A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6707 0000612D 7524                    	jne	low_ram_fail
  6708 0000612F E2F8                    	loop	.1
  6709 00006131 31F6                    	xor	si,si
  6710 00006133 31FF                    	xor	di,di
  6711 00006135 B855AA                  	mov	ax,0AA55h		; second test pattern
  6712 00006138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6713 0000613B F3AB                        rep stosw				; store test pattern
  6714 0000613D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6715                                  .2:
  6716 00006140 AD                      	lodsw
  6717 00006141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6718 00006144 750D                    	jne	low_ram_fail
  6719 00006146 E2F8                    	loop	.2
  6720 00006148 31FF                    	xor	di,di
  6721 0000614A 31C0                    	xor	ax,ax			; zero
  6722 0000614C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6723 0000614F F3AB                        rep stosw				; zero the memory
  6724 00006151 EB29                    	jmp	low_ram_ok		; test passed
  6725                                  
  6726                                  low_ram_fail:
  6727 00006153 B054                    	mov	al,e_low_ram_fail	; test failed
  6728 00006155 E680                    	out	post_reg,al
  6729                                  
  6730                                  ;-------------------------------------------------------------------------
  6731                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  6732                                  
  6733 00006157 B0B6                    	mov	al,0B6h
  6734 00006159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6735 0000615B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6736 0000615E E642                    	out	pit_ch2_reg,al
  6737 00006160 88E0                    	mov	al,ah
  6738 00006162 E642                    	out	pit_ch2_reg,al
  6739 00006164 E461                    	in	al,port_b_reg
  6740                                  .1:
  6741 00006166 0C03                    	or	al,3			; turn speaker on and enable
  6742 00006168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6743 0000616A B90000                  	mov	cx,0
  6744                                  .2:
  6745 0000616D 90                      	nop
  6746 0000616E E2FD                    	loop	.2
  6747 00006170 24FC                    	and	al,0FCh			; turn of speaker
  6748 00006172 E661                    	out	port_b_reg,al
  6749 00006174 B90000                  	mov	cx,0
  6750                                  .3:
  6751 00006177 90                      	nop
  6752 00006178 E2FD                    	loop	.3
  6753 0000617A EBEA                    	jmp	.1
  6754                                  
  6755                                  ;-------------------------------------------------------------------------
  6756                                  ; Low memory test passed
  6757                                  
  6758                                  low_ram_ok:
  6759 0000617C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  6760 00006180 B004                    	mov	al,e_low_ram_ok
  6761 00006182 E680                    	out	post_reg,al
  6762                                  
  6763                                  ;-------------------------------------------------------------------------
  6764                                  ; Set up stack - using upper 256 bytes of interrupt table
  6765                                  
  6766 00006184 B83000                  	mov	ax,0030h
  6767 00006187 8ED0                    	mov	ss,ax
  6768 00006189 BC0001                  	mov	sp,0100h
  6769                                  
  6770                                  ;-------------------------------------------------------------------------
  6771                                  ; Initialize interrupt table
  6772                                  
  6773 0000618C 0E                      	push	cs
  6774 0000618D 1F                      	pop	ds
  6775 0000618E 31FF                    	xor	di,di
  6776 00006190 8EC7                    	mov	es,di
  6777 00006192 BE[3628]                	mov	si,interrupt_table
  6778 00006195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  6779 00006198 B800F0                  	mov	ax,bioscseg
  6780                                  .1:
  6781 0000619B A5                      	movsw				; copy ISR address (offset part)
  6782 0000619C AB                      	stosw				; store segment part
  6783 0000619D E2FC                    	loop	.1
  6784                                  %ifdef AT_COMPAT
  6785 0000619F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  6786 000061A2 BE[7628]                	mov	si,interrupt_table2
  6787 000061A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  6788                                  .2:
  6789 000061A8 A5                      	movsw				; copy ISR address (offset part)
  6790 000061A9 AB                      	stosw				; store segment part
  6791 000061AA E2FC                    	loop	.2
  6792                                  %endif ; AT_COMPAT
  6793 000061AC B005                    	mov     al,e_int_ok
  6794 000061AE E680                    	out	post_reg,al
  6795                                  
  6796                                  ;-------------------------------------------------------------------------
  6797                                  ; set DS to BIOS data area
  6798                                  
  6799 000061B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6800 000061B3 8ED8                    	mov	ds,ax
  6801                                  
  6802                                  ;-------------------------------------------------------------------------
  6803                                  ; Initialize PIT (8254 timer)
  6804                                  
  6805 000061B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  6806 000061B7 E643                    	out	pit_ctl_reg,al
  6807 000061B9 B000                    	mov	al,0
  6808 000061BB E640                    	out	pit_ch0_reg,al
  6809 000061BD E640                    	out	pit_ch0_reg,al
  6810 000061BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  6811 000061C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  6812 000061C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  6813 000061C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  6814 000061C7 B040                    	mov	al,40h			; XXX timer latch
  6815 000061C9 E643                    	out	pit_ctl_reg,al
  6816                                  
  6817                                  ;-------------------------------------------------------------------------
  6818                                  ; Play "power on" sound - also tests PIT functionality
  6819 000061CB E872C1                  	call	sound
  6820                                  
  6821 000061CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  6822 000061D0 E680                    	out	post_reg,al
  6823                                  
  6824                                  ;-------------------------------------------------------------------------
  6825                                  ; Initialize PIC (8259)
  6826                                  
  6827                                  %ifdef AT_COMPAT
  6828 000061D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  6829 000061D4 E620                    	out	pic1_reg0,al
  6830 000061D6 E6A0                    	out	pic2_reg0,al
  6831 000061D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  6832 000061DA E621                    	out	pic1_reg1,al
  6833 000061DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  6834 000061DE E6A1                    	out	pic2_reg1,al
  6835 000061E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  6836 000061E2 E621                    	out	pic1_reg1,al
  6837 000061E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  6838 000061E6 E6A1                    	out	pic2_reg1,al
  6839 000061E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  6840 000061EA E621                    	out	pic1_reg1,al
  6841 000061EC E6A1                    	out	pic2_reg1,al
  6842                                  %else
  6843                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  6844                                  	out	pic1_reg0,al
  6845                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  6846                                  	out	pic1_reg1,al
  6847                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  6848                                  	out	pic1_reg1,al
  6849                                  	mov	al,e_pic_ok
  6850                                  	out	post_reg,al
  6851                                  %endif ; AT_COMPAT
  6852                                  
  6853                                  ;-------------------------------------------------------------------------
  6854                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  6855                                  
  6856 000061EE E8F7B7                  	call	kbc_init
  6857                                  
  6858                                  ;-------------------------------------------------------------------------
  6859                                  ; enable interrupts
  6860                                  
  6861                                  %ifdef AT_COMPAT
  6862 000061F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  6863 000061F3 E621                    	out	pic1_reg1,al
  6864                                  %ifndef PS2_MOUSE
  6865                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  6866                                  %else
  6867 000061F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  6868                                  %endif ; PS2_MOUSE
  6869 000061F7 E6A1                    	out	pic2_reg1,al
  6870                                  %else
  6871                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  6872                                  	out	pic1_reg1,al
  6873                                  %endif ; AT_COMPAT
  6874 000061F9 FB                      	sti
  6875                                  
  6876                                  ;-------------------------------------------------------------------------
  6877                                  ; look for video BIOS, initialize it if present
  6878                                  
  6879 000061FA BA00C0                  	mov	dx,0C000h
  6880 000061FD BB00C8                  	mov	bx,0C800h
  6881 00006200 E87EC2                  	call	extension_scan
  6882 00006203 833E670000              	cmp	word [67h],0
  6883 00006208 7418                    	jz	.no_video_bios
  6884 0000620A B011                    	mov	al,e_video_bios_ok
  6885 0000620C E680                    	out	post_reg,al
  6886 0000620E FF1E6700                	call	far [67h]
  6887 00006212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6888 00006215 8ED8                    	mov	ds,ax
  6889 00006217 B012                    	mov	al,e_video_init_ok
  6890 00006219 E680                    	out	post_reg,al
  6891                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  6892 0000621B 83261000CF              	and	word [equipment_list],~equip_video
  6893 00006220 EB14                    	jmp	.video_initialized
  6894                                  
  6895                                  .no_video_bios:
  6896 00006222 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  6897 00006226 80E430                  	and	ah,equip_video		; get video adapter type
  6898 00006229 B007                    	mov	al,07h			; monochrome 80x25 mode
  6899 0000622B 80FC30                  	cmp	ah,equip_mono		; monochrome?
  6900 0000622E 7402                    	jz	.set_mode
  6901 00006230 B003                    	mov	al,03h			; color 80x25 mode
  6902                                  
  6903                                  .set_mode:
  6904 00006232 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  6905 00006234 CD10                    	int	10h
  6906                                  
  6907                                  .video_initialized:
  6908                                  
  6909                                  ;-------------------------------------------------------------------------
  6910                                  ; print the copyright message
  6911                                  
  6912 00006236 BE[0000]                	mov	si,msg_copyright
  6913 00006239 E8D0C3                  	call	print
  6914                                  
  6915                                  ;-------------------------------------------------------------------------
  6916                                  ; Initialize RTC / NVRAM
  6917                                  
  6918 0000623C E801A9                  	call	rtc_init
  6919                                  
  6920                                  ; read equipment byte from CMOS and set it in BIOS data area
  6921                                  
  6922 0000623F BE[6904]                	mov	si,msg_setup
  6923 00006242 E8C7C3                  	call	print
  6924                                  
  6925                                  ;-------------------------------------------------------------------------
  6926                                  ; detect and print availability of various equipment
  6927                                  
  6928 00006245 E84EC1                  	call	detect_cpu		; detect and print CPU type
  6929 00006248 E8D4C1                  	call	detect_fpu		; detect and print FPU presence
  6930                                  
  6931 0000624B E874AC                  	call	print_rtc		; print current RTC time
  6932                                  
  6933 0000624E E86CC5                  	call	print_display		; print display type
  6934 00006251 E889C5                  	call	print_mouse		; print mouse presence
  6935                                  
  6936 00006254 E82ABD                  	call	detect_serial		; detect serial ports and print findings
  6937 00006257 E8F1BD                  	call	detect_parallel		; detect parallel ports and print
  6938                                  					; findings
  6939                                  
  6940 0000625A B010                    	mov	al,cmos_floppy
  6941 0000625C E8C3A8                  	call	rtc_read		; floppies type to AL
  6942 0000625F E828B6                  	call	print_floppy		; print floppy drive types
  6943                                  
  6944 00006262 E852C4                  	call	detect_ram		; test RAM, get RAM size in AX
  6945                                  
  6946 00006265 BE[2C03]                	mov	si,msg_ram_total
  6947 00006268 E8A1C3                  	call	print
  6948 0000626B E8DBC3                  	call	print_dec		; print RAM size
  6949 0000626E BE[8403]                	mov	si,msg_kib
  6950 00006271 E898C3                  	call	print
  6951                                  
  6952 00006274 E808C4                  	call	reserve_ebda		; reserve EBDA if needed
  6953                                  
  6954 00006277 BE[6703]                	mov	si,msg_ram_avail
  6955 0000627A E88FC3                  	call	print
  6956 0000627D A11300                  	mov	ax,word [memory_size]
  6957 00006280 E8C6C3                  	call	print_dec		; print remaining RAM size
  6958 00006283 BE[8403]                	mov	si,msg_kib
  6959 00006286 E883C3                  	call	print
  6960                                  
  6961 00006289 E868C5                  	call	detect_rom_ext		; detect and initialize extension ROMs
  6962                                  
  6963                                  ;-------------------------------------------------------------------------
  6964                                  ; Check for F1 (setup key), run setup utility if pressed
  6965                                  
  6966 0000628C B401                    	mov	ah,01h
  6967 0000628E CD16                    	int	16h
  6968 00006290 740E                    	jz	.no_key
  6969 00006292 B400                    	mov	ah,00h
  6970 00006294 CD16                    	int	16h			; read the keystroke
  6971 00006296 3D003B                  	cmp	ax,3B00h		; F1?
  6972 00006299 7505                    	jne	.no_key
  6973 0000629B 800E120001              	or	byte [post_flags],post_setup
  6974                                  .no_key:
  6975                                  
  6976 000062A0 F606120001              	test	byte [post_flags],post_setup
  6977 000062A5 7403                    	jz	.no_setup
  6978 000062A7 E8B1A9                  	call	rtc_setup
  6979                                  
  6980                                  .no_setup:
  6981                                  
  6982                                  ;-------------------------------------------------------------------------
  6983                                  ; boot the OS
  6984                                  
  6985 000062AA B000                    	mov	al,e_boot		; boot the OS POST code
  6986 000062AC E680                    	out	post_reg,al
  6987                                  
  6988 000062AE BE[F903]                	mov	si,msg_boot
  6989 000062B1 E858C3                  	call	print
  6990 000062B4 CD19                    	int	19h			; boot the OS
  6991                                  
  6992                                  ;=========================================================================
  6993                                  ; int_02 - NMI
  6994                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  6995                                  ;	implemented
  6996                                  ;-------------------------------------------------------------------------
  6997 000062B6 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  6998          ******************       warning: (setloc:7) Inserting 13 bytes
  6999                                  int_02:
  7000 000062C3 50                      	push	ax
  7001 000062C4 B00D                    	mov	al,0Dh & nmi_disable
  7002 000062C6 E859A8                  	call	rtc_read		; disable NMI
  7003 000062C9 E461                    	in	al,port_b_reg		; read Port B
  7004 000062CB 88C4                    	mov	ah,al
  7005 000062CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  7006 000062CF E661                    	out	port_b_reg,al
  7007 000062D1 A840                    	test	al,iochk_status
  7008 000062D3 7506                    	jnz	.iochk_nmi
  7009 000062D5 88E0                    	mov	al,ah
  7010 000062D7 E661                    	out	port_b_reg,al		; restore original bits
  7011 000062D9 EB24                    	jmp	.exit
  7012                                  
  7013                                  .iochk_nmi:
  7014 000062DB 56                      	push	si
  7015 000062DC BE[0663]                	mov	si,msg_iochk_nmi
  7016 000062DF E82AC3                  	call	print
  7017 000062E2 5E                      	pop	si
  7018                                  .1:
  7019 000062E3 B400                    	mov	ah,0h
  7020 000062E5 CD16                    	int	16h
  7021 000062E7 3C69                    	cmp	al,'i'			; exit from NMI
  7022 000062E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  7023 000062EB 3C49                    	cmp	al,'I'
  7024 000062ED 7410                    	je	.exit
  7025 000062EF 3C72                    	cmp	al,'r'
  7026 000062F1 7503E965FD              	je	cold_start
  7027 000062F6 3C52                    	cmp	al,'R'
  7028 000062F8 7503E95EFD              	je	cold_start
  7029 000062FD EBE4                    	jmp	.1
  7030                                  .exit:
  7031 000062FF B08D                    	mov	al,0Dh | nmi_enable
  7032 00006301 E81EA8                  	call	rtc_read		; enable NMI
  7033 00006304 58                      	pop	ax
  7034 00006305 CF                      	iret
  7035                                  
  7036                                  msg_iochk_nmi:
  7037 00006306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  7038 0000630F 206465746563746564-
  7039 00006318 2E2054797065202769-
  7040 00006321 2720746F2069676E6F-
  7041 0000632A 726520494F43484B20-
  7042 00006333 4E4D49732C206F7220-
  7043 0000633C 27722720746F207265-
  7044 00006345 626F6F742E         
  7045 0000634A 0D0A00                  	db	0Dh, 0Ah, 00h
  7046                                  
  7047                                  ;=========================================================================
  7048                                  ; int_18 - execute ROM BASIC
  7049                                  ; Note:
  7050                                  ;	Prints an error message since we don't have ROM BASIC
  7051                                  ;-------------------------------------------------------------------------
  7052                                  int_18:
  7053 0000634D BE[B803]                	mov	si,msg_no_basic
  7054 00006350 E8B9C2                  	call	print
  7055                                  .1:
  7056 00006353 F4                      	hlt
  7057 00006354 EBFD                    	jmp	.1
  7058                                  
  7059                                  ;=========================================================================
  7060                                  ; int_19 - load and execute the boot sector
  7061                                  ;-------------------------------------------------------------------------
  7062 00006356 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  7063          ******************       warning: (setloc:7) Inserting 924 bytes
  7064                                  int_19:
  7065 000066F2 E9DEBD                  	jmp	ipl
  7066                                  
  7067                                  ;=========================================================================
  7068                                  ; configuration data table
  7069                                  ;-------------------------------------------------------------------------
  7070                                  	setloc	0E6F5h
  7071                                  config_table:
  7072 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  7073                                  .bytes:
  7074                                  %ifdef AT_COMPAT
  7075 000066F7 FC                      	db	0FCh			; byte 2: model = AT
  7076 000066F8 00                      	db	00h			; byte 3: submodel = 0
  7077 000066F9 00                      	db	00h			; byte 4: release = 0
  7078 000066FA 70                      	db	01110000b		; byte 5: feature byte 1
  7079                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7080                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7081                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7082                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7083                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7084                                  ;		||`-- real time clock installed
  7085                                  ;		|`-- 2nd interrupt controller installed
  7086                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7087 000066FB 00                      	db	00h			; byte 6: feature byte 2
  7088 000066FC 00                      	db	00h			; byte 7: feature byte 3
  7089 000066FD 00                      	db	00h			; byte 8: feature byte 4
  7090 000066FE 00                      	db	00h			; byte 9: feature byte 5
  7091                                  %else
  7092                                  	db	0FEh			; byte 2: model = XT
  7093                                  	db	00h			; byte 3: submodel = 0
  7094                                  	db	00h			; byte 4: release = 0
  7095                                  	db	00000000b		; byte 5: feature byte 1
  7096                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7097                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7098                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7099                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7100                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7101                                  ;		||`-- real time clock installed
  7102                                  ;		|`-- 2nd interrupt controller installed
  7103                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7104                                  	db	00h			; byte 6: feature byte 2
  7105                                  	db	00h			; byte 7: feature byte 3
  7106                                  	db	00h			; byte 8: feature byte 4
  7107                                  	db	00h			; byte 9: feature byte 5
  7108                                  %endif ; AT_COMPAT
  7109                                  .size	equ	$-.bytes
  7110                                  
  7111                                  ;=========================================================================
  7112                                  ; Includes with fixed entry points (for IBM compatibility)
  7113                                  ;-------------------------------------------------------------------------
  7114                                  
  7115                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  7116                              <1> ;========================================================================
  7117                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  7118                              <1> ;       INT 14h, function AH=00h
  7119                              <1> ;       INT 14h, function AH=03h
  7120                              <1> ;       INT 14h, function AH=04h
  7121                              <1> ;       INT 14h, function AH=05h
  7122                              <1> ;	- see serial1.inc for other INT 14h functions
  7123                              <1> ;-------------------------------------------------------------------------
  7124                              <1> ;
  7125                              <1> ; Compiles with NASM 2.07, might work with other versions
  7126                              <1> ;
  7127                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7128                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7129                              <1> ;
  7130                              <1> ; This program is free software: you can redistribute it and/or modify
  7131                              <1> ; it under the terms of the GNU General Public License as published by
  7132                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7133                              <1> ; (at your option) any later version.
  7134                              <1> ;
  7135                              <1> ; This program is distributed in the hope that it will be useful,
  7136                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7137                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7138                              <1> ; GNU General Public License for more details.
  7139                              <1> ;
  7140                              <1> ; You should have received a copy of the GNU General Public License
  7141                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7142                              <1> ;
  7143                              <1> ;=========================================================================
  7144                              <1> 
  7145                              <1> ;=========================================================================
  7146                              <1> ; int_14 - BIOS Serial Port Communication Services
  7147                              <1> ;-------------------------------------------------------------------------
  7148 000066FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  7149          ******************  <1>  warning: (setloc:7) Inserting 42 bytes
  7150                              <1> int_14:
  7151 00006729 FB                  <1> 	sti
  7152 0000672A 51                  <1> 	push	cx
  7153 0000672B 52                  <1> 	push	dx
  7154 0000672C 56                  <1> 	push	si
  7155 0000672D 1E                  <1> 	push	ds
  7156 0000672E 53                  <1> 	push	bx
  7157 0000672F BB4000              <1> 	mov	bx,biosdseg
  7158 00006732 8EDB                <1> 	mov	ds,bx
  7159 00006734 80FC06              <1> 	cmp	ah,.max/2
  7160 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
  7161 00006739 83FA04              <1> 	cmp	dx,num_serial
  7162 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
  7163 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  7164 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  7165 00006743 89D3                <1> 	mov	bx,dx
  7166 00006745 D1E3                <1> 	shl	bx,1
  7167 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  7168 00006749 09D2                <1> 	or	dx,dx
  7169 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
  7170 0000674D B700                <1> 	mov	bh,0
  7171 0000674F 88E3                <1> 	mov	bl,ah
  7172 00006751 D1E3                <1> 	shl	bx,1
  7173 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
  7174                              <1> .dispatch:
  7175 00006758 [6C67]              <1> 	dw	int_14_fn00
  7176 0000675A [1C1F]              <1> 	dw	int_14_fn01
  7177 0000675C [371F]              <1> 	dw	int_14_fn02
  7178 0000675E [A167]              <1> 	dw	int_14_fn03
  7179 00006760 [AB67]              <1> 	dw	int_14_fn04
  7180 00006762 [0568]              <1> 	dw	int_14_fn05
  7181                              <1> .max	equ	$-.dispatch
  7182                              <1> 
  7183                              <1> int_14_error:
  7184 00006764 31C0                <1> 	xor	ax,ax
  7185                              <1> 
  7186                              <1> int_14_exit:
  7187 00006766 5B                  <1> 	pop	bx
  7188 00006767 1F                  <1> 	pop	ds
  7189 00006768 5E                  <1> 	pop	si
  7190 00006769 5A                  <1> 	pop	dx
  7191 0000676A 59                  <1> 	pop	cx
  7192 0000676B CF                  <1> 	iret
  7193                              <1> 
  7194                              <1> ;=========================================================================
  7195                              <1> ; int_14_fn00 - Initialize serial port
  7196                              <1> ; Input:
  7197                              <1> ;	AH = 0 - function 00h - initialize serial port
  7198                              <1> ;	AL - initialization parameters
  7199                              <1> ;		bit 1,0	= 10	- 7 data bits
  7200                              <1> ;			= 11	- 8 data bits
  7201                              <1> ;		bit 2	= 0	- 1 stop bit
  7202                              <1> ;			= 1	- 2 stop bits
  7203                              <1> ;		bit 3	= 0	- parity disable
  7204                              <1> ;			= 1	- parity enable
  7205                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  7206                              <1> ;			= 1	- even parity (if parity enabled)
  7207                              <1> ;		bit 7-5 = 000	- 110 bps
  7208                              <1> ;			= 001	- 150 bps
  7209                              <1> ;			= 010	- 300 bps
  7210                              <1> ;			= 011	- 600 bps
  7211                              <1> ;			= 100	- 1200 bps
  7212                              <1> ;			= 101	- 2400 bps
  7213                              <1> ;			= 110	- 4800 bps
  7214                              <1> ;			= 111	- 9600 bps
  7215                              <1> ;	DX = serial port number (0-3)
  7216                              <1> ; Output:
  7217                              <1> ;	AL = modem status
  7218                              <1> ;		bit 0	= 1	- delta clear to send
  7219                              <1> ;		bit 1	= 1	- delta data set ready
  7220                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  7221                              <1> ;		bit 3	= 1	- delta data carrier detect
  7222                              <1> ;		bit 4	= 1	- clear to send
  7223                              <1> ;		bit 5	= 1	- data set ready
  7224                              <1> ;		bit 6	= 1	- ring indicator
  7225                              <1> ;		bit 7	= 1	- data carrier detect
  7226                              <1> ;	AH = line status
  7227                              <1> ;		bit 0	= 1	- data ready
  7228                              <1> ;		bit 1	= 1	- overrun error
  7229                              <1> ;		bit 2	= 1	- parity error
  7230                              <1> ;		bit 3	= 1	- framing error
  7231                              <1> ;		bit 4	= 1	- break interrupt
  7232                              <1> ;		bit 5	= 1	- transmitter holding register
  7233                              <1> ;		bit 6	= 1	- transmitter empty
  7234                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  7235                              <1> ;-------------------------------------------------------------------------
  7236                              <1> int_14_fn00:
  7237 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  7238 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7239 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7240 00006773 EE                  <1> 	out	dx,al
  7241 00006774 31DB                <1> 	xor	bx,bx
  7242 00006776 88E3                <1> 	mov	bl,ah
  7243 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  7244 0000677B D0EB                <1> 	shr	bl,1
  7245 0000677D D0EB                <1> 	shr	bl,1
  7246 0000677F D0EB                <1> 	shr	bl,1
  7247 00006781 D0EB                <1> 	shr	bl,1
  7248 00006783 2E8B9F[1F20]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7249 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7250 0000678B 88D8                <1> 	mov	al,bl
  7251 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  7252 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  7253 0000678F 88F8                <1> 	mov	al,bh
  7254 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  7255 00006792 42                  <1> 	inc	dx
  7256 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  7257 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  7258 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  7259                              <1> 					; get control bits
  7260 00006798 EE                  <1> 	out	dx,al			; set LCR
  7261 00006799 4A                  <1> 	dec	dx
  7262 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  7263                              <1> 					; OPTIMIZATION:
  7264                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7265 0000679B B000                <1> 	mov	al,0
  7266 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  7267 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  7268                              <1> 					; OPTIMIZATION:
  7269                              <1> 					; uart_base = uart_ier_reg - 1
  7270 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7271                              <1> 
  7272                              <1> ;=========================================================================
  7273                              <1> ; int_14_fn03 - Return serial port status
  7274                              <1> ; Input:
  7275                              <1> ;	AH = 03h - function 03h - return serial port status
  7276                              <1> ;	DX = serial port number (0-3)
  7277                              <1> ; Output:
  7278                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7279                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7280                              <1> ;-------------------------------------------------------------------------
  7281                              <1> int_14_fn03:
  7282 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  7283 000067A4 EC                  <1> 	in	al,dx
  7284 000067A5 88C4                <1> 	mov	ah,al
  7285 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  7286 000067A8 EC                  <1> 	in	al,dx
  7287 000067A9 EBBB                <1> 	jmp	int_14_exit
  7288                              <1> 
  7289                              <1> ;=========================================================================
  7290                              <1> ; int_14_fn04 - Extended initialize serial port
  7291                              <1> ; Input:
  7292                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  7293                              <1> ;	AL - break status:
  7294                              <1> ;		00h = no break
  7295                              <1> ;		01h = break
  7296                              <1> ;	BH - parity:
  7297                              <1> ;		00h = no parity
  7298                              <1> ;		01h = odd parity
  7299                              <1> ;		02h = even parity
  7300                              <1> ;		03h = stick parity odd
  7301                              <1> ;		04h = stick parity even
  7302                              <1> ;	BL - stop bits:
  7303                              <1> ;		00h = 1 stop bit
  7304                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  7305                              <1> ;	CH - word length:
  7306                              <1> ;		00h = 5 bits
  7307                              <1> ;		01h = 6 bits
  7308                              <1> ;		02h = 7 bits
  7309                              <1> ;		03h = 8 bits
  7310                              <1> ;	CL - bps rate:
  7311                              <1> ;		00h = 110 bps
  7312                              <1> ;		01h = 150 bps
  7313                              <1> ;		02h = 300 bps
  7314                              <1> ;		03h = 600 bps
  7315                              <1> ;		04h = 1200 bps
  7316                              <1> ;		05h = 2400 bps
  7317                              <1> ;		06h = 6000 bps
  7318                              <1> ;		07h = 9600 bps
  7319                              <1> ;		08h = 19200 bps
  7320                              <1> ;		09h = 38400 bps
  7321                              <1> ;		0Ah = 57600 bps
  7322                              <1> ;		0Bh = 115200 bps
  7323                              <1> ;	DX = serial port number (0-3)
  7324                              <1> ; Output:
  7325                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7326                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7327                              <1> ;-------------------------------------------------------------------------
  7328                              <1> int_14_fn04:
  7329 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  7330 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  7331 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  7332                              <1> 					; exit returning modem and line status
  7333 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7334 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7335 000067B7 EE                  <1> 	out	dx,al
  7336 000067B8 31DB                <1> 	xor	bx,bx
  7337 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  7338 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  7339 000067BE 2E8B9F[1F20]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7340 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7341 000067C6 88D8                <1> 	mov	al,bl
  7342 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  7343 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  7344 000067CA 88F8                <1> 	mov	al,bh
  7345 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  7346 000067CD 42                  <1> 	inc	dx
  7347 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  7348                              <1> 
  7349 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  7350 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  7351                              <1> 
  7352 000067D4 D0E0                <1> 	shl	al,1
  7353 000067D6 D0E0                <1> 	shl	al,1
  7354 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  7355                              <1> 	
  7356 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  7357 000067DB 53                  <1> 	push	bx			; push it back to the stack
  7358                              <1> 
  7359 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  7360 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  7361 000067E1 FECF                <1> 	dec	bh
  7362 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  7363 000067E6 D0E7                <1> 	shl	bh,1
  7364 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  7365                              <1> 
  7366                              <1> .set_parity:
  7367 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  7368                              <1> 
  7369 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  7370                              <1> 	
  7371 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  7372 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  7373                              <1> 
  7374 000067F3 D0E0                <1> 	shl	al,1
  7375 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  7376                              <1> 
  7377 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  7378 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  7379                              <1> 
  7380 000067FC EE                  <1> 	out	dx,al			; set LCR
  7381 000067FD 4A                  <1> 	dec	dx
  7382 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  7383                              <1> 					; OPTIMIZATION:
  7384                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7385 000067FF B000                <1> 	mov	al,0
  7386 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  7387 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  7388                              <1> 					; OPTIMIZATION:
  7389                              <1> 					; uart_base = uart_ier_reg - 1
  7390 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7391                              <1> 
  7392                              <1> ;=========================================================================
  7393                              <1> ; int_14_fn05 - Extended serial port control
  7394                              <1> ; Input:
  7395                              <1> ;	AH = 05h - function 05h - extended serial port control
  7396                              <1> ;	AL - sub-function:
  7397                              <1> ;		00h = read modem control register
  7398                              <1> ;		01h = write modem control register
  7399                              <1> ;			BL = modem control register
  7400                              <1> ;	DX = serial port number (0-3)
  7401                              <1> ; Output:
  7402                              <1> ;	AX = status	
  7403                              <1> ;	sub-function AL = 00h:
  7404                              <1> ;		BL = modem control register
  7405                              <1> ;-------------------------------------------------------------------------
  7406                              <1> int_14_fn05:
  7407 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  7408 00006807 750D                <1> 	jnz	int_14_fn05_01
  7409                              <1> 
  7410                              <1> ;-------------------------------------------------------------------------
  7411                              <1> ; sub-function 00h - read modem control register
  7412                              <1> ; int_14_fn05_00:
  7413 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7414 0000680C EC                  <1> 	in	al,dx
  7415 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  7416 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  7417 00006810 53                  <1> 	push	bx			; put BX back to the stack
  7418 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7419 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7420                              <1> 
  7421                              <1> ;-------------------------------------------------------------------------
  7422                              <1> ; sub-function 01h - write modem control register
  7423                              <1> int_14_fn05_01:
  7424 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7425 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  7426 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  7427 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  7428 0000681D EE                  <1> 	out	dx,al
  7429 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7430 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7431                                  %include	"atkbd.inc"		; INT 16, INT 09
  7432                              <1> ;=========================================================================
  7433                              <1> ; atkbd.inc - AT keyboard support
  7434                              <1> ;       INT 16h - BIOS Keyboard Services
  7435                              <1> ;		- function AH=02h
  7436                              <1> ;		- function AH=03h
  7437                              <1> ;		- function AH=05h
  7438                              <1> ;		- function AH=12h
  7439                              <1> ;		- see scancode.inc for other (scancode related)
  7440                              <1> ;                 INT 16h functions
  7441                              <1> ;       INT 09h - IRQ1 interrupt handler
  7442                              <1> ;-------------------------------------------------------------------------
  7443                              <1> ;
  7444                              <1> ; Compiles with NASM 2.07, might work with other versions
  7445                              <1> ;
  7446                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  7447                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7448                              <1> ;
  7449                              <1> ; This program is free software: you can redistribute it and/or modify
  7450                              <1> ; it under the terms of the GNU General Public License as published by
  7451                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7452                              <1> ; (at your option) any later version.
  7453                              <1> ;
  7454                              <1> ; This program is distributed in the hope that it will be useful,
  7455                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7456                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7457                              <1> ; GNU General Public License for more details.
  7458                              <1> ;
  7459                              <1> ; You should have received a copy of the GNU General Public License
  7460                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7461                              <1> ;
  7462                              <1> ;=========================================================================
  7463                              <1> 
  7464                              <1> ;=========================================================================
  7465                              <1> ; Scan codes and keyboard flags
  7466                              <1> ;-------------------------------------------------------------------------
  7467                              <1> 
  7468                              <1> ; scancodes for special keys
  7469                              <1> 
  7470                              <1> kbd_num_code	equ	45h
  7471                              <1> kbd_scroll_code	equ	46h
  7472                              <1> kbd_caps_code	equ	3ah
  7473                              <1> kbd_ctrl_code	equ	1dh
  7474                              <1> kbd_alt_code	equ	38h
  7475                              <1> kbd_rshift_code	equ	36h
  7476                              <1> kbd_prtsc_code	equ	37h
  7477                              <1> kbd_lshift_code	equ	2ah
  7478                              <1> kbd_ins_code	equ	52h
  7479                              <1> kbd_del_code	equ	53h
  7480                              <1> 
  7481                              <1> ; Bits for the various modifier keys
  7482                              <1> 
  7483                              <1> kbd_rshft_bit	equ	1
  7484                              <1> kbd_lshft_bit	equ	2
  7485                              <1> kbd_ctrl_bit	equ	4
  7486                              <1> kbd_alt_bit	equ	8
  7487                              <1> kbd_scroll_bit	equ	10h
  7488                              <1> kbd_num_bit	equ	20h
  7489                              <1> kbd_caps_bit	equ	40h
  7490                              <1> kbd_ins_bit	equ	80h
  7491                              <1> 
  7492                              <1> ;=========================================================================
  7493                              <1> ; int_16 - BIOS keyboard functions
  7494                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  7495                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  7496                              <1> ;	conditions
  7497                              <1> ;-------------------------------------------------------------------------
  7498 00006824 FF<rept>            <1> 	setloc	0E82Eh
  7499          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  7500                              <1> int_16:
  7501 0000682E 53                  <1> 	push	bx
  7502 0000682F 1E                  <1> 	push	ds
  7503 00006830 BB4000              <1> 	mov	bx,biosdseg
  7504 00006833 8EDB                <1> 	mov	ds,bx
  7505 00006835 80FC13              <1> 	cmp	ah,.num_func
  7506 00006838 7331                <1> 	jae	int_16_exit
  7507 0000683A B700                <1> 	mov	bh,0
  7508 0000683C 88E3                <1> 	mov	bl,ah
  7509 0000683E D1E3                <1> 	shl	bx,1
  7510 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
  7511                              <1> 
  7512                              <1> .dispatch:
  7513 00006845 [311E]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  7514 00006847 [861E]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  7515 00006849 [7468]              <1> 	dw	int_16_fn02		; get shift status
  7516 0000684B [7968]              <1> 	dw	int_16_fn03		; set delays
  7517 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
  7518 0000684F [A668]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  7519 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
  7520 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
  7521 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
  7522 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
  7523 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
  7524 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  7525 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  7526 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  7527 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  7528 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  7529 00006865 [DE1E]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  7530 00006867 [051F]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  7531 00006869 [CF68]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  7532                              <1> .num_func	equ	($-.dispatch)/2
  7533                              <1> 
  7534                              <1> int_16_exit:
  7535 0000686B 1F                  <1> 	pop	ds
  7536 0000686C 5B                  <1> 	pop	bx
  7537 0000686D CF                  <1> 	iret
  7538                              <1> 
  7539                              <1> int_16_exitf:
  7540 0000686E 1F                  <1> 	pop	ds
  7541 0000686F 5B                  <1> 	pop	bx
  7542 00006870 FB                  <1> 	sti
  7543 00006871 CA0200              <1> 	retf	2
  7544                              <1> 
  7545                              <1> ;=========================================================================
  7546                              <1> ; int_16_fn02 - get shift flags
  7547                              <1> ; Input:
  7548                              <1> ;	AH = 02h
  7549                              <1> ; Output:
  7550                              <1> ;	AL - shift flags
  7551                              <1> ;            AL bits:
  7552                              <1> ;		7 - Insert active
  7553                              <1> ;		6 - Caps Lock active
  7554                              <1> ;		5 - Num Lock active
  7555                              <1> ;		4 - Scroll Lock active
  7556                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  7557                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  7558                              <1> ;		1 - left shift key pressed
  7559                              <1> ;		0 - right shift key pressed
  7560                              <1> ;-------------------------------------------------------------------------
  7561                              <1> int_16_fn02:
  7562 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7563 00006877 EBF2                <1> 	jmp	int_16_exit
  7564                              <1> 
  7565                              <1> ;=========================================================================
  7566                              <1> ; int_16_fn03 - set keyboard typematic rate
  7567                              <1> ; Input:
  7568                              <1> ;	AH = 03
  7569                              <1> ;	AL - subfunction
  7570                              <1> ;	     00 - set typematic rate to default
  7571                              <1> ;	     01 - increase initial delay
  7572                              <1> ;	     02 - slow typematic rate by 1/2
  7573                              <1> ;	     04 - turn off typematic chars
  7574                              <1> ;	     05 - set typematic rate/delay
  7575                              <1> ;	BH - repeat delay (AL=5)
  7576                              <1> ;		0 - 250ms	2 - 750ms
  7577                              <1> ;		1 - 500ms	3 - 1000ms
  7578                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  7579                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  7580                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  7581                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  7582                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  7583                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  7584                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  7585                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  7586                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  7587                              <1> ; Output:
  7588                              <1> ;	none
  7589                              <1> ;-------------------------------------------------------------------------
  7590                              <1> int_16_fn03:
  7591 00006879 3C05                <1> 	cmp	al,05
  7592 0000687B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  7593 0000687D 53                  <1> 	push	bx
  7594 0000687E 51                  <1> 	push	cx
  7595 0000687F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7596 00006881 E8AFB0              <1> 	call	kbc_send_cmd_byte
  7597 00006884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  7598 00006887 B105                <1> 	mov	cl,5
  7599 00006889 D2E7                <1> 	shl	bh,cl
  7600 0000688B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  7601 0000688E B0F3                <1> 	mov	al,0F3h
  7602 00006890 E83CB0              <1> 	call	kbc_kb_send
  7603 00006893 88F8                <1> 	mov	al,bh
  7604 00006895 E837B0              <1> 	call	kbc_kb_send
  7605 00006898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7606 0000689A E896B0              <1> 	call	kbc_send_cmd_byte
  7607 0000689D B004                <1> 	mov	al,04h
  7608 0000689F E82DB0              <1> 	call	kbc_kb_send
  7609 000068A2 59                  <1> 	pop	cx
  7610 000068A3 5B                  <1> 	pop	bx
  7611                              <1> .exit:
  7612 000068A4 EBC5                <1> 	jmp	int_16_exit
  7613                              <1> 
  7614                              <1> ;=========================================================================
  7615                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  7616                              <1> ; Input:
  7617                              <1> ;	AH = 05h
  7618                              <1> ;	CH = BIOS scan code
  7619                              <1> ;	CL = ACII character
  7620                              <1> ; Output:
  7621                              <1> ;	AL - status
  7622                              <1> ;	     00h - success
  7623                              <1> ;	     01h - keyboard buffer full
  7624                              <1> ;-------------------------------------------------------------------------
  7625                              <1> int_16_fn05:
  7626 000068A6 56                  <1> 	push	si
  7627 000068A7 B001                <1> 	mov	al,1			; assume no space
  7628 000068A9 FA                  <1> 	cli				; critical section
  7629 000068AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7630 000068AE 89DE                <1> 	mov	si,bx
  7631 000068B0 83C302              <1> 	add	bx,2
  7632 000068B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7633 000068B7 7504                <1> 	jne	.1
  7634 000068B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7635                              <1> .1:
  7636 000068BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7637 000068C1 7408                <1> 	je	.no_space		; no space in buffer
  7638 000068C3 890C                <1> 	mov	word [si],cx
  7639 000068C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7640 000068C9 B000                <1> 	mov	al,0			; stored successfully
  7641                              <1> .no_space:
  7642 000068CB FB                  <1> 	sti
  7643 000068CC 5E                  <1> 	pop	si
  7644 000068CD EB9C                <1> 	jmp	int_16_exit
  7645                              <1> 
  7646                              <1> ;=========================================================================
  7647                              <1> ; int_16_fn12 - get extended shift flags
  7648                              <1> ; Input:
  7649                              <1> ;	AH = 12h
  7650                              <1> ; Output:
  7651                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  7652                              <1> ;	AH - shift flags 2
  7653                              <1> ;            AH bits:
  7654                              <1> ;		7 - SysRq key pressed
  7655                              <1> ;		6 - Caps Lock pressed
  7656                              <1> ;		5 - Num Lock pressed
  7657                              <1> ;		4 - Scroll Lock pressed
  7658                              <1> ;		3 - right Alt key pressed
  7659                              <1> ;		2 - right Ctrl key pressed
  7660                              <1> ;		1 - left Alt key pressed
  7661                              <1> ;		0 - left Ctrl key pressed
  7662                              <1> ;-------------------------------------------------------------------------
  7663                              <1> int_16_fn12:
  7664 000068CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  7665 000068D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  7666 000068D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  7667 000068D9 7403                <1> 	je	.1
  7668 000068DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  7669                              <1> .1:
  7670 000068DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  7671 000068E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  7672 000068E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  7673 000068E6 08C4                <1> 	or	ah,al			; copy to AH
  7674 000068E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7675 000068EB E97DFF              <1> 	jmp	int_16_exit
  7676                              <1> 
  7677                              <1> ;=========================================================================
  7678                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  7679                              <1> ;-------------------------------------------------------------------------
  7680 000068EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  7681          ******************  <1>  warning: (setloc:7) Inserting 153 bytes
  7682                              <1> int_09:
  7683 00006987 50                  <1> 	push	ax
  7684 00006988 53                  <1> 	push	bx
  7685 00006989 1E                  <1> 	push	ds
  7686                              <1> 
  7687 0000698A B84000              <1> 	mov	ax,biosdseg
  7688 0000698D 8ED8                <1> 	mov	ds,ax
  7689                              <1> 
  7690                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7691                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7692                              <1> 	call    kbc_send_cmd_byte
  7693                              <1> %endif
  7694 0000698F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  7695 00006991 FB                  <1> 	sti
  7696 00006992 B44F                <1> 	mov	ah,4Fh
  7697 00006994 F9                  <1> 	stc
  7698 00006995 CD15                <1> 	int	15h			; keyboard intercept
  7699 00006997 7203E9CB01          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  7700                              <1> 
  7701                              <1> ; check for KBC response codes
  7702                              <1> 
  7703 0000699C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  7704 0000699E 7503E9C401          <1> 	je      keyboard_int_exit
  7705 000069A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  7706 000069A5 7508                <1> 	jne     .2
  7707 000069A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  7708 000069AC E9B801              <1> 	jmp	keyboard_int_exit
  7709                              <1> .2:
  7710 000069AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  7711 000069B1 7508                <1> 	jne	.3
  7712 000069B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  7713 000069B8 E9AC01              <1> 	jmp	keyboard_int_exit
  7714                              <1> 
  7715                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  7716                              <1> 
  7717                              <1> .3:
  7718                              <1> 
  7719                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  7720                              <1> 
  7721 000069BB 3CE0                <1> 	cmp	al,0E0h
  7722 000069BD 750D                <1> 	jne	.4
  7723 000069BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  7724 000069C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  7725 000069C9 E99B01              <1> 	jmp	keyboard_int_exit
  7726                              <1> .4:
  7727 000069CC 3CE1                <1> 	cmp	al,0E1h
  7728 000069CE 750D                <1> 	jne	.5
  7729 000069D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  7730 000069D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  7731 000069DA E98A01              <1> 	jmp	keyboard_int_exit
  7732                              <1> 
  7733                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  7734                              <1> 
  7735                              <1> .5:
  7736 000069DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  7737 000069E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  7738 000069E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  7739 000069E7 7529                <1> 	jne	.6
  7740 000069E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  7741 000069EB 750B                <1> 	jne	.check_minus
  7742 000069ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  7743 000069F3 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  7744                              <1> 
  7745                              <1> .check_minus:
  7746 000069F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  7747 000069FA 7509                <1> 	jne	.check_plus
  7748                              <1> 
  7749                              <1> .turbo_off:
  7750 000069FC E461                <1> 	in	al,port_b_reg
  7751 000069FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  7752 00006A00 E661                <1> 	out	port_b_reg,al
  7753 00006A02 E96201              <1> 	jmp	keyboard_int_exit
  7754                              <1> 
  7755                              <1> .check_plus:
  7756 00006A05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  7757 00006A07 7509                <1> 	jne	.6
  7758                              <1> 
  7759                              <1> .turbo_on:
  7760 00006A09 E461                <1> 	in	al,port_b_reg
  7761 00006A0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  7762 00006A0D E661                <1> 	out	port_b_reg,al
  7763 00006A0F E95501              <1> 	jmp	keyboard_int_exit
  7764                              <1> 
  7765                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  7766                              <1> ; in the keyboard flags variables.
  7767                              <1> 
  7768                              <1> .6:
  7769 00006A12 3C52                <1> 	cmp	al,kbd_ins_code
  7770 00006A14 7508                <1> 	jne	.7
  7771 00006A16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  7772 00006A1B E90A01              <1> 	jmp	.translate	   	; pass on INS key
  7773                              <1> 
  7774                              <1> .7:
  7775 00006A1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  7776 00006A20 750D                <1> 	jne     .8
  7777 00006A22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  7778 00006A27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  7779 00006A2C E93301              <1> 	jmp     .no_buffer
  7780                              <1> 
  7781                              <1> ; handle the left and right Shift keys
  7782                              <1> 
  7783                              <1> .8:
  7784 00006A2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  7785 00006A31 7508                <1> 	jne	.9
  7786 00006A33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  7787 00006A38 E92701              <1> 	jmp	.no_buffer
  7788                              <1> .9:
  7789 00006A3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  7790 00006A3D 7508                <1> 	jne     .10
  7791 00006A3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  7792 00006A44 E91B01              <1> 	jmp     .no_buffer
  7793                              <1> .10:
  7794 00006A47 3C36                <1> 	cmp	al,kbd_rshift_code
  7795 00006A49 7508                <1> 	jne	.11
  7796 00006A4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  7797 00006A50 E90F01              <1> 	jmp	.no_buffer
  7798                              <1> .11:
  7799 00006A53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  7800 00006A55 7508                <1> 	jne     .12
  7801 00006A57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  7802 00006A5C E90301              <1> 	jmp	.no_buffer
  7803                              <1> 
  7804                              <1> ; handle the Alt key
  7805                              <1> 
  7806                              <1> .12:
  7807 00006A5F 3C38                <1> 	cmp	al,kbd_alt_code
  7808 00006A61 7508                <1> 	jne	.13
  7809 00006A63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  7810 00006A68 E9F700              <1> 	jmp	.no_buffer
  7811                              <1> .13:
  7812 00006A6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  7813 00006A6D 751C                <1> 	jne	.14
  7814 00006A6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  7815 00006A74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  7816 00006A79 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  7817 00006A7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  7818 00006A81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  7819 00006A86 B400                <1> 	mov	ah,0
  7820 00006A88 E9B600              <1> 	jmp	.put_in_buffer
  7821                              <1> 
  7822                              <1> ; handle the Ctrl key
  7823                              <1> 
  7824                              <1> .14:
  7825 00006A8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  7826 00006A8D 7508                <1> 	jne	.15
  7827 00006A8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  7828 00006A94 E9CB00              <1> 	jmp	.no_buffer
  7829                              <1> .15:
  7830 00006A97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  7831 00006A99 7508                <1> 	jne	.16
  7832 00006A9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  7833 00006AA0 E9BF00              <1> 	jmp	.no_buffer
  7834                              <1> 
  7835                              <1> ; handle the Caps Lock key
  7836                              <1> 
  7837                              <1> .16:
  7838 00006AA3 3C3A                <1> 	cmp	al,kbd_caps_code
  7839 00006AA5 750D                <1> 	jne	.17
  7840 00006AA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  7841 00006AAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  7842 00006AB1 E9AE00              <1> 	jmp	.no_buffer
  7843                              <1> .17:
  7844 00006AB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  7845 00006AB6 7508                <1> 	jne	.18
  7846 00006AB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  7847 00006ABD E9D000              <1> 	jmp	set_LEDs
  7848                              <1> 
  7849                              <1> ; check if print screen key was pressed
  7850                              <1> 
  7851                              <1> .18:
  7852 00006AC0 3C37                <1> 	cmp	al,kbd_prtsc_code
  7853 00006AC2 750A                <1> 	jne	.test_scroll_loc
  7854 00006AC4 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7855 00006AC9 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  7856 00006ACB E9B500              <1> 	jmp	print_screen
  7857                              <1> 
  7858                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  7859                              <1> 
  7860                              <1> .test_scroll_loc:
  7861 00006ACE 3C46                <1> 	cmp	al,kbd_scroll_code
  7862 00006AD0 7528                <1> 	jne	.19
  7863 00006AD2 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7864 00006AD7 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  7865                              <1> 
  7866                              <1> ; handle Ctrl-Break
  7867                              <1> 
  7868 00006AD9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  7869 00006ADD 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  7870 00006AE1 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7871 00006AE5 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  7872 00006AEA CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  7873 00006AEC EB74                <1> 	jmp	.no_buffer
  7874                              <1> 
  7875                              <1> ; handle Scroll Lock
  7876                              <1> 
  7877                              <1> .scroll_lock:
  7878 00006AEE 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  7879 00006AF3 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  7880 00006AF8 EB68                <1> 	jmp	.no_buffer
  7881                              <1> .19:
  7882 00006AFA 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  7883 00006AFC 7508                <1> 	jne	.20
  7884 00006AFE 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  7885 00006B03 E98A00              <1> 	jmp	set_LEDs
  7886                              <1> 
  7887                              <1> ; handle the Num Lock
  7888                              <1> 
  7889                              <1> .20:
  7890 00006B06 3C45                <1> 	cmp	al,kbd_num_code
  7891 00006B08 7513                <1> 	jne	.21
  7892 00006B0A F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  7893 00006B0F 755E                <1> 	jnz	pause			; jump if pause
  7894 00006B11 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  7895 00006B16 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  7896 00006B1B EB45                <1> 	jmp	.no_buffer
  7897                              <1> .21:
  7898 00006B1D 3CC5                <1> 	cmp	al,kbd_num_code+80h
  7899 00006B1F 7507                <1> 	jne	.translate
  7900 00006B21 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  7901 00006B26 EB68                <1> 	jmp	set_LEDs
  7902                              <1> 
  7903                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  7904                              <1> 
  7905                              <1> .translate:
  7906 00006B28 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  7907 00006B2D 7407                <1> 	jz	.check_release
  7908 00006B2F 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  7909 00006B34 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  7910                              <1> .check_release:
  7911 00006B36 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  7912 00006B38 7528                <1> 	jnz	.no_buffer
  7913                              <1> 
  7914 00006B3A E83BB2              <1> 	call	scan_xlat
  7915 00006B3D 85C0                <1> 	test	ax,ax		 	; check for bad code
  7916 00006B3F 7421                <1> 	je	.no_buffer
  7917                              <1> 
  7918                              <1> .put_in_buffer:
  7919 00006B41 56                  <1> 	push	si			; XXX - use Int 16h/05?
  7920 00006B42 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7921 00006B46 89DE                <1> 	mov	si,bx
  7922 00006B48 83C302              <1> 	add	bx,2
  7923 00006B4B 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7924 00006B4F 7504                <1> 	jne	.1
  7925 00006B51 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7926                              <1> .1:
  7927 00006B55 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7928 00006B59 7406                <1> 	je	.no_space		; no space in buffer
  7929 00006B5B 8904                <1> 	mov	word [si],ax
  7930 00006B5D 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7931                              <1> 
  7932                              <1> .no_space:
  7933 00006B61 5E                  <1> 	pop	si
  7934                              <1> 
  7935                              <1> .no_buffer:
  7936 00006B62 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  7937                              <1> 
  7938                              <1> keyboard_int_exit:
  7939                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7940                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7941                              <1> 	call	kbc_send_cmd_byte
  7942                              <1> %endif
  7943 00006B67 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7944 00006B69 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  7945                              <1> 
  7946                              <1> keyboard_int_exit1:
  7947 00006B6B 1F                  <1> 	pop	ds
  7948 00006B6C 5B                  <1> 	pop	bx
  7949 00006B6D 58                  <1> 	pop	ax
  7950 00006B6E CF                  <1> 	iret
  7951                              <1> 
  7952                              <1> pause:
  7953 00006B6F 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  7954 00006B74 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  7955                              <1> 
  7956 00006B76 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7957 00006B78 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7958                              <1> 
  7959                              <1> .pause_loop:
  7960 00006B7A F606180008          <1> 	test	byte [kbd_flags_2],08h
  7961 00006B7F 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  7962 00006B81 EBE8                <1> 	jmp	keyboard_int_exit1
  7963                              <1> 
  7964                              <1> print_screen:
  7965 00006B83 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7966 00006B85 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7967 00006B87 CD05                <1> 	int	5h			; INT 5 - print screen
  7968 00006B89 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  7969 00006B8E EBDB                <1> 	jmp	keyboard_int_exit1
  7970                              <1> 
  7971                              <1> ;=========================================================================
  7972                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  7973                              <1> ; 	     variable and update LEDs on the keyboard
  7974                              <1> ;-------------------------------------------------------------------------
  7975                              <1> set_LEDs:
  7976                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7977                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7978                              <1> 	call	kbc_send_cmd_byte
  7979                              <1> %endif
  7980                              <1> 
  7981 00006B90 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7982 00006B92 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7983                              <1> 
  7984 00006B94 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7985 00006B97 D0E8                <1> 	shr	al,1
  7986 00006B99 D0E8                <1> 	shr	al,1
  7987 00006B9B D0E8                <1> 	shr	al,1
  7988 00006B9D D0E8                <1> 	shr	al,1
  7989 00006B9F 2407                <1> 	and	al,111b
  7990 00006BA1 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  7991 00006BA6 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  7992 00006BAA 88C4                <1> 	mov	ah,al			; save LED bits
  7993                              <1> 
  7994 00006BAC B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7995 00006BAE E882AD              <1> 	call	kbc_send_cmd_byte
  7996                              <1> 
  7997 00006BB1 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  7998 00006BB3 E819AD              <1> 	call	kbc_kb_send		; send the command to the keyboard
  7999 00006BB6 88E0                <1> 	mov	al,ah			; get parameter byte
  8000 00006BB8 E814AD              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  8001                              <1> 
  8002 00006BBB B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  8003 00006BBD E873AD              <1> 	call	kbc_send_cmd_byte
  8004 00006BC0 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  8005 00006BC2 E80AAD              <1> 	call	kbc_kb_send
  8006 00006BC5 EBA4                <1> 	jmp	keyboard_int_exit1
  8007                              <1> 
  8008                                  %include	"floppy2.inc"		; INT 13
  8009                              <1> ;=========================================================================
  8010                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  8011                              <1> ;       INT 13h, function AH=02h
  8012                              <1> ;       INT 13h, function AH=03h
  8013                              <1> ;       INT 13h, function AH=04h
  8014                              <1> ;       INT 13h, function AH=05h
  8015                              <1> ;	- see floppy1.inc for other INT 13h functions
  8016                              <1> ;-------------------------------------------------------------------------
  8017                              <1> ;
  8018                              <1> ; Compiles with NASM 2.07, might work with other versions
  8019                              <1> ;
  8020                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8021                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8022                              <1> ;
  8023                              <1> ; This program is free software: you can redistribute it and/or modify
  8024                              <1> ; it under the terms of the GNU General Public License as published by
  8025                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8026                              <1> ; (at your option) any later version.
  8027                              <1> ;
  8028                              <1> ; This program is distributed in the hope that it will be useful,
  8029                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8030                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8031                              <1> ; GNU General Public License for more details.
  8032                              <1> ;
  8033                              <1> ; You should have received a copy of the GNU General Public License
  8034                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8035                              <1> ;
  8036                              <1> ;=========================================================================
  8037                              <1> 
  8038                              <1> ;-------------------------------------------------------------------------
  8039                              <1> ; offsets for registers on stack
  8040                              <1> int_13_bp	equ	0
  8041                              <1> int_13_ds	equ	int_13_bp+2
  8042                              <1> int_13_di	equ	int_13_ds+2
  8043                              <1> int_13_si	equ	int_13_di+2
  8044                              <1> int_13_dx	equ	int_13_si+2
  8045                              <1> int_13_dl	equ	int_13_dx
  8046                              <1> int_13_dh	equ	int_13_dx+1
  8047                              <1> int_13_cx	equ	int_13_dx+2
  8048                              <1> int_13_cl	equ	int_13_cx
  8049                              <1> int_13_ch	equ	int_13_cx+1
  8050                              <1> int_13_bx	equ	int_13_cx+2
  8051                              <1> int_13_bl	equ	int_13_bx
  8052                              <1> int_13_bh	equ	int_13_bx+1
  8053                              <1> int_13_ax	equ	int_13_bx+2
  8054                              <1> int_13_al	equ	int_13_ax
  8055                              <1> int_13_ah	equ	int_13_ax+1
  8056                              <1> int_13_ip	equ	int_13_ax+2
  8057                              <1> int_13_cs	equ	int_13_ip+2
  8058                              <1> int_13_flags	equ	int_13_cs+2
  8059                              <1> int_13_flags_l	equ	int_13_flags
  8060                              <1> 
  8061                              <1> ;=========================================================================
  8062                              <1> ; int_13 - BIOS floppy disk services
  8063                              <1> ; Input:
  8064                              <1> ;	AH = function
  8065                              <1> ;		00h - Reset disk system
  8066                              <1> ;		01h - Get status of last operation
  8067                              <1> ;		02h - Read disk sectors
  8068                              <1> ;		03h - Write disk sectors
  8069                              <1> ;		04h - Verify disk sectors
  8070                              <1> ;		05h - Format track
  8071                              <1> ;		08h - Get drive parameters
  8072                              <1> ;		15h - Get disk type
  8073                              <1> ;		16h - Detect disk change
  8074                              <1> ;		17h - Set disk type for format
  8075                              <1> ;		18h - Set media type for format
  8076                              <1> ; Output:
  8077                              <1> ;	- depends on function
  8078                              <1> ;	- for most functions:
  8079                              <1> ;		CF clear if successful
  8080                              <1> ;			AH = 00h - successful completion
  8081                              <1> ;		CF set on error
  8082                              <1> ;			AH = error code
  8083                              <1> ;-------------------------------------------------------------------------
  8084 00006BC7 FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  8085          ******************  <1>  warning: (setloc:7) Inserting 146 bytes
  8086                              <1> int_13:
  8087 00006C59 FB                  <1> 	sti
  8088 00006C5A 50                  <1> 	push	ax
  8089 00006C5B 53                  <1> 	push	bx
  8090 00006C5C 51                  <1> 	push	cx
  8091 00006C5D 52                  <1> 	push	dx
  8092 00006C5E 56                  <1> 	push	si
  8093 00006C5F 57                  <1> 	push	di
  8094 00006C60 1E                  <1> 	push	ds
  8095 00006C61 55                  <1> 	push	bp
  8096 00006C62 89E5                <1> 	mov	bp,sp
  8097 00006C64 80FC19              <1> 	cmp	ah,.num_func
  8098 00006C67 7743                <1> 	ja	.invalid_function
  8099 00006C69 88E0                <1> 	mov	al,ah
  8100 00006C6B 98                  <1> 	cbw
  8101 00006C6C 89C7                <1> 	mov	di,ax
  8102 00006C6E D1E7                <1> 	shl	di,1
  8103 00006C70 B84000              <1> 	mov	ax,biosdseg
  8104 00006C73 8ED8                <1> 	mov	ds,ax
  8105 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  8106                              <1> 
  8107                              <1> .dispatch:
  8108 00006C7A [BF10]              <1> 	dw	int_13_fn00		; Reset disk system
  8109 00006C7C [2E11]              <1> 	dw	int_13_fn01		; Get status of last operation
  8110 00006C7E [EF6C]              <1> 	dw	int_13_fn02		; Read disk sectors
  8111 00006C80 [EF6C]              <1> 	dw	int_13_fn03		; Write disk sectors
  8112 00006C82 [EF6C]              <1> 	dw	int_13_fn04		; Verify disk sectors
  8113 00006C84 [5D6E]              <1> 	dw	int_13_fn05		; Format track
  8114 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  8115 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  8116 00006C8A [3A11]              <1> 	dw	int_13_fn08		; Get drive parameters
  8117 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  8118 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  8119 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  8120 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  8121 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  8122 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  8123 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  8124 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  8125 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  8126 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  8127 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  8128 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  8129 00006CA4 [E711]              <1> 	dw	int_13_fn15		; Get disk type
  8130 00006CA6 [0812]              <1> 	dw	int_13_fn16		; Detect disk change
  8131 00006CA8 [5412]              <1> 	dw	int_13_fn17		; Set disk type for format
  8132 00006CAA [BF12]              <1> 	dw	int_13_fn18		; Set media type for format
  8133                              <1> .num_func	equ ($-.dispatch)/2
  8134                              <1> 
  8135                              <1> .invalid_function:
  8136 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  8137 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  8138 00006CB2 F9                  <1> 	stc				; error condition
  8139 00006CB3 EB21                <1> 	jmp	int_13_exit
  8140                              <1> 
  8141                              <1> ;-------------------------------------------------------------------------
  8142                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  8143                              <1> 
  8144                              <1> int_13_upd_exit:
  8145 00006CB5 9C                  <1> 	pushf
  8146 00006CB6 50                  <1> 	push	ax
  8147 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  8148 00006CBA 3C01                <1> 	cmp	al,1
  8149 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  8150 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  8151 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  8152 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  8153 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  8154 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  8155 00006CCA 08C0                <1> 	or	al,al
  8156 00006CCC 7402                <1> 	jz	.drive_0
  8157 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  8158                              <1> 
  8159                              <1> .drive_0:
  8160 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  8161                              <1> 
  8162                              <1> .no_update:
  8163 00006CD4 58                  <1> 	pop	ax
  8164 00006CD5 9D                  <1> 	popf
  8165                              <1> 
  8166                              <1> int_13_exit:
  8167 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  8168 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  8169 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  8170 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  8171 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  8172                              <1> 
  8173                              <1> .set_error:
  8174 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  8175 00006CE6 5D                  <1> 	pop	bp
  8176 00006CE7 1F                  <1> 	pop	ds
  8177 00006CE8 5F                  <1> 	pop	di
  8178 00006CE9 5E                  <1> 	pop	si
  8179 00006CEA 5A                  <1> 	pop	dx
  8180 00006CEB 59                  <1> 	pop	cx
  8181 00006CEC 5B                  <1> 	pop	bx
  8182 00006CED 58                  <1> 	pop	ax
  8183 00006CEE CF                  <1> 	iret
  8184                              <1> 
  8185                              <1> ;=========================================================================
  8186                              <1> ; int_13_fn02 - Read disk sectors
  8187                              <1> ; int_13_fn03 - Write disk sectors
  8188                              <1> ; int_13_fn04 - Verify disk sectors
  8189                              <1> ; Input:
  8190                              <1> ;	AH = function
  8191                              <1> ;		02h - read
  8192                              <1> ;		03h - write
  8193                              <1> ;		04h - verify
  8194                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  8195                              <1> ;	CH = cylinder number
  8196                              <1> ;	CL = sector number
  8197                              <1> ;	DH = head number (0 or 1)
  8198                              <1> ;	DL = drive number (0 or 1)
  8199                              <1> ;	ES:BX -> data buffer
  8200                              <1> ; Output:
  8201                              <1> ;	CF clear if successful
  8202                              <1> ;		AH = 00h - successful completion
  8203                              <1> ;		AL = number of sectors transferred or verified
  8204                              <1> ;	CF set on error
  8205                              <1> ;		AH = error code
  8206                              <1> ;-------------------------------------------------------------------------
  8207                              <1> int_13_fn02:
  8208                              <1> int_13_fn03:
  8209                              <1> int_13_fn04:
  8210 00006CEF 80FA01              <1> 	cmp	dl,1
  8211 00006CF2 7603E94801          <1> 	ja	.invalid_drive
  8212 00006CF7 BE9000              <1> 	mov	si,fdc_media_state
  8213 00006CFA 52                  <1> 	push	dx
  8214 00006CFB B600                <1> 	mov	dh,00h
  8215 00006CFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  8216 00006CFF 5A                  <1> 	pop	dx
  8217                              <1> 
  8218 00006D00 E80CAA              <1> 	call	read_cmos_type		; get drive type in AL
  8219 00006D03 7303E93701          <1> 	jc	.invalid_drive
  8220                              <1> 
  8221 00006D08 BF3F00              <1> 	mov	di,fdc_motor_state
  8222 00006D0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  8223 00006D0E 80FC03              <1> 	cmp	ah,03h			; write function
  8224 00006D11 7503                <1> 	jne	.motor_on		; jump if not write function
  8225 00006D13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  8226                              <1> 
  8227                              <1> .motor_on:
  8228 00006D16 E867A7              <1> 	call	fdc_motor_on
  8229 00006D19 3C01                <1> 	cmp	al,cmos_360
  8230 00006D1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  8231 00006D20 3C03                <1> 	cmp	al,cmos_720
  8232 00006D22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  8233                              <1> 
  8234 00006D27 E810A8              <1> 	call	fdc_disk_change
  8235 00006D2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  8236                              <1> 
  8237 00006D2F F60410              <1> 	test	byte [si],fdc_m_established
  8238 00006D32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  8239                              <1> 
  8240 00006D37 E8C5AA              <1> 	call	fdc_select_rate		; select transfer rate
  8241                              <1> 	
  8242                              <1> .fdc_send_specify:
  8243 00006D3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  8244                              <1> 					; 0BFh - specify byte 0 for 1.44M
  8245 00006D3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  8246 00006D40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  8247 00006D42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  8248 00006D44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  8249 00006D47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  8250 00006D49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  8251                              <1> 
  8252                              <1> .fdc_send_specify_cmd:
  8253 00006D4B BE0200              <1> 	mov	si,2			; specify byte 1
  8254 00006D4E B103                <1> 	mov	cl,3			; 3 bytes command
  8255 00006D50 E88DA8              <1> 	call	fdc_send_cmd
  8256 00006D53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  8257 00006D58 1E                  <1> 	push	ds
  8258 00006D59 31F6                <1> 	xor	si,si
  8259 00006D5B 8EDE                <1> 	mov	ds,si
  8260 00006D5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8261 00006D61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  8262 00006D64 B400                <1> 	mov	ah,00h
  8263 00006D66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  8264 00006D68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  8265 00006D6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  8266 00006D6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  8267 00006D70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  8268 00006D72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  8269                              <1> 
  8270                              <1> .calc_dma_count:
  8271 00006D75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  8272 00006D78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  8273 00006D7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  8274 00006D7D 1F                  <1> 	pop	ds
  8275 00006D7E 48                  <1> 	dec	ax			; minus one byte
  8276 00006D7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  8277                              <1> 
  8278 00006D81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  8279 00006D84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  8280 00006D86 80FC02              <1> 	cmp	ah,02h			; read function?
  8281 00006D89 7409                <1> 	je	.configure_dma		; jump if read function
  8282 00006D8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8283 00006D8D 80FC03              <1> 	cmp	ah,03h			; write function?
  8284 00006D90 7402                <1> 	je	.configure_dma		; jump if write function
  8285 00006D92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  8286                              <1> 
  8287                              <1> .configure_dma:
  8288 00006D94 E8EBA7              <1> 	call	fdc_configure_dma
  8289 00006D97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  8290 00006D9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  8291                              <1> 
  8292 00006D9F E827A6              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8293 00006DA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8294                              <1> 
  8295 00006DA7 1E                  <1> 	push	ds
  8296 00006DA8 31C0                <1> 	xor	ax,ax
  8297 00006DAA 8ED8                <1> 	mov	ds,ax
  8298 00006DAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8299 00006DB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  8300 00006DB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  8301 00006DB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  8302 00006DB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  8303 00006DBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  8304 00006DBD 1F                  <1> 	pop	ds
  8305                              <1> 
  8306 00006DBE BE9000              <1> 	mov	si,fdc_media_state
  8307 00006DC1 B600                <1> 	mov	dh,00h
  8308 00006DC3 01D6                <1> 	add	si,dx
  8309 00006DC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  8310 00006DC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  8311 00006DC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  8312 00006DCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  8313 00006DCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  8314 00006DD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  8315 00006DD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  8316 00006DD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  8317 00006DD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  8318 00006DDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  8319 00006DDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  8320 00006DDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  8321                              <1> 	
  8322                              <1> .gap_set:
  8323 00006DE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  8324 00006DE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  8325 00006DE7 88F4                <1> 	mov	ah,dh			; head
  8326 00006DE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  8327 00006DEB D0E4                <1> 	shl	ah,1
  8328 00006DED D0E4                <1> 	shl	ah,1
  8329 00006DEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  8330 00006DF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  8331 00006DF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  8332 00006DF7 7502                <1> 	jne	.send_command		; jump if not write 
  8333 00006DF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  8334                              <1> 
  8335                              <1> .send_command:
  8336 00006DFB B109                <1> 	mov	cl,9			; 9 bytes command
  8337 00006DFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8338 00006E02 E8DBA7              <1> 	call	fdc_send_cmd
  8339 00006E05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  8340 00006E07 E827AA              <1> 	call	fdc_wait_irq
  8341 00006E0A 7228                <1> 	jc	.error_fdc_get_result
  8342 00006E0C B107                <1> 	mov	cl,7
  8343 00006E0E E834A8              <1> 	call	fdc_get_result		; read result bytes
  8344 00006E11 7228                <1> 	jc	.error_end_io
  8345                              <1> 
  8346 00006E13 E884A8              <1> 	call	fdc_get_error
  8347                              <1> 
  8348                              <1> .exit_end_io:
  8349 00006E16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  8350                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  8351 00006E19 E8F3A6              <1> 	call	fdc_end_io		; return number of last sector in BL
  8352 00006E1C 08C0                <1> 	or	al,al
  8353 00006E1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  8354 00006E20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  8355 00006E22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  8356                              <1> 
  8357                              <1> .zero_sectors:
  8358 00006E25 08E4                <1> 	or	ah,ah
  8359 00006E27 7401                <1> 	jz	.exit			; jump if no errors
  8360                              <1> 
  8361                              <1> .error:
  8362 00006E29 F9                  <1> 	stc				; indicate error
  8363                              <1> 
  8364                              <1> .exit:
  8365 00006E2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  8366 00006E2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  8367 00006E31 E981FE              <1> 	jmp	int_13_upd_exit
  8368                              <1> 
  8369                              <1> .error_fdc_get_result:
  8370 00006E34 B107                <1> 	mov	cl,7
  8371 00006E36 50                  <1> 	push	ax
  8372 00006E37 E80BA8              <1> 	call	fdc_get_result		; read result bytes
  8373 00006E3A 58                  <1> 	pop	ax
  8374                              <1> 
  8375                              <1> .error_end_io:
  8376 00006E3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  8377 00006E3D EBD7                <1> 	jmp	.exit_end_io
  8378                              <1> 
  8379                              <1> .invalid_drive:
  8380 00006E3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  8381 00006E42 EBE5                <1> 	jmp	.error
  8382                              <1> 
  8383                              <1> ; 360K and 720K drives don't support change line, and only support
  8384                              <1> ; one media type - set it here
  8385                              <1> 
  8386                              <1> .set_media_360:
  8387 00006E44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  8388 00006E46 EB02                <1> 	jmp	.set_media
  8389                              <1> 
  8390                              <1> .set_media_720:
  8391 00006E48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  8392                              <1> 
  8393                              <1> .set_media:
  8394 00006E4A 8804                <1> 	mov	byte [si],al		; save media state
  8395 00006E4C E8D7A9              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  8396 00006E4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  8397 00006E52 E9E5FE              <1> 	jmp	.fdc_send_specify
  8398                              <1> 
  8399                              <1> ; establish media type
  8400                              <1> 
  8401                              <1> .establish_media:
  8402 00006E55 E8DAA8              <1> 	call	fdc_detect_media
  8403 00006E58 72E1                <1> 	jc	.error_end_io
  8404 00006E5A E9DDFE              <1> 	jmp	.fdc_send_specify
  8405                              <1> 	
  8406                              <1> 
  8407                              <1> ;=========================================================================
  8408                              <1> ; int_13_fn05 - Format track
  8409                              <1> ; Input:
  8410                              <1> ;	AH = 05h
  8411                              <1> ;	CH = track number
  8412                              <1> ;	DH = head number (0 or 1)
  8413                              <1> ;	DL = drive number (0 or 1)
  8414                              <1> ;	ES:BX -> address field buffer
  8415                              <1> ; Output:
  8416                              <1> ;	CF clear if successful
  8417                              <1> ;		AH = 00h - successful completion
  8418                              <1> ;	CF set on error
  8419                              <1> ;		AH = error code 
  8420                              <1> ;-------------------------------------------------------------------------
  8421                              <1> int_13_fn05:
  8422 00006E5D 80FA01              <1> 	cmp	dl,1
  8423 00006E60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  8424 00006E65 E8A7A8              <1> 	call	read_cmos_type		; get drive type in AL
  8425 00006E68 7303E99500          <1> 	jc	.invalid_drive
  8426 00006E6D BE9000              <1> 	mov	si,fdc_media_state
  8427 00006E70 52                  <1> 	push	dx
  8428 00006E71 B600                <1> 	mov	dh,00h
  8429 00006E73 01D6                <1> 	add	si,dx			; SI -> drive media state
  8430 00006E75 5A                  <1> 	pop	dx
  8431 00006E76 803C00              <1> 	cmp	byte [si],0
  8432 00006E79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  8433 00006E7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  8434 00006E83 E8FAA5              <1> 	call	fdc_motor_on
  8435 00006E86 E8B1A6              <1> 	call	fdc_disk_change		; read disk change line
  8436 00006E89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  8437 00006E8B E871A9              <1> 	call	fdc_select_rate		; select transfer rate
  8438 00006E8E E87EA2              <1> 	call	fdc_send_specify	; send FDC Specify command
  8439 00006E91 1E                  <1> 	push	ds
  8440 00006E92 31F6                <1> 	xor	si,si
  8441 00006E94 8EDE                <1> 	mov	ds,si
  8442 00006E96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8443 00006E9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  8444 00006E9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  8445 00006EA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  8446 00006EA3 1F                  <1> 	pop	ds
  8447 00006EA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  8448 00006EA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  8449 00006EA8 D1E1                <1> 	shl	cx,1
  8450 00006EAA 49                  <1> 	dec	cx	 		; minus one byte...
  8451 00006EAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8452 00006EAD E8D2A6              <1> 	call	fdc_configure_dma
  8453 00006EB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  8454 00006EB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  8455 00006EB5 56                  <1> 	push	si
  8456 00006EB6 E810A5              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8457 00006EB9 5E                  <1> 	pop	si
  8458 00006EBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8459                              <1> 
  8460 00006EBC 88F4                <1> 	mov	ah,dh
  8461 00006EBE D0E4                <1> 	shl	ah,1
  8462 00006EC0 D0E4                <1> 	shl	ah,1
  8463 00006EC2 08D4                <1> 	or	ah,dl
  8464 00006EC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  8465                              <1> 
  8466 00006EC6 B106                <1> 	mov	cl,6			; 6 byte command
  8467 00006EC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8468 00006ECD E810A7              <1> 	call	fdc_send_cmd
  8469 00006ED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  8470 00006ED2 E85CA9              <1> 	call	fdc_wait_irq
  8471 00006ED5 720A                <1> 	jc	.exit_end_io
  8472 00006ED7 B107                <1> 	mov	cl,7
  8473 00006ED9 E869A7              <1> 	call	fdc_get_result		; read result bytes
  8474 00006EDC 7203                <1> 	jc	.exit_end_io
  8475 00006EDE E8B9A7              <1> 	call	fdc_get_error		; get error code
  8476                              <1> 
  8477                              <1> .exit_end_io:
  8478 00006EE1 E82BA6              <1> 	call	fdc_end_io
  8479 00006EE4 08E4                <1> 	or	ah,ah
  8480 00006EE6 7401                <1> 	jz	.exit			; jump if no errors
  8481                              <1> 
  8482                              <1> .error:
  8483 00006EE8 F9                  <1> 	stc				; indicate error
  8484                              <1> 
  8485                              <1> .exit:
  8486 00006EE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  8487 00006EED E9C5FD              <1> 	jmp	int_13_upd_exit
  8488                              <1> 
  8489                              <1> .error_fdc_get_result:
  8490 00006EF0 B107                <1> 	mov	cl,7
  8491 00006EF2 50                  <1> 	push	ax
  8492 00006EF3 E84FA7              <1> 	call	fdc_get_result		; read result bytes
  8493 00006EF6 58                  <1> 	pop	ax
  8494 00006EF7 EBE8                <1> 	jmp	.exit_end_io
  8495                              <1> 
  8496                              <1> .error_end_io:
  8497 00006EF9 E813A6              <1> 	call	fdc_end_io
  8498 00006EFC EBEA                <1> 	jmp	.error
  8499                              <1> 
  8500                              <1> .timeout:
  8501 00006EFE B480                <1> 	mov	ah,fdc_e_timeout
  8502 00006F00 EBE6                <1> 	jmp	.error
  8503                              <1> 
  8504                              <1> .invalid_drive:
  8505 00006F02 B401                <1> 	mov	ah,fdc_e_invalid
  8506 00006F04 EBE2                <1> 	jmp	.error
  8507                              <1> 
  8508                              <1> ;=========================================================================
  8509                              <1> ; int_0E - IRQ6 (FDC) service routine
  8510                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  8511                              <1> ;-------------------------------------------------------------------------
  8512 00006F06 FF<rept>            <1> 	setloc	0EF57h
  8513          ******************  <1>  warning: (setloc:7) Inserting 81 bytes
  8514                              <1> 
  8515                              <1> int_0E:
  8516 00006F57 50                  <1> 	push	ax
  8517 00006F58 1E                  <1> 	push	ds
  8518 00006F59 B84000              <1> 	mov	ax,biosdseg
  8519 00006F5C 8ED8                <1> 	mov	ds,ax
  8520 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  8521 00006F63 1F                  <1> 	pop	ds
  8522 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  8523 00006F66 E620                <1> 	out	pic1_reg0,al
  8524 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  8525 00006F6B CD15                <1> 	int	15h
  8526 00006F6D 58                  <1> 	pop	ax
  8527 00006F6E CF                  <1> 	iret
  8528                              <1> 
  8529                              <1> ;=========================================================================
  8530                              <1> ; Disk parameter tables in INT 1Eh format
  8531                              <1> ; Byte 0: First byte for specify command:
  8532                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  8533                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  8534                              <1> ; Byte 1: Second byte for specify command:
  8535                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  8536                              <1> ;	bit 0: non-DMA mode (always 0)
  8537                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  8538                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  8539                              <1> ; Byte 4: sectors per track
  8540                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  8541                              <1> ; Byte 6: special sector size (0FFh - not used)
  8542                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  8543                              <1> ; Byte 8: format filler byte (default 0F6h)
  8544                              <1> ; Byte 9: head settle time in milliseconds
  8545                              <1> ; Byte A: motor start time, in 1/8 seconds
  8546                              <1> ; Byte B: number of cylinders minus one
  8547                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  8548                              <1> ;-------------------------------------------------------------------------
  8549                              <1> media_360_in_360:
  8550 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8551 00006F78 0F08                <1>
  8552 00006F7A 2780                <1> 	db	27h, 80h
  8553                              <1> media_1200:
  8554 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  8555 00006F85 0F08                <1>
  8556 00006F87 4F00                <1> 	db	4Fh, 00h
  8557                              <1> media_720:
  8558 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8559 00006F92 0F08                <1>
  8560 00006F94 4F80                <1> 	db	4Fh, 80h
  8561                              <1> media_1440:
  8562 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  8563 00006F9F 0F08                <1>
  8564 00006FA1 4F00                <1> 	db	4Fh, 00h
  8565                              <1> media_360_in_1200:
  8566 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  8567 00006FAC 0F08                <1>
  8568 00006FAE 2740                <1> 	db	27h, 40h
  8569                              <1> media_2880:
  8570 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8571 00006FB9 0F08                <1>
  8572 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  8573                              <1> 
  8574                              <1> ;=========================================================================
  8575                              <1> ; Disk parameter table for IBM compatibility
  8576                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  8577                              <1> ;-------------------------------------------------------------------------
  8578 00006FBD FF<rept>            <1> 	setloc	0EFC7h
  8579          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  8580                              <1> int_1E:
  8581 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8582 00006FD0 0F08                <1>
  8583                                  %include	"printer2.inc"		; INT 17
  8584                              <1> ;=========================================================================
  8585                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  8586                              <1> ;       INT 17h, function AH=00h
  8587                              <1> ;	INT 17h, function AH=02h
  8588                              <1> ;	- see printer1.inc for other INT 17h functions
  8589                              <1> ;-------------------------------------------------------------------------
  8590                              <1> ;
  8591                              <1> ; Compiles with NASM 2.07, might work with other versions
  8592                              <1> ;
  8593                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8594                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8595                              <1> ;
  8596                              <1> ; This program is free software: you can redistribute it and/or modify
  8597                              <1> ; it under the terms of the GNU General Public License as published by
  8598                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8599                              <1> ; (at your option) any later version.
  8600                              <1> ;
  8601                              <1> ; This program is distributed in the hope that it will be useful,
  8602                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8603                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8604                              <1> ; GNU General Public License for more details.
  8605                              <1> ;
  8606                              <1> ; You should have received a copy of the GNU General Public License
  8607                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8608                              <1> ;
  8609                              <1> ;=========================================================================
  8610                              <1> 
  8611                              <1> ;=========================================================================
  8612                              <1> ; int_17  - BIOS Printer Services
  8613                              <1> ;-------------------------------------------------------------------------
  8614                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  8615                              <1> int_17:
  8616 00006FD2 FB                  <1> 	sti
  8617 00006FD3 53                  <1> 	push	bx
  8618 00006FD4 52                  <1> 	push	dx
  8619 00006FD5 56                  <1> 	push	si
  8620 00006FD6 1E                  <1> 	push	ds
  8621 00006FD7 BB4000              <1> 	mov	bx,biosdseg
  8622 00006FDA 8EDB                <1> 	mov	ds,bx
  8623 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
  8624 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  8625 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  8626 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  8627 00006FE6 89D3                <1> 	mov	bx,dx
  8628 00006FE8 D1E3                <1> 	shl	bx,1
  8629 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  8630 00006FED 09D2                <1> 	or	dx,dx
  8631 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  8632                              <1> 
  8633 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  8634                              <1> 
  8635 00006FF3 08E4                <1> 	or	ah,ah
  8636 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  8637 00006FF7 FECC                <1> 	dec	ah
  8638 00006FF9 7503E939B0          <1> 	jz	int_17_fn01		; AH = 01h
  8639 00006FFE FECC                <1> 	dec	ah
  8640 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  8641                              <1> 
  8642                              <1> int_17_exit:
  8643 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  8644 00007005 88D8                <1> 	mov	al,bl			; restore AL
  8645                              <1> 
  8646                              <1> int_17_error:
  8647 00007007 1F                  <1> 	pop	ds
  8648 00007008 5E                  <1> 	pop	si
  8649 00007009 5A                  <1> 	pop	dx
  8650 0000700A 5B                  <1> 	pop	bx
  8651 0000700B CF                  <1> 	iret
  8652                              <1> 
  8653                              <1> ;=========================================================================
  8654                              <1> ; int_17_fn00 - Print character
  8655                              <1> ; Input:
  8656                              <1> ;	AH = 0 - function 00h - print character
  8657                              <1> ;	AL = character to print
  8658                              <1> ;	DX = printer port number (0-2)
  8659                              <1> ; Output:
  8660                              <1> ;	AH = printer status:
  8661                              <1> ;		bit 0	= 1	- timeout error
  8662                              <1> ;		bit 1,2		- reserved
  8663                              <1> ;		bit 3	= 1	- I/O error
  8664                              <1> ;		bit 4	= 1	- printed selected
  8665                              <1> ;		bit 5	= 1	- out of paper
  8666                              <1> ;		bit 6	= 1	- acknowledge from printer
  8667                              <1> ;		bit 7	= 1	- printer not busy
  8668                              <1> ;-------------------------------------------------------------------------
  8669                              <1> int_17_fn00:
  8670 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  8671 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8672                              <1> 					; OPTIMIZATION:
  8673                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8674 0000700E EC                  <1> 	in	al,dx			; read status
  8675 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  8676 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  8677 00007014 750C                <1>         jnz     .not_busy
  8678                              <1> 
  8679 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  8680 00007019 CD15                <1> 	int	15h			; call OS hook
  8681                              <1> 
  8682 0000701B B780                <1> 	mov	bh,prn_stat_busy
  8683 0000701D E83CAF              <1> 	call	wait_for_port		; wait for printer to be ready
  8684 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  8685                              <1> 
  8686                              <1> .not_busy:
  8687 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  8688                              <1> 					; OPTIMIZATION:
  8689                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  8690 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  8691 00007025 EE                  <1> 	out	dx,al			; activate strobe
  8692 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  8693 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  8694 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  8695 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  8696 0000702E EBD2                <1> 	jmp	int_17_exit
  8697                              <1> 
  8698                              <1> .timeout:
  8699 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  8700 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  8701 00007036 EBCA                <1> 	jmp	int_17_exit
  8702                              <1> 
  8703                              <1> ;=========================================================================
  8704                              <1> ; int_17_fn02 - Return printer status
  8705                              <1> ; Input:
  8706                              <1> ;	AH = 2 - function 02h - return printer status
  8707                              <1> ;	DX = printer port number (0-2)
  8708                              <1> ; Output:
  8709                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  8710                              <1> ;-------------------------------------------------------------------------
  8711                              <1> int_17_fn02:
  8712 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8713                              <1> 					; OPTIMIZATION:
  8714                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8715                              <1> int_17_status:
  8716 00007039 EC                  <1> 	in	al,dx			; read the status
  8717 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  8718 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  8719 0000703F EBC1                <1> 	jmp	int_17_exit
  8720                                  %include	"video.inc"		; INT 10
  8721                              <1> ;=========================================================================
  8722                              <1> ; video.inc - BIOS video services
  8723                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  8724                              <1> ;-------------------------------------------------------------------------
  8725                              <1> ;
  8726                              <1> ; Compiles with NASM 2.07, might work with other versions
  8727                              <1> ;
  8728                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  8729                              <1> ;
  8730                              <1> ; This program is free software: you can redistribute it and/or modify
  8731                              <1> ; it under the terms of the GNU General Public License as published by
  8732                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8733                              <1> ; (at your option) any later version.
  8734                              <1> ;
  8735                              <1> ; This program is distributed in the hope that it will be useful,
  8736                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8737                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8738                              <1> ; GNU General Public License for more details.
  8739                              <1> ;
  8740                              <1> ; You should have received a copy of the GNU General Public License
  8741                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8742                              <1> ;
  8743                              <1> ;=========================================================================
  8744                              <1> 
  8745                              <1> ;-------------------------------------------------------------------------
  8746                              <1> ; CRTC registers
  8747                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  8748                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  8749                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  8750                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  8751                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  8752                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  8753                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  8754                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  8755                              <1> 
  8756                              <1> ;-------------------------------------------------------------------------
  8757                              <1> ; control characters
  8758                              <1> bel	equ	07h
  8759                              <1> bs	equ	08h
  8760                              <1> lf	equ	0Ah
  8761                              <1> cr	equ	0Dh
  8762                              <1> 
  8763 00007041 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  8764          ******************  <1>  warning: (setloc:7) Inserting 4 bytes
  8765                              <1> 
  8766                              <1> int_10_dispatch:
  8767 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
  8768 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  8769 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
  8770 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  8771 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
  8772 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
  8773 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
  8774 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
  8775 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
  8776 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
  8777 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
  8778 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
  8779 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  8780 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  8781 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
  8782 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
  8783                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  8784                              <1> 
  8785                              <1> 
  8786                              <1> ;-------------------------------------------------------------------------
  8787                              <1> ; offsets for registers on stack
  8788                              <1> 
  8789                              <1> int_10_ax	equ	0
  8790                              <1> int_10_al	equ	int_10_ax
  8791                              <1> int_10_ah	equ	int_10_ax+1
  8792                              <1> int_10_bx	equ	int_10_ax+2
  8793                              <1> int_10_bl	equ	int_10_bx
  8794                              <1> int_10_bh	equ	int_10_bx+1
  8795                              <1> int_10_cx	equ	int_10_bx+2
  8796                              <1> int_10_ch	equ	int_10_cx+1
  8797                              <1> int_10_dx	equ	int_10_cx+2
  8798                              <1> 
  8799                              <1> ;=========================================================================
  8800                              <1> ; int_10 - BIOS video services
  8801                              <1> ; Input:
  8802                              <1> ;	AH - Function
  8803                              <1> ;		00h - Set video mode
  8804                              <1> ;		01h - Set text mode cursor shape
  8805                              <1> ;		02h - Set cursor position
  8806                              <1> ;		03h - Get cursor position and shape
  8807                              <1> ;		04h - Read light pen position
  8808                              <1> ;		05h - Select active display page
  8809                              <1> ;		06h - Scroll up window
  8810                              <1> ;		07h - Scroll down window
  8811                              <1> ;		08h - Read character and attribute at cursor position
  8812                              <1> ;		09h - Write character and attribute at cursor position
  8813                              <1> ;		0Ah - Write character only at cursor position
  8814                              <1> ;		0Bh -
  8815                              <1> ;			BH = 00h - Set background/border color
  8816                              <1> ;			BH = 01h - Set palette
  8817                              <1> ;		0Ch - Write graphics pixel
  8818                              <1> ;		0Dh - Read graphics pixel
  8819                              <1> ;		0Eh - Teletype output
  8820                              <1> ;		0Fh - Get current video mode
  8821                              <1> ;-------------------------------------------------------------------------
  8822                              <1> 	setloc	0F065h			; int 10 Entry Point
  8823                              <1> int_10:
  8824 00007065 FB                  <1> 	sti
  8825 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  8826 00007067 55                  <1> 	push	bp
  8827 00007068 06                  <1> 	push	es
  8828 00007069 1E                  <1> 	push	ds
  8829 0000706A 56                  <1> 	push	si
  8830 0000706B 57                  <1> 	push	di
  8831 0000706C 52                  <1> 	push	dx
  8832 0000706D 51                  <1> 	push	cx
  8833 0000706E 53                  <1> 	push	bx
  8834 0000706F 50                  <1> 	push	ax
  8835 00007070 BB4000              <1> 	mov	bx,biosdseg
  8836 00007073 8EDB                <1> 	mov	ds,bx
  8837 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  8838 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  8839 0000707C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  8840 0000707F 7202                <1> 	jb	.color			; it is CGA
  8841 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  8842                              <1> 
  8843                              <1> .color:
  8844 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  8845 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  8846 00007087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  8847 0000708A 730B                <1> 	jae	.exit			; invalid function
  8848 0000708C B700                <1> 	mov	bh,0
  8849 0000708E 88E3                <1> 	mov	bl,ah
  8850 00007090 D1E3                <1> 	shl	bx,1
  8851 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  8852                              <1> 
  8853                              <1> .exit:
  8854 00007097 58                  <1> 	pop	ax
  8855 00007098 5B                  <1> 	pop	bx
  8856 00007099 59                  <1> 	pop	cx
  8857 0000709A 5A                  <1> 	pop	dx
  8858 0000709B 5F                  <1> 	pop	di
  8859 0000709C 5E                  <1> 	pop	si
  8860 0000709D 1F                  <1> 	pop	ds
  8861 0000709E 07                  <1> 	pop	es
  8862 0000709F 5D                  <1> 	pop	bp
  8863 000070A0 CF                  <1> 	iret
  8864                              <1> 
  8865                              <1> 
  8866                              <1> ;=========================================================================
  8867                              <1> ; int_1D - Video parameters tables
  8868                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  8869                              <1> ; video mode initialization
  8870                              <1> ;-------------------------------------------------------------------------
  8871 000070A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  8872          ******************  <1>  warning: (setloc:7) Inserting 3 bytes
  8873                              <1> int_1D:
  8874                              <1> 	; CGA test 40x25 modes
  8875 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  8876 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8877                              <1> 
  8878                              <1> 	; CGA text 80x25 modes
  8879 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  8880 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8881                              <1> 
  8882                              <1> 	; CGA graphics modes
  8883 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  8884 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  8885                              <1> 
  8886                              <1> 	; MDA text 80x25 mode
  8887 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  8888 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  8889                              <1> 
  8890                              <1> page_size:
  8891 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  8892 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  8893 000070E8 0040                <1> 	dw	4000h			; graphics modes
  8894 000070EA 0040                <1> 	dw	4000h
  8895                              <1> 
  8896                              <1> columns:
  8897 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  8898 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  8899 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  8900 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  8901                              <1> 
  8902 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  8903                              <1> 
  8904 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  8905                              <1> 
  8906                              <1> ;=========================================================================
  8907                              <1> ; int_10_fn00 - Set video mode
  8908                              <1> ; Input:
  8909                              <1> ;	AH = 00h
  8910                              <1> ;	AL = video mode
  8911                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  8912                              <1> ;		01h - CGA - text 40x25, 16 colors
  8913                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  8914                              <1> ;		03h - CGA - text 80x25, 16 colors
  8915                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  8916                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  8917                              <1> ;		06h - CGA - graphics 640x200, monochrome
  8918                              <1> ;		07h - MDA - text 80x25, monochrome
  8919                              <1> ;-------------------------------------------------------------------------
  8920                              <1> int_10_fn00:
  8921 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  8922 00007107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  8923 0000710A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  8924 0000710D B000                <1> 	mov	al,0
  8925 0000710F 80FB07              <1> 	cmp	bl,07h
  8926 00007112 7206                <1> 	jb	.color			; jump if monochrome mode
  8927 00007114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  8928 00007116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  8929 00007118 FEC0                <1> 	inc	al
  8930                              <1> 
  8931                              <1> .color:
  8932 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  8933 0000711C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  8934 00007120 80C204              <1> 	add	dl,4
  8935 00007123 EE                  <1> 	out	dx,al			; Reset the video
  8936 00007124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  8937 00007128 B700                <1> 	mov	bh,0
  8938 0000712A 53                  <1> 	push	bx
  8939 0000712B 06                  <1> 	push	es
  8940 0000712C 31C0                <1> 	xor	ax,ax
  8941 0000712E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  8942 00007130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  8943 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  8944 0000713A 01DE                <1> 	add	si,bx
  8945                              <1> 
  8946 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  8947 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  8948 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  8949                              <1> 
  8950 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  8951                              <1> 
  8952                              <1> .setup_crt_loop:
  8953 00007149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  8954 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  8955 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  8956 00007151 46                  <1> 	inc	si			;  ...point to next
  8957 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  8958 00007154 07                  <1> 	pop	es
  8959 00007155 31FF                <1> 	xor	di,di
  8960 00007157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  8961 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  8962 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  8963 0000715F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  8964 00007161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  8965 00007163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  8966                              <1> 
  8967                              <1> .text_fill:
  8968 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  8969                              <1> 
  8970                              <1> .clear_screen:
  8971 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  8972                              <1> 
  8973 0000716B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  8974 0000716F 80C204              <1> 	add	dl,4
  8975 00007172 5B                  <1> 	pop	bx
  8976 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  8977 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  8978 00007179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  8979 0000717C 42                  <1> 	inc	dx
  8980 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  8981 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  8982 00007182 7502                <1> 	jnz	.set_palette
  8983 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  8984                              <1> 
  8985                              <1> .set_palette:
  8986 00007186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  8987 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  8988                              <1> 
  8989 0000718A 8CD8                <1> 	mov	ax,ds
  8990 0000718C 8EC0                <1> 	mov	es,ax
  8991 0000718E 31C0                <1> 	xor	ax,ax
  8992 00007190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  8993 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  8994 00007196 BF4E00              <1> 	mov	di,video_page_offt
  8995 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  8996                              <1> 
  8997 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  8998 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  8999 000071A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  9000                              <1> 					; but it means that for mode 7
  9001                              <1> 					; we'll get graphics page size?!
  9002 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  9003 000071AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  9004 000071AE C3                  <1> 	ret
  9005                              <1> 
  9006                              <1> ;=========================================================================
  9007                              <1> ; int_10_fn01 - Set text-mode cursor shape
  9008                              <1> ; Input:
  9009                              <1> ;	AH = 01h
  9010                              <1> ;	CH = cursor scan line start
  9011                              <1> ;	CL = cursor scan line end
  9012                              <1> ; Output:
  9013                              <1> ;	none
  9014                              <1> ;-------------------------------------------------------------------------
  9015                              <1> int_10_fn01:
  9016 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  9017 000071B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  9018 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  9019 000071B8 C3                  <1> 	ret
  9020                              <1> 
  9021                              <1> ;=========================================================================
  9022                              <1> ; int_10_fn02 - Set cursor position
  9023                              <1> ; Input:
  9024                              <1> ;	AH = 02h
  9025                              <1> ;	BH = page number
  9026                              <1> ;	DH = cursor row (00h is top)
  9027                              <1> ;	DL = cursor column (00h is left)
  9028                              <1> ; Output:
  9029                              <1> ;	none
  9030                              <1> ;-------------------------------------------------------------------------
  9031                              <1> int_10_fn02:
  9032 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9033 000071BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  9034 000071C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  9035                              <1> 
  9036                              <1> ;=========================================================================
  9037                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  9038                              <1> ;	BL = page
  9039                              <1> ;	DH = cursor row (00h is top)
  9040                              <1> ;	DL = cursor column (00h is left)
  9041                              <1> ;-------------------------------------------------------------------------
  9042                              <1> set_cur_pos:
  9043 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  9044 000071C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  9045 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  9046 000071CB D1E8                <1> 	shr	ax,1
  9047 000071CD 89C1                <1> 	mov	cx,ax
  9048 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9049 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9050                              <1> bios_set_cur_pos:
  9051 000071D4 B700                <1> 	mov	bh,0
  9052 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  9053 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  9054 000071DB C3                  <1> 	ret
  9055                              <1> 
  9056                              <1> ;=========================================================================
  9057                              <1> ; int_10_fn03 - Get cursor position and shape
  9058                              <1> ; Input:
  9059                              <1> ;	AH = 03h
  9060                              <1> ;	BH = page number
  9061                              <1> ; Output:
  9062                              <1> ;	CH = cursor start scan line
  9063                              <1> ;	CL = cursor end scan line
  9064                              <1> ;	DH = cursor row (00h is top)
  9065                              <1> ;	DL = cursor column (00h is left)
  9066                              <1> ;-------------------------------------------------------------------------
  9067                              <1> int_10_fn03:
  9068 000071DC B700                <1> 	mov	bh,0
  9069 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9070 000071E1 D0E3                <1> 	shl	bl,1
  9071 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  9072 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  9073 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  9074 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  9075 000071EF C3                  <1> 	ret
  9076                              <1> 
  9077                              <1> ;=========================================================================
  9078                              <1> ; int_10_fn04 - Read light pen position
  9079                              <1> ; Input:
  9080                              <1> ;	AH = 04h
  9081                              <1> ; Output:
  9082                              <1> ;	AH - light pen trigger flag
  9083                              <1> ;		00h not down/triggered
  9084                              <1> ;		01h down/triggered
  9085                              <1> ;	If light pen is triggered:
  9086                              <1> ;		DH = character row
  9087                              <1> ;		DL = character column
  9088                              <1> ;		CH = pixel row
  9089                              <1> ;		BX = pixel column
  9090                              <1> ;-------------------------------------------------------------------------
  9091                              <1> int_10_fn04:
  9092 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  9093 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  9094 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  9095 000071FB EC                  <1> 	in	al,dx			; read it
  9096 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  9097 000071FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  9098 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  9099 00007202 7501                <1> 	jnz	.read_pen		; continue if triggered
  9100 00007204 C3                  <1> 	ret				; not triggered - return
  9101                              <1> 
  9102                              <1> .read_pen:
  9103 00007205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  9104 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  9105 0000720B EE                  <1> 	out	dx,al			; select it
  9106 0000720C 42                  <1> 	inc	dx			; CRTC data register
  9107 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  9108 0000720E 88C4                <1> 	mov	ah,al
  9109 00007210 4A                  <1> 	dec	dx			; CRTC index register
  9110 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  9111 00007213 EE                  <1> 	out	dx,al			; select it
  9112 00007214 42                  <1> 	inc	dx			; CRTC data register
  9113 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  9114                              <1> 
  9115 00007216 B700                <1> 	mov	bh,0
  9116 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  9117 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  9118 00007221 29D8                <1> 	sub	ax,bx
  9119 00007223 7902                <1> 	jns	.1
  9120 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  9121                              <1> 
  9122                              <1> .1:
  9123 00007227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  9124 0000722A 7325                <1> 	jnb	.text			; calculate character position if text
  9125 0000722C B228                <1> 	mov	dl,40			; divide by 40
  9126 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  9127 00007230 B700                <1> 	mov	bh,0
  9128 00007232 88E3                <1> 	mov	bl,ah
  9129 00007234 B103                <1> 	mov	cl,3
  9130 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  9131 00007238 88C5                <1> 	mov	ch,al
  9132 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  9133 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  9134 0000723E 88C6                <1> 	mov	dh,al
  9135 00007240 D0EE                <1> 	shr	dh,1
  9136 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  9137 00007244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  9138 00007249 751A                <1> 	jnz	.exit
  9139 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  9140 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  9141 0000724F EB14                <1> 	jmp	.exit
  9142                              <1> 
  9143                              <1> .text:
  9144 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  9145 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  9146 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  9147 00007259 B103                <1> 	mov	cl,3
  9148 0000725B D2E4                <1> 	shl	ah,cl
  9149 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  9150 0000725F B700                <1> 	mov	bh,0
  9151 00007261 88C3                <1> 	mov	bl,al
  9152 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  9153                              <1> 
  9154                              <1> .exit:
  9155 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  9156 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  9157 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  9158 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  9159                              <1> 
  9160                              <1> .reset_pen:
  9161 00007272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  9162 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  9163 00007279 EE                  <1> 	out	dx,al			; reset it
  9164 0000727A C3                  <1> 	ret
  9165                              <1> 
  9166                              <1> .correction:
  9167 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  9168                              <1> 
  9169                              <1> ;=========================================================================
  9170                              <1> ; int_10_fn05 - Select active display page
  9171                              <1> ; Input:
  9172                              <1> ;	AH = 05h
  9173                              <1> ;	AL - new page number (00h is the first page)
  9174                              <1> ; Output:
  9175                              <1> ;	none
  9176                              <1> ;-------------------------------------------------------------------------
  9177                              <1> int_10_fn05:
  9178 00007283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  9179 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  9180 00007288 B400                <1> 	mov	ah,0
  9181 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  9182 0000728E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  9183 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  9184 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  9185 00007295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  9186 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  9187                              <1> 
  9188 0000729A B700                <1> 	mov	bh,0
  9189 0000729C D1E3                <1> 	shl	bx,1
  9190 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  9191 000072A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  9192 000072A4 D1E8                <1> 	shr	ax,1
  9193 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  9194 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9195 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9196 000072AD C3                  <1> 	ret
  9197                              <1> 
  9198                              <1> ;=========================================================================
  9199                              <1> ; int_10_fn06 - scroll up window
  9200                              <1> ; int_10_fn07 - scroll down window
  9201                              <1> ; Input:
  9202                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  9203                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  9204                              <1> ;	BH = attribute used to write blank rows at bottom of window
  9205                              <1> ;	CH,CL = row,column of window's upper left corner
  9206                              <1> ;	DH,DL = row,column of window's lower right corner
  9207                              <1> ; Output:
  9208                              <1> ;	none
  9209                              <1> ; TODO:
  9210                              <1> ;	optimize graphics fill
  9211                              <1> ;-------------------------------------------------------------------------
  9212                              <1> int_10_fn06:
  9213                              <1> int_10_fn07:
  9214 000072AE E86604              <1> 	call	vid_check_mode
  9215 000072B1 7303E9D900          <1> 	jb	.graphics_scroll
  9216                              <1> 
  9217 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  9218 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  9219 000072BD 720A                <1> 	jb	.no_snow
  9220 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  9221 000072C4 7703                <1> 	ja	.no_snow
  9222 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  9223                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  9224                              <1> .no_snow:
  9225 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9226 000072CC 50                  <1> 	push	ax
  9227 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  9228 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  9229 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9230                              <1> 
  9231                              <1> .1:
  9232 000072D6 E89804              <1> 	call	vid_position_to_offset
  9233 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  9234 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9235                              <1> 
  9236                              <1> ; calculate scroll window size (DX)
  9237                              <1> 
  9238 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9239 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  9240 000072E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  9241                              <1> 
  9242                              <1> ; calculate offset between the source and the destination (AX)
  9243                              <1> 
  9244 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  9245 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  9246 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  9247 000072F0 52                  <1> 	push    dx
  9248 000072F1 B400                <1>         mov     ah,0
  9249 000072F3 F7E3                <1>         mul     bx
  9250 000072F5 5A                  <1>         pop     dx
  9251                              <1> 
  9252 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  9253 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  9254 000072FA 1E                  <1> 	push	ds
  9255 000072FB 8CC1                <1> 	mov	cx,es
  9256 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9257 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9258 00007303 7405                <1> 	jz	.2			; jump if scroll up
  9259 00007305 F7D8                <1> 	neg	ax			; negate offset
  9260 00007307 F7DB                <1> 	neg	bx			; negate distance
  9261 00007309 FD                  <1> 	std				; copy backwards
  9262                              <1> 
  9263                              <1> .2:
  9264 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  9265 0000730D 08C9                <1> 	or	cl,cl
  9266 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  9267 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  9268 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  9269 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  9270                              <1> 
  9271 00007316 09DB                <1> 	or	bx,bx
  9272 00007318 7434                <1> 	jz	.text_full_row_scroll
  9273                              <1> 
  9274                              <1> .text_scroll_loop:
  9275 0000731A B500                <1> 	mov	ch,0
  9276 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  9277                              <1> 
  9278 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  9279 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  9280 00007322 E85800              <1> 	call	.retrace_wait
  9281                              <1> 
  9282                              <1> .text_scroll_no_retrace:
  9283 00007325 F3A5                <1> 	repz	movsw			; copy one row
  9284                              <1> 
  9285                              <1> ;.text_scroll_next_row:
  9286 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  9287 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  9288 0000732B FECE                <1> 	dec	dh			; decrement row counter
  9289 0000732D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  9290                              <1> 
  9291                              <1> .text_fill:
  9292 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  9293 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  9294                              <1> 
  9295                              <1> .text_fill_only:
  9296 00007334 B500                <1> 	mov	ch,0
  9297 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  9298 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  9299                              <1> 
  9300                              <1> .text_fill_loop:
  9301 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  9302 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  9303 0000733F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  9304 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  9305                              <1> 
  9306                              <1> .text_fill_no_retrace:
  9307 00007344 F3AB                <1> 	repz	stosw			; fill one row
  9308 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  9309 00007348 FECE                <1> 	dec	dh			; decrement row counter
  9310 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  9311                              <1> 
  9312 0000734C 1F                  <1> 	pop	ds
  9313 0000734D C3                  <1> 	ret
  9314                              <1> 
  9315                              <1> .text_full_row_scroll:
  9316 0000734E 09C0                <1> 	or	ax,ax
  9317 00007350 741F                <1> 	jz	.text_full_row_no_snow
  9318 00007352 50                  <1> 	push	ax
  9319 00007353 88D0                <1> 	mov	al,dl
  9320 00007355 F6E6                <1> 	mul	dh
  9321                              <1> 
  9322                              <1> .text_full_row_loop:
  9323 00007357 B9F000              <1> 	mov	cx,240
  9324 0000735A 39C8                <1> 	cmp	ax,cx
  9325 0000735C 7705                <1> 	ja	.copy_chunk
  9326 0000735E 91                  <1> 	xchg	ax,cx
  9327 0000735F 31C0                <1> 	xor	ax,ax
  9328 00007361 EB02                <1> 	jmp	.do_copy
  9329                              <1> 
  9330                              <1> .copy_chunk:
  9331 00007363 29C8                <1> 	sub	ax,cx
  9332                              <1> 
  9333                              <1> .do_copy:
  9334 00007365 E81500              <1> 	call	.retrace_wait
  9335 00007368 F3A5                <1> 	rep	movsw
  9336 0000736A 09C0                <1> 	or	ax,ax
  9337 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  9338 0000736E 58                  <1> 	pop	ax
  9339 0000736F EBBE                <1> 	jmp	.text_fill
  9340                              <1> 
  9341                              <1> .text_full_row_no_snow:
  9342 00007371 50                  <1> 	push	ax
  9343 00007372 88D0                <1> 	mov	al,dl
  9344 00007374 F6E6                <1> 	mul	dh
  9345 00007376 89C1                <1> 	mov	cx,ax
  9346 00007378 F3A5                <1> 	rep	movsw
  9347 0000737A 58                  <1> 	pop	ax
  9348 0000737B EBB2                <1> 	jmp	.text_fill
  9349                              <1> 
  9350                              <1> ;-------------------------------------------------------------------------
  9351                              <1> ; .retrace_wait - next till the next vertical retrace
  9352                              <1> 
  9353                              <1> .retrace_wait:
  9354 0000737D 50                  <1> 	push	ax
  9355 0000737E 52                  <1> 	push	dx
  9356 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  9357                              <1> 
  9358                              <1> .retrace_wait_not_set:
  9359 00007382 EC                  <1> 	in	al,dx
  9360 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9361 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  9362                              <1> 
  9363                              <1> .retrace_wait_set:
  9364 00007387 EC                  <1> 	in	al,dx
  9365 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9366 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  9367 0000738C 5A                  <1> 	pop	dx
  9368 0000738D 58                  <1> 	pop	ax
  9369                              <1> 
  9370                              <1> .retrace_exit:
  9371 0000738E C3                  <1> 	ret
  9372                              <1> 
  9373                              <1> ;-------------------------------------------------------------------------
  9374                              <1> ; .graphics_scroll - scroll for graphics modes
  9375                              <1> 
  9376                              <1> .graphics_scroll:
  9377 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9378 00007392 50                  <1> 	push	ax
  9379 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  9380 00007397 7403                <1> 	jz	.3			; jump if scroll down
  9381 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9382                              <1> 
  9383                              <1> .3:
  9384 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  9385 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9386                              <1> 
  9387                              <1> ; calculate scroll windows size (DX)
  9388                              <1> 
  9389 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9390 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  9391 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  9392 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  9393 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  9394 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9395 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  9396 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  9397 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  9398 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  9399 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9400 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  9401 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  9402                              <1> 
  9403                              <1> .4:
  9404 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9405 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  9406 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  9407                              <1> 					;   for copying backwards
  9408                              <1> 
  9409                              <1> .5:
  9410 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  9411 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  9412 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  9413 000073CF 53                  <1> 	push	bx
  9414 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  9415 000073D2 B050                <1> 	mov	al,50h
  9416 000073D4 F6E3                <1> 	mul	bl
  9417 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  9418 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9419 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  9420 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  9421 000073E1 BB5020              <1> 	mov	bx,2050h
  9422 000073E4 FD                  <1> 	std				; copy backwards
  9423                              <1> 
  9424                              <1> .6:
  9425 000073E5 89FE                <1> 	mov	si,di
  9426 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  9427 000073E9 58                  <1> 	pop	ax
  9428 000073EA 8CC1                <1> 	mov	cx,es
  9429 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9430 000073EE 08C0                <1> 	or	al,al
  9431 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  9432 000073F2 50                  <1> 	push	ax
  9433                              <1> 
  9434                              <1> .graphics_scroll_loop:
  9435 000073F3 B500                <1> 	mov	ch,0
  9436 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9437 000073F7 56                  <1> 	push	si
  9438 000073F8 57                  <1> 	push	di
  9439 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  9440 000073FB 5F                  <1> 	pop	di
  9441 000073FC 5E                  <1> 	pop	si
  9442 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  9443 00007401 81C70020            <1> 	add	di,2000h
  9444 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9445 00007407 56                  <1> 	push	si
  9446 00007408 57                  <1> 	push	di
  9447 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  9448 0000740B 5F                  <1> 	pop	di
  9449 0000740C 5E                  <1> 	pop	si
  9450 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  9451 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  9452 00007411 FECE                <1> 	dec	dh			; decrement row counter
  9453 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  9454                              <1> 
  9455 00007415 58                  <1> 	pop	ax
  9456 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  9457                              <1> 
  9458                              <1> .graphics_fill:
  9459 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  9460 0000741B B500                <1> 	mov	ch,0
  9461                              <1> 
  9462                              <1> .graphics_fill_loop:
  9463 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9464 0000741F 57                  <1> 	push	di
  9465 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  9466 00007422 5F                  <1> 	pop	di
  9467 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  9468 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9469 00007429 57                  <1> 	push	di
  9470 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  9471 0000742C 5F                  <1> 	pop	di
  9472 0000742D 29DF                <1> 	sub	di,bx
  9473 0000742F FECE                <1> 	dec	dh			; decrement row counter
  9474 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  9475 00007433 C3                  <1> 	ret
  9476                              <1> 
  9477                              <1> ;=========================================================================
  9478                              <1> ; int_10_fn08 - Read character and attribute
  9479                              <1> ; Input:
  9480                              <1> ;	AH = 08h
  9481                              <1> ; Output:
  9482                              <1> ;	AL - character read
  9483                              <1> ;	BH - video attribute (text modes only)
  9484                              <1> ; int_10_fn09 - Write character and attribute
  9485                              <1> ; Input:
  9486                              <1> ;	AH = 09h
  9487                              <1> ;	AL - character to write
  9488                              <1> ;	BH - page number
  9489                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  9490                              <1> ;	CX - number of times to write character
  9491                              <1> ; Output:
  9492                              <1> ;	none
  9493                              <1> ; int_10_fn0A - Write character only
  9494                              <1> ; Input:
  9495                              <1> ;	AH = 0Ah
  9496                              <1> ;	AL - character to write
  9497                              <1> ;	BH - page number
  9498                              <1> ;	CX - repeat count
  9499                              <1> ; Output:
  9500                              <1> ;	none
  9501                              <1> ;-------------------------------------------------------------------------
  9502                              <1> int_10_fn08:
  9503                              <1> int_10_fn09:
  9504                              <1> int_10_fn0A:
  9505 00007434 E8E002              <1> 	call	vid_check_mode
  9506 00007437 7277                <1> 	jb	.graphics		; jump if graphics mode
  9507 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9508 0000743C B700                <1> 	mov	bh,0
  9509 0000743E 53                  <1> 	push	bx
  9510 0000743F E82803              <1> 	call	vid_current_offset
  9511 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  9512 00007444 58                  <1> 	pop	ax			; AX = page number
  9513 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  9514 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  9515 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  9516 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  9517 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  9518 00007454 1E                  <1> 	push	ds
  9519 00007455 8CC3                <1> 	mov	bx,es
  9520 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  9521 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9522 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  9523 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  9524                              <1> 
  9525                              <1> .read_retrace_wait:
  9526 00007460 EC                  <1> 	in	al,dx
  9527 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9528 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  9529 00007465 FA                  <1> 	cli
  9530                              <1> 
  9531                              <1> .read_no_retrace_wait:
  9532 00007466 EC                  <1> 	in	al,dx
  9533 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9534 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  9535                              <1> 
  9536 0000746B AD                  <1> 	lodsw				; read character and attribute
  9537 0000746C FB                  <1> 	sti
  9538 0000746D 1F                  <1> 	pop	ds
  9539 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  9540 00007471 C3                  <1> 	ret
  9541                              <1> 
  9542                              <1> .text_write:
  9543 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  9544 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  9545 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  9546 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  9547 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  9548                              <1> 
  9549                              <1> .write_char_retrace:
  9550 0000747F EC                  <1> 	in	al,dx
  9551 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9552 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  9553                              <1> 
  9554                              <1> .write_retrace_wait1:
  9555 00007484 EC                  <1> 	in	al,dx
  9556 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9557 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  9558 00007489 FA                  <1> 	cli
  9559                              <1> 
  9560                              <1> .write_no_retrace_wait1:
  9561 0000748A EC                  <1> 	in	al,dx
  9562 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9563 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  9564                              <1> 
  9565                              <1> .do_write_char_attr:
  9566 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  9567 00007491 AB                  <1> 	stosw				; write it to video memory
  9568 00007492 FB                  <1> 	sti
  9569 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  9570 00007495 1F                  <1> 	pop	ds
  9571 00007496 C3                  <1> 	ret
  9572                              <1> 
  9573                              <1> .text_write_char_only:
  9574 00007497 EC                  <1> 	in	al,dx
  9575 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9576 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  9577                              <1> 
  9578                              <1> .write_retrace_wait2:
  9579 0000749C EC                  <1> 	in	al,dx
  9580 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9581 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  9582 000074A1 FA                  <1> 	cli
  9583                              <1> 
  9584                              <1> .write_no_retrace_wait2:
  9585 000074A2 EC                  <1> 	in	al,dx
  9586 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9587 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  9588                              <1> 
  9589                              <1> .do_write_char_only:
  9590 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  9591 000074A9 AA                  <1> 	stosb				; write it to video memory
  9592 000074AA FB                  <1> 	sti
  9593 000074AB 47                  <1> 	inc	di			; skip attribute
  9594 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  9595 000074AE 1F                  <1> 	pop	ds
  9596 000074AF C3                  <1> 	ret
  9597                              <1> 
  9598                              <1> .graphics:
  9599 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  9600 000074B4 7503E9B300          <1> 	jz	.graphics_read
  9601                              <1> 
  9602 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  9603 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  9604 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  9605 000074C1 1E                  <1> 	push	ds
  9606 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  9607 000074C5 B400                <1> 	mov	ah,0
  9608 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  9609 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  9610 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  9611 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  9612 000074D0 EB0C                <1> 	jmp	.CG9_03
  9613                              <1> 
  9614                              <1> .CG9_02:
  9615 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  9616 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  9617 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  9618 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  9619 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  9620                              <1> 
  9621                              <1> .CG9_03:
  9622 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  9623 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  9624 000074E1 D3E0                <1> 	shl	ax,cl
  9625 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  9626 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  9627 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  9628 000074ED 1E                  <1> 	push	ds
  9629 000074EE 8EDA                <1> 	mov	ds,dx
  9630 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  9631 000074F2 D1E7                <1> 	shl	di,1
  9632 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  9633 000074F7 83E003              <1> 	and	ax,3
  9634 000074FA BB5555              <1> 	mov	bx,5555h
  9635 000074FD F7E3                <1> 	mul	bx
  9636 000074FF 89C2                <1> 	mov	dx,ax
  9637 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  9638                              <1> 
  9639                              <1> .CG9_04:
  9640 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  9641 00007506 57                  <1> 	push	di
  9642 00007507 56                  <1> 	push	si
  9643                              <1> 
  9644                              <1> .CG9_05:
  9645 00007508 AC                  <1> 	lodsb				; Read the screen
  9646 00007509 51                  <1> 	push	cx
  9647 0000750A 53                  <1> 	push	bx
  9648 0000750B 31DB                <1> 	xor	bx,bx
  9649 0000750D B90800              <1> 	mov	cx,8
  9650                              <1> 
  9651                              <1> .CG9_06:
  9652 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  9653 00007512 D1DB                <1> 	rcr	bx,1
  9654 00007514 D1FB                <1> 	sar	bx,1
  9655 00007516 E2F8                <1> 	loop	.CG9_06
  9656                              <1> 
  9657 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  9658 0000751A 5B                  <1> 	pop	bx
  9659 0000751B 59                  <1> 	pop	cx
  9660 0000751C 21D0                <1> 	and	ax,dx
  9661 0000751E 86E0                <1> 	xchg	ah,al
  9662 00007520 08DB                <1> 	or	bl,bl
  9663 00007522 7903                <1> 	jns	.CG9_07
  9664 00007524 263305              <1>     es	xor	ax,word [di]
  9665                              <1> 
  9666                              <1> .CG9_07:
  9667 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  9668 0000752A 81F70020            <1> 	xor	di,2000h
  9669 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  9670 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  9671 00007534 83C750              <1> 	add	di,50h			; Else advance character
  9672                              <1> 
  9673                              <1> .CG9_08:
  9674 00007537 FECF                <1> 	dec	bh			; Show another char written
  9675 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  9676 0000753B 5E                  <1> 	pop	si
  9677 0000753C 5F                  <1> 	pop	di
  9678 0000753D 47                  <1> 	inc	di
  9679 0000753E 47                  <1> 	inc	di
  9680 0000753F E2C3                <1> 	loop	.CG9_04
  9681 00007541 1F                  <1> 	pop	ds
  9682 00007542 C3                  <1> 	ret
  9683                              <1> 
  9684                              <1> .CG8_02:
  9685 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  9686 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  9687                              <1> 
  9688                              <1> .CG8_03:
  9689 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  9690 0000754B 57                  <1> 	push	di
  9691 0000754C 56                  <1> 	push	si
  9692                              <1> 
  9693                              <1> .CG8_04:
  9694 0000754D AC                  <1> 	lodsb				; Read from one plane
  9695 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  9696 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  9697 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  9698                              <1> 
  9699                              <1> .CG8_05:
  9700 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  9701 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  9702 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  9703 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  9704 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  9705                              <1> 
  9706                              <1> .CG8_06:
  9707 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  9708 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  9709 00007565 5E                  <1> 	pop	si
  9710 00007566 5F                  <1> 	pop	di
  9711 00007567 47                  <1> 	inc	di
  9712 00007568 E2DF                <1> 	loop	.CG8_03
  9713 0000756A 1F                  <1> 	pop	ds
  9714 0000756B C3                  <1> 	ret
  9715                              <1> 
  9716                              <1> .graphics_read:
  9717 0000756C FC                  <1> 	cld				; Increment upwards
  9718 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  9719 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  9720 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  9721 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  9722 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  9723 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  9724 0000757F 8CC0                <1> 	mov	ax,es
  9725 00007581 1E                  <1> 	push	ds
  9726 00007582 57                  <1> 	push	di
  9727 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  9728 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  9729 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  9730 00007589 D1E6                <1> 	shl	si,1
  9731 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  9732                              <1> 
  9733                              <1> CGR_02:
  9734 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  9735 00007590 86E0                <1> 	xchg	ah,al
  9736 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  9737 00007595 B200                <1> 	mov	dl,0
  9738                              <1> 
  9739                              <1> CGR_03:
  9740 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  9741 00007599 F8                  <1> 	clc
  9742 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  9743 0000759C F9                  <1> 	stc				; Else show not set
  9744                              <1> 
  9745                              <1> CGR_04:
  9746 0000759D D0D2                <1> 	rcl	dl,1
  9747 0000759F D1E9                <1> 	shr	cx,1
  9748 000075A1 D1E9                <1> 	shr	cx,1
  9749 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  9750 000075A5 368815              <1>     ss	mov	byte [di],dl
  9751 000075A8 47                  <1> 	inc	di
  9752 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  9753 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  9754 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  9755 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  9756                              <1> 
  9757                              <1> CGR_05:
  9758 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  9759 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  9760 000075B6 EB17                <1> 	jmp	short	CGR_08
  9761                              <1> 
  9762                              <1> CGR_06:
  9763 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  9764                              <1> 
  9765                              <1> CGR_07:
  9766 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  9767 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  9768 000075BF 47                  <1> 	inc	di			;  ...advance
  9769 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  9770 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  9771 000075C7 47                  <1> 	inc	di			;  ...advance
  9772 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  9773 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  9774 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  9775                              <1> 
  9776                              <1> CGR_08:
  9777 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  9778 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  9779 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  9780 000075D6 8CD2                <1> 	mov	dx,ss
  9781 000075D8 8EDA                <1> 	mov	ds,dx
  9782 000075DA 5E                  <1> 	pop	si
  9783 000075DB B000                <1> 	mov	al,0
  9784                              <1> 
  9785                              <1> CGR_09:
  9786 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  9787                              <1> 
  9788                              <1> CGR_10:
  9789 000075E0 56                  <1> 	push	si
  9790 000075E1 57                  <1> 	push	di
  9791 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  9792 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  9793 000075E7 5F                  <1> 	pop	di
  9794 000075E8 5E                  <1> 	pop	si
  9795 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  9796 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  9797 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  9798 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  9799 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  9800                              <1> 
  9801 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  9802 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  9803 000075F7 31DB                <1> 	xor	bx,bx
  9804 000075F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  9805 000075FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  9806 000075FF 8CC3                <1> 	mov	bx,es
  9807 00007601 09FB                <1> 	or	bx,di
  9808 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  9809 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  9810                              <1> 
  9811                              <1> CGR_11:
  9812 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  9813 0000760A 1F                  <1> 	pop	ds
  9814 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  9815 0000760E C3                  <1> 	ret
  9816                              <1> 
  9817                              <1> ;=========================================================================
  9818                              <1> ; int_10_fn0B - Set background color or palette
  9819                              <1> ; Input:
  9820                              <1> ; 	AH - 0Bh
  9821                              <1> ;	BH = 00h - set background / border color
  9822                              <1> ;		BL - background (graphics modes) or border (text modes)
  9823                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  9824                              <1> ;		BL - palette ID:
  9825                              <1> ;			00h - background, green, red, and yellow (brown)
  9826                              <1> ;			01h - background, cyan, magenta, and white
  9827                              <1> ; Output:
  9828                              <1> ;	none
  9829                              <1> ;-------------------------------------------------------------------------
  9830                              <1> int_10_fn0B:
  9831 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  9832 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  9833 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  9834 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  9835                              <1> 
  9836 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  9837 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  9838 00007620 08E0                <1> 	or	al,ah			; apply new color
  9839 00007622 EB09                <1> 	jmp	.write_palet_reg
  9840                              <1> 
  9841                              <1> .set_palette:
  9842 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  9843 00007626 F6C401              <1> 	test	ah,01h
  9844 00007629 7402                <1> 	jz	.write_palet_reg
  9845 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  9846                              <1> 
  9847                              <1> .write_palet_reg:
  9848 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  9849 00007630 8B166300            <1> 	mov	dx,word [video_port]
  9850 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  9851 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  9852 00007638 C3                  <1> 	ret
  9853                              <1> 
  9854                              <1> ;=========================================================================
  9855                              <1> ; int_10_fn0C - Write graphics pixel
  9856                              <1> ; Input:
  9857                              <1> ;	AH = 0Ch
  9858                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  9859                              <1> ;	CX = column
  9860                              <1> ;	DX = row
  9861                              <1> ; Output:
  9862                              <1> ;	none
  9863                              <1> ;-------------------------------------------------------------------------
  9864                              <1> int_10_fn0C:
  9865 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  9866 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9867 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9868 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  9869 00007643 2401                <1> 	and	al,1			; one bit per pixel
  9870 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9871 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  9872 00007649 EB0F                <1> 	jmp	.prepare_mask
  9873                              <1> 
  9874                              <1> .mode_320x200:
  9875 0000764B D0E1                <1> 	shl	cl,1
  9876 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9877 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  9878 00007652 2403                <1> 	and	al,3			; two bit per pixel
  9879 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9880 00007656 D0C8                <1> 	ror	al,1
  9881 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  9882                              <1> 
  9883                              <1> .prepare_mask:
  9884 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  9885 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  9886 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  9887 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  9888 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  9889 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  9890 00007667 EB04                <1> 	jmp	.write_pixel
  9891                              <1> 
  9892                              <1> .set_color:
  9893 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  9894 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  9895                              <1> 
  9896                              <1> .write_pixel:
  9897 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  9898 00007670 C3                  <1> 	ret
  9899                              <1> 
  9900                              <1> ;=========================================================================
  9901                              <1> ; int_10_fn0D - Read graphics pixel
  9902                              <1> ; Input:
  9903                              <1> ;	AH = 0Dh
  9904                              <1> ;	CX = column
  9905                              <1> ;	DX = row
  9906                              <1> ; Output:
  9907                              <1> ;	AL = pixel color 
  9908                              <1> ;-------------------------------------------------------------------------
  9909                              <1> int_10_fn0D:
  9910 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  9911 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  9912 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9913 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  9914 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  9915 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  9916 0000767F EB0A                <1> 	jmp	.exit
  9917                              <1> 
  9918                              <1> .mode_320x200:
  9919 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  9920 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  9921 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  9922 00007687 D0C0                <1> 	rol	al,1
  9923 00007689 2403                <1> 	and	al,3			; two bits per pixel
  9924                              <1> 
  9925                              <1> .exit:
  9926 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  9927 0000768E C3                  <1> 	ret
  9928                              <1> 
  9929                              <1> ;=========================================================================
  9930                              <1> ; int_10_fn0E - Teletype output
  9931                              <1> ; Input:
  9932                              <1> ;	AH = 0Eh
  9933                              <1> ;	AL = character to write
  9934                              <1> ;	BL = foreground color (graphics modes only)
  9935                              <1> ; Output:
  9936                              <1> ;	none
  9937                              <1> ; Notes:
  9938                              <1> ;	- writes character to the active video page
  9939                              <1> ;	- support following control characters: BEL, BS, LF, CR
  9940                              <1> ;-------------------------------------------------------------------------
  9941                              <1> int_10_fn0E:
  9942 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9943 00007693 B700                <1> 	mov	bh,0
  9944 00007695 D0E3                <1> 	shl	bl,1			; word index
  9945 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  9946                              <1> 
  9947 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  9948 0000769D 3C08                <1> 	cmp	al,bs
  9949 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  9950 000076A1 3C0A                <1> 	cmp	al,lf
  9951 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  9952 000076A5 3C07                <1> 	cmp	al,bel
  9953 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  9954 000076A9 3C0D                <1> 	cmp	al,cr
  9955 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  9956 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  9957 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  9958 000076B2 B90100              <1> 	mov	cx,1			; one character
  9959 000076B5 CD10                <1> 	int	10h			; write character
  9960 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  9961 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  9962 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  9963 000076BF B200                <1> 	mov	dl,0			; move to the first position
  9964                              <1> 
  9965                              <1> .lf:
  9966 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  9967 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  9968 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  9969 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  9970                              <1> 
  9971                              <1> .bs:
  9972 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  9973 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  9974 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
  9975 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  9976                              <1> 
  9977                              <1> .cr:
  9978 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  9979                              <1> 
  9980                              <1> .set_cursor_pos:
  9981 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9982 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  9983                              <1> 
  9984                              <1> .bel:
  9985 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
  9986 000076DE E891AC              <1> 	call	beep
  9987 000076E1 C3                  <1> 	ret
  9988                              <1> 
  9989                              <1> .scroll:
  9990 000076E2 B402                <1> 	mov	ah,02h
  9991 000076E4 CD10                <1> 	int	10h			; set new cursor position
  9992 000076E6 E82E00              <1> 	call	vid_check_mode
  9993 000076E9 B700                <1> 	mov	bh,0
  9994 000076EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
  9995 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  9996 000076EF CD10                <1> 	int	10h			; read attirbute at current position
  9997 000076F1 88E7                <1> 	mov	bh,ah
  9998                              <1> 
  9999                              <1> .do_scroll:
 10000 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
 10001 000076F5 B001                <1> 	mov	al,1			; scroll one line
 10002 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
 10003 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
 10004 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
 10005 000076FF FECA                <1> 	dec	dl
 10006 00007701 CD10                <1> 	int	10h			; scroll page up
 10007 00007703 C3                  <1> 	ret
 10008                              <1> 
 10009                              <1> ;=========================================================================
 10010                              <1> ; int_10_fn0F - Get current video mode
 10011                              <1> ; Input:
 10012                              <1> ;	AH = 0Fh
 10013                              <1> ; Output:
 10014                              <1> ;	AL = video mode
 10015                              <1> ;	AH = characters per column
 10016                              <1> ;	BH = active video page
 10017                              <1> ;-------------------------------------------------------------------------
 10018                              <1> int_10_fn0F:
 10019 00007704 A04A00              <1> 	mov	al,byte [video_columns]
 10020 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
 10021 0000770A A04900              <1> 	mov	al,byte [video_mode]
 10022 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
 10023 00007710 A06200              <1> 	mov	al,byte [video_page]
 10024 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
 10025 00007716 C3                  <1> 	ret
 10026                              <1> 
 10027                              <1> ;=========================================================================
 10028                              <1> ; vid_check_mode - Check current video mode
 10029                              <1> ; Input:
 10030                              <1> ;	none
 10031                              <1> ; Output:
 10032                              <1> ;	ZF set if monochrome mode (mode 07h)
 10033                              <1> ;	CF set if graphics modes (modes 04h - 06h)
 10034                              <1> ;-------------------------------------------------------------------------
 10035                              <1> vid_check_mode:
 10036 00007717 50                  <1> 	push	ax
 10037 00007718 A04900              <1> 	mov	al,byte [video_mode]
 10038 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
 10039 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
 10040 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
 10041 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
 10042 00007722 7303                <1> 	jnb	.exit			; jump if not graphics
 10043 00007724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
 10044 00007726 F9                  <1> 	stc				; XXX
 10045                              <1> 
 10046                              <1> .exit:
 10047 00007727 58                  <1> 	pop	ax
 10048 00007728 C3                  <1> 	ret
 10049                              <1> 
 10050                              <1> ;=========================================================================
 10051                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10052                              <1> ; Input:
 10053                              <1> ;	AH = register number
 10054                              <1> ;	CX = word to write
 10055                              <1> ; Output:
 10056                              <1> ;	AX trashed
 10057                              <1> ; Note:
 10058                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
 10059                              <1> ;-------------------------------------------------------------------------
 10060                              <1> vid_crtc_writew:
 10061 00007729 88E8                <1> 	mov	al,ch
 10062 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
 10063 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
 10064 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
 10065                              <1> 
 10066                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
 10067                              <1> 
 10068                              <1> ;=========================================================================
 10069                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10070                              <1> ; Input:
 10071                              <1> ;	AH = register number
 10072                              <1> ;	AL = byte to write
 10073                              <1> ; Output:
 10074                              <1> ;	none
 10075                              <1> ;-------------------------------------------------------------------------
 10076                              <1> vid_crtc_writeb:
 10077 00007732 52                  <1> 	push	dx
 10078 00007733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
 10079 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
 10080 00007739 EE                  <1> 	out	dx,al			; write register number
 10081 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
 10082 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
 10083 0000773E EE                  <1> 	out	dx,al			; write byte
 10084 0000773F 5A                  <1> 	pop	dx
 10085 00007740 C3                  <1> 	ret
 10086                              <1> 
 10087                              <1> ;=========================================================================
 10088                              <1> ; vid_pixel_address - calculate pixel address and mask
 10089                              <1> ; Input:
 10090                              <1> ;	CX - column
 10091                              <1> ;	DX - row
 10092                              <1> ; Output:
 10093                              <1> ;	SI - pixel address
 10094                              <1> ;	CH - pixel mask
 10095                              <1> ;	CL - pixel position in the byte
 10096                              <1> ;	ZF - mode
 10097                              <1> ;		0 = 320x200
 10098                              <1> ;		1 = 640x200
 10099                              <1> ;-------------------------------------------------------------------------
 10100                              <1> vid_pixel_address:
 10101 00007741 31F6                <1> 	xor	si,si			; SI = 0
 10102 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
 10103 00007745 7303                <1> 	jnb	.even			; jump if on even row 
 10104 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
 10105                              <1> 
 10106                              <1> .even:
 10107 0000774A B050                <1> 	mov	al,50h			; bytes in each row
 10108 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
 10109                              <1> 
 10110 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
 10111 00007750 89CA                <1> 	mov	dx,cx			; DX - column
 10112 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
 10113 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
 10114 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
 10115 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
 10116 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
 10117                              <1> 
 10118                              <1> .1:
 10119 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
 10120 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
 10121 00007764 01D6                <1> 	add	si,dx			; add column address to SI
 10122 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
 10123 00007768 9D                  <1> 	popf
 10124 00007769 C3                  <1> 	ret
 10125                              <1> 
 10126                              <1> ;=========================================================================
 10127                              <1> ; vid_current_offset - convert current cursor position to offset
 10128                              <1> ;		       relative to page starting address
 10129                              <1> ; Input:
 10130                              <1> ;	BL = page
 10131                              <1> ; Output:
 10132                              <1> ;	AX = offset
 10133                              <1> ;-------------------------------------------------------------------------
 10134                              <1> vid_current_offset:
 10135 0000776A B700                <1> 	mov	bh,0
 10136 0000776C D1E3                <1> 	shl	bx,1				; word index
 10137 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
 10138                              <1> 
 10139                              <1> ; fall through to vid_position_to_offset
 10140                              <1> 
 10141                              <1> ;=========================================================================
 10142                              <1> ; vid_position_to_offset - convert position (row and column) to offset
 10143                              <1> ;			   relative to page starting address
 10144                              <1> ; Input:
 10145                              <1> ;	AH = row
 10146                              <1> ;	AL = column
 10147                              <1> ; Output:
 10148                              <1> ;	AX = offset
 10149                              <1> ;-------------------------------------------------------------------------
 10150                              <1> vid_position_to_offset:
 10151 00007771 53                  <1> 	push	bx
 10152 00007772 88C3                <1> 	mov	bl,al			; BL = column
 10153 00007774 88E0                <1> 	mov	al,ah			; AL = row
 10154 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10155 0000777A B700                <1> 	mov	bh,0			;
 10156 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
 10157 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
 10158 00007780 5B                  <1> 	pop	bx
 10159 00007781 C3                  <1> 	ret
 10160                              <1> 
 10161                              <1> ;=========================================================================
 10162                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
 10163                              <1> ; Input:
 10164                              <1> ;	AH = row
 10165                              <1> ;	AL = column
 10166                              <1> ; Output:
 10167                              <1> ;	AX = offset
 10168                              <1> ;-------------------------------------------------------------------------
 10169                              <1> vid_gfx_pos_to_offset:
 10170 00007782 53                  <1> 	push	bx
 10171 00007783 88C3                <1> 	mov	bl,al			; BL = column
 10172 00007785 88E0                <1> 	mov	al,ah			; AL = row
 10173 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10174 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
 10175 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
 10176 0000778F B700                <1> 	mov	bh,0
 10177 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
 10178 00007793 5B                  <1> 	pop	bx
 10179 00007794 C3                  <1> 	ret
 10180                                  
 10181                                  ;=========================================================================
 10182                                  ; int_12 - Get memory size
 10183                                  ; Input:
 10184                                  ;	none
 10185                                  ; Output:
 10186                                  ;	AX = memory size
 10187                                  ;-------------------------------------------------------------------------
 10188 00007795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
 10189          ******************       warning: (setloc:7) Inserting 172 bytes
 10190                                  int_12:
 10191 00007841 FB                      	sti
 10192 00007842 1E                      	push	ds
 10193 00007843 B84000                  	mov	ax,biosdseg
 10194 00007846 8ED8                    	mov	ds,ax
 10195 00007848 A11300                  	mov	ax,word [memory_size]
 10196 0000784B 1F                      	pop	ds
 10197 0000784C CF                      	iret
 10198                                  
 10199                                  ;=========================================================================
 10200                                  ; int_11 - Get equipment list
 10201                                  ; Input:
 10202                                  ;	none
 10203                                  ; Output:
 10204                                  ;	AX = equipment list
 10205                                  ;-------------------------------------------------------------------------
 10206                                  	setloc	0F84Dh			; INT 11 Entry Point
 10207                                  int_11:
 10208 0000784D FB                      	sti
 10209 0000784E 1E                      	push	ds
 10210 0000784F B84000                  	mov	ax,biosdseg
 10211 00007852 8ED8                    	mov	ds,ax
 10212 00007854 A11000                  	mov	ax,word [equipment_list]
 10213 00007857 1F                      	pop	ds
 10214 00007858 CF                      	iret
 10215                                  
 10216                                  ;=========================================================================
 10217                                  ; Includes with fixed entry points (for IBM compatibility)
 10218                                  ;-------------------------------------------------------------------------
 10219                                  
 10220                                  %include	"misc.inc"
 10221                              <1> ;=========================================================================
 10222                              <1> ; misc.inc - Miscellaneous BIOS Services
 10223                              <1> ;       INT 15h, functions:
 10224                              <1> ;       	4Fh	- OS hook keyboard intercept
 10225                              <1> ;		90h	- Device busy loop
 10226                              <1> ;		91h	- Interrupt completed
 10227                              <1> ;		0C0h	- Get system configruation
 10228                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
 10229                              <1> ;		
 10230                              <1> ;-------------------------------------------------------------------------
 10231                              <1> ;
 10232                              <1> ; Compiles with NASM 2.07, might work with other versions
 10233                              <1> ;
 10234                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10235                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10236                              <1> ;
 10237                              <1> ; This program is free software: you can redistribute it and/or modify
 10238                              <1> ; it under the terms of the GNU General Public License as published by
 10239                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10240                              <1> ; (at your option) any later version.
 10241                              <1> ;
 10242                              <1> ; This program is distributed in the hope that it will be useful,
 10243                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10244                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10245                              <1> ; GNU General Public License for more details.
 10246                              <1> ;
 10247                              <1> ; You should have received a copy of the GNU General Public License
 10248                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10249                              <1> ;
 10250                              <1> ;=========================================================================
 10251                              <1> 
 10252                              <1> ;-------------------------------------------------------------------------
 10253                              <1> ; offsets for registers on stack
 10254                              <1> int_15_bp	equ	0
 10255                              <1> int_15_ip	equ	int_15_bp+2
 10256                              <1> int_15_cs	equ	int_15_ip+2
 10257                              <1> int_15_flags	equ	int_15_cs+2
 10258                              <1> 
 10259                              <1> ;=========================================================================
 10260                              <1> ; int_15 - Miscellaneous BIOS services
 10261                              <1> ; Input:
 10262                              <1> ;	AH = 4Fh - OS hook keyboard intercept
 10263                              <1> ;		- Does nothing
 10264                              <1> ;	AH = 0C2h - PS/2 mouse services
 10265                              <1> ;		- Implemented in ps2aux.inc
 10266                              <1> ;-------------------------------------------------------------------------
 10267                              <1> 	setloc	0F859h			; INT 15 Entry Point
 10268                              <1> int_15:
 10269 00007859 FB                  <1> 	sti
 10270 0000785A 80FC4F              <1> 	cmp	ah,4Fh
 10271 0000785D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
 10272 0000785F 80FCC0              <1> 	cmp	ah,0C0h
 10273 00007862 742E                <1> 	je	int_15_fnC0
 10274 00007864 3D0190              <1> 	cmp	ax,9001h
 10275 00007867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
 10276 00007869 3DFD90              <1> 	cmp	ax,90FDh
 10277 0000786C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
 10278 0000786E 3D0191              <1> 	cmp	ax,9101h
 10279 00007871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
 10280                              <1> 
 10281                              <1> %ifdef PS2_MOUSE
 10282 00007873 80FCC2              <1> 	cmp	ah,0C2h
 10283 00007876 7503                <1> 	jne	.1
 10284 00007878 E97AA8              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
 10285                              <1> .1:
 10286                              <1> %endif
 10287                              <1> 
 10288 0000787B B486                <1> 	mov	ah,86h			; no cassete present
 10289                              <1> 
 10290                              <1> int_15_err:
 10291 0000787D 55                  <1> 	push	bp
 10292 0000787E 89E5                <1> 	mov	bp,sp
 10293 00007880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
 10294 00007884 5D                  <1> 	pop	bp
 10295 00007885 CF                  <1> 	iret
 10296                              <1> 
 10297                              <1> int_15_ok:
 10298 00007886 55                  <1> 	push	bp
 10299 00007887 89E5                <1> 	mov	bp,sp
 10300 00007889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
 10301 0000788D 5D                  <1> 	pop	bp
 10302 0000788E CF                  <1> 	iret
 10303                              <1> 
 10304                              <1> int_15_os_hook:
 10305 0000788F B400                <1> 	mov	ah,00h
 10306                              <1> 
 10307                              <1> int_15_exit:
 10308 00007891 CF                  <1> 	iret
 10309                              <1> 
 10310                              <1> ;=========================================================================
 10311                              <1> ; int_15_fnC0 - Get configuration
 10312                              <1> ; Input:
 10313                              <1> ;	AH = 0C0h - get configuration
 10314                              <1> ; Output:
 10315                              <1> ;	AH = 00h - function supported
 10316                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
 10317                              <1> ;	CF = 0 (success)
 10318                              <1> ;-------------------------------------------------------------------------
 10319                              <1> int_15_fnC0:
 10320 00007892 B400                <1> 	mov	ah,00h
 10321 00007894 BB00F0              <1> 	mov	bx,bioscseg
 10322 00007897 8EC3                <1> 	mov	es,bx
 10323 00007899 BB[F566]            <1> 	mov	bx,config_table
 10324 0000789C EBE8                <1> 	jmp	int_15_ok
 10325                                  %include	"fnt00-7F.inc"
 10326                              <1> ;=========================================================================
 10327                              <1> ; fnt00-7F.inc - Font for graphics modes
 10328                              <1> ;       Characters from 00h to 7Fh
 10329                              <1> ;-------------------------------------------------------------------------
 10330                              <1> ;
 10331                              <1> ; Compiles with NASM 2.07, might work with other versions
 10332                              <1> ;
 10333                              <1> ; This font is borrowed from kbd package (alt-8x8)
 10334                              <1> ;
 10335                              <1> ; This program is free software: you can redistribute it and/or modify
 10336                              <1> ; it under the terms of the GNU General Public License as published by
 10337                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10338                              <1> ; (at your option) any later version.
 10339                              <1> ;
 10340                              <1> ; This program is distributed in the hope that it will be useful,
 10341                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10342                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10343                              <1> ; GNU General Public License for more details.
 10344                              <1> ;
 10345                              <1> ; You should have received a copy of the GNU General Public License
 10346                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10347                              <1> ;
 10348                              <1> ;=========================================================================
 10349 0000789E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
 10350          ******************  <1>  warning: (setloc:7) Inserting 464 bytes
 10351                              <1> gfx_font:
 10352 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
 10353 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
 10354 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
 10355 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
 10356 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
 10357 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
 10358 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
 10359 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
 10360 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
 10361 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
 10362 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
 10363 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
 10364 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
 10365 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
 10366 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
 10367 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
 10368 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
 10369 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
 10370 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
 10371 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
 10372 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
 10373 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
 10374 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
 10375 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
 10376 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
 10377 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
 10378 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
 10379 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
 10380 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
 10381 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
 10382 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
 10383 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
 10384 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
 10385 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
 10386 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
 10387 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
 10388 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
 10389 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
 10390 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
 10391 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
 10392 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
 10393 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
 10394 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
 10395 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
 10396 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
 10397 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
 10398 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
 10399 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
 10400 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
 10401 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
 10402 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
 10403 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
 10404 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
 10405 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
 10406 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
 10407 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
 10408 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
 10409 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
 10410 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
 10411 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
 10412 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
 10413 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
 10414 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
 10415 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
 10416 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
 10417 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
 10418 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
 10419 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
 10420 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
 10421 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
 10422 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
 10423 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
 10424 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
 10425 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10426 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
 10427 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
 10428 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
 10429 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
 10430 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
 10431 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
 10432 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
 10433 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
 10434 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
 10435 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
 10436 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
 10437 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
 10438 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10439 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
 10440 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
 10441 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
 10442 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
 10443 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
 10444 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
 10445 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
 10446 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
 10447 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
 10448 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
 10449 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
 10450 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
 10451 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
 10452 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
 10453 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
 10454 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
 10455 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10456 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
 10457 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
 10458 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
 10459 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
 10460 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10461 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
 10462 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
 10463 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
 10464 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
 10465 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
 10466 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
 10467 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
 10468 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
 10469 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
 10470 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10471 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
 10472 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
 10473 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10474 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
 10475 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
 10476 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
 10477 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
 10478 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
 10479 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
 10480                                  %include	"time2.inc"
 10481                              <1> ;=========================================================================
 10482                              <1> ; time2.int - BIOS Time Services
 10483                              <1> ;       INT 1Ah - BIOS Time Serivces
 10484                              <1> ;		dispatcher
 10485                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
 10486                              <1> ;-------------------------------------------------------------------------
 10487                              <1> ;
 10488                              <1> ; Compiles with NASM 2.07, might work with other versions
 10489                              <1> ;
 10490                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10491                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10492                              <1> ;
 10493                              <1> ; This program is free software: you can redistribute it and/or modify
 10494                              <1> ; it under the terms of the GNU General Public License as published by
 10495                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10496                              <1> ; (at your option) any later version.
 10497                              <1> ;
 10498                              <1> ; This program is distributed in the hope that it will be useful,
 10499                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10500                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10501                              <1> ; GNU General Public License for more details.
 10502                              <1> ;
 10503                              <1> ; You should have received a copy of the GNU General Public License
 10504                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10505                              <1> ;
 10506                              <1> ;=========================================================================
 10507                              <1> 
 10508                              <1> ;=========================================================================
 10509                              <1> ; int_1A - BIOS Time Services
 10510                              <1> ; Note: see time1.inc for functions implementation
 10511                              <1> ;-------------------------------------------------------------------------
 10512                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
 10513                              <1> int_1A:
 10514 00007E6E 53                  <1> 	push	bx
 10515 00007E6F 1E                  <1> 	push	ds
 10516 00007E70 BB4000              <1> 	mov	bx,biosdseg
 10517 00007E73 8EDB                <1> 	mov	ds,bx
 10518 00007E75 80FC08              <1> 	cmp	ah,.max/2
 10519 00007E78 731B                <1> 	jae	int_1A_exit
 10520 00007E7A B700                <1> 	mov	bh,0
 10521 00007E7C 88E3                <1> 	mov	bl,ah
 10522 00007E7E D1E3                <1> 	shl	bx,1
 10523 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
 10524                              <1> .dispatch:
 10525 00007E85 [3E0F]              <1> 	dw	int_1A_fn00
 10526 00007E87 [500F]              <1> 	dw	int_1A_fn01
 10527 00007E89 [600F]              <1> 	dw	int_1A_fn02
 10528 00007E8B [920F]              <1> 	dw	int_1A_fn03
 10529 00007E8D [D70F]              <1> 	dw	int_1A_fn04
 10530 00007E8F [0710]              <1> 	dw	int_1A_fn05
 10531 00007E91 [4610]              <1> 	dw	int_1A_fn06
 10532 00007E93 [9710]              <1> 	dw	int_1A_fn07
 10533                              <1> .max	equ	$-.dispatch
 10534                              <1> int_1A_exit:
 10535 00007E95 1F                  <1> 	pop	ds
 10536 00007E96 5B                  <1> 	pop	bx
 10537 00007E97 CF                  <1> 	iret
 10538                              <1> int_1A_exitf:
 10539 00007E98 1F                  <1> 	pop	ds
 10540 00007E99 5B                  <1> 	pop	bx
 10541 00007E9A CA0200              <1> 	retf	2
 10542                              <1> 
 10543                              <1> ;=========================================================================
 10544                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
 10545                              <1> ;-------------------------------------------------------------------------
 10546 00007E9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
 10547          ******************  <1>  warning: (setloc:7) Inserting 8 bytes
 10548                              <1> int_08:
 10549 00007EA5 50                  <1> 	push	ax
 10550 00007EA6 1E                  <1> 	push	ds
 10551 00007EA7 B84000              <1> 	mov	ax,biosdseg
 10552 00007EAA 8ED8                <1> 	mov	ds,ax
 10553 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
 10554 00007EB1 7413                <1> 	jz	.1
 10555 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
 10556 00007EB7 750D                <1> 	jnz	.1
 10557 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
 10558 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
 10559 00007EC0 52                  <1> 	push	dx
 10560 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
 10561 00007EC4 EE                  <1> 	out	dx,al
 10562 00007EC5 5A                  <1> 	pop	dx
 10563                              <1> .1:
 10564 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
 10565 00007ECA 7504                <1> 	jnz	.2
 10566 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
 10567                              <1> .2:
 10568 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
 10569 00007ED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
 10570 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
 10571 00007EDD 7512                <1> 	jnz	.3
 10572 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
 10573 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
 10574 00007EEB C70670000100        <1> 	mov	word [new_day],1
 10575                              <1> .3:
 10576 00007EF1 CD1C                <1> 	int	1Ch			; User timer interrupt
 10577 00007EF3 B020                <1> 	mov	al,20h
 10578 00007EF5 E620                <1> 	out	pic1_reg0,al
 10579 00007EF7 1F                  <1> 	pop	ds
 10580 00007EF8 58                  <1> 	pop	ax
 10581 00007EF9 CF                  <1> 	iret
 10582                                  
 10583                                  ;=========================================================================
 10584                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
 10585                                  ;-------------------------------------------------------------------------
 10586 00007EFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
 10587          ******************       warning: (setloc:7) Inserting 41 bytes
 10588                                  int_ignore:
 10589 00007F23 50                      	push	ax
 10590 00007F24 1E                      	push	ds
 10591 00007F25 B84000                  	mov	ax,biosdseg
 10592 00007F28 8ED8                    	mov	ds,ax
 10593 00007F2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
 10594 00007F2C E620                    	out	pic1_reg0,al
 10595 00007F2E 90                      	nop
 10596 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
 10597 00007F31 88C4                    	mov	ah,al
 10598 00007F33 08C0                    	or	al,al
 10599 00007F35 7504                    	jnz	.1
 10600 00007F37 B4FF                    	mov	ah,0FFh
 10601 00007F39 EB0A                    	jmp	.2
 10602                                  .1:
 10603 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
 10604 00007F3D 08E0                    	or	al,ah
 10605 00007F3F E621                    	out	pic1_reg1,al
 10606 00007F41 B020                    	mov	al,20h			; end of interrupt
 10607 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
 10608                                  .2:
 10609 00007F45 88266B00                	mov	byte [last_irq],ah
 10610 00007F49 1F                      	pop	ds
 10611 00007F4A 58                      	pop	ax
 10612 00007F4B CF                      	iret
 10613                                  
 10614                                  ;=========================================================================
 10615                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
 10616                                  ;-------------------------------------------------------------------------
 10617 00007F4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
 10618          ******************       warning: (setloc:7) Inserting 7 bytes
 10619                                  int_dummy:
 10620 00007F53 CF                      	iret
 10621                                  
 10622                                  ;=========================================================================
 10623                                  ; int_05 - BIOS Print Screen
 10624                                  ;-------------------------------------------------------------------------
 10625                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
 10626                                  int_05:
 10627 00007F54 FB                      	sti
 10628 00007F55 50                      	push	ax
 10629 00007F56 53                      	push	bx
 10630 00007F57 51                      	push	cx
 10631 00007F58 52                      	push	dx
 10632 00007F59 1E                      	push	ds
 10633 00007F5A B84000                  	mov	ax,biosdseg
 10634 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
 10635 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
 10636 00007F64 746A                    	je	.exit			; print screen is already in progress
 10637 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
 10638                                  					; signal that print screen is running
 10639                                  
 10640 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
 10641 00007F6D CD10                    	int	10h			; returns number of columns in AH
 10642                                  					; and active display page in BH
 10643 00007F6F 88E1                    	mov	cl,ah			; store number columns
 10644                                  
 10645 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
 10646 00007F75 08ED                    	or	ch,ch
 10647 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
 10648                                  
 10649 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
 10650 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
 10651 00007F7E 7602                    	jbe	.get_cursor_pos
 10652                                  
 10653                                  .wrong_num_rows:
 10654 00007F80 B519                    	mov	ch,25			; assume 25 rows
 10655                                  
 10656                                  .get_cursor_pos:
 10657 00007F82 B403                    	mov	ah,03h			; get cursor position and size
 10658 00007F84 CD10                    	int	10h			; returns cursor position in DX
 10659 00007F86 52                      	push	dx			; save original position / DX in stack
 10660                                  
 10661                                  	
 10662 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
 10663 00007F89 E85100                  	call	.print_char
 10664 00007F8C 7548                    	jnz	.error
 10665 00007F8E B40A                    	mov	ah,0Ah
 10666 00007F90 E84A00                  	call	.print_char
 10667 00007F93 7541                    	jnz	.error
 10668                                  
 10669 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
 10670                                  
 10671                                  .row_loop:
 10672 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
 10673                                  
 10674                                  .column_loop:
 10675 00007F99 B402                    	mov	ah,02h
 10676 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
 10677                                  
 10678 00007F9D B408                    	mov	ah,08h
 10679 00007F9F CD10                    	int	10h			; read character at cursor position
 10680                                  
 10681 00007FA1 3C20                    	cmp	al,20h			; control character?
 10682 00007FA3 7302                    	jae	.continue		; no, print it
 10683 00007FA5 B020                    	mov	al,20h			; print space instead
 10684                                  
 10685                                  .continue:
 10686 00007FA7 E83300                  	call	.print_char
 10687 00007FAA 752A                    	jnz	.error
 10688 00007FAC FEC2                    	inc	dl
 10689 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
 10690 00007FB0 72E7                    	jb	.column_loop		; print next column
 10691                                  
 10692 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
 10693 00007FB4 E82600                  	call	.print_char
 10694 00007FB7 751D                    	jnz	.error
 10695 00007FB9 B40A                    	mov	ah,0Ah
 10696 00007FBB E81F00                  	call	.print_char
 10697 00007FBE 7516                    	jnz	.error
 10698                                  
 10699 00007FC0 FEC6                    	inc	dh
 10700 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
 10701 00007FC4 72D1                    	jb	.row_loop		; print next row
 10702                                  
 10703 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
 10704                                  					; ready for the next call
 10705                                  
 10706                                  .restore_cursor:
 10707 00007FCB 5A                      	pop	dx			; DX = original cursor position
 10708 00007FCC B402                    	mov	ah,02h
 10709 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
 10710                                  
 10711                                  .exit:
 10712 00007FD0 1F                      	pop	ds
 10713 00007FD1 5A                      	pop	dx
 10714 00007FD2 59                      	pop	cx
 10715 00007FD3 5B                      	pop	bx
 10716 00007FD4 58                      	pop	ax
 10717 00007FD5 CF                      	iret
 10718                                  
 10719                                  .error:
 10720 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
 10721                                  					; signal failure
 10722 00007FDB EBEE                    	jmp	.restore_cursor
 10723                                  	
 10724                                  
 10725                                  .print_char:
 10726 00007FDD 52                      	push	dx
 10727 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
 10728 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
 10729 00007FE2 CD17                    	int	17h
 10730 00007FE4 5A                      	pop	dx
 10731 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
 10732 00007FE8 C3                      	ret
 10733                                  
 10734                                  ;=========================================================================
 10735                                  ; start - at power up or reset execution starts here (F000:FFF0)
 10736                                  ;-------------------------------------------------------------------------
 10737 00007FE9 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
 10738          ******************       warning: (setloc:7) Inserting 7 bytes
 10739                                  start:
 10740 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
 10741                                  
 10742                                  	setloc	0FFF5h			; ROM Date in ASCII
 10743 00007FF5 30382F30352F3136        	db	DATE			; BIOS release date MM/DD/YY
 10744 00007FFD 20                      	db	20h
 10745                                  
 10746                                  	setloc	0FFFEh			; System Model
 10747                                  %ifdef AT_COMPAT
 10748 00007FFE FC                      	db	0fch			; system is an IBM AT compatible
 10749                                  %else
 10750                                  	db	0feh			; system is an IBM PC/XT compatible
 10751                                  %endif ; AT_COMPAT
 10752 00007FFF FF                      	db	0ffh
