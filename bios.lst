     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.07, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
   108                                  %include "config.inc"
   109                              <1> ;=========================================================================
   110                              <1> ; config.inc - Compilation time settings and settings
   111                              <1> ;-------------------------------------------------------------------------
   112                              <1> ;
   113                              <1> ; Compiles with NASM 2.07, might work with other versions
   114                              <1> ;
   115                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   116                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   117                              <1> ;
   118                              <1> ; This program is free software: you can redistribute it and/or modify
   119                              <1> ; it under the terms of the GNU General Public License as published by
   120                              <1> ; the Free Software Foundation, either version 3 of the License, or
   121                              <1> ; (at your option) any later version.
   122                              <1> ;
   123                              <1> ; This program is distributed in the hope that it will be useful,
   124                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   125                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   126                              <1> ; GNU General Public License for more details.
   127                              <1> ;
   128                              <1> ; You should have received a copy of the GNU General Public License
   129                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   130                              <1> ;
   131                              <1> ;=========================================================================
   132                              <1> 
   133                              <1> %define DATE		'12/26/12'	; BIOS release date MM/DD/YY
   134                              <1> %define VERSION		'0.8'		; BIOS version
   135                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   136                              <1> 
   137                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
   138                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   139                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   140                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   141                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   142                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   143                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   144                              <1> 					; EBDA is required for PS/2 aux support
   145                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   146                                  %include "errno.inc"
   147                              <1> ;=========================================================================
   148                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> ;
   151                              <1> ; Compiles with NASM 2.07, might work with other versions
   152                              <1> ;
   153                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   154                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   155                              <1> ;
   156                              <1> ; This program is free software: you can redistribute it and/or modify
   157                              <1> ; it under the terms of the GNU General Public License as published by
   158                              <1> ; the Free Software Foundation, either version 3 of the License, or
   159                              <1> ; (at your option) any later version.
   160                              <1> ;
   161                              <1> ; This program is distributed in the hope that it will be useful,
   162                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   163                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   164                              <1> ; GNU General Public License for more details.
   165                              <1> ;
   166                              <1> ; You should have received a copy of the GNU General Public License
   167                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   168                              <1> ;
   169                              <1> ;=========================================================================
   170                              <1> 
   171                              <1> e_start		equ	01h		; BIOS POST started
   172                              <1> e_cpu_ok	equ	02h		; CPU test passed
   173                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   174                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   175                              <1> e_int_ok	equ	05h		; interrupt table initialized
   176                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   177                              <1> e_pic_ok	equ	08h		; PIC initialized
   178                              <1> e_kbd_ok	equ	10h		; KBD test passed
   179                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   180                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   181                              <1> e_rtc_init_ok	equ	20h		; RTC initialized
   182                              <1> e_cpu_detect_ok	equ	21h		; CPU type detected
   183                              <1> e_fpu_detect_ok	equ	22h		; FPU type detected
   184                              <1> e_serial_ok	equ	24h		; Serial port scan finished
   185                              <1> e_parallel_ok	equ	25h		; Parallel port scan finished
   186                              <1> e_ram_start	equ	30h		; RAM test start
   187                              <1> e_ram_complete	equ	31h		; RAM test completed
   188                              <1> e_ram_esc	equ	32h		; RAM test canceled
   189                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   190                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found
   191                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   192                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   193                              <1> e_boot		equ	49h		; Boot the OS
   194                              <1> e_cpu_fail	equ	52h		; CPU test failed
   195                              <1> e_low_ram_fail	equ	54h		; low RAM test failed
   196                              <1> e_kbd_ctrl_fail	equ	60h		; KBD test - controller selftest failed
   197                              <1> e_kbd_key_fail	equ	61h		; KBD test - echo test failed
   198                              <1> e_kbd_timeout	equ	62h		; KBD timeout
   199                              <1> e_kbd_int_fail	equ	63h		; KBD test - interface test failed
   200                              <1> e_ram_fail	equ	80h		; RAM test failed
   201                                  
   202                                  bioscseg	equ	0F000h
   203                                  biosdseg	equ	0040h
   204                                  
   205                                  pic1_reg0	equ	20h
   206                                  pic1_reg1	equ	21h
   207                                  pit_ch0_reg	equ	40h
   208                                  pit_ch1_reg	equ	41h
   209                                  pit_ch2_reg	equ	42h
   210                                  pit_ctl_reg	equ	43h
   211                                  port_b_reg	equ	61h
   212                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   213                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   214                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   215                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   216                                  post_reg	equ	80h	; POST status output port
   217                                  pic2_reg0	equ	0A0h
   218                                  pic2_reg1	equ	0A1h
   219                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   220                                  cga_mode_reg	equ	3D8h
   221                                  mda_mode_reg	equ	3B8h
   222                                  
   223                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   224                                  
   225                                  ;========================================================================
   226                                  ; BIOS data area variables
   227                                  ;------------------------------------------------------------------------
   228                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   229                                  				; or 0 if port doesn't exist
   230                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   231                                  				; or 0 if port doesn't exist
   232                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   233                                  equipment_list	equ	10h	; word - equpment list
   234                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   235                                  equip_fpu	equ	0000000000000010b	; FPU installed
   236                                  equip_mouse	equ	0000000000000100b
   237                                  equip_video	equ	0000000000110000b	; video type bit mask
   238                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   239                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   240                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   241                                  ;			|||||||||||||||`-- floppy drives installed
   242                                  ;			||||||||||||||`-- FPU installed
   243                                  ;			|||||||||||||`-- PS/2 mouse installed
   244                                  ;			||||||||||||`-- reserved
   245                                  ;			||||||||||`--- initial video mode
   246                                  ;			||||||||`---- number of floppy drives - 1
   247                                  ;			|||||||`---- O = DMA installed
   248                                  ;			||||`------ number of serial ports
   249                                  ;			|||`------ game adapter installed
   250                                  ;			||`------ internal modem?!
   251                                  ;			`------- number of parallel ports
   252                                  
   253                                  post_flags	equ	12h	; byte - post flags
   254                                  post_setup	equ	01h	; run NVRAM setup
   255                                  memory_size	equ	13h	; word - memory size in KiB
   256                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   257                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   258                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   259                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   260                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   261                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   262                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   263                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   264                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   265                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   266                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   267                                  video_mode	equ	49h	; byte - active video mode number
   268                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   269                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   270                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   271                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   272                                  video_cur_shape	equ	60h	; word - cursor shape
   273                                  video_page	equ	62h	; byte - active video page
   274                                  video_port	equ	63h	; word - I/O port for the display adapter
   275                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   276                                  video_palet_reg	equ	66h	; byte - color palette
   277                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   278                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   279                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   280                                  new_day		equ	70h	; byte - 1 = new day flag
   281                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   282                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   283                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   284                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   285                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   286                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   287                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   288                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   289                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   290                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   291                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   292                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   293                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   294                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   295                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   296                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   297                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   298                                  
   299                                  ;=========================================================================
   300                                  ; Extended BIOS data area variables
   301                                  ;-------------------------------------------------------------------------
   302                                  ebda_size	equ	0h
   303                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   304                                  mouse_flags_1	equ	26h
   305                                  mouse_flags_2	equ	27h
   306                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   307                                  
   308                                  	org	START		; Use only upper 32 KiB of ROM
   309                                  
   310                                  ;=========================================================================
   311                                  ; Includes
   312                                  ;-------------------------------------------------------------------------
   313                                  %include	"messages.inc"		; POST messages
   314                              <1> ;=========================================================================
   315                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> ;
   318                              <1> ; Compiles with NASM 2.07, might work with other versions
   319                              <1> ;
   320                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   321                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   322                              <1> ;
   323                              <1> ; This program is free software: you can redistribute it and/or modify
   324                              <1> ; it under the terms of the GNU General Public License as published by
   325                              <1> ; the Free Software Foundation, either version 3 of the License, or
   326                              <1> ; (at your option) any later version.
   327                              <1> ;
   328                              <1> ; This program is distributed in the hope that it will be useful,
   329                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   330                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   331                              <1> ; GNU General Public License for more details.
   332                              <1> ;
   333                              <1> ; You should have received a copy of the GNU General Public License
   334                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   335                              <1> ;
   336                              <1> ;=========================================================================
   337                              <1> 
   338 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   339 00000002 586920383038382042- <1> 		db	"Xi 8088 BIOS, Version "
   340 0000000B 494F532C2056657273- <1>
   341 00000014 696F6E20            <1>
   342 00000018 302E38              <1> 		db	VERSION
   343 0000001B 2E20                <1> 		db	". "
   344 0000001D 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2012 Sergey Kiselev", 0Dh, 0Ah
   345 00000026 202843292032303130- <1>
   346 0000002F 202D20323031322053- <1>
   347 00000038 6572676579204B6973- <1>
   348 00000041 656C65760D0A        <1>
   349 00000047 446973747269627574- <1> 		db	"Distributed under the terms of "
   350 00000050 656420756E64657220- <1>
   351 00000059 746865207465726D73- <1>
   352 00000062 206F6620            <1>
   353 00000066 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   354 0000006F 656E6572616C205075- <1>
   355 00000078 626C6963204C696365- <1>
   356 00000081 6E73650D0A          <1>
   357 00000086 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   358 00000089 6E6F6E6500          <1> msg_none	db	'none', 00h
   359 0000008E 3A2000              <1> msg_colon	db	': ', 00h
   360 00000091 3B2000              <1> msg_semicolon	db	'; ', 00h
   361 00000094 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   362 0000009D 6573736F723A202020- <1>
   363 000000A6 202020202020202020- <1>
   364 000000AF 2000                <1>
   365 000000B1 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   366 000000BA 637320436F2D70726F- <1>
   367 000000C3 636573736F723A2020- <1>
   368 000000CC 2000                <1>
   369 000000CE 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 0Dh, 0Ah
   370 000000D7 38202737380D0A      <1>
   371 000000DE 5741524E494E473A20- <1> 		db      'WARNING: This CPU does not disable interrupts '
   372 000000E7 546869732043505520- <1>
   373 000000F0 646F6573206E6F7420- <1>
   374 000000F9 64697361626C652069- <1>
   375 00000102 6E7465727275707473- <1>
   376 0000010B 20                  <1>
   377 0000010C 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   378 00000115 64696E67207365676D- <1>
   379 0000011E 656E74207265676973- <1>
   380 00000127 74657273210D0A00    <1>
   381 0000012F 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   382 00000138 3820273831206F7220- <1>
   383 00000141 6C617465722C20      <1>
   384 00000148 6F72206F6C64657220- <1> 		db      'or older Intel 80C88', 0Dh, 0Ah, 00h
   385 00000151 496E74656C20383043- <1>
   386 0000015A 38380D0A00          <1>
   387 0000015F 486172726973202F20- <1> msg_cpu_harris  db      'Harris / Intersil / newer Intel 80C88', 0Dh, 0Ah, 00h
   388 00000168 496E74657273696C20- <1>
   389 00000171 2F206E657765722049- <1>
   390 0000017A 6E74656C2038304338- <1>
   391 00000183 380D0A00            <1>
   392 00000187 4E4543205632300D0A- <1> msg_cpu_nec_v20 db      'NEC V20', 0Dh, 0Ah, 00h
   393 00000190 00                  <1>
   394 00000191 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   395 0000019A 370D0A00            <1>
   396 0000019E 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   397 000001A7 646170746572205479- <1>
   398 000001B0 70653A202020202020- <1>
   399 000001B9 2000                <1>
   400 000001BB 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   401 000001C4 566964656F2042494F- <1>
   402 000001CD 532050726573656E74- <1>
   403 000001D6 290D0A00            <1>
   404 000001DA 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   405 000001E0 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   406 000001E9 7263756C65730D0A00  <1>
   407 000001F2 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   408 000001FB 736B20647269766573- <1>
   409 00000204 3A2020202020202020- <1>
   410 0000020D 20447269766520303A- <1>
   411 00000216 2000                <1>
   412 00000218 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   413 00000221 3A2000              <1>
   414 00000224 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   415 0000022D 2E32352200          <1>
   416 00000232 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   417 0000023B 2E32352200          <1>
   418 00000240 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   419 00000249 2E352200            <1>
   420 0000024D 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   421 00000256 332E352200          <1>
   422 0000025B 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   423 00000264 332E352200          <1>
   424 00000269 50532F322041757820- <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   425 00000272 44657669636520284D- <1>
   426 0000027B 6F757365293A202020- <1>
   427 00000284 2000                <1>
   428 00000286 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   429 0000028F 00                  <1>
   430 00000290 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   431 00000299 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   432 000002A2 7274733A2020202020- <1>
   433 000002AB 202020202020202020- <1>
   434 000002B4 2000                <1>
   435 000002B6 434F4D00            <1> msg_serial_com	db	'COM', 00h
   436 000002BA 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   437 000002C3 506F7274733A202020- <1>
   438 000002CC 202020202020202020- <1>
   439 000002D5 2000                <1>
   440 000002D7 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   441 000002DB 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   442 000002E4 414D20284553432074- <1>
   443 000002ED 6F20736B6970293A20- <1>
   444 000002F6 2000                <1>
   445 000002F8 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   446 00000301 4661756C7479206D65- <1>
   447 0000030A 6D6F72792064657465- <1>
   448 00000313 637465642061742000  <1>
   449 0000031C 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   450 00000325 6E76656E74696F6E61- <1>
   451 0000032E 6C2052414D3A202020- <1>
   452 00000337 202000              <1>
   453 0000033A 526573657276656420- <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   454 00000343 666F7220454244413A- <1>
   455 0000034C 202020202020202020- <1>
   456 00000355 2000                <1>
   457 00000357 417661696C61626C65- <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   458 00000360 20436F6E76656E7469- <1>
   459 00000369 6F6E616C2052414D3A- <1>
   460 00000372 2000                <1>
   461 00000374 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   462 0000037B 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   463 00000384 65642C207072657373- <1>
   464 0000038D 20616E79206B657920- <1>
   465 00000396 746F20747279206167- <1>
   466 0000039F 61696E2E2E2E0D0A00  <1>
   467 000003A8 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   468 000003B1 5349430D0A00        <1>
   469 000003B7 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   470 000003C0 5320657874656E7369- <1>
   471 000003C9 6F6E20524F4D206174- <1>
   472 000003D2 2000                <1>
   473 000003D4 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   474 000003DD 6C697A696E672E2E2E- <1>
   475 000003E6 0D0A00              <1>
   476 000003E9 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   477 000003F2 532E2E2E0D0A00      <1>
   478 000003F9 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   479 00000402 432062617474657279- <1>
   480 0000040B 206973206261640D0A- <1>
   481 00000414 00                  <1>
   482 00000415 4552524F523A204E56- <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   483 0000041E 52414D20636865636B- <1>
   484 00000427 73756D20697320696E- <1>
   485 00000430 76616C69642C20      <1>
   486 00000437 6C6F6164696E672064- <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   487 00000440 656661756C74207661- <1>
   488 00000449 6C75657320746F204E- <1>
   489 00000452 5652414D0D0A00      <1>
   490 00000459 507265737320463120- <1> msg_setup	db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   491 00000462 746F2072756E204E56- <1>
   492 0000046B 52414D207365747570- <1>
   493 00000474 2E2E2E0D0A0D0A00    <1>
   494 0000047C 0D0A                <1> msg_set_menu	db	0Dh, 0Ah
   495 0000047E 4E5652414D20536574- <1> 		db	'NVRAM Setup Menu:', 0Dh, 0Ah,
   496 00000487 7570204D656E753A0D- <1>
   497 00000490 0A                  <1>
   498 00000491 66202D204368616E67- <1> 		db	'f - Change first floppy type', 0Dh, 0Ah
   499 0000049A 652066697273742066- <1>
   500 000004A3 6C6F70707920747970- <1>
   501 000004AC 650D0A              <1>
   502 000004AF 67202D204368616E67- <1> 		db	'g - Change second floppy type', 0Dh, 0Ah
   503 000004B8 65207365636F6E6420- <1>
   504 000004C1 666C6F707079207479- <1>
   505 000004CA 70650D0A            <1>
   506 000004CE 70202D205072696E74- <1> 		db	'p - Print current settings', 0Dh, 0Ah
   507 000004D7 2063757272656E7420- <1>
   508 000004E0 73657474696E67730D- <1>
   509 000004E9 0A                  <1>
   510 000004EA 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   511 000004F3 6368616E6765732061- <1>
   512 000004FC 6E6420657869740D0A  <1>
   513 00000505 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   514 0000050E 776974686F75742073- <1>
   515 00000517 6176696E6720636861- <1>
   516 00000520 6E6765730D0A        <1>
   517 00000526 0D0A                <1> 		db	0Dh, 0Ah
   518 00000528 456E74657220796F75- <1> 		db	'Enter your selection: ', 00h
   519 00000531 722073656C65637469- <1>
   520 0000053A 6F6E3A2000          <1>
   521 0000053F 0D0A                <1> msg_set_floppy	db	0Dh, 0Ah
   522 00000541 466C6F707079205365- <1> 		db	'Floppy Setup Menu:', 0Dh, 0Ah
   523 0000054A 747570204D656E753A- <1>
   524 00000553 0D0A                <1>
   525 00000555 30202D204E6F20666C- <1> 		db	'0 - No floppy', 0Dh, 0Ah
   526 0000055E 6F7070790D0A        <1>
   527 00000564 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"', 0Dh, 0Ah
   528 0000056D 422C20352E3235220D- <1>
   529 00000576 0A                  <1>
   530 00000577 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.24"', 0Dh, 0Ah
   531 00000580 422C20352E3234220D- <1>
   532 00000589 0A                  <1>
   533 0000058A 33202D20373230204B- <1> 		db	'3 - 720 KB, 3.5"', 0Dh, 0Ah
   534 00000593 422C20332E35220D0A  <1>
   535 0000059C 34202D20312E343420- <1> 		db	'4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   536 000005A5 4D422C20332E35220D- <1>
   537 000005AE 0A                  <1>
   538 000005AF 36202D20322E383820- <1> 		db	'6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   539 000005B8 4D422C20332E35220D- <1>
   540 000005C1 0A                  <1>
   541 000005C2 71202D205265747572- <1> 		db	'q - Return to the main menu', 0Dh, 0Ah
   542 000005CB 6E20746F2074686520- <1>
   543 000005D4 6D61696E206D656E75- <1>
   544 000005DD 0D0A                <1>
   545 000005DF 0D0A                <1> 		db	0Dh, 0Ah
   546 000005E1 456E74657220796F75- <1> 		db	'Enter your selection: ', 00h
   547 000005EA 722073656C65637469- <1>
   548 000005F3 6F6E3A2000          <1>
   549 000005F8 [8900]              <1> tbl_floppy	dw	msg_none
   550 000005FA [2402]              <1> 		dw	msg_floppy_360
   551 000005FC [3202]              <1> 		dw	msg_floppy_1200
   552 000005FE [4002]              <1> 		dw	msg_floppy_720
   553 00000600 [4D02]              <1> 		dw	msg_floppy_1440
   554 00000602 [8900]              <1> 		dw	msg_none
   555 00000604 [5B02]              <1> 		dw	msg_floppy_2880
   556 00000606 [8900]              <1> 		dw	msg_none
   557                                  %include	"fnt80-FF.inc"		; font for graphics modes
   558                              <1> ;=========================================================================
   559                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   560                              <1> ;       Characters from 80h to 0FFh
   561                              <1> ;-------------------------------------------------------------------------
   562                              <1> ;
   563                              <1> ; Compiles with NASM 2.07, might work with other versions
   564                              <1> ;
   565                              <1> ; This font is borrowed from kbd package (alt-8x8)
   566                              <1> ;
   567                              <1> ; This program is free software: you can redistribute it and/or modify
   568                              <1> ; it under the terms of the GNU General Public License as published by
   569                              <1> ; the Free Software Foundation, either version 3 of the License, or
   570                              <1> ; (at your option) any later version.
   571                              <1> ;
   572                              <1> ; This program is distributed in the hope that it will be useful,
   573                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   574                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   575                              <1> ; GNU General Public License for more details.
   576                              <1> ;
   577                              <1> ; You should have received a copy of the GNU General Public License
   578                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   579                              <1> ;
   580                              <1> ;=========================================================================
   581                              <1> int_1F:
   582 00000608 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   583 00000610 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   584 00000618 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   585 00000620 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   586 00000628 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   587 00000630 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   588 00000638 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   589 00000640 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   590 00000648 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   591 00000650 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   592 00000658 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   593 00000660 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   594 00000668 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   595 00000670 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   596 00000678 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   597 00000680 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   598 00000688 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   599 00000690 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   600 00000698 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   601 000006A0 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   602 000006A8 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   603 000006B0 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   604 000006B8 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   605 000006C0 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   606 000006C8 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   607 000006D0 DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   608 000006D8 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   609 000006E0 C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   610 000006E8 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   611 000006F0 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   612 000006F8 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   613 00000700 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   614 00000708 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   615 00000710 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   616 00000718 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   617 00000720 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   618 00000728 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   619 00000730 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   620 00000738 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   621 00000740 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   622 00000748 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   623 00000750 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   624 00000758 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   625 00000760 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   626 00000768 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   627 00000770 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   628 00000778 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   629 00000780 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   630 00000788 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   631 00000790 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   632 00000798 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   633 000007A0 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   634 000007A8 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   635 000007B0 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   636 000007B8 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   637 000007C0 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   638 000007C8 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   639 000007D0 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   640 000007D8 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   641 000007E0 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   642 000007E8 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   643 000007F0 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   644 000007F8 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   645 00000800 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   646 00000808 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   647 00000810 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   648 00000818 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   649 00000820 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   650 00000828 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   651 00000830 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   652 00000838 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   653 00000840 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   654 00000848 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   655 00000850 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   656 00000858 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   657 00000860 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   658 00000868 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   659 00000870 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   660 00000878 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   661 00000880 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   662 00000888 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   663 00000890 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   664 00000898 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   665 000008A0 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   666 000008A8 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   667 000008B0 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   668 000008B8 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   669 000008C0 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   670 000008C8 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   671 000008D0 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   672 000008D8 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   673 000008E0 FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   674 000008E8 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   675 000008F0 F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   676 000008F8 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   677 00000900 FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   678 00000908 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   679 00000910 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   680 00000918 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   681 00000920 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   682 00000928 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   683 00000930 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   684 00000938 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   685 00000940 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   686 00000948 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   687 00000950 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   688 00000958 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   689 00000960 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   690 00000968 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   691 00000970 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   692 00000978 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   693 00000980 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   694 00000988 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   695 00000990 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   696 00000998 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   697 000009A0 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   698 000009A8 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   699 000009B0 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   700 000009B8 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   701 000009C0 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   702 000009C8 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   703 000009D0 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   704 000009D8 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   705 000009E0 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   706 000009E8 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   707 000009F0 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   708 000009F8 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   709 00000A00 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   710                                  ;%include	"inttrace.inc"		; XXX
   711                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   712                              <1> ;=========================================================================
   713                              <1> ; rtc.inc - RTC/CMOS read and write functions
   714                              <1> ;-------------------------------------------------------------------------
   715                              <1> ;
   716                              <1> ; Compiles with NASM 2.07, might work with other versions
   717                              <1> ;
   718                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   719                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   720                              <1> ;
   721                              <1> ; This program is free software: you can redistribute it and/or modify
   722                              <1> ; it under the terms of the GNU General Public License as published by
   723                              <1> ; the Free Software Foundation, either version 3 of the License, or
   724                              <1> ; (at your option) any later version.
   725                              <1> ;
   726                              <1> ; This program is distributed in the hope that it will be useful,
   727                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   728                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   729                              <1> ; GNU General Public License for more details.
   730                              <1> ;
   731                              <1> ; You should have received a copy of the GNU General Public License
   732                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   733                              <1> ;
   734                              <1> ;=========================================================================
   735                              <1> 
   736                              <1> ;-------------------------------------------------------------------------
   737                              <1> ; RTC ports
   738                              <1> rtc_addr_reg	equ	70h	; RTC address port
   739                              <1> rtc_data_reg	equ	71h	; RTC data port
   740                              <1> 
   741                              <1> ;-------------------------------------------------------------------------
   742                              <1> ; locations in RTC and NVRAM
   743                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   744                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   745                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   746                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   747                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   748                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   749                              <1> cmos_day	equ	06h	; day location in RTC
   750                              <1> cmos_date	equ	07h	; date location in RTC
   751                              <1> cmos_month	equ	08h	; month location in RTC
   752                              <1> cmos_year	equ	09h	; year location in RTC
   753                              <1> cmos_floppy	equ	10h	; floppy type byte
   754                              <1> cmos_equip	equ	14h	; equipment byte
   755                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   756                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   757                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   758                              <1> 
   759                              <1> ;-------------------------------------------------------------------------
   760                              <1> ; RTC control register and their bits
   761                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   762                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   763                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   764                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   765                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   766                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   767                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   768                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   769                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   770                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   771                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   772                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   773                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   774                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   775                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   776                              <1> 
   777                              <1> ;-------------------------------------------------------------------------
   778                              <1> ; NMI flag
   779                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   780                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   781                              <1> 
   782                              <1> ;=========================================================================
   783                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   784                              <1> ; Input:
   785                              <1> ;	AL - address and NMI enable bit
   786                              <1> ;		bits 6-0 - address of byte to read
   787                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   788                              <1> ; Output:
   789                              <1> ;	AL = byte from RTC
   790                              <1> ;-------------------------------------------------------------------------
   791                              <1> rtc_read:
   792 00000A08 FA                  <1> 	cli
   793 00000A09 E670                <1> 	out	rtc_addr_reg,al
   794 00000A0B EB00                <1> 	jmp	$+2
   795 00000A0D EB00                <1> 	jmp	$+2
   796 00000A0F E471                <1> 	in	al,rtc_data_reg
   797 00000A11 FB                  <1> 	sti
   798 00000A12 C3                  <1> 	ret
   799                              <1> 
   800                              <1> ;=========================================================================
   801                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   802                              <1> ; Input:
   803                              <1> ;	AL - address and NMI enable bit
   804                              <1> ;		bits 6-0 - address of byte to read
   805                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   806                              <1> ;	AH = byte to write to RTC
   807                              <1> ;-------------------------------------------------------------------------
   808                              <1> rtc_write:
   809 00000A13 FA                  <1> 	cli
   810 00000A14 E670                <1> 	out	rtc_addr_reg,al
   811 00000A16 EB00                <1> 	jmp	$+2
   812 00000A18 EB00                <1> 	jmp	$+2
   813 00000A1A 86E0                <1> 	xchg	ah,al
   814 00000A1C E671                <1> 	out	rtc_data_reg,al
   815 00000A1E 86E0                <1> 	xchg	ah,al
   816 00000A20 FB                  <1> 	sti
   817 00000A21 C3                  <1> 	ret
   818                              <1> 
   819                              <1> ;=========================================================================
   820                              <1> ; rtc_init - Initialize RTC
   821                              <1> ; Notes:
   822                              <1> ;	- makes sure RTC battery is OK, resets time if not
   823                              <1> ;	- disables RTC interrupts
   824                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   825                              <1> ;-------------------------------------------------------------------------
   826                              <1> rtc_init:
   827 00000A22 50                  <1> 	push	ax
   828 00000A23 53                  <1> 	push	bx
   829 00000A24 51                  <1> 	push	cx
   830 00000A25 52                  <1> 	push	dx
   831 00000A26 56                  <1> 	push	si
   832 00000A27 57                  <1> 	push	di
   833 00000A28 B00A                <1> 	mov	al,cmos_control_a	; select control A register
   834 00000A2A B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   835                              <1> 					; set SQW frequency to 1.024 KHz
   836 00000A2C E8E4FF              <1> 	call	rtc_write		; write control register A
   837                              <1> 
   838 00000A2F B00B                <1> 	mov	al,cmos_control_b
   839 00000A31 B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   840                              <1> 					; interrupts disabled
   841 00000A33 E8DDFF              <1> 	call	rtc_write		; write control register B
   842                              <1> 
   843 00000A36 B00C                <1> 	mov	al,cmos_control_c
   844 00000A38 E8CDFF              <1> 	call	rtc_read		; read control register C - reset
   845                              <1> 					; interrupt flags
   846                              <1> 
   847 00000A3B B00D                <1> 	mov	al,cmos_control_d
   848 00000A3D E8C8FF              <1> 	call	rtc_read		; read control register D
   849 00000A40 A880                <1> 	test	al,cmos_vrt
   850 00000A42 7518                <1> 	jnz	.1			; RTC battery is OK
   851 00000A44 BE[F903]            <1> 	mov	si,msg_rtc_bad
   852 00000A47 E8C817              <1> 	call	print
   853                              <1> ; RTC is bad, set initial time
   854 00000A4A B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   855 00000A4C 31C9                <1> 	xor	cx,cx
   856 00000A4E 31D2                <1> 	xor	dx,dx
   857 00000A50 CD1A                <1> 	int	1Ah
   858 00000A52 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   859 00000A54 B91020              <1> 	mov	cx,2010h		; year 2010
   860 00000A57 BA0101              <1> 	mov	dx,0101h		; January 1st
   861 00000A5A CD1A                <1> 	int	1Ah
   862                              <1> 
   863                              <1> .1:
   864                              <1> ; set timer variables to RTC time
   865 00000A5C B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   866 00000A5E CD1A                <1> 	int	1Ah
   867                              <1> 
   868                              <1> ; convert time to ticks * 2^11
   869                              <1> 
   870                              <1> ; ticks = seconds * 37287
   871 00000A60 88F0                <1> 	mov	al,dh
   872 00000A62 E8AE00              <1> 	call	bcd_to_binary		; convert seconds to binary
   873                              <1> 
   874 00000A65 BAA791              <1> 	mov	dx,37287
   875 00000A68 F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   876                              <1> 
   877 00000A6A 89C6                <1> 	mov	si,ax
   878 00000A6C 89D7                <1> 	mov	di,dx
   879                              <1> 
   880                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   881 00000A6E 88C8                <1> 	mov	al,cl
   882 00000A70 E8A000              <1> 	call	bcd_to_binary		; convert minutes to binary
   883                              <1> 
   884 00000A73 89C3                <1> 	mov	bx,ax
   885 00000A75 BA2023              <1> 	mov	dx,8992
   886 00000A78 F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   887                              <1> 
   888 00000A7A 01C6                <1> 	add	si,ax
   889 00000A7C 11D7                <1> 	adc	di,dx
   890                              <1> 
   891 00000A7E 89D8                <1> 	mov	ax,bx
   892 00000A80 BA2200              <1> 	mov	dx,34
   893 00000A83 F7E2                <1> 	mul	dx
   894                              <1> 
   895 00000A85 01C7                <1> 	add	di,ax
   896                              <1> 
   897                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   898 00000A87 88E8                <1> 	mov	al,ch
   899 00000A89 E88700              <1> 	call	bcd_to_binary		; convert hours to binary
   900                              <1> 
   901 00000A8C 89C3                <1> 	mov	bx,ax
   902 00000A8E BA6A3B              <1> 	mov	dx,15210
   903 00000A91 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   904                              <1> 
   905 00000A93 01C6                <1> 	add	si,ax
   906 00000A95 11D7                <1> 	adc	di,dx
   907                              <1> 
   908 00000A97 89D8                <1> 	mov	ax,bx
   909 00000A99 BA0008              <1> 	mov	dx,2048
   910 00000A9C F7E2                <1> 	mul	dx			; AX = hours * 2048
   911                              <1> 
   912 00000A9E 01C7                <1> 	add	di,ax
   913                              <1> 
   914                              <1> ; CX:DX = DI:SI / 2048
   915 00000AA0 B10B                <1> 	mov	cl,11
   916 00000AA2 D3EE                <1> 	shr	si,cl
   917 00000AA4 89FA                <1> 	mov	dx,di
   918 00000AA6 B105                <1> 	mov	cl,5
   919 00000AA8 D3E2                <1> 	shl	dx,cl
   920 00000AAA 09F2                <1> 	or	dx,si
   921                              <1> 
   922 00000AAC B10B                <1> 	mov	cl,11
   923 00000AAE D3EF                <1> 	shr	di,cl
   924 00000AB0 89F9                <1> 	mov	cx,di
   925                              <1> 
   926                              <1> 					; CX = high word of tick count
   927                              <1> 					; DX = low word of tick count
   928                              <1> 	
   929 00000AB2 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   930 00000AB4 CD1A                <1> 	int	1Ah	
   931                              <1> 
   932                              <1> 
   933                              <1> ; compare NVRAM checksum with stored value
   934                              <1> 
   935 00000AB6 E86C00              <1> 	call	rtc_checksum
   936                              <1> 
   937 00000AB9 B02E                <1> 	mov	al,cmos_sum_hi
   938 00000ABB E84AFF              <1> 	call	rtc_read
   939 00000ABE 88C4                <1> 	mov	ah,al
   940 00000AC0 B02F                <1> 	mov	al,cmos_sum_lo
   941 00000AC2 E843FF              <1> 	call	rtc_read
   942 00000AC5 39C3                <1> 	cmp	bx,ax
   943 00000AC7 742F                <1> 	je	.update_equipment
   944                              <1> 
   945 00000AC9 BE[1504]            <1> 	mov	si,msg_rtc_sum
   946 00000ACC E84317              <1> 	call	print
   947                              <1> 
   948                              <1> ; clear NVRAM
   949                              <1> 
   950 00000ACF B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   951                              <1> 
   952                              <1> .nvram_clear_loop:
   953 00000AD2 E83EFF              <1> 	call	rtc_write
   954 00000AD5 FEC0                <1> 	inc	al
   955 00000AD7 3C20                <1> 	cmp	al,20h			; last address is 20h
   956 00000AD9 76F7                <1> 	jbe	.nvram_clear_loop
   957                              <1> 
   958 00000ADB B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   959 00000ADE E832FF              <1> 	call	rtc_write
   960                              <1> 
   961 00000AE1 B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
   962 00000AE4 E82CFF              <1> 	call	rtc_write
   963                              <1> 
   964                              <1> ; update checksum
   965                              <1> 
   966 00000AE7 E83B00              <1> 	call	rtc_checksum
   967                              <1> 
   968 00000AEA B02E                <1> 	mov	al,cmos_sum_hi
   969 00000AEC 88FC                <1> 	mov	ah,bh
   970 00000AEE E822FF              <1> 	call	rtc_write
   971                              <1> 
   972 00000AF1 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
   973 00000AF3 88DC                <1> 	mov	ah,bl
   974 00000AF5 E81BFF              <1> 	call	rtc_write
   975                              <1> 
   976                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
   977                              <1> 
   978                              <1> .update_equipment:
   979 00000AF8 B014                <1> 	mov	al,cmos_equip
   980 00000AFA E80BFF              <1> 	call	rtc_read
   981 00000AFD 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
   982 00000AFF 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
   983 00000B04 08061000            <1> 	or	byte [equipment_list],al
   984                              <1> 
   985 00000B08 B020                <1> 	mov	al,e_rtc_init_ok	; RTC initialzied successfully
   986 00000B0A E680                <1> 	out	post_reg,al
   987                              <1> 
   988 00000B0C 5F                  <1> 	pop	di
   989 00000B0D 5E                  <1> 	pop	si
   990 00000B0E 5A                  <1> 	pop	dx
   991 00000B0F 59                  <1> 	pop	cx
   992 00000B10 5B                  <1> 	pop	bx
   993 00000B11 58                  <1> 	pop	ax
   994 00000B12 C3                  <1> 	ret
   995                              <1> 
   996                              <1> bcd_to_binary:
   997 00000B13 51                  <1> 	push	cx
   998 00000B14 88C5                <1> 	mov	ch,al
   999 00000B16 80E50F              <1> 	and	ch,0Fh
  1000 00000B19 B104                <1> 	mov	cl,4
  1001 00000B1B D2E8                <1> 	shr	al,cl
  1002 00000B1D B10A                <1> 	mov	cl,10
  1003 00000B1F F6E1                <1> 	mul	cl
  1004 00000B21 00E8                <1> 	add	al,ch
  1005 00000B23 59                  <1> 	pop	cx
  1006 00000B24 C3                  <1> 	ret
  1007                              <1> 
  1008                              <1> ;=========================================================================
  1009                              <1> ; rtc_checksum - calculate NVRAM checksum
  1010                              <1> ; Input:
  1011                              <1> ;	none
  1012                              <1> ; Output:
  1013                              <1> ;	BX = NVRAM checksum
  1014                              <1> ;-------------------------------------------------------------------------
  1015                              <1> rtc_checksum:
  1016 00000B25 50                  <1> 	push	ax
  1017 00000B26 31DB                <1> 	xor	bx,bx
  1018 00000B28 B410                <1> 	mov	ah,10h			; start from 10h
  1019                              <1> 
  1020                              <1> .checksum_loop:
  1021 00000B2A 88E0                <1> 	mov	al,ah
  1022 00000B2C E8D9FE              <1> 	call	rtc_read
  1023 00000B2F 00C3                <1> 	add	bl,al			; BX += AL
  1024 00000B31 80D700              <1> 	adc	bh,0
  1025 00000B34 FEC4                <1> 	inc	ah
  1026 00000B36 80FC20              <1> 	cmp	ah,20h			; last address is 20h
  1027 00000B39 76EF                <1> 	jbe	.checksum_loop
  1028 00000B3B 58                  <1> 	pop	ax
  1029 00000B3C C3                  <1> 	ret
  1030                              <1> 
  1031                              <1> ;=========================================================================
  1032                              <1> ; rtc_setup - NVRAM configuration utility
  1033                              <1> ; Input:
  1034                              <1> ;	none
  1035                              <1> ; Output:
  1036                              <1> ;	none
  1037                              <1> ;-------------------------------------------------------------------------
  1038                              <1> rtc_setup:
  1039 00000B3D 50                  <1> 	push	ax
  1040 00000B3E 53                  <1> 	push	bx
  1041 00000B3F 51                  <1> 	push	cx
  1042 00000B40 52                  <1> 	push	dx
  1043 00000B41 56                  <1> 	push	si
  1044                              <1> 
  1045 00000B42 B010                <1> 	mov	al,cmos_floppy
  1046 00000B44 E8C1FE              <1> 	call	rtc_read		; read currently configured floppies
  1047 00000B47 88C1                <1> 	mov	cl,al			; save it to CL
  1048                              <1> 
  1049                              <1> .menu_loop:
  1050 00000B49 BE[7C04]            <1> 	mov	si,msg_set_menu
  1051 00000B4C E8C316              <1> 	call	print
  1052                              <1> 
  1053                              <1> .menu_input:
  1054 00000B4F B400                <1> 	mov	ah,00h
  1055 00000B51 CD16                <1> 	int	16h
  1056 00000B53 0C20                <1> 	or	al,20h			; convert to lower case
  1057 00000B55 B200                <1> 	mov	dl,0			; floppy 0
  1058 00000B57 3C66                <1> 	cmp	al,'f'
  1059 00000B59 7417                <1> 	je	.set_floppy
  1060 00000B5B FEC2                <1> 	inc	dl			; floppy 1
  1061 00000B5D 3C67                <1> 	cmp	al,'g'
  1062 00000B5F 7411                <1> 	je	.set_floppy
  1063 00000B61 3C70                <1> 	cmp	al,'p'
  1064 00000B63 7458                <1> 	je	.print_settings
  1065 00000B65 3C77                <1> 	cmp	al,'w'
  1066 00000B67 7469                <1> 	je	.save
  1067 00000B69 3C71                <1> 	cmp	al,'q'
  1068 00000B6B 7503E99C00          <1> 	je	.exit
  1069 00000B70 EBDD                <1> 	jmp	.menu_input
  1070                              <1> 
  1071                              <1> .set_floppy:
  1072 00000B72 B40E                <1> 	mov	ah,0Eh			; echo
  1073 00000B74 BB0700              <1> 	mov	bx,0007h
  1074 00000B77 CD10                <1> 	int	10h
  1075 00000B79 BE[3F05]            <1> 	mov	si,msg_set_floppy
  1076 00000B7C E89316              <1> 	call	print
  1077                              <1> .floppy_input:
  1078 00000B7F B400                <1> 	mov	ah,00h
  1079 00000B81 CD16                <1> 	int	16h
  1080 00000B83 0C20                <1> 	or	al,20h			; convert to lower case
  1081 00000B85 3C71                <1> 	cmp	al,'q'
  1082 00000B87 742B                <1> 	je	.floppy_exit
  1083 00000B89 3C30                <1> 	cmp	al,'0'
  1084 00000B8B 72F2                <1> 	jb	.floppy_input
  1085 00000B8D 3C36                <1> 	cmp	al,'6'
  1086 00000B8F 77EE                <1> 	ja	.floppy_input
  1087 00000B91 3C35                <1> 	cmp	al,'5'
  1088 00000B93 74EA                <1> 	je	.floppy_input
  1089 00000B95 B40E                <1> 	mov	ah,0Eh			; echo
  1090 00000B97 BB0700              <1> 	mov	bx,0007h
  1091 00000B9A CD10                <1> 	int	10h
  1092 00000B9C 2C30                <1> 	sub	al,'0'
  1093 00000B9E B6F0                <1> 	mov	dh,0F0h
  1094 00000BA0 08D2                <1> 	or	dl,dl			; drive	0?
  1095 00000BA2 750A                <1> 	jnz	.drive_1
  1096 00000BA4 D0E0                <1> 	shl	al,1
  1097 00000BA6 D0E0                <1> 	shl	al,1
  1098 00000BA8 D0E0                <1> 	shl	al,1
  1099 00000BAA D0E0                <1> 	shl	al,1
  1100 00000BAC B60F                <1> 	mov	dh,0Fh
  1101                              <1> .drive_1:
  1102 00000BAE 20F1                <1> 	and	cl,dh
  1103 00000BB0 08C1                <1> 	or	cl,al
  1104 00000BB2 EB95                <1> 	jmp	.menu_loop
  1105                              <1> 
  1106                              <1> .floppy_exit:
  1107 00000BB4 B40E                <1> 	mov	ah,0Eh			; echo
  1108 00000BB6 BB0700              <1> 	mov	bx,0007h
  1109 00000BB9 CD10                <1> 	int	10h
  1110 00000BBB EB8C                <1> 	jmp	.menu_loop
  1111                              <1> 
  1112                              <1> .print_settings:
  1113 00000BBD B40E                <1> 	mov	ah,0Eh			; echo
  1114 00000BBF BB0700              <1> 	mov	bx,0007h
  1115 00000BC2 CD10                <1> 	int	10h
  1116 00000BC4 BE[8600]            <1> 	mov	si,msg_crlf
  1117 00000BC7 E84816              <1> 	call	print
  1118 00000BCA 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1119 00000BCC E8B309              <1> 	call	print_floppy
  1120 00000BCF E977FF              <1> 	jmp	.menu_loop
  1121                              <1> 
  1122                              <1> .save:
  1123 00000BD2 50                  <1> 	push	ax
  1124                              <1> 
  1125 00000BD3 B010                <1> 	mov	al,cmos_floppy
  1126 00000BD5 88CC                <1> 	mov	ah,cl
  1127 00000BD7 E839FE              <1> 	call	rtc_write
  1128                              <1> 
  1129 00000BDA 8A261000            <1> 	mov	ah,byte [equipment_list]
  1130 00000BDE 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1131                              <1> 
  1132 00000BE1 F6C170              <1> 	test	cl,70h
  1133 00000BE4 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1134 00000BE6 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1135                              <1> 
  1136                              <1> .second_floppy:
  1137 00000BE9 F6C107              <1> 	test	cl,07h
  1138 00000BEC 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1139 00000BEE 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1140                              <1> 					; (even if the first one is missing)
  1141                              <1> 
  1142                              <1> .save_equipment:
  1143 00000BF1 88261000            <1> 	mov	byte [equipment_list],ah
  1144 00000BF5 B014                <1> 	mov	al,cmos_equip
  1145 00000BF7 E819FE              <1> 	call	rtc_write
  1146                              <1> 
  1147 00000BFA E828FF              <1> 	call	rtc_checksum
  1148                              <1> 
  1149 00000BFD B02E                <1> 	mov	al,cmos_sum_hi
  1150 00000BFF 88FC                <1> 	mov	ah,bh
  1151 00000C01 E80FFE              <1> 	call	rtc_write
  1152                              <1> 
  1153 00000C04 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1154 00000C06 88DC                <1> 	mov	ah,bl
  1155 00000C08 E808FE              <1> 	call	rtc_write
  1156                              <1> 	
  1157 00000C0B 58                  <1> 	pop	ax
  1158                              <1> 
  1159                              <1> .exit:
  1160 00000C0C B40E                <1> 	mov	ah,0Eh			; echo
  1161 00000C0E BB0700              <1> 	mov	bx,0007h
  1162 00000C11 CD10                <1> 	int	10h
  1163 00000C13 BE[8600]            <1> 	mov	si,msg_crlf
  1164 00000C16 E8F915              <1> 	call	print
  1165 00000C19 5E                  <1> 	pop	si
  1166 00000C1A 5A                  <1> 	pop	dx
  1167 00000C1B 59                  <1> 	pop	cx
  1168 00000C1C 5B                  <1> 	pop	bx
  1169 00000C1D 58                  <1> 	pop	ax
  1170 00000C1E C3                  <1> 	ret
  1171                              <1> 
  1172                              <1> ;=========================================================================
  1173                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1174                              <1> ; Input:
  1175                              <1> ;	CX = time to delay (in 15 microsecond units)
  1176                              <1> ; Notes:
  1177                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1178                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1179                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1180                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1181                              <1> ;-------------------------------------------------------------------------
  1182                              <1> delay_15us:
  1183 00000C1F 50                  <1> 	push	ax
  1184 00000C20 51                  <1> 	push	cx
  1185                              <1> .zero:
  1186 00000C21 E461                <1> 	in	al,port_b_reg
  1187 00000C23 A810                <1> 	test	al,refresh_flag
  1188 00000C25 74FA                <1> 	jz	.zero
  1189 00000C27 49                  <1> 	dec	cx
  1190 00000C28 7409                <1> 	jz	.exit
  1191                              <1> .one:
  1192 00000C2A E461                <1> 	in	al,port_b_reg
  1193 00000C2C A810                <1> 	test	al,refresh_flag
  1194 00000C2E 75FA                <1> 	jnz	.one
  1195 00000C30 49                  <1> 	dec	cx
  1196 00000C31 75EE                <1> 	jnz	.zero
  1197                              <1> .exit:
  1198 00000C33 59                  <1> 	pop	cx
  1199 00000C34 58                  <1> 	pop	ax
  1200 00000C35 C3                  <1> 	ret
  1201                              <1> 
  1202                              <1> %if 0
  1203                              <1> ;=========================================================================
  1204                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1205                              <1> ; Input:
  1206                              <1> ;	DX:AX	- dividend
  1207                              <1> ;	CX	- divisor
  1208                              <1> ; Output:
  1209                              <1> ;	DX:AX	- quotient
  1210                              <1> ;-------------------------------------------------------------------------
  1211                              <1> divide_32:
  1212                              <1> 	or	dx,dx
  1213                              <1> 	jnz	.1
  1214                              <1> 	div	cx
  1215                              <1> 	xor	dx,dx
  1216                              <1> 	ret
  1217                              <1> .1:
  1218                              <1> 	push	bx
  1219                              <1> 	mov	bx,ax
  1220                              <1> 	mov	ax,dx
  1221                              <1> 	xor	dx,dx
  1222                              <1> 	div	cx
  1223                              <1> 	xchg	bx,ax
  1224                              <1> 	div	cx
  1225                              <1> 	mov	dx,bx
  1226                              <1> 	pop	bx
  1227                              <1> 	ret
  1228                              <1> %endif ; 0
  1229                                  %include	"time1.inc"		; time services
  1230                              <1> ;=========================================================================
  1231                              <1> ; time1.inc - BIOS Time Services
  1232                              <1> ;       INT 1Ah - BIOS Time Services
  1233                              <1> ;		functions AH=00h to AH=07h
  1234                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1235                              <1> ;-------------------------------------------------------------------------
  1236                              <1> ;
  1237                              <1> ; Compiles with NASM 2.07, might work with other versions
  1238                              <1> ;
  1239                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  1240                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1241                              <1> ;
  1242                              <1> ; This program is free software: you can redistribute it and/or modify
  1243                              <1> ; it under the terms of the GNU General Public License as published by
  1244                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1245                              <1> ; (at your option) any later version.
  1246                              <1> ;
  1247                              <1> ; This program is distributed in the hope that it will be useful,
  1248                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1249                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1250                              <1> ; GNU General Public License for more details.
  1251                              <1> ;
  1252                              <1> ; You should have received a copy of the GNU General Public License
  1253                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1254                              <1> ;
  1255                              <1> ;=========================================================================
  1256                              <1> 
  1257                              <1> ;=========================================================================
  1258                              <1> ; int_1A_fn00 - Read current time
  1259                              <1> ; Input:
  1260                              <1> ;	AH = 0 - read current time
  1261                              <1> ; Output:
  1262                              <1> ;	CX = high word of tick count
  1263                              <1> ;	DX = low word of tick count
  1264                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1265                              <1> ;-------------------------------------------------------------------------
  1266                              <1> int_1A_fn00:
  1267 00000C36 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1268 00000C3A 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1269 00000C3E A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1270 00000C41 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1271 00000C45 E94D72              <1> 	jmp	int_1A_exit
  1272                              <1> 
  1273                              <1> ;=========================================================================
  1274                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1275                              <1> ; Input:
  1276                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1277                              <1> ;	CX = high word of tick count
  1278                              <1> ;	DX = low word of tick count
  1279                              <1> ; Output:
  1280                              <1> ;	None
  1281                              <1> ;-------------------------------------------------------------------------
  1282                              <1> int_1A_fn01:
  1283 00000C48 89166C00            <1> 	mov	word [ticks_lo],dx
  1284 00000C4C 890E6E00            <1> 	mov	word [ticks_hi],cx
  1285 00000C50 C606700000          <1> 	mov	byte [new_day],00h
  1286 00000C55 E93D72              <1> 	jmp	int_1A_exit
  1287                              <1> 
  1288                              <1> ;=========================================================================
  1289                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1290                              <1> ; Input:
  1291                              <1> ;	AH = 02h - function 02h - read RTC time
  1292                              <1> ; Output:
  1293                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1294                              <1> ;	CH = BCD hours
  1295                              <1> ;	CL = BCD minutes
  1296                              <1> ;	DH = BCD seconds
  1297                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1298                              <1> ;-------------------------------------------------------------------------
  1299                              <1> int_1A_fn02:
  1300 00000C58 50                  <1> 	push	ax
  1301 00000C59 B00A                <1> 	mov	al,cmos_control_a
  1302 00000C5B E8AAFD              <1> 	call	rtc_read		; read control A register
  1303 00000C5E A880                <1> 	test	al,cmos_uip
  1304 00000C60 7405                <1> 	jz	.1			; no update in progess
  1305 00000C62 F9                  <1> 	stc
  1306 00000C63 58                  <1> 	pop	ax
  1307 00000C64 E93172              <1> 	jmp	int_1A_exitf
  1308                              <1> .1:
  1309 00000C67 B00B                <1> 	mov	al,cmos_control_b
  1310 00000C69 E89CFD              <1> 	call	rtc_read		; read control B register
  1311 00000C6C 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1312 00000C6E 88C2                <1> 	mov	dl,al
  1313 00000C70 B000                <1> 	mov	al,cmos_seconds
  1314 00000C72 E893FD              <1> 	call	rtc_read		; read seconds
  1315 00000C75 88C6                <1> 	mov	dh,al
  1316 00000C77 B002                <1> 	mov	al,cmos_minutes
  1317 00000C79 E88CFD              <1> 	call	rtc_read		; read minutes
  1318 00000C7C 88C1                <1> 	mov	cl,al
  1319 00000C7E B004                <1> 	mov	al,cmos_hours
  1320 00000C80 E885FD              <1> 	call	rtc_read		; read hours
  1321 00000C83 88C5                <1> 	mov	ch,al
  1322 00000C85 F8                  <1> 	clc
  1323 00000C86 58                  <1> 	pop	ax
  1324 00000C87 E90E72              <1> 	jmp	int_1A_exitf
  1325                              <1> 
  1326                              <1> ;=========================================================================
  1327                              <1> ; int_1A_fn03 - Set real time clock
  1328                              <1> ; Input:
  1329                              <1> ;	AH = 03h - function 03h - set RTC time
  1330                              <1> ;	CH = BCD hours
  1331                              <1> ;	CL = BCD minutes
  1332                              <1> ;	DH = BCD seconds
  1333                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1334                              <1> ; Output:
  1335                              <1> ;	None
  1336                              <1> ;-------------------------------------------------------------------------
  1337                              <1> int_1A_fn03:
  1338 00000C8A 50                  <1> 	push	ax
  1339 00000C8B B00B                <1> 	mov	al,cmos_control_b
  1340 00000C8D E878FD              <1> 	call	rtc_read		; read control B register
  1341 00000C90 88C4                <1> 	mov	ah,al
  1342 00000C92 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1343 00000C95 B00B                <1> 	mov	al,cmos_control_b
  1344 00000C97 E879FD              <1> 	call	rtc_write		; write control B register
  1345                              <1> 
  1346 00000C9A 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1347 00000C9D 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1348 00000CA0 08D4                <1> 	or	ah,dl			; add it from the input
  1349 00000CA2 B00B                <1> 	mov	al,cmos_control_b
  1350 00000CA4 E86CFD              <1> 	call	rtc_write		; write control B register
  1351                              <1> 
  1352 00000CA7 B000                <1> 	mov	al,cmos_seconds
  1353 00000CA9 88F4                <1> 	mov	ah,dh
  1354 00000CAB E865FD              <1> 	call	rtc_write		; write seconds
  1355 00000CAE B002                <1> 	mov	al,cmos_minutes
  1356 00000CB0 88CC                <1> 	mov	ah,cl
  1357 00000CB2 E85EFD              <1> 	call	rtc_write		; write minutes
  1358 00000CB5 B004                <1> 	mov	al,cmos_hours
  1359 00000CB7 88EC                <1> 	mov	ah,ch
  1360 00000CB9 E857FD              <1> 	call	rtc_write		; write hours
  1361                              <1> 
  1362 00000CBC B00B                <1> 	mov	al,cmos_control_b
  1363 00000CBE E847FD              <1> 	call	rtc_read		; read control B register
  1364 00000CC1 88C4                <1> 	mov	ah,al
  1365 00000CC3 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1366 00000CC6 B00B                <1> 	mov	al,cmos_control_b
  1367 00000CC8 E848FD              <1> 	call	rtc_write		; write control B register
  1368 00000CCB 58                  <1> 	pop	ax
  1369 00000CCC E9C671              <1> 	jmp	int_1A_exit
  1370                              <1> 
  1371                              <1> ;=========================================================================
  1372                              <1> ; int_1A_fn04 - Read date from real time clock
  1373                              <1> ; Input:
  1374                              <1> ;	AH = 04h - function 04h - read RTC date
  1375                              <1> ; Output:
  1376                              <1> ;	CH = BCD century
  1377                              <1> ;	CL = BCD year
  1378                              <1> ;	DH = BCD month
  1379                              <1> ;	DL = BCD date
  1380                              <1> ;-------------------------------------------------------------------------
  1381                              <1> int_1A_fn04:
  1382 00000CCF 50                  <1> 	push	ax
  1383 00000CD0 B00A                <1> 	mov	al,cmos_control_a
  1384 00000CD2 E833FD              <1> 	call	rtc_read		; read control A register
  1385 00000CD5 A880                <1> 	test	al,cmos_uip
  1386 00000CD7 7405                <1> 	jz	.1			; no update in progess
  1387 00000CD9 F9                  <1> 	stc
  1388 00000CDA 58                  <1> 	pop	ax
  1389 00000CDB E9BA71              <1> 	jmp	int_1A_exitf
  1390                              <1> .1:
  1391 00000CDE B007                <1> 	mov	al,cmos_date
  1392 00000CE0 E825FD              <1> 	call	rtc_read		; read date
  1393 00000CE3 88C2                <1> 	mov	dl,al
  1394 00000CE5 B008                <1> 	mov	al,cmos_month
  1395 00000CE7 E81EFD              <1> 	call	rtc_read		; read month
  1396 00000CEA 88C6                <1> 	mov	dh,al
  1397 00000CEC B009                <1> 	mov	al,cmos_year
  1398 00000CEE E817FD              <1> 	call	rtc_read		; read year
  1399 00000CF1 88C1                <1> 	mov	cl,al
  1400 00000CF3 B032                <1> 	mov	al,cmos_century
  1401 00000CF5 E810FD              <1> 	call	rtc_read		; read century
  1402 00000CF8 88C5                <1> 	mov	ch,al
  1403 00000CFA F8                  <1> 	clc
  1404 00000CFB 58                  <1> 	pop	ax
  1405 00000CFC E99971              <1> 	jmp	int_1A_exitf
  1406                              <1> 
  1407                              <1> ;=========================================================================
  1408                              <1> ; int_1A_fn05 - Set date inreal time clock
  1409                              <1> ; Input:
  1410                              <1> ;	AH = 05h - function 05h - set RTC date
  1411                              <1> ;	CH = BCD century
  1412                              <1> ;	CL = BCD year
  1413                              <1> ;	DH = BCD month
  1414                              <1> ;	DL = BCD date
  1415                              <1> ; Output:
  1416                              <1> ;	None
  1417                              <1> ;-------------------------------------------------------------------------
  1418                              <1> int_1A_fn05:
  1419 00000CFF 50                  <1> 	push	ax
  1420 00000D00 B00B                <1> 	mov	al,cmos_control_b
  1421 00000D02 E803FD              <1> 	call	rtc_read		; read control B register
  1422 00000D05 88C4                <1> 	mov	ah,al
  1423 00000D07 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1424 00000D0A B00B                <1> 	mov	al,cmos_control_b
  1425 00000D0C E804FD              <1> 	call	rtc_write		; write control B register
  1426                              <1> 
  1427 00000D0F B007                <1> 	mov	al,cmos_date
  1428 00000D11 88D4                <1> 	mov	ah,dl
  1429 00000D13 E8FDFC              <1> 	call	rtc_write		; write date
  1430                              <1> 
  1431 00000D16 B008                <1> 	mov	al,cmos_month
  1432 00000D18 88F4                <1> 	mov	ah,dh
  1433 00000D1A E8F6FC              <1> 	call	rtc_write		; write month
  1434 00000D1D B009                <1> 	mov	al,cmos_year
  1435 00000D1F 88CC                <1> 	mov	ah,cl
  1436 00000D21 E8EFFC              <1> 	call	rtc_write		; write year
  1437 00000D24 B032                <1> 	mov	al,cmos_century
  1438 00000D26 88EC                <1> 	mov	ah,ch
  1439 00000D28 E8E8FC              <1> 	call	rtc_write		; write centry
  1440                              <1> 
  1441 00000D2B B00B                <1> 	mov	al,cmos_control_b
  1442 00000D2D E8D8FC              <1> 	call	rtc_read		; read control B register
  1443 00000D30 88C4                <1> 	mov	ah,al
  1444 00000D32 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1445 00000D35 B00B                <1> 	mov	al,cmos_control_b
  1446 00000D37 E8D9FC              <1> 	call	rtc_write		; write control B register
  1447 00000D3A 58                  <1> 	pop	ax
  1448 00000D3B E95771              <1> 	jmp	int_1A_exit
  1449                              <1> 
  1450                              <1> ;=========================================================================
  1451                              <1> ; int_1A_fn06 - Set real time clock alarm
  1452                              <1> ; Input:
  1453                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1454                              <1> ;	CH = BCD hours
  1455                              <1> ;	CL = BCD minutes
  1456                              <1> ;	DH = BCD seconds
  1457                              <1> ; Output:
  1458                              <1> ;	CF = 1 - alarm already set
  1459                              <1> ;-------------------------------------------------------------------------
  1460                              <1> int_1A_fn06:
  1461 00000D3E 50                  <1> 	push	ax
  1462 00000D3F B00B                <1> 	mov	al,cmos_control_b
  1463 00000D41 E8C4FC              <1> 	call	rtc_read		; read control B register
  1464 00000D44 A820                <1> 	test	al,cmos_aie
  1465 00000D46 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1466 00000D48 F9                  <1> 	stc
  1467 00000D49 58                  <1> 	pop	ax
  1468 00000D4A E94B71              <1> 	jmp	int_1A_exitf
  1469                              <1> .1:
  1470 00000D4D 88C4                <1> 	mov	ah,al
  1471 00000D4F 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1472 00000D52 B00B                <1> 	mov	al,cmos_control_b
  1473 00000D54 E8BCFC              <1> 	call	rtc_write		; write control B register
  1474                              <1> 
  1475 00000D57 B001                <1> 	mov	al,cmos_alarm_secs
  1476 00000D59 88F4                <1> 	mov	ah,dh
  1477 00000D5B E8B5FC              <1> 	call	rtc_write		; write alarm seconds
  1478 00000D5E B003                <1> 	mov	al,cmos_alarm_mins
  1479 00000D60 88CC                <1> 	mov	ah,cl
  1480 00000D62 E8AEFC              <1> 	call	rtc_write		; write alarm minutes
  1481 00000D65 B005                <1> 	mov	al,cmos_alarm_hrs
  1482 00000D67 88EC                <1> 	mov	ah,ch
  1483 00000D69 E8A7FC              <1> 	call	rtc_write		; write alarm hours
  1484                              <1> 
  1485 00000D6C B00B                <1> 	mov	al,cmos_control_b
  1486 00000D6E E897FC              <1> 	call	rtc_read		; read control B register
  1487 00000D71 88C4                <1> 	mov	ah,al
  1488 00000D73 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1489 00000D76 B00B                <1> 	mov	al,cmos_control_b
  1490 00000D78 E898FC              <1> 	call	rtc_write		; write control B register
  1491                              <1> 
  1492 00000D7B B00B                <1> 	mov	al,cmos_control_b
  1493 00000D7D E888FC              <1> 	call	rtc_read		; read control B register
  1494 00000D80 88C4                <1> 	mov	ah,al
  1495 00000D82 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1496 00000D85 B00B                <1> 	mov	al,cmos_control_b
  1497 00000D87 E889FC              <1> 	call	rtc_write		; write control B register with AIE set
  1498                              <1> 
  1499 00000D8A 58                  <1> 	pop	ax
  1500 00000D8B F8                  <1> 	clc
  1501 00000D8C E90971              <1> 	jmp	int_1A_exitf
  1502                              <1> 
  1503                              <1> ;=========================================================================
  1504                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1505                              <1> ; Input:
  1506                              <1> ;	AH = 07h - function 07h - set RTC time
  1507                              <1> ; Output:
  1508                              <1> ;	None
  1509                              <1> ;-------------------------------------------------------------------------
  1510                              <1> int_1A_fn07:
  1511 00000D8F 50                  <1> 	push	ax
  1512                              <1> 
  1513 00000D90 B00B                <1> 	mov	al,cmos_control_b
  1514 00000D92 E873FC              <1> 	call	rtc_read		; read control B register
  1515 00000D95 88C4                <1> 	mov	ah,al
  1516 00000D97 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1517 00000D9A B00B                <1> 	mov	al,cmos_control_b
  1518 00000D9C E874FC              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1519                              <1> 
  1520 00000D9F 58                  <1> 	pop	ax
  1521 00000DA0 E9F270              <1> 	jmp	int_1A_exit
  1522                              <1> 	
  1523                              <1> ;=========================================================================
  1524                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1525                              <1> ; Notes:
  1526                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1527                              <1> ;-------------------------------------------------------------------------
  1528                              <1> int_70:
  1529 00000DA3 50                  <1> 	push	ax
  1530 00000DA4 B020                <1> 	mov	al,20h
  1531 00000DA6 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1532 00000DA8 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1533 00000DAA B00C                <1> 	mov	al,cmos_control_c
  1534 00000DAC E859FC              <1> 	call	rtc_read		; read control C register
  1535 00000DAF A840                <1> 	test	al,cmos_af		; check for alarm flag
  1536 00000DB1 7402                <1> 	jz	.1
  1537 00000DB3 CD4A                <1> 	int	4Ah			; call INT 4Ah
  1538                              <1> .1:
  1539 00000DB5 58                  <1> 	pop	ax
  1540 00000DB6 CF                  <1> 	iret
  1541                                  %include	"floppy1.inc"		; floppy services
  1542                              <1> ;=========================================================================
  1543                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
  1544                              <1> ;       INT 13h, function AH=00h
  1545                              <1> ;       INT 13h, function AH=01h
  1546                              <1> ;       INT 13h, function AH=08h
  1547                              <1> ;       INT 13h, function AH=15h
  1548                              <1> ;       INT 13h, function AH=16h
  1549                              <1> ;       INT 13h, function AH=17h
  1550                              <1> ;       INT 13h, function AH=18h
  1551                              <1> ;       INT 13h, function AH=08h
  1552                              <1> ;	- see floppy2.inc for other INT 13h functions
  1553                              <1> ;-------------------------------------------------------------------------
  1554                              <1> ;
  1555                              <1> ; Compiles with NASM 2.07, might work with other versions
  1556                              <1> ;
  1557                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  1558                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1559                              <1> ;
  1560                              <1> ; This program is free software: you can redistribute it and/or modify
  1561                              <1> ; it under the terms of the GNU General Public License as published by
  1562                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1563                              <1> ; (at your option) any later version.
  1564                              <1> ;
  1565                              <1> ; This program is distributed in the hope that it will be useful,
  1566                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1567                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1568                              <1> ; GNU General Public License for more details.
  1569                              <1> ;
  1570                              <1> ; You should have received a copy of the GNU General Public License
  1571                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1572                              <1> ;
  1573                              <1> ;=========================================================================
  1574                              <1> 
  1575                              <1> ;-------------------------------------------------------------------------
  1576                              <1> ; FDC registers
  1577                              <1> 
  1578                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1579                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1580                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1581                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1582                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1583                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1584                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1585                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1586                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1587                              <1> 
  1588                              <1> ;-------------------------------------------------------------------------
  1589                              <1> ; DMAC registers
  1590                              <1> 
  1591                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1592                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1593                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1594                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1595                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1596                              <1> 					; first / last flip-flop
  1597                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1598                              <1> 
  1599                              <1> ;-------------------------------------------------------------------------
  1600                              <1> ; Floppy disk services - error codes
  1601                              <1> 
  1602                              <1> fdc_e_success	equ	00h		; successful completion
  1603                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1604                              <1> fdc_e_address	equ	02h		; address mark not found
  1605                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1606                              <1> fdc_e_notfound	equ	04h		; sector not found
  1607                              <1> fdc_e_changed	equ	06h		; disk changed
  1608                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1609                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1610                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1611                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1612                              <1> fdc_e_failure	equ	20h		; controller failure
  1613                              <1> fdc_e_seek	equ	40h		; seek failed
  1614                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1615                              <1> 
  1616                              <1> ;-------------------------------------------------------------------------
  1617                              <1> ; Drive media state for fdc_media_state
  1618                              <1> 
  1619                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1620                              <1> fdc_m_established	equ	10h	; bit 4:    media/drive established
  1621                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1622                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1623                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1624                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1625                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1626                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1627                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1628                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1629                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  1630                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  1631                              <1> 
  1632                              <1> ;-------------------------------------------------------------------------
  1633                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  1634                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  1635                              <1> 
  1636                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  1637                              <1> 
  1638                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  1639                              <1> ;	       unset for read or verify
  1640                              <1> 
  1641                              <1> fdc_write_flag	equ	80h		; write or format operation
  1642                              <1> 
  1643                              <1> ;-------------------------------------------------------------------------
  1644                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  1645                              <1> 
  1646                              <1> cmos_no_floppy	equ	00h
  1647                              <1> cmos_360	equ	01h
  1648                              <1> cmos_1200	equ	02h
  1649                              <1> cmos_720	equ	03h
  1650                              <1> cmos_1440	equ	04h
  1651                              <1> cmos_2880	equ	06h
  1652                              <1> 
  1653                              <1> ;=========================================================================
  1654                              <1> ; int_13_fn00: Reset disk system
  1655                              <1> ; Input:
  1656                              <1> ;	AH = 00h
  1657                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1658                              <1> ; Output:
  1659                              <1> ;	CF clear if successful
  1660                              <1> ;		AH = 00h - successful completion
  1661                              <1> ;	CF set on error
  1662                              <1> ;		AH = 20h - controller failure
  1663                              <1> ;		AH = 80h - timeout / device not ready
  1664                              <1> ; Note:
  1665                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1666                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1667                              <1> ;-------------------------------------------------------------------------
  1668                              <1> int_13_fn00:
  1669 00000DB7 E80700              <1> 	call	fdc_init
  1670 00000DBA 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1671 00000DBE E9155F              <1> 	jmp	int_13_exit
  1672                              <1> 
  1673                              <1> ;=========================================================================
  1674                              <1> ; fdc_init - Initialize floppy disk controller
  1675                              <1> ; Input:
  1676                              <1> ;	none
  1677                              <1> ; Output:
  1678                              <1> ;	CF clear on success
  1679                              <1> ;		AH = 00h - successful completion
  1680                              <1> ;	CF set if error
  1681                              <1> ;		AH = 20h - controller failure
  1682                              <1> ;		AH = 80h - timeout / device not ready
  1683                              <1> ;-------------------------------------------------------------------------
  1684                              <1> fdc_init:
  1685 00000DC1 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  1686 00000DC6 E80906              <1> 	call	fdc_reset		; reset FDC
  1687 00000DC9 7257                <1> 	jc	fdc_init_error
  1688 00000DCB BAF403              <1> 	mov	dx,fdc_status_reg
  1689 00000DCE EC                  <1> 	in	al,dx
  1690 00000DCF A880                <1> 	test	al,80h
  1691 00000DD1 7404                <1> 	jz	.try_again		; try again if FDC not ready
  1692 00000DD3 A840                <1> 	test	al,40h
  1693 00000DD5 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  1694                              <1> .try_again:
  1695 00000DD7 E8F805              <1> 	call	fdc_reset
  1696 00000DDA BAF403              <1> 	mov	dx,fdc_status_reg
  1697 00000DDD EC                  <1> 	in	al,dx
  1698 00000DDE A880                <1> 	test	al,80h
  1699 00000DE0 7440                <1> 	jz	fdc_init_error
  1700 00000DE2 A840                <1> 	test	al,40h
  1701 00000DE4 753C                <1> 	jnz	fdc_init_error
  1702                              <1> .fdc_ready:
  1703 00000DE6 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  1704 00000DE8 E83905              <1> 	call	fdc_write		; send the command
  1705 00000DEB 7235                <1> 	jc	fdc_init_error
  1706 00000DED E88105              <1> 	call	fdc_read		; read ST0
  1707 00000DF0 7230                <1> 	jc	fdc_init_error
  1708 00000DF2 A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  1709 00000DF5 88C4                <1> 	mov	ah,al			; save AL to AH
  1710 00000DF7 E87705              <1> 	call	fdc_read		; read current cylinder
  1711 00000DFA 7226                <1> 	jc	fdc_init_error
  1712 00000DFC A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  1713 00000DFF 80E4C0              <1> 	and	ah,0C0h
  1714 00000E02 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  1715 00000E05 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  1716                              <1> 
  1717                              <1> ; fall through to fdc_send_specify
  1718                              <1> 
  1719                              <1> ;=========================================================================
  1720                              <1> ; fdc_send_specify - Send specify command to FDC
  1721                              <1> ; Input:
  1722                              <1> ;	none
  1723                              <1> ; Output:
  1724                              <1> ;	CF clear on success
  1725                              <1> ;		AH = 00 - successful completion
  1726                              <1> ;	CF set if error
  1727                              <1> ;		AH = 20h - controller failure
  1728                              <1> ;	AX,CL,SI trashed
  1729                              <1> ; Note:
  1730                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  1731                              <1> ;-------------------------------------------------------------------------
  1732                              <1> fdc_send_specify:
  1733                              <1> 
  1734 00000E07 1E                  <1> 	push	ds
  1735 00000E08 31C0                <1> 	xor	ax,ax
  1736 00000E0A 8ED8                <1> 	mov	ds,ax
  1737 00000E0C C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1738 00000E10 B003                <1> 	mov	al,3		 	; FDC Specify command
  1739 00000E12 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  1740 00000E14 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  1741 00000E17 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  1742 00000E19 1F                  <1> 	pop	ds
  1743 00000E1A E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  1744 00000E1D 7203                <1> 	jc	fdc_init_error
  1745 00000E1F B400                <1> 	mov	ah,fdc_e_success	; successful completion
  1746 00000E21 C3                  <1> 	ret
  1747                              <1> 
  1748                              <1> fdc_init_error:
  1749 00000E22 B420                <1> 	mov	ah,fdc_e_failure
  1750 00000E24 F9                  <1> 	stc
  1751 00000E25 C3                  <1> 	ret
  1752                              <1> 
  1753                              <1> ;=========================================================================
  1754                              <1> ; int_13_fn01 - Get status of last operation
  1755                              <1> ; Input:
  1756                              <1> ;	AH = 01h
  1757                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1758                              <1> ; Output:
  1759                              <1> ;	CF clear if last operation was successful
  1760                              <1> ;		AH = 00h - successful completion
  1761                              <1> ;	CF set on error
  1762                              <1> ;		AH - error code of the last operation
  1763                              <1> ; Note:
  1764                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1765                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1766                              <1> ;-------------------------------------------------------------------------
  1767                              <1> int_13_fn01:
  1768 00000E26 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  1769 00000E2A 08E4                <1> 	or	ah,ah
  1770 00000E2C 7401                <1> 	jz	.no_error
  1771 00000E2E F9                  <1> 	stc
  1772                              <1> .no_error:
  1773 00000E2F E9A45E              <1> 	jmp	int_13_exit
  1774                              <1> 
  1775                              <1> ;=========================================================================
  1776                              <1> ; int_13_fn08: Get drive parameters
  1777                              <1> ; Input:
  1778                              <1> ;	AH = 08h
  1779                              <1> ;	DL = drive number (0 - 7Fh)
  1780                              <1> ; Output:
  1781                              <1> ;	CF clear if successful
  1782                              <1> ;		AX = 0000h
  1783                              <1> ;		BH = 00h
  1784                              <1> ;		BL = CMOS drive type
  1785                              <1> ;		CH = maximal cylinder number - 1
  1786                              <1> ;		CL = maximal sector number
  1787                              <1> ;		DH = maximal head number
  1788                              <1> ;		DL = number of drives
  1789                              <1> ;		ES:DI -> diskette parameter table
  1790                              <1> ;	CF set on error
  1791                              <1> ;		AH = 01h - drive number is greater than 7Fh
  1792                              <1> ; Notes:
  1793                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  1794                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  1795                              <1> ;	- If media type is not established function sets media parameters 
  1796                              <1> ;	based on CMOS drive type
  1797                              <1> ;-------------------------------------------------------------------------
  1798                              <1> int_13_fn08:
  1799 00000E32 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  1800 00000E35 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  1801 00000E3A A01000              <1> 	mov	al,byte [equipment_list]
  1802 00000E3D 2441                <1> 	and	al,equip_floppies|equip_floppy2
  1803 00000E3F B402                <1> 	mov	ah,2			; assume two floppy drives
  1804 00000E41 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  1805 00000E43 7406                <1> 	je	.check_drive_number
  1806 00000E45 FECC                <1> 	dec	ah			; assume one floppy drive
  1807 00000E47 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  1808 00000E49 757C                <1> 	jne	.no_drives
  1809                              <1> 
  1810                              <1> .check_drive_number:
  1811 00000E4B 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  1812 00000E4E 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  1813                              <1> 					; than number of disks?
  1814 00000E50 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  1815 00000E52 E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  1816 00000E55 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  1817                              <1> 
  1818 00000E57 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  1819 00000E5B 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  1820 00000E5E 8CC9                <1> 	mov	cx,cs
  1821 00000E60 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  1822                              <1> 
  1823 00000E62 3C01                <1> 	cmp	al,cmos_360
  1824 00000E64 7417                <1> 	je	.set_360
  1825 00000E66 3C03                <1> 	cmp	al,cmos_720
  1826 00000E68 741E                <1> 	je	.set_720
  1827 00000E6A 3C02                <1> 	cmp	al,cmos_1200
  1828 00000E6C 7425                <1> 	je	.set_1200
  1829 00000E6E 3C04                <1> 	cmp	al,cmos_1440
  1830 00000E70 742C                <1> 	je	.set_1440
  1831                              <1> 
  1832                              <1> .set_2880:
  1833 00000E72 B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  1834 00000E74 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  1835 00000E78 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  1836 00000E7B EB2A                <1> 	jmp	.set_media_type
  1837                              <1> 
  1838                              <1> .set_360:
  1839 00000E7D B093                <1> 	mov	al,fdc_m_360in360
  1840 00000E7F 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  1841 00000E83 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  1842 00000E86 EB1F                <1> 	jmp	.set_media_type
  1843                              <1> 
  1844                              <1> .set_720:
  1845 00000E88 B097                <1> 	mov	al,fdc_m_720
  1846 00000E8A 8D3E[896F]          <1> 	lea	di,[media_720]
  1847 00000E8E B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  1848 00000E91 EB14                <1> 	jmp	.set_media_type
  1849                              <1> 
  1850                              <1> .set_1200:
  1851 00000E93 B002                <1> 	mov	al,fdc_m_try_1200in1200
  1852 00000E95 8D3E[7C6F]          <1> 	lea	di,[media_1200]
  1853 00000E99 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  1854 00000E9C EB09                <1> 	jmp	.set_media_type
  1855                              <1> 
  1856                              <1> .set_1440:
  1857 00000E9E B007                <1> 	mov	al,fdc_m_try_1440
  1858 00000EA0 8D3E[966F]          <1> 	lea	di,[media_1440]
  1859 00000EA4 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  1860                              <1> 
  1861                              <1> .set_media_type:
  1862 00000EA7 BB9000              <1> 	mov	bx,fdc_media_state
  1863 00000EAA 00D3                <1> 	add	bl,dl			; BX -> drive media state
  1864 00000EAC F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  1865 00000EAF 7502                <1> 	jnz	.set_parameters		; no need to update if established
  1866 00000EB1 8807                <1> 	mov	[bx],al
  1867                              <1> 
  1868                              <1> .set_parameters:
  1869 00000EB3 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  1870 00000EB5 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  1871 00000EB8 A24100              <1> 	mov	byte [fdc_last_error],al
  1872 00000EBB 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  1873 00000EBE 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  1874 00000EC1 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  1875 00000EC4 E90F5E              <1> 	jmp	int_13_exit
  1876                              <1> 
  1877                              <1> .no_drives:
  1878 00000EC7 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  1879                              <1> 
  1880                              <1> .non_existent_drive:
  1881 00000ECB 31C9                <1> 	xor	cx,cx
  1882 00000ECD 31FF                <1> 	xor	di,di
  1883 00000ECF 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  1884 00000ED2 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  1885 00000ED5 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  1886 00000ED7 EBDA                <1> 	jmp	.set_parameters
  1887                              <1> 
  1888                              <1> .invalid_drive:
  1889 00000ED9 B401                <1> 	mov	ah,fdc_e_invalid
  1890 00000EDB F9                  <1> 	stc
  1891 00000EDC E9F75D              <1> 	jmp	int_13_exit
  1892                              <1> 
  1893                              <1> ;=========================================================================
  1894                              <1> ; int_13_fn15: Get disk type
  1895                              <1> ; Input:
  1896                              <1> ;	AH = 15h
  1897                              <1> ;	DL = drive number (0 or 1)
  1898                              <1> ; Output:
  1899                              <1> ;	AH = type code:
  1900                              <1> ;		00h - no such drive (invalid drive specified)
  1901                              <1> ;		01h - floppy without change-line support
  1902                              <1> ;		02h - floppy with change-line support
  1903                              <1> ;-------------------------------------------------------------------------
  1904                              <1> int_13_fn15:
  1905 00000EDF B400                <1> 	mov	ah,00h			; assume no drive
  1906 00000EE1 80FA01              <1> 	cmp	dl,1
  1907 00000EE4 7711                <1> 	ja	.exit			; jump if invalid drive number
  1908 00000EE6 E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  1909 00000EE9 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  1910 00000EEB B401                <1> 	mov	ah,01h			; assume no change-line support
  1911 00000EED 3C01                <1> 	cmp	al,cmos_360
  1912 00000EEF 7406                <1> 	je	.exit
  1913 00000EF1 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  1914 00000EF3 7402                <1> 	je	.exit
  1915 00000EF5 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  1916                              <1> 
  1917                              <1> .exit:
  1918 00000EF7 F8                  <1> 	clc
  1919 00000EF8 C606410000          <1> 	mov	byte [fdc_last_error],0
  1920 00000EFD E9D65D              <1> 	jmp	int_13_exit
  1921                              <1> 
  1922                              <1> ;=========================================================================
  1923                              <1> ; int_13_fn16 - Detect disk change
  1924                              <1> ; Input:
  1925                              <1> ;	AH = 16h
  1926                              <1> ;	DL = drive number (0 or 1)
  1927                              <1> ; Output:
  1928                              <1> ;	CF clear if change line inactive
  1929                              <1> ;		AH = 00h - disk not changed
  1930                              <1> ;	CF set if change line active or error
  1931                              <1> ;		AH = 01h - invalid drive number
  1932                              <1> ;		AH = 06h - disk changed or change line not supported
  1933                              <1> ;		AH = 80h - timeout / device not ready
  1934                              <1> ;-------------------------------------------------------------------------
  1935                              <1> int_13_fn16:
  1936 00000F00 80FA01              <1> 	cmp	dl,1
  1937 00000F03 7741                <1> 	ja	.invalid_drive
  1938 00000F05 E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  1939 00000F08 723C                <1> 	jc	.invalid_drive
  1940                              <1> 
  1941 00000F0A 3C01                <1> 	cmp	al,cmos_360
  1942 00000F0C 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  1943 00000F0E 3C03                <1> 	cmp	al,cmos_720
  1944 00000F10 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  1945                              <1> 
  1946 00000F12 E86302              <1> 	call	fdc_motor_on		; turn motor on
  1947 00000F15 30E4                <1> 	xor	ah,ah			; assume disk not changed
  1948 00000F17 BAF703              <1> 	mov	dx,fdc_dir_reg
  1949 00000F1A EC                  <1> 	in	al,dx			; read disk change line
  1950 00000F1B D0E0                <1> 	shl	al,1			; bit 7 to CF
  1951 00000F1D 7303                <1> 	jnc	.exit
  1952 00000F1F B406                <1> 	mov	ah,fdc_e_changed
  1953 00000F21 F9                  <1> 	stc
  1954                              <1> 
  1955                              <1> .exit:
  1956 00000F22 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1957 00000F26 9C                  <1> 	pushf
  1958 00000F27 1E                  <1> 	push	ds
  1959 00000F28 31F6                <1> 	xor	si,si
  1960 00000F2A 8EDE                <1> 	mov	ds,si
  1961 00000F2C C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1962 00000F30 8A4C02              <1> 	mov	cl,byte [si+2]
  1963 00000F33 1F                  <1> 	pop	ds
  1964 00000F34 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  1965 00000F38 9D                  <1> 	popf
  1966 00000F39 E99A5D              <1> 	jmp	int_13_exit
  1967                              <1> 
  1968                              <1> 
  1969                              <1> .no_change_line:
  1970 00000F3C B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  1971 00000F3E F9                  <1> 	stc
  1972 00000F3F 88264100            <1> 	mov	byte [fdc_last_error],ah
  1973 00000F43 E9905D              <1> 	jmp	int_13_exit
  1974                              <1> 
  1975                              <1> .invalid_drive:
  1976 00000F46 B401                <1> 	mov	ah,fdc_e_invalid
  1977 00000F48 F9                  <1> 	stc
  1978 00000F49 E98A5D              <1> 	jmp	int_13_exit
  1979                              <1> 
  1980                              <1> ;=========================================================================
  1981                              <1> ; int_13_fn17 - Set disk type for format
  1982                              <1> ; Input:
  1983                              <1> ;	AH = 17h
  1984                              <1> ;	AL = format type
  1985                              <1> ;		01h - 320K / 360K disk in 360K drive
  1986                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  1987                              <1> ;		03h - 1.2M disk in 1.2M drive
  1988                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  1989                              <1> ;	DL = drive number (0 or 1)
  1990                              <1> ; Output:
  1991                              <1> ;	CF clear if successful
  1992                              <1> ;		AH = 00h - successful completion
  1993                              <1> ;	CF set on error
  1994                              <1> ;		AH = 01h - invalid drive number
  1995                              <1> ;		AH = 06h - disk changed
  1996                              <1> ;		AH = 80h - timeout / device not ready
  1997                              <1> ;-------------------------------------------------------------------------
  1998                              <1> int_13_fn17:
  1999 00000F4C 80FA01              <1> 	cmp	dl,1
  2000 00000F4F 7762                <1> 	ja	.invalid_parameters
  2001 00000F51 E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  2002 00000F54 725D                <1> 	jc	.invalid_parameters
  2003 00000F56 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  2004 00000F59 80F900              <1> 	cmp	cl,0			; validate parameters
  2005 00000F5C 7455                <1> 	je	.invalid_parameters
  2006 00000F5E 80F904              <1> 	cmp	cl,4
  2007 00000F61 7750                <1> 	ja	.invalid_parameters
  2008 00000F63 BB9000              <1> 	mov	bx,fdc_media_state
  2009 00000F66 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2010 00000F68 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  2011 00000F6B 7507                <1> 	jne	.not_360in360
  2012 00000F6D C60793              <1> 	mov	byte [bx],fdc_m_360in360
  2013 00000F70 B400                <1> 	mov	ah,0			; no error
  2014 00000F72 EB33                <1> 	jmp	.exit_check_error
  2015                              <1> 
  2016                              <1> .not_360in360:
  2017 00000F74 E80102              <1> 	call	fdc_motor_on
  2018 00000F77 89DE                <1> 	mov	si,bx
  2019 00000F79 E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  2020 00000F7C 80FC06              <1> 	cmp	ah,fdc_e_changed
  2021 00000F7F 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  2022 00000F81 80FC80              <1> 	cmp	ah,fdc_e_timeout
  2023 00000F84 750A                <1> 	jne	.set_type		; floppy disk is installed
  2024 00000F86 803F97              <1> 	cmp	byte [bx],97h		; 250 Kbps and not 5.25?
  2025 00000F89 741C                <1> 	je	.exit_check_error
  2026 00000F8B C60761              <1> 	mov	byte [bx],61h		; 300 Kpbs, try 360 in 1.2M
  2027 00000F8E EB17                <1> 	jmp	.exit_check_error
  2028                              <1> 
  2029                              <1> .set_type:
  2030 00000F90 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  2031 00000F93 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  2032 00000F95 C60797              <1> 	mov	byte [bx],fdc_m_720
  2033 00000F98 EB0D                <1> 	jmp	.exit_check_error
  2034                              <1> 
  2035                              <1> .check_360in1200:
  2036 00000F9A 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  2037 00000F9D 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  2038 00000F9F C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  2039 00000FA2 EB03                <1> 	jmp	.exit_check_error
  2040                              <1> 
  2041                              <1> .set_1200in1200:
  2042 00000FA4 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  2043                              <1> 
  2044                              <1> .exit_check_error:
  2045 00000FA7 88264100            <1> 	mov	byte [fdc_last_error],ah
  2046 00000FAB 08E4                <1> 	or	ah,ah
  2047 00000FAD 7401                <1> 	jz	.exit			; jump if no error
  2048 00000FAF F9                  <1> 	stc				; indicate error
  2049                              <1> 
  2050                              <1> .exit:
  2051 00000FB0 E9025D              <1> 	jmp	int_13_upd_exit
  2052                              <1> 
  2053                              <1> .invalid_parameters:
  2054 00000FB3 B401                <1> 	mov	ah,fdc_e_invalid
  2055 00000FB5 EBF9                <1> 	jmp	.exit
  2056                              <1> 
  2057                              <1> ;=========================================================================
  2058                              <1> ; int_13_fn18 - Set media type for format
  2059                              <1> ; Input:
  2060                              <1> ;	AH = 18h
  2061                              <1> ;	DL = drive number (0 or 1)
  2062                              <1> ;	CH = number of cylinders - 1
  2063                              <1> ;	CL = sectors per track
  2064                              <1> ; Output:
  2065                              <1> ;	CF = clear if successful
  2066                              <1> ;		AH = 00h - requested format is supported
  2067                              <1> ;		ES:DI -> diskette parameter table
  2068                              <1> ;	CF = set on error
  2069                              <1> ;		AH = 01h - invalid drive number specified
  2070                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  2071                              <1> ;-------------------------------------------------------------------------
  2072                              <1> int_13_fn18:
  2073 00000FB7 80FA01              <1> 	cmp	dl,1
  2074 00000FBA 7603E99900          <1> 	ja	.invalid_drive
  2075 00000FBF E84504              <1> 	call	read_cmos_type		; get drive type in AL
  2076 00000FC2 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  2077                              <1> 
  2078 00000FC7 BB9000              <1> 	mov	bx,fdc_media_state
  2079 00000FCA 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2080                              <1> 
  2081 00000FCC 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  2082 00000FCE 7511                <1> 	jne	.try_drive_1200
  2083 00000FD0 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  2084 00000FD4 7403E98300          <1> 	jnz	.unsupported_format
  2085 00000FD9 B093                <1> 	mov	al,93h			; 360K in 360K established, 250 Kbps
  2086 00000FDB 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2087 00000FDF EB54                <1> 	jmp	.set_media
  2088                              <1> 
  2089                              <1> .try_drive_1200:
  2090 00000FE1 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2091 00000FE3 751C                <1> 	jne	.try_drive_2880
  2092 00000FE5 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2093 00000FE9 7508                <1> 	jne	.try_media_360_in_1200
  2094 00000FEB B015                <1> 	mov	al,15h			; 1.2M in 1.2M established, 500Kbps
  2095 00000FED 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
  2096 00000FF1 EB42                <1> 	jmp	.set_media
  2097                              <1> 
  2098                              <1> .try_media_360_in_1200:
  2099 00000FF3 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2100 00000FF7 7563                <1> 	jne	.unsupported_format
  2101 00000FF9 B074                <1> 	mov	al,74h			; 360K in 1.2M established, 300Kbps
  2102 00000FFB 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2103 00000FFF EB34                <1> 	jmp	.set_media
  2104                              <1> 
  2105                              <1> .try_drive_2880:
  2106 00001001 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2107 00001003 750E                <1> 	jne	.try_drive_1440
  2108 00001005 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2109 00001009 750C                <1> 	jne	.try_media_1440
  2110 0000100B B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2111 0000100D 8D3E[B06F]          <1> 	lea	di,[media_2880]
  2112 00001011 EB22                <1> 	jmp	.set_media
  2113                              <1> 
  2114                              <1> .try_drive_1440:
  2115 00001013 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2116 00001015 750E                <1> 	jne	.try_drive_720
  2117                              <1> 
  2118                              <1> .try_media_1440:
  2119 00001017 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2120 0000101B 750C                <1> 	jne	.try_media_720
  2121 0000101D B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2122 0000101F 8D3E[966F]          <1> 	lea	di,[media_1440]
  2123 00001023 EB10                <1> 	jmp	.set_media
  2124                              <1> 
  2125                              <1> .try_drive_720:
  2126 00001025 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2127 00001027 7533                <1> 	jne	.unsupported_format	; should never happen...
  2128                              <1> 
  2129                              <1> .try_media_720:	
  2130 00001029 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2131 0000102D 752D                <1> 	jne	.unsupported_format
  2132 0000102F B097                <1> 	mov	al,97h			; other established, 250Kbps
  2133 00001031 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
  2134                              <1> 
  2135                              <1> .set_media:
  2136 00001035 8807                <1> 	mov	byte [bx],al		; set physical media
  2137 00001037 E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2138 0000103A D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2139 0000103C D0C8                <1> 	ror	al,1
  2140 0000103E 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2141 00001043 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2142 00001047 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2143 0000104A 8CC9                <1> 	mov	cx,cs
  2144 0000104C 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2145 0000104E C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2146 00001053 30E4                <1> 	xor	ah,ah
  2147 00001055 E95D5C              <1> 	jmp	int_13_upd_exit
  2148                              <1> 
  2149                              <1> .invalid_drive:
  2150 00001058 B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2151 0000105A EB02                <1> 	jmp	.error
  2152                              <1> 
  2153                              <1> .unsupported_format:
  2154 0000105C B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2155                              <1> 
  2156                              <1> .error:
  2157 0000105E F9                  <1> 	stc
  2158 0000105F E9535C              <1> 	jmp	int_13_upd_exit
  2159                              <1> 
  2160                              <1> ;=========================================================================
  2161                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2162                              <1> ; Input:
  2163                              <1> ;	DL = drive number (0 or 1)
  2164                              <1> ; Output:
  2165                              <1> ;	CF clear if successful
  2166                              <1> ;		AH = 00h - successful completion
  2167                              <1> ;	CF set on error
  2168                              <1> ;		AH = 20h - controller failure
  2169                              <1> ;		AH = 20h - timeout
  2170                              <1> ;	AH trashed
  2171                              <1> ;-------------------------------------------------------------------------
  2172                              <1> fdc_recalibrate:
  2173 00001062 56                  <1> 	push	si
  2174 00001063 51                  <1> 	push	cx
  2175 00001064 52                  <1> 	push	dx
  2176 00001065 B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2177 00001067 88D4                <1> 	mov	ah,dl			; drive number
  2178 00001069 B102                <1> 	mov	cl,2			; 2 bytes command
  2179 0000106B 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2180 00001070 E86502              <1> 	call	fdc_send_cmd
  2181 00001073 7244                <1> 	jc	recal_end		; failure
  2182 00001075 E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2183 00001078 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2184 0000107A B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2185 0000107C B101                <1> 	mov	cl,1			; 1 byte command
  2186 0000107E E85702              <1> 	call	fdc_send_cmd
  2187 00001081 7236                <1> 	jc	recal_end		; failure
  2188 00001083 B90200              <1> 	mov	cx,2			; 2 bytes result
  2189 00001086 E8B402              <1> 	call	fdc_get_result		; store result
  2190 00001089 722E                <1> 	jc	recal_end		; failure
  2191 0000108B BB4200              <1> 	mov	bx,fdc_ctrl_status
  2192 0000108E B440                <1> 	mov	ah,fdc_e_seek
  2193 00001090 8A17                <1> 	mov	dl,[bx]			; ST0
  2194 00001092 80E260              <1> 	and	dl,60h
  2195 00001095 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2196 00001098 F9                  <1> 	stc				; indicate error
  2197 00001099 741E                <1> 	je	recal_end		; failure
  2198 0000109B 5A                  <1> 	pop	dx
  2199 0000109C 52                  <1> 	push	dx
  2200 0000109D 30F6                <1> 	xor	dh,dh				 
  2201 0000109F BB9400              <1> 	mov	bx,fdc_cylinder
  2202 000010A2 01D3                <1> 	add	bx,dx
  2203 000010A4 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2204 000010A7 88D1                <1> 	mov	cl,dl
  2205 000010A9 B201                <1> 	mov	dl,1
  2206 000010AB D2E2                <1> 	shl	dl,cl
  2207 000010AD 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2208 000010B1 B94300              <1> 	mov	cx,43h
  2209 000010B4 E868FB              <1> 	call	delay_15us		; 1 ms delay
  2210 000010B7 30E4                <1> 	xor	ah,ah
  2211                              <1> 
  2212                              <1> recal_end:
  2213 000010B9 88264100            <1> 	mov	byte [fdc_last_error],ah
  2214 000010BD 5A                  <1> 	pop	dx
  2215 000010BE 59                  <1> 	pop	cx
  2216 000010BF 5E                  <1> 	pop	si
  2217 000010C0 C3                  <1> 	ret
  2218                              <1> 
  2219                              <1> ;=========================================================================
  2220                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2221                              <1> ; Input:
  2222                              <1> ;	DL = drive number
  2223                              <1> ;	DH = head number
  2224                              <1> ;	CH = cylinder
  2225                              <1> ; Output:
  2226                              <1> ;	CF clear if successful
  2227                              <1> ;		AH = 00h - successful completion
  2228                              <1> ;	CF set on error
  2229                              <1> ;		AH = 20h - controller failure
  2230                              <1> ;		AH = 40h - seek failed
  2231                              <1> ;		AH = 80h - timeout / device not ready
  2232                              <1> ;-------------------------------------------------------------------------
  2233                              <1> fdc_seek:
  2234 000010C1 53                  <1> 	push	bx
  2235 000010C2 51                  <1> 	push	cx
  2236 000010C3 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2237 000010C7 88D1                <1> 	mov	cl,dl
  2238 000010C9 FEC1                <1> 	inc	cl
  2239 000010CB D2EC                <1> 	shr	ah,cl
  2240 000010CD 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2241 000010CF E890FF              <1> 	call	fdc_recalibrate
  2242 000010D2 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2243 000010D4 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2244 000010D7 727F                <1> 	jc	.exit			; no luck...
  2245                              <1> 
  2246                              <1> .skip_recalibrate:
  2247 000010D9 B700                <1> 	mov	bh,00h
  2248 000010DB 88D3                <1> 	mov	bl,dl			; BX = drive number
  2249                              <1> 
  2250 000010DD F687900020          <1> 	test	byte [fdc_media_state+bx],20h 	; check double stepping bit
  2251 000010E2 7402                <1> 	jz	.no_double_stepping
  2252 000010E4 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2253                              <1> 
  2254                              <1> .no_double_stepping:
  2255 000010E6 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2256 000010EA 750B                <1> 	jne	.do_seek		; jump if seek is required
  2257 000010EC 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2258 000010F1 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2259 000010F3 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2260 000010F5 EB61                <1> 	jmp	.exit
  2261                              <1> 
  2262                              <1> .do_seek:
  2263 000010F7 88E8                <1> 	mov	al,ch			; cylinder
  2264 000010F9 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2265 000010FB B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2266 000010FD 88F4                <1> 	mov	ah,dh			; head
  2267 000010FF D0E4                <1> 	shl	ah,1
  2268 00001101 D0E4                <1> 	shl	ah,1
  2269 00001103 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2270 00001105 B103                <1> 	mov	cl,3			; 3 bytes command
  2271 00001107 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2272 0000110C E8C901              <1> 	call	fdc_send_cmd
  2273 0000110F 7243                <1> 	jc	.set_result		; seek error
  2274 00001111 E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2275 00001114 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2276                              <1> 
  2277 00001116 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2278 00001118 B101                <1> 	mov	cl,1			; 1 byte command
  2279 0000111A E8BB01              <1> 	call	fdc_send_cmd
  2280 0000111D 7235                <1> 	jc	.set_result		; failure
  2281 0000111F B102                <1> 	mov	cl,2
  2282 00001121 53                  <1> 	push	bx
  2283 00001122 E81802              <1> 	call	fdc_get_result		; read result bytes
  2284 00001125 5B                  <1> 	pop	bx
  2285 00001126 722C                <1> 	jc	.set_result		; error
  2286 00001128 B440                <1> 	mov	ah,fdc_e_seek
  2287 0000112A A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2288 0000112D 2460                <1> 	and	al,60h
  2289 0000112F 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2290 00001131 F9                  <1> 	stc
  2291 00001132 7420                <1> 	je	.set_result		; seek error
  2292 00001134 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2293                              <1> 
  2294 00001138 1E                  <1> 	push	ds
  2295 00001139 31F6                <1> 	xor	si,si
  2296 0000113B 8EDE                <1> 	mov	ds,si
  2297 0000113D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2298 00001141 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2299 00001144 1F                  <1> 	pop	ds
  2300                              <1> 
  2301 00001145 08C0                <1> 	or	al,al			; head settle time is zero?!
  2302 00001147 7412                <1> 	jz	.get_settle_time
  2303                              <1> 
  2304 00001149 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2305 0000114B F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2306 0000114D 89C1                <1> 	mov	cx,ax
  2307                              <1> 
  2308                              <1> .wait:
  2309 0000114F E8CDFA              <1> 	call	delay_15us
  2310                              <1> 
  2311                              <1> .wait_end:
  2312 00001152 30E4                <1> 	xor	ah,ah
  2313                              <1> 
  2314                              <1> .set_result:
  2315 00001154 88264100            <1> 	mov	byte [fdc_last_error],ah
  2316                              <1> 
  2317                              <1> .exit:
  2318 00001158 59                  <1> 	pop	cx
  2319 00001159 5B                  <1> 	pop	bx
  2320 0000115A C3                  <1> 	ret
  2321                              <1> 
  2322                              <1> .get_settle_time:
  2323 0000115B F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2324 00001160 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2325                              <1> 	
  2326 00001162 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2327 00001166 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2328 00001169 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2329 0000116C 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2330 0000116E 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2331 00001171 74DC                <1> 	je	.wait			; jump if 360K, media established
  2332 00001173 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2333 00001176 EBD7                <1> 	jmp	.wait
  2334                              <1> 
  2335                              <1> ;=========================================================================
  2336                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2337                              <1> ; Input:
  2338                              <1> ;	DL = drive number (0 or 1)
  2339                              <1> ; Output:
  2340                              <1> ;	none
  2341                              <1> ;-------------------------------------------------------------------------
  2342                              <1> fdc_motor_on:
  2343 00001178 50                  <1> 	push	ax
  2344 00001179 51                  <1> 	push	cx
  2345 0000117A 52                  <1> 	push	dx
  2346 0000117B FA                  <1> 	cli				; entering critical section
  2347 0000117C C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2348 00001181 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2349 00001186 88D1                <1> 	mov	cl,dl			; CL = drive number
  2350 00001188 D0E2                <1> 	shl	dl,1
  2351 0000118A D0E2                <1> 	shl	dl,1
  2352 0000118C D0E2                <1> 	shl	dl,1
  2353 0000118E D0E2                <1> 	shl	dl,1
  2354 00001190 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2355 00001194 FEC1                <1> 	inc	cl
  2356 00001196 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2357 0000119A D2EA                <1> 	shr	dl,cl
  2358 0000119C 7255                <1> 	jc	.already_on
  2359 0000119E B201                <1> 	mov	dl,1
  2360 000011A0 FEC9                <1> 	dec	cl
  2361 000011A2 D2E2                <1> 	shl	dl,cl
  2362 000011A4 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2363 000011A8 FB                  <1> 	sti				; end of critical section
  2364 000011A9 A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2365 000011AC D0C8                <1> 	ror	al,1
  2366 000011AE D0C8                <1> 	ror	al,1
  2367 000011B0 D0C8                <1> 	ror	al,1
  2368 000011B2 D0C8                <1> 	ror	al,1
  2369 000011B4 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2370 000011B6 BAF203              <1> 	mov	dx,fdc_dor_reg
  2371 000011B9 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2372 000011BA B8FD90              <1> 	mov	ax,90FDh
  2373 000011BD CD15                <1> 	int	15h			; call OS hook
  2374 000011BF 722E                <1> 	jc	.exit
  2375 000011C1 1E                  <1> 	push	ds
  2376 000011C2 56                  <1> 	push	si
  2377 000011C3 31F6                <1> 	xor	si,si
  2378 000011C5 8EDE                <1> 	mov	ds,si
  2379 000011C7 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2380 000011CB 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2381 000011CE 5E                  <1> 	pop	si
  2382 000011CF 1F                  <1> 	pop	ds
  2383                              <1> 
  2384 000011D0 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2385 000011D5 7408                <1> 	jz	.read_verify		; jump if not write operation
  2386 000011D7 3C08                <1> 	cmp	al,8
  2387 000011D9 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2388 000011DB B008                <1> 	mov	al,8			; wait at least 1 second for write
  2389 000011DD EB06                <1> 	jmp	.wait_loop
  2390                              <1> 
  2391                              <1> .read_verify:
  2392 000011DF 3C05                <1> 	cmp	al,5
  2393 000011E1 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2394 000011E3 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2395                              <1> 
  2396                              <1> .wait_loop:
  2397 000011E5 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2398 000011E8 E834FA              <1> 	call	delay_15us		; wait 125 ms
  2399 000011EB FEC8                <1> 	dec	al
  2400 000011ED 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2401                              <1> 
  2402                              <1> .exit:
  2403 000011EF 59                  <1> 	pop	cx
  2404 000011F0 5A                  <1> 	pop	dx
  2405 000011F1 58                  <1> 	pop	ax
  2406 000011F2 C3                  <1> 	ret
  2407                              <1> 
  2408                              <1> .already_on:
  2409 000011F3 FB                  <1> 	sti
  2410 000011F4 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2411 000011F7 D0C8                <1> 	ror	al,1
  2412 000011F9 D0C8                <1> 	ror	al,1
  2413 000011FB D0C8                <1> 	ror	al,1
  2414 000011FD D0C8                <1> 	ror	al,1
  2415 000011FF 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2416 00001201 BAF203              <1> 	mov	dx,fdc_dor_reg
  2417 00001204 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2418 00001205 EBE8                <1> 	jmp	.exit
  2419                              <1> 
  2420                              <1> ;=========================================================================
  2421                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2422                              <1> ; Input:
  2423                              <1> ;	CH = cylinder
  2424                              <1> ;	DH = head
  2425                              <1> ; Output:
  2426                              <1> ;	BL = next sector to be transferred
  2427                              <1> ;-------------------------------------------------------------------------	
  2428                              <1> 
  2429                              <1> fdc_end_io:
  2430 00001207 50                  <1> 	push	ax
  2431 00001208 1E                  <1> 	push	ds
  2432 00001209 31DB                <1> 	xor	bx,bx
  2433 0000120B 8EDB                <1> 	mov	ds,bx
  2434 0000120D C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2435 00001211 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2436 00001214 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2437 00001217 FEC0                <1> 	inc	al
  2438 00001219 1F                  <1> 	pop	ds
  2439 0000121A BB4200              <1> 	mov	bx,fdc_ctrl_status
  2440 0000121D 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2441 00001220 7508                <1> 	jne	.exit
  2442 00001222 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2443 00001225 7503                <1> 	jne	.exit
  2444 00001227 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2445                              <1> .exit:
  2446 0000122A 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2447 0000122E 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2448 00001230 58                  <1> 	pop	ax
  2449 00001231 C3                  <1> 	ret
  2450                              <1> 
  2451                              <1> ;========================================================================
  2452                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2453                              <1> ; Input:
  2454                              <1> ;	AL = CMOS drive type
  2455                              <1> ;	DS:SI -> drive media type
  2456                              <1> ; Output:
  2457                              <1> ;	CF clear if disk not changed
  2458                              <1> ;		AH = 00h - disk not changed
  2459                              <1> ;	CF set if disk changed or on error
  2460                              <1> ;		AH = 06h - disk changed
  2461                              <1> ;		AH = error code
  2462                              <1> ; Note:
  2463                              <1> ;	Motor needs to be turned on before calling this function
  2464                              <1> ;------------------------------------------------------------------------
  2465                              <1> fdc_disk_change:
  2466 00001232 51                  <1> 	push	cx
  2467 00001233 B400                <1> 	mov	ah,0
  2468 00001235 3C01                <1> 	cmp	al,cmos_360
  2469 00001237 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2470 00001239 3C03                <1> 	cmp	al,cmos_720
  2471 0000123B 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2472                              <1> .cmos_invalid:
  2473 0000123D 8A04                <1> 	mov	al,[si]			; media type
  2474 0000123F 2407                <1> 	and	al,fdc_m_state_bits
  2475 00001241 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2476 00001243 3C03                <1> 	cmp	al,3
  2477 00001245 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2478 00001247 BAF703              <1> 	mov	dx,fdc_dir_reg
  2479 0000124A EC                  <1> 	in	al,dx			; read disk change line
  2480 0000124B D0E0                <1> 	shl	al,1
  2481 0000124D 7326                <1> 	jnc	.exit			; no disk change
  2482 0000124F 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2483 00001252 E86CFB              <1> 	call	fdc_init		; full initialization
  2484 00001255 721E                <1> 	jc	.exit
  2485 00001257 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2486 0000125A B501                <1> 	mov	ch,1
  2487 0000125C E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2488 0000125F 7214                <1> 	jc	.exit
  2489 00001261 B500                <1> 	mov	ch,0
  2490 00001263 E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2491 00001266 720D                <1> 	jc	.exit
  2492 00001268 B406                <1> 	mov	ah,fdc_e_changed
  2493 0000126A BAF703              <1> 	mov	dx,fdc_dir_reg
  2494 0000126D EC                  <1> 	in	al,dx			; read disk change line
  2495 0000126E D0E0                <1> 	shl	al,1
  2496 00001270 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2497 00001272 B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2498                              <1> 
  2499                              <1> .changed_or_error:
  2500 00001274 F9                  <1> 	stc
  2501                              <1> 
  2502                              <1> .exit:
  2503 00001275 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2504 00001278 59                  <1> 	pop	cx
  2505 00001279 C3                  <1> 	ret
  2506                              <1> 
  2507                              <1> ;=========================================================================
  2508                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2509                              <1> ; Input:
  2510                              <1> ;	AL = DMA mode byte
  2511                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2512                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2513                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2514                              <1> ;	CX = byte count (minus 1)
  2515                              <1> ;	ES:BX -> buffer address for DMA operation
  2516                              <1> ; Output:
  2517                              <1> ;	CF clear on success
  2518                              <1> ;	CF set if error
  2519                              <1> ;		AH = 08h - DMA overrun
  2520                              <1> ;	AX,BX trashed
  2521                              <1> ; Note:
  2522                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2523                              <1> ;-------------------------------------------------------------------------
  2524                              <1> fdc_configure_dma:
  2525 0000127A 52                  <1> 	push	dx
  2526 0000127B 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2527 0000127D D1C2                <1> 	rol	dx,1
  2528 0000127F D1C2                <1> 	rol	dx,1
  2529 00001281 D1C2                <1> 	rol	dx,1
  2530 00001283 D1C2                <1> 	rol	dx,1
  2531 00001285 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2532 00001287 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2533 0000128A 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2534 0000128D 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2535 0000128F 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2536                              <1> 
  2537 00001292 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2538 00001294 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2539 00001296 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2540                              <1> 
  2541 00001298 FA                  <1> 	cli
  2542 00001299 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2543 0000129B EB00                <1> 	jmp	$+2
  2544 0000129D EB00                <1> 	jmp	$+2
  2545 0000129F E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2546 000012A1 EB00                <1> 	jmp	$+2
  2547 000012A3 EB00                <1> 	jmp	$+2
  2548 000012A5 88C8                <1> 	mov	al,cl
  2549 000012A7 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2550 000012A9 EB00                <1> 	jmp	$+2
  2551 000012AB EB00                <1> 	jmp	$+2
  2552 000012AD 88E8                <1> 	mov	al,ch
  2553 000012AF E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2554 000012B1 EB00                <1> 	jmp	$+2
  2555 000012B3 EB00                <1> 	jmp	$+2
  2556 000012B5 88D0                <1> 	mov	al,dl
  2557 000012B7 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2558 000012B9 EB00                <1> 	jmp	$+2
  2559 000012BB EB00                <1> 	jmp	$+2
  2560 000012BD 88F0                <1> 	mov	al,dh
  2561 000012BF E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2562 000012C1 EB00                <1> 	jmp	$+2
  2563 000012C3 EB00                <1> 	jmp	$+2
  2564 000012C5 88E0                <1> 	mov	al,ah
  2565 000012C7 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2566 000012C9 EB00                <1> 	jmp	$+2
  2567 000012CB EB00                <1> 	jmp	$+2
  2568 000012CD B002                <1> 	mov	al,2
  2569 000012CF E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2570 000012D1 FB                  <1> 	sti
  2571                              <1> 
  2572                              <1> .exit:
  2573 000012D2 5A                  <1> 	pop	dx
  2574 000012D3 C3                  <1> 	ret
  2575                              <1> 
  2576                              <1> .dma_boundary:				; Note: CF is already set
  2577 000012D4 B409                <1> 	mov	ah,fdc_e_boundary
  2578 000012D6 EBFA                <1> 	jmp	.exit
  2579                              <1> 
  2580                              <1> ;=========================================================================
  2581                              <1> ; fdc_send_cmd - Send a command to FDC
  2582                              <1> ; Input:
  2583                              <1> ;	AL = 1st byte of the command
  2584                              <1> ;	AH = 2nd byte of the command
  2585                              <1> ;	SI = 3rd and 4th bytes of the command
  2586                              <1> ;	DI = 5th and 6th bytes of the command
  2587                              <1> ;	BL = 7th byte of the command
  2588                              <1> ;	BH = 8th byte of the command
  2589                              <1> ;	CH = 9th byte of the command
  2590                              <1> ;	CL = command length (number of bytes)
  2591                              <1> ; Output:
  2592                              <1> ;	CF clear if successful
  2593                              <1> ;		AH = 00h - successful completion
  2594                              <1> ;	CF set on error
  2595                              <1> ;		AH = 20h - controller failure
  2596                              <1> ;		AH = 80h - timeout / device not ready
  2597                              <1> ;	AX trashed
  2598                              <1> ;-------------------------------------------------------------------------
  2599                              <1> fdc_send_cmd:
  2600 000012D8 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2601 000012DB FEC9                <1> 	dec	cl
  2602 000012DD 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2603 000012DF 88E0                <1> 	mov	al,ah
  2604 000012E1 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2605 000012E4 FEC9                <1> 	dec	cl
  2606 000012E6 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2607 000012E8 89F0                <1> 	mov	ax,si
  2608 000012EA E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2609 000012ED FEC9                <1> 	dec	cl
  2610 000012EF 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2611 000012F1 88E0                <1> 	mov	al,ah
  2612 000012F3 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2613 000012F6 FEC9                <1> 	dec	cl
  2614 000012F8 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2615 000012FA 89F8                <1> 	mov	ax,di
  2616 000012FC E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2617 000012FF FEC9                <1> 	dec	cl
  2618 00001301 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2619 00001303 88E0                <1> 	mov	al,ah
  2620 00001305 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2621 00001308 FEC9                <1> 	dec	cl
  2622 0000130A 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2623 0000130C 88D8                <1> 	mov	al,bl
  2624 0000130E E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2625 00001311 FEC9                <1> 	dec	cl
  2626 00001313 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2627 00001315 88F8                <1> 	mov	al,bh
  2628 00001317 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2629 0000131A FEC9                <1> 	dec	cl
  2630 0000131C 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2631 0000131E 88E8                <1> 	mov	al,ch
  2632 00001320 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  2633                              <1> 
  2634                              <1> .send_cmd_exit:
  2635 00001323 C3                  <1> 	ret
  2636                              <1> 
  2637                              <1> ;=========================================================================
  2638                              <1> ; fdc_write - Send byte to FDC
  2639                              <1> ; Input:
  2640                              <1> ;	AL = byte to send
  2641                              <1> ; Output:
  2642                              <1> ;	CF clear if successful
  2643                              <1> ;	CF set if timeout
  2644                              <1> ;		AH = 80h - timeout / device not ready
  2645                              <1> ;-------------------------------------------------------------------------
  2646                              <1> fdc_write:
  2647 00001324 52                  <1> 	push	dx
  2648 00001325 50                  <1> 	push	ax
  2649 00001326 E83502              <1> 	call	fdc_wait_ready
  2650 00001329 720D                <1> 	jc	.timeout
  2651 0000132B 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  2652 0000132D 3C80                <1> 	cmp	al,fdc_stat_ready
  2653 0000132F 7507                <1> 	jne	.timeout
  2654 00001331 58                  <1> 	pop	ax
  2655 00001332 BAF503              <1> 	mov	dx,fdc_data_reg
  2656 00001335 EE                  <1> 	out	dx,al			; write byte
  2657                              <1> 
  2658                              <1> .exit:
  2659 00001336 5A                  <1> 	pop	dx
  2660 00001337 C3                  <1> 	ret
  2661                              <1> 
  2662                              <1> .timeout:
  2663 00001338 58                  <1> 	pop	ax
  2664 00001339 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2665 0000133B EBF9                <1> 	jmp	.exit
  2666                              <1> 
  2667                              <1> ;=========================================================================
  2668                              <1> ; fdc_get_result - Read FDC result
  2669                              <1> ; Input:
  2670                              <1> ;	CL = number of result bytes
  2671                              <1> ; Output:
  2672                              <1> ;	CF clear if successful
  2673                              <1> ;		AH = 00h - operation successful
  2674                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  2675                              <1> ;	CF set on error
  2676                              <1> ;		AH = 20h - controller failure
  2677                              <1> ;		AH = 80h - timeout / device not ready
  2678                              <1> ;	AL,BX - trashed
  2679                              <1> ;-------------------------------------------------------------------------
  2680                              <1> fdc_get_result:
  2681 0000133D 52                  <1> 	push	dx
  2682 0000133E BB4200              <1> 	mov	bx,fdc_ctrl_status
  2683                              <1> 
  2684                              <1> .next_byte:
  2685 00001341 E81A02              <1> 	call	fdc_wait_ready
  2686 00001344 7222                <1> 	jc	.timeout
  2687 00001346 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  2688 00001348 88C4                <1> 	mov	ah,al
  2689 0000134A 80E4EF              <1> 	and	ah,~fdc_stat_busy
  2690 0000134D 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  2691 00001350 7412                <1> 	je	.done			; jump if finished
  2692 00001352 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  2693 00001354 7516                <1> 	jne	.failure		; jump on invalid controller status
  2694 00001356 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  2695 00001359 7311                <1> 	jnb	.failure		; controller error if so
  2696 0000135B BAF503              <1> 	mov	dx,fdc_data_reg
  2697 0000135E EC                  <1> 	in	al,dx
  2698 0000135F 8807                <1> 	mov	byte [bx],al
  2699 00001361 43                  <1> 	inc	bx
  2700 00001362 EBDD                <1> 	jmp	.next_byte
  2701                              <1> 
  2702                              <1> .done:
  2703 00001364 30E4                <1> 	xor	ah,ah			; operation successful
  2704                              <1> 
  2705                              <1> .exit:
  2706 00001366 5A                  <1> 	pop	dx
  2707 00001367 C3                  <1> 	ret
  2708                              <1> 
  2709                              <1> .timeout:
  2710 00001368 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2711 0000136A EBFA                <1> 	jmp	.exit
  2712                              <1> 
  2713                              <1> .failure:
  2714 0000136C B420                <1> 	mov	ah,fdc_e_failure
  2715 0000136E F9                  <1> 	stc
  2716 0000136F EBF5                <1> 	jmp	.exit
  2717                              <1> 
  2718                              <1> ;=========================================================================
  2719                              <1> ; fdc_read - Read byte from FDC
  2720                              <1> ; Input:
  2721                              <1> ;	none
  2722                              <1> ; Output:
  2723                              <1> ;	CF clear if successful
  2724                              <1> ;		AL = byte read from FDC
  2725                              <1> ;		AH - unchanged
  2726                              <1> ;	CF set on error
  2727                              <1> ;		AH = 20h - controller failure
  2728                              <1> ;		AH = 80h - timeout / device not ready
  2729                              <1> ;	CX trashed
  2730                              <1> ;-------------------------------------------------------------------------
  2731                              <1> fdc_read:
  2732 00001371 52                  <1> 	push	dx
  2733 00001372 BAF403              <1> 	mov	dx,fdc_status_reg
  2734 00001375 E8E601              <1> 	call	fdc_wait_ready
  2735 00001378 720F                <1> 	jc	.timeout
  2736 0000137A EC                  <1> 	in	al,dx
  2737 0000137B A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  2738 0000137D 740E                <1> 	jz	.failure		; jump if not ready
  2739 0000137F EB00                <1> 	jmp	short $+2		; I/O delay
  2740 00001381 EB00                <1> 	jmp	short $+2
  2741 00001383 BAF503              <1> 	mov	dx,fdc_data_reg
  2742 00001386 EC                  <1> 	in	al,dx			; read the byte
  2743                              <1> 
  2744                              <1> .exit:
  2745 00001387 5A                  <1> 	pop	dx
  2746 00001388 C3                  <1> 	ret
  2747                              <1> 
  2748                              <1> .timeout:
  2749 00001389 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2750 0000138B EBFA                <1> 	jmp	.exit
  2751                              <1> 
  2752                              <1> .failure:
  2753 0000138D B420                <1> 	mov	ah,fdc_e_failure
  2754 0000138F F9                  <1> 	stc
  2755 00001390 EBF5                <1> 	jmp	.exit
  2756                              <1> 
  2757                              <1> ;=========================================================================
  2758                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  2759                              <1> ; Input:
  2760                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  2761                              <1> ; Output:
  2762                              <1> ;	AH = error code
  2763                              <1> ;-------------------------------------------------------------------------
  2764                              <1> 
  2765                              <1> fdc_get_error:
  2766 00001392 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2767 00001395 8B1F                <1> 	mov	bx,[bx]
  2768 00001397 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  2769 0000139A B400                <1> 	mov	ah,fdc_e_success
  2770 0000139C 7433                <1> 	jz	.exit			; jump if successful completion
  2771 0000139E F6C340              <1> 	test	bl,40h			; abnormal termination?
  2772 000013A1 B420                <1> 	mov	ah,fdc_e_failure
  2773 000013A3 742C                <1> 	jz	.exit
  2774 000013A5 F6C701              <1> 	test	bh,1			; address mark not found?
  2775 000013A8 B402                <1> 	mov	ah,fdc_e_address
  2776 000013AA 7525                <1> 	jnz	.exit
  2777 000013AC F6C702              <1> 	test	bh,2			; disk write protected?
  2778 000013AF B403                <1> 	mov	ah,fdc_e_wprotect
  2779 000013B1 751E                <1> 	jnz	.exit
  2780 000013B3 F6C704              <1> 	test	bh,4			; sector not found?
  2781 000013B6 B404                <1> 	mov	ah,fdc_e_notfound
  2782 000013B8 7517                <1> 	jnz	.exit
  2783 000013BA F6C710              <1> 	test	bh,10H			; DMA overrun?
  2784 000013BD B408                <1> 	mov	ah,fdc_e_dma
  2785 000013BF 7510                <1> 	jnz	.exit
  2786 000013C1 F6C720              <1> 	test	bh,20H			; CRC error?
  2787 000013C4 B410                <1> 	mov	ah,fdc_e_crc
  2788 000013C6 7509                <1> 	jnz	.exit
  2789 000013C8 F6C780              <1> 	test	bh,80h			; access after last sector?
  2790 000013CB B404                <1> 	mov	ah,fdc_e_notfound
  2791 000013CD 7502                <1> 	jnz	.exit
  2792 000013CF B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  2793                              <1> 
  2794                              <1> .exit:
  2795 000013D1 C3                  <1> 	ret
  2796                              <1> 
  2797                              <1> ;=========================================================================
  2798                              <1> ; fdc_reset - Reset FDC
  2799                              <1> ; Input:
  2800                              <1> ;	none
  2801                              <1> ; Output:
  2802                              <1> ;	Resets FDC flags in BIOS area
  2803                              <1> ;	AX,CX,DX - trashed 
  2804                              <1> ;-------------------------------------------------------------------------
  2805                              <1> 
  2806                              <1> fdc_reset:
  2807 000013D2 FA                  <1> 	cli
  2808 000013D3 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  2809 000013D8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2810 000013DD A03F00              <1> 	mov	al,byte [fdc_motor_state]
  2811 000013E0 D0C0                <1> 	rol	al,1			; after rol:
  2812 000013E2 D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  2813 000013E4 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  2814 000013E6 D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  2815 000013E8 24FB                <1> 	and	al,0FBh			; clear reserved bit
  2816 000013EA 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  2817 000013EC BAF203              <1> 	mov	dx,fdc_dor_reg
  2818 000013EF EE                  <1> 	out	dx,al			; send it to FDC
  2819 000013F0 B90300              <1> 	mov	cx,3
  2820 000013F3 E829F8              <1> 	call	delay_15us		; 30-45 us delay
  2821 000013F6 0C0C                <1> 	or	al,0Ch
  2822 000013F8 EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  2823 000013F9 FB                  <1> 	sti
  2824 000013FA E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2825 000013FD 7207                <1> 	jc	.exit
  2826 000013FF 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  2827 00001404 30E4                <1> 	xor	ah,ah			; no errors
  2828                              <1> .exit:
  2829 00001406 C3                  <1> 	ret
  2830                              <1> 
  2831                              <1> ;=========================================================================
  2832                              <1> ; read_cmos_type - Read drive type from CMOS
  2833                              <1> ; Input:
  2834                              <1> ;	DL = drive number (0 or 1)
  2835                              <1> ; Output:
  2836                              <1> ;	CF clear if successful
  2837                              <1> ;		AL = drive type
  2838                              <1> ;	CF set on error (invalid drive type)
  2839                              <1> ;=========================================================================
  2840                              <1> 
  2841                              <1> read_cmos_type:
  2842 00001407 B010                <1> 	mov	al,cmos_floppy
  2843 00001409 E8FCF5              <1> 	call	rtc_read		; read drive type
  2844 0000140C 08D2                <1> 	or	dl,dl			; drive 0?
  2845 0000140E 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  2846 00001410 D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  2847 00001412 D0E8                <1> 	shr	al,1
  2848 00001414 D0E8                <1> 	shr	al,1
  2849 00001416 D0E8                <1> 	shr	al,1
  2850                              <1> .drive_1:
  2851 00001418 240F                <1> 	and	al,0Fh			; mask drive bits
  2852 0000141A 3C00                <1> 	cmp	al,cmos_no_floppy
  2853 0000141C 740A                <1> 	je	.error
  2854 0000141E 3C05                <1> 	cmp	al,5			; invalid value
  2855 00001420 7406                <1> 	je	.error
  2856 00001422 3C06                <1> 	cmp	al,cmos_2880
  2857 00001424 7702                <1> 	ja	.error
  2858 00001426 F8                  <1> 	clc
  2859 00001427 C3                  <1> 	ret
  2860                              <1> 
  2861                              <1> .error:
  2862 00001428 F9                  <1> 	stc
  2863 00001429 C3                  <1> 	ret
  2864                              <1> 
  2865                              <1> ;=========================================================================
  2866                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  2867                              <1> ; Input:
  2868                              <1> ;	none, expects drive number in [bp+int_13_dl]
  2869                              <1> ; Output:
  2870                              <1> ;	CF clear if successful
  2871                              <1> ;		AH = 00h
  2872                              <1> ;	CF set on error
  2873                              <1> ;		AH = 20h - invalid CMOS
  2874                              <1> ;-------------------------------------------------------------------------
  2875                              <1> fdc_detect_media:
  2876 0000142A 52                  <1> 	push	dx
  2877 0000142B 51                  <1> 	push	cx
  2878 0000142C 53                  <1> 	push	bx
  2879 0000142D 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  2880 00001430 BB9000              <1> 	mov	bx,fdc_media_state
  2881 00001433 00D3                <1> 	add	bl,dl
  2882 00001435 E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  2883 00001438 B400                <1> 	mov	ah,0
  2884 0000143A 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  2885                              <1> 
  2886 0000143C 3C03                <1> 	cmp	al,cmos_720
  2887 0000143E 7410                <1> 	je	.set_720
  2888 00001440 3C02                <1> 	cmp	al,cmos_1200
  2889 00001442 7415                <1> 	je	.detect_1200
  2890 00001444 3C04                <1> 	cmp	al,cmos_1440
  2891 00001446 7427                <1> 	je	.detect_1440
  2892 00001448 3C06                <1> 	cmp	al,cmos_2880
  2893 0000144A 7439                <1> 	je	.detect_2880
  2894                              <1> 	
  2895 0000144C B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  2896 0000144E EB02                <1> 	jmp	.set_rate
  2897                              <1> 
  2898                              <1> .set_720:
  2899 00001450 B097                <1> 	mov	al,fdc_m_720
  2900                              <1> 
  2901                              <1> .set_rate:
  2902 00001452 50                  <1> 	push	ax
  2903 00001453 E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  2904 00001456 58                  <1> 	pop	ax
  2905 00001457 EB49                <1> 	jmp	.exit_set_media
  2906                              <1> 
  2907                              <1> .detect_1200:
  2908 00001459 B000                <1> 	mov	al,0			; try 500 Kbps
  2909 0000145B E85300              <1> 	call	fdc_read_id
  2910 0000145E B015                <1> 	mov	al,fdc_m_1200in1200
  2911 00001460 7340                <1> 	jnc	.exit_set_media		; jump if successful
  2912 00001462 B040                <1> 	mov	al,40h			; try 300 Kbps
  2913 00001464 E84A00              <1> 	call	fdc_read_id
  2914 00001467 B074                <1> 	mov	al,fdc_m_360in1200
  2915 00001469 7337                <1> 	jnc	.exit_set_media		; jump if successful
  2916 0000146B B002                <1> 	mov	al,fdc_m_try_1200in1200
  2917 0000146D EB33                <1> 	jmp	.exit_set_media
  2918                              <1> 
  2919                              <1> .detect_1440:
  2920 0000146F B000                <1> 	mov	al,0			; try 500 Kbps
  2921 00001471 E83D00              <1> 	call	fdc_read_id
  2922 00001474 B017                <1> 	mov	al,fdc_m_1440
  2923 00001476 732A                <1> 	jnc	.exit_set_media		; jump if successful
  2924 00001478 B080                <1> 	mov	al,80h			; try 250 Kbps
  2925 0000147A E83400              <1> 	call	fdc_read_id
  2926 0000147D B097                <1> 	mov	al,fdc_m_720
  2927 0000147F 7321                <1> 	jnc	.exit_set_media		; jump if successful
  2928 00001481 B007                <1> 	mov	al,fdc_m_try_1440
  2929 00001483 EB1D                <1> 	jmp	.exit_set_media
  2930                              <1> 
  2931                              <1> .detect_2880:
  2932 00001485 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  2933 00001487 E82700              <1> 	call	fdc_read_id
  2934 0000148A B0D7                <1> 	mov	al,fdc_m_2880
  2935 0000148C 7314                <1> 	jnc	.exit_set_media		; jump if successful
  2936 0000148E B000                <1> 	mov	al,0			; try 500 Kbps
  2937 00001490 E81E00              <1> 	call	fdc_read_id
  2938 00001493 B017                <1> 	mov	al,fdc_m_1440
  2939 00001495 730B                <1> 	jnc	.exit_set_media		; jump if successful
  2940 00001497 B080                <1> 	mov	al,80h			; try 250 Kbps
  2941 00001499 E81500              <1> 	call	fdc_read_id
  2942 0000149C B097                <1> 	mov	al,fdc_m_720
  2943 0000149E 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  2944 000014A0 B0C7                <1> 	mov	al,fdc_m_try_2880
  2945                              <1> 
  2946                              <1> .exit_set_media:
  2947 000014A2 8807                <1> 	mov	byte [bx],al		; set media type
  2948                              <1> 
  2949                              <1> .exit:
  2950 000014A4 88264100            <1> 	mov	byte [fdc_last_error],ah
  2951 000014A8 5B                  <1> 	pop	bx
  2952 000014A9 59                  <1> 	pop	cx
  2953 000014AA 5A                  <1> 	pop	dx
  2954 000014AB C3                  <1> 	ret
  2955                              <1> 
  2956                              <1> .invalid_cmos:
  2957 000014AC B420                <1> 	mov	ah,fdc_e_failure
  2958 000014AE F9                  <1> 	stc
  2959 000014AF EBF3                <1> 	jmp	.exit
  2960                              <1> 
  2961                              <1> ;=========================================================================
  2962                              <1> ; fdc_read_id - Read ID
  2963                              <1> ; Input:
  2964                              <1> ;	AL = data transfer rate (bits 7-6)
  2965                              <1> ; Output:
  2966                              <1> ;	CF clear if successful
  2967                              <1> ;		AH = 0 - successful completion
  2968                              <1> ;		AL = ID (bits 7-6)
  2969                              <1> ;	CF set on error
  2970                              <1> ;		AH = error code
  2971                              <1> ;-------------------------------------------------------------------------
  2972                              <1> fdc_read_id:
  2973 000014B1 53                  <1> 	push	bx
  2974 000014B2 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  2975 000014B7 E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  2976 000014BA 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  2977 000014BD E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  2978 000014C0 7305                <1> 	jnc	.do_read_id
  2979 000014C2 E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  2980 000014C5 722D                <1> 	jc	.error
  2981                              <1> 
  2982                              <1> .do_read_id:
  2983 000014C7 B90300              <1> 	mov	cx,3			; 3 attempts
  2984                              <1> 
  2985                              <1> .read_id_loop:
  2986 000014CA 51                  <1> 	push	cx
  2987 000014CB B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  2988 000014CD 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  2989 000014CF B102                <1> 	mov	cl,2			; 2 byte commands
  2990 000014D1 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2991 000014D6 E8FFFD              <1> 	call	fdc_send_cmd
  2992 000014D9 7218                <1> 	jc	.error_cmd
  2993 000014DB E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2994 000014DE 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  2995 000014E0 B107                <1> 	mov	cl,7
  2996 000014E2 E858FE              <1> 	call	fdc_get_result		; read result bytes
  2997 000014E5 720C                <1> 	jc	.error_cmd
  2998 000014E7 E8A8FE              <1> 	call	fdc_get_error		; get error code
  2999 000014EA 59                  <1> 	pop	cx
  3000 000014EB 08E4                <1> 	or	ah,ah
  3001 000014ED 7406                <1> 	jz	.exit			; if no errors
  3002 000014EF E2D9                <1> 	loop	.read_id_loop		; retry
  3003 000014F1 EB01                <1> 	jmp	.error
  3004                              <1> 
  3005                              <1> .error_cmd:
  3006 000014F3 59                  <1> 	pop	cx
  3007                              <1> 
  3008                              <1> .error:
  3009 000014F4 F9                  <1> 	stc
  3010                              <1> 
  3011                              <1> .exit:
  3012 000014F5 5B                  <1> 	pop	bx
  3013 000014F6 C3                  <1> 	ret
  3014                              <1> 
  3015                              <1> ;=========================================================================
  3016                              <1> ; fdc_select_rate - Select FDC transfer rate
  3017                              <1> ; Input:
  3018                              <1> ;	AL = data transfer rate (bits 7-6)
  3019                              <1> ; Output:
  3020                              <1> ;	none
  3021                              <1> ;-------------------------------------------------------------------------
  3022                              <1> fdc_select_rate:
  3023 000014F7 53                  <1> 	push	bx
  3024 000014F8 BB9000              <1> 	mov	bx,fdc_media_state
  3025 000014FB 00D3                <1> 	add	bl,dl			; SI -> drive media state
  3026 000014FD 8A37                <1> 	mov	dh,byte [bx]		; new media status
  3027 000014FF 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  3028 00001503 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  3029 00001507 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  3030 00001509 740E                <1> 	je	.exit			; exit if rate is already selected
  3031 0000150B 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  3032 00001510 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  3033 00001514 88F0                <1> 	mov	al,dh
  3034 00001516 E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  3035                              <1> 
  3036                              <1> .exit:
  3037 00001519 5B                  <1> 	pop	bx
  3038 0000151A 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  3039 0000151D C3                  <1> 	ret
  3040                              <1> 
  3041                              <1> ;=========================================================================
  3042                              <1> ; fdc_set_rate - Set transfer rate
  3043                              <1> ; Input:
  3044                              <1> ;	AL = transfer rate (bits 7 and 6)
  3045                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  3046                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  3047                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  3048                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  3049                              <1> ; Output:
  3050                              <1> ;	AL = transfer rate (bits 1 and 0)
  3051                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  3052                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  3053                              <1> ;	DX = 3F7h - FDC CCR
  3054                              <1> ;-------------------------------------------------------------------------
  3055                              <1> fdc_set_rate:
  3056 0000151E 24C0                <1> 	and	al,fdc_m_rate_bits
  3057 00001520 D0C0                <1> 	rol	al,1
  3058 00001522 D0C0                <1> 	rol	al,1
  3059 00001524 BAF703              <1> 	mov	dx,fdc_ccr_reg
  3060 00001527 EE                  <1> 	out	dx,al
  3061 00001528 C3                  <1> 	ret
  3062                              <1> 
  3063                              <1> ;=========================================================================
  3064                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  3065                              <1> ; Input:
  3066                              <1> ;	none
  3067                              <1> ; Output:
  3068                              <1> ;	CF clear if interrupt had occurred
  3069                              <1> ;		AH = 00h - successful completion
  3070                              <1> ;	CF set if no interrupt
  3071                              <1> ;		AH = 80h - timeout
  3072                              <1> ;	BX = fdc_calib_state
  3073                              <1> ;	AL,CX - trashed
  3074                              <1> ;-------------------------------------------------------------------------
  3075                              <1> fdc_wait_irq:
  3076 00001529 FB                  <1> 	sti
  3077 0000152A F8                  <1> 	clc
  3078 0000152B B80190              <1> 	mov	ax,9001h
  3079 0000152E CD15                <1> 	int	15h			; call OS hook
  3080 00001530 7221                <1> 	jc	.timeout
  3081 00001532 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  3082 00001535 31C9                <1> 	xor	cx,cx
  3083                              <1> 
  3084                              <1> .zero:
  3085 00001537 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3086 0000153A 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3087                              <1> 
  3088                              <1> .zero_loop:
  3089 0000153C E461                <1> 	in	al,port_b_reg
  3090 0000153E A810                <1> 	test	al,refresh_flag
  3091 00001540 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3092 00001542 E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3093 00001544 EB0D                <1> 	jmp	.timeout
  3094                              <1> 
  3095                              <1> .one:
  3096 00001546 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3097 00001549 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3098                              <1> 
  3099                              <1> .one_loop:
  3100 0000154B E461                <1> 	in	al,port_b_reg
  3101 0000154D A810                <1> 	test	al,refresh_flag
  3102 0000154F 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3103 00001551 E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3104                              <1> 
  3105                              <1> .timeout:
  3106 00001553 B480                <1> 	mov	ah,fdc_e_timeout
  3107 00001555 F9                  <1> 	stc
  3108 00001556 C3                  <1> 	ret
  3109                              <1> 
  3110                              <1> .exit:
  3111 00001557 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3112 0000155A B400                <1> 	mov	ah,fdc_e_success
  3113 0000155C F8                  <1> 	clc				; DEBUG - remove after debug
  3114 0000155D C3                  <1> 	ret
  3115                              <1> 
  3116                              <1> ;=========================================================================
  3117                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3118                              <1> ;		   but no more than one second
  3119                              <1> ; Input:
  3120                              <1> ; Output:
  3121                              <1> ;	CF clear if FDC is ready
  3122                              <1> ;		AL = FDC main status register
  3123                              <1> ;	CF set on timeout
  3124                              <1> ;		AL trashed
  3125                              <1> ;	DX - trashed
  3126                              <1> ;-------------------------------------------------------------------------
  3127                              <1> 
  3128                              <1> fdc_wait_ready:
  3129 0000155E 51                  <1> 	push	cx
  3130 0000155F BAF403              <1> 	mov	dx,fdc_status_reg
  3131 00001562 31C9                <1> 	xor	cx,cx
  3132                              <1> 
  3133                              <1> .zero:
  3134 00001564 EC                  <1> 	in	al,dx			; read I/O port
  3135 00001565 A880                <1> 	test	al,fdc_stat_ready
  3136 00001567 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3137                              <1> 
  3138                              <1> .zero_loop:
  3139 00001569 E461                <1> 	in	al,port_b_reg
  3140 0000156B A810                <1> 	test	al,refresh_flag
  3141 0000156D 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3142 0000156F 49                  <1> 	dec	cx
  3143 00001570 740D                <1> 	jz	.timeout
  3144 00001572 EC                  <1> 	in	al,dx			; read I/O port again
  3145 00001573 A880                <1> 	test	al,fdc_stat_ready
  3146 00001575 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3147                              <1> 
  3148                              <1> .one_loop:
  3149 00001577 E461                <1> 	in	al,port_b_reg
  3150 00001579 A810                <1> 	test	al,refresh_flag
  3151 0000157B 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3152 0000157D E2E5                <1> 	loop	.zero
  3153                              <1> 
  3154                              <1> .timeout:
  3155 0000157F F9                  <1> 	stc
  3156                              <1> 
  3157                              <1> .exit:
  3158 00001580 59                  <1> 	pop	cx
  3159 00001581 C3                  <1> 	ret
  3160                              <1> 
  3161                              <1> ;=========================================================================
  3162                              <1> ; print_floppy - Print floppy configuration
  3163                              <1> ; Input:
  3164                              <1> ;	AL = NVRAM floppy configuration byte
  3165                              <1> ; Ouput:
  3166                              <1> ;	none
  3167                              <1> ;-------------------------------------------------------------------------
  3168                              <1> print_floppy:
  3169 00001582 50                  <1> 	push	ax
  3170 00001583 56                  <1> 	push	si
  3171 00001584 BE[F201]            <1> 	mov	si,msg_floppy
  3172 00001587 E8880C              <1> 	call	print
  3173 0000158A D0C8                <1> 	ror	al,1
  3174 0000158C D0C8                <1> 	ror	al,1
  3175 0000158E D0C8                <1> 	ror	al,1
  3176 00001590 D0C8                <1> 	ror	al,1
  3177 00001592 89C6                <1> 	mov	si,ax
  3178 00001594 83E607              <1> 	and	si,0007h
  3179 00001597 D1E6                <1> 	shl	si,1
  3180 00001599 2E8BB4[F805]        <1>     cs	mov	si,word [tbl_floppy+si]
  3181 0000159E E8710C              <1> 	call	print
  3182 000015A1 BE[1802]            <1> 	mov	si,msg_floppy_2
  3183 000015A4 E86B0C              <1> 	call	print
  3184 000015A7 D0C8                <1> 	ror	al,1
  3185 000015A9 D0C8                <1> 	ror	al,1
  3186 000015AB D0C8                <1> 	ror	al,1
  3187 000015AD D0C8                <1> 	ror	al,1
  3188 000015AF 89C6                <1> 	mov	si,ax
  3189 000015B1 83E607              <1> 	and	si,0007h
  3190 000015B4 D1E6                <1> 	shl	si,1
  3191 000015B6 2E8BB4[F805]        <1>     cs	mov	si,word [tbl_floppy+si]
  3192 000015BB E8540C              <1> 	call	print
  3193 000015BE BE[8600]            <1> 	mov	si,msg_crlf
  3194 000015C1 E84E0C              <1> 	call	print
  3195 000015C4 5E                  <1> 	pop	si
  3196 000015C5 58                  <1> 	pop	ax
  3197 000015C6 C3                  <1> 	ret
  3198                                  %include	"kbc.inc"		; keyboard controller functions
  3199                              <1> ;=========================================================================
  3200                              <1> ; kbc.inc - Keyboard controller support
  3201                              <1> ;-------------------------------------------------------------------------
  3202                              <1> ;
  3203                              <1> ; Compiles with NASM 2.07, might work with other versions
  3204                              <1> ;
  3205                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  3206                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3207                              <1> ;
  3208                              <1> ; This program is free software: you can redistribute it and/or modify
  3209                              <1> ; it under the terms of the GNU General Public License as published by
  3210                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3211                              <1> ; (at your option) any later version.
  3212                              <1> ;
  3213                              <1> ; This program is distributed in the hope that it will be useful,
  3214                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3215                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3216                              <1> ; GNU General Public License for more details.
  3217                              <1> ;
  3218                              <1> ; You should have received a copy of the GNU General Public License
  3219                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3220                              <1> ;
  3221                              <1> ;=========================================================================
  3222                              <1> 
  3223                              <1> ;=========================================================================
  3224                              <1> ; Keyboard controller defines - ports, commands, and flags
  3225                              <1> ;-------------------------------------------------------------------------
  3226                              <1> kbc_data_reg	equ	60h
  3227                              <1> kbc_input_reg	equ	60h
  3228                              <1> kbc_output_reg	equ	60h
  3229                              <1> ; keyboard controller return codes
  3230                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3231                              <1> ; keyboard controller status register and its bits
  3232                              <1> kbc_status_reg	equ	64h
  3233                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3234                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3235                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3236                              <1> ; keyboard contoller command register and commands
  3237                              <1> kbc_command_reg	equ	64h
  3238                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3239                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3240                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3241                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3242                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3243                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3244                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3245                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3246                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3247                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3248                              <1> ; keyboard controller control register bits
  3249                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3250                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3251                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3252                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3253                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3254                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3255                              <1> ; keyboard controller input port bits
  3256                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3257                              <1> 
  3258                              <1> ;=========================================================================
  3259                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3260                              <1> ; Input:
  3261                              <1> ;	AL = command
  3262                              <1> ; Output:
  3263                              <1> ;	none
  3264                              <1> ;-------------------------------------------------------------------------
  3265                              <1> kbc_kb_send:
  3266 000015C7 50                  <1> 	push	ax
  3267 000015C8 51                  <1> 	push	cx
  3268 000015C9 88C4                <1> 	mov	ah,al			; save command to AH
  3269 000015CB B90300              <1> 	mov	cx,3			; try 3 times
  3270                              <1> 
  3271                              <1> .1:
  3272 000015CE 51                  <1> 	push	cx
  3273 000015CF FA                  <1> 	cli
  3274                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3275 000015D0 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3276 000015D5 31C9                <1> 	xor	cx,cx
  3277                              <1> 
  3278                              <1> .2:					; wait for KBC to empty input buffer
  3279 000015D7 E464                <1> 	in	al,kbc_status_reg
  3280 000015D9 A802                <1> 	test	al,kbc_stat_ibf
  3281 000015DB E0FA                <1> 	loopnz	.2
  3282                              <1> 
  3283 000015DD 88E0                <1> 	mov	al,ah
  3284 000015DF E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3285 000015E1 FB                  <1> 	sti
  3286 000015E2 31C9                <1> 	xor	cx,cx
  3287                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3288 000015E4 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3289 000015E9 E1F9                <1> 	loopz	.3
  3290 000015EB 59                  <1> 	pop	cx
  3291 000015EC 7507                <1> 	jnz	.4
  3292 000015EE E2DE                <1> 	loop	.1			; try again
  3293                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3294 000015F0 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3295                              <1> .4:
  3296 000015F5 59                  <1> 	pop	cx
  3297 000015F6 58                  <1> 	pop	ax
  3298 000015F7 C3                  <1> 	ret
  3299                              <1> 
  3300                              <1> ;=========================================================================
  3301                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3302                              <1> ; Input:
  3303                              <1> ;	AL - command byte
  3304                              <1> ;	AH = argument
  3305                              <1> ; Output:
  3306                              <1> ;	ZF == 0 - success
  3307                              <1> ;	ZF == 1 - error
  3308                              <1> ;-------------------------------------------------------------------------
  3309                              <1> kbc_send_cmd:
  3310 000015F8 51                  <1> 	push	cx
  3311 000015F9 88C5                <1> 	mov	ch,al			; save command byte to CH
  3312 000015FB B11E                <1> 	mov	cl,30			; 30 retries
  3313                              <1> .1:
  3314 000015FD FA                  <1> 	cli
  3315 000015FE 88E8                <1> 	mov	al,ch
  3316 00001600 E82800              <1> 	call	kbc_send_cmd_byte
  3317 00001603 7522                <1> 	jnz	.exit			; time out
  3318 00001605 E464                <1> 	in	al,kbc_status_reg
  3319 00001607 A801                <1> 	test	al,kbc_stat_obf
  3320 00001609 7414                <1> 	jz	.3			; output buffer is empty
  3321 0000160B A820                <1> 	test	al,kbc_stat_aobf
  3322 0000160D 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3323 0000160F E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3324                              <1> %ifdef PS2_MOUSE
  3325 00001611 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3326                              <1> %endif ; PS2_MOUSE
  3327 00001616 EB07                <1> 	jmp	.3
  3328                              <1> .2:
  3329 00001618 FB                  <1> 	sti
  3330 00001619 FEC9                <1> 	dec	cl
  3331 0000161B 75E0                <1> 	jnz	.1
  3332 0000161D EB08                <1> 	jmp	.exit			; note: ZF=1
  3333                              <1> .3:
  3334 0000161F 88E0                <1> 	mov	al,ah
  3335 00001621 E660                <1> 	out	kbc_input_reg,al
  3336 00001623 FB                  <1> 	sti
  3337 00001624 80C901              <1> 	or	cl,1			; set ZF=0
  3338                              <1> .exit:
  3339 00001627 88E8                <1> 	mov	al,ch			; restore AL
  3340 00001629 59                  <1> 	pop	cx
  3341 0000162A C3                  <1> 	ret
  3342                              <1> 
  3343                              <1> ;=========================================================================
  3344                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3345                              <1> ; Input:
  3346                              <1> ;	AL - command byte
  3347                              <1> ; Output:
  3348                              <1> ;	ZF == 1 - success
  3349                              <1> ;	ZF == 0 - time out
  3350                              <1> ; Note:
  3351                              <1> ;	XXX - function should be reused in keyboard code
  3352                              <1> ;-------------------------------------------------------------------------
  3353                              <1> kbc_send_cmd_byte:
  3354 0000162B 51                  <1> 	push	cx
  3355 0000162C 50                  <1> 	push	ax
  3356 0000162D 31C9                <1> 	xor	cx,cx
  3357                              <1> 				; wait for KBC to empty input buffer
  3358                              <1> .1:
  3359 0000162F E464                <1> 	in	al,kbc_status_reg
  3360 00001631 A802                <1> 	test	al,kbc_stat_ibf
  3361 00001633 E0FA                <1> 	loopnz	.1
  3362 00001635 750C                <1> 	jnz	.exit		; time out
  3363                              <1> 
  3364 00001637 58                  <1> 	pop	ax
  3365 00001638 E664                <1> 	out	kbc_command_reg,al
  3366                              <1> 
  3367 0000163A 50                  <1> 	push	ax
  3368 0000163B 31C9                <1> 	xor	cx,cx
  3369                              <1> 				; wait for KBC to empty input buffer
  3370                              <1> .2:
  3371 0000163D E464                <1> 	in	al,kbc_status_reg
  3372 0000163F A802                <1> 	test	al,kbc_stat_ibf
  3373 00001641 E0FA                <1> 	loopnz	.2
  3374                              <1> .exit:
  3375 00001643 58                  <1> 	pop	ax
  3376 00001644 59                  <1> 	pop	cx
  3377 00001645 C3                  <1> 	ret
  3378                              <1> 
  3379                              <1> ;=========================================================================
  3380                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3381                              <1> ; Input:
  3382                              <1> ;	none
  3383                              <1> ; Output:
  3384                              <1> ;	AL = keyboard status register
  3385                              <1> ;	ZF == 0 - data is available
  3386                              <1> ;	ZF == 1 - timed out
  3387                              <1> ; Note:
  3388                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3389                              <1> ;	      be merged with kbc_wait_aux_full
  3390                              <1> ;-------------------------------------------------------------------------
  3391                              <1> kbc_wait_output_full:
  3392 00001646 51                  <1> 	push	cx
  3393 00001647 31C9                <1> 	xor	cx,cx
  3394                              <1> .1:
  3395 00001649 E464                <1> 	in	al,kbc_status_reg
  3396 0000164B A801                <1> 	test	al,kbc_stat_obf
  3397 0000164D E1FA                <1> 	loopz	.1
  3398 0000164F 09C9                <1> 	or	cx,cx
  3399 00001651 59                  <1> 	pop	cx
  3400 00001652 C3                  <1> 	ret
  3401                              <1> 
  3402                              <1> %ifdef PS2_MOUSE
  3403                              <1> ;=========================================================================
  3404                              <1> ; kbc_aux_read - read data from auxiliary device
  3405                              <1> ; Input:
  3406                              <1> ;	none
  3407                              <1> ; Output:
  3408                              <1> ;	AL = data
  3409                              <1> ;	CF == 0 - data is available
  3410                              <1> ;	CF == 1 - time out
  3411                              <1> ;-------------------------------------------------------------------------
  3412                              <1> kbc_aux_read:
  3413 00001653 51                  <1> 	push	cx
  3414                              <1> ;	xor	cx,cx			; XXX too much?!
  3415 00001654 B91400              <1> 	mov	cx,20			; retry 20 times
  3416                              <1> .1:
  3417 00001657 E86000              <1> 	call	kbc_wait_aux_full
  3418 0000165A 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3419 0000165C E1F9                <1> 	loopz	.1
  3420 0000165E EB0B                <1> 	jmp	.error			; time out
  3421                              <1> .2:
  3422 00001660 B90100              <1> 	mov	cx,1
  3423 00001663 E8B9F5              <1> 	call	delay_15us
  3424 00001666 E460                <1> 	in	al,kbc_output_reg
  3425 00001668 F8                  <1> 	clc
  3426 00001669 EB01                <1> 	jmp	.exit
  3427                              <1> .error:
  3428 0000166B F9                  <1> 	stc
  3429                              <1> .exit:
  3430 0000166C 59                  <1> 	pop	cx
  3431 0000166D C3                  <1> 	ret
  3432                              <1> 
  3433                              <1> ;=========================================================================
  3434                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3435                              <1> ; Input:
  3436                              <1> ;	AL = command
  3437                              <1> ; Output:
  3438                              <1> ;	AH - status:
  3439                              <1> ;		00h - success
  3440                              <1> ;		03h - interface error (time out)
  3441                              <1> ;		04h - resend requested
  3442                              <1> ;	CF == 0 - no error
  3443                              <1> ;	CF == 1 - error
  3444                              <1> ;-------------------------------------------------------------------------
  3445                              <1> kbc_aux_send:
  3446 0000166E 51                  <1> 	push	cx
  3447 0000166F 88C4                <1> 	mov	ah,al			; store command to AH
  3448 00001671 B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3449 00001673 E882FF              <1> 	call	kbc_send_cmd
  3450 00001676 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3451                              <1> 
  3452                              <1> 					; wait for acknowledge
  3453 00001678 B90A00              <1> 	mov	cx,10			; retry 10 times
  3454                              <1> .1:
  3455 0000167B E83C00              <1> 	call	kbc_wait_aux_full
  3456 0000167E 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3457 00001680 E2F9                <1> 	loop	.1
  3458 00001682 EB17                <1> 	jmp	.timeout		; no reply - timeout
  3459                              <1> .2:
  3460 00001684 E460                <1> 	in	al,kbc_output_reg
  3461 00001686 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3462 00001688 740C                <1> 	je	.ok
  3463 0000168A 3CFE                <1> 	cmp	al,0FEh			; resend?
  3464 0000168C 7411                <1> 	je	.resend
  3465 0000168E 3CFC                <1> 	cmp	al,0FCh			; error?
  3466 00001690 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3467 00001692 E2E7                <1> 	loop	.1
  3468 00001694 EB05                <1> 	jmp	.timeout
  3469                              <1> 
  3470                              <1> .ok:
  3471 00001696 30C0                <1> 	xor	al,al			; success - ACK received
  3472 00001698 F8                  <1> 	clc
  3473 00001699 EB07                <1> 	jmp	.exit
  3474                              <1> 
  3475                              <1> .timeout:
  3476 0000169B B003                <1> 	mov	al,03h			; interface error
  3477 0000169D EB02                <1> 	jmp	.error
  3478                              <1> 
  3479                              <1> .resend:
  3480 0000169F B004                <1> 	mov	al,04h			; resend
  3481                              <1> 
  3482                              <1> .error:
  3483 000016A1 F9                  <1> 	stc
  3484                              <1> 
  3485                              <1> .exit:
  3486 000016A2 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3487 000016A4 59                  <1> 	pop	cx
  3488 000016A5 C3                  <1> 	ret
  3489                              <1> 
  3490                              <1> ;=========================================================================
  3491                              <1> ; kbc_aux_enable - enable auxiliary device
  3492                              <1> ; Input:
  3493                              <1> ;	none
  3494                              <1> ; Output:
  3495                              <1> ;	ZF = 0 - no error
  3496                              <1> ;	ZF = 1 - error
  3497                              <1> ;-------------------------------------------------------------------------
  3498                              <1> kbc_aux_enable:
  3499 000016A6 50                  <1> 	push	ax
  3500 000016A7 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3501 000016A9 B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3502                              <1> 					; enable keyboard, enable aux obf
  3503                              <1> 					; interrupt, enable obf interrupt
  3504 000016AB E84AFF              <1> 	call	kbc_send_cmd
  3505 000016AE 58                  <1> 	pop	ax
  3506 000016AF C3                  <1> 	ret
  3507                              <1> 
  3508                              <1> ;=========================================================================
  3509                              <1> ; kbc_aux_disable - disable auxiliary device
  3510                              <1> ; Input:
  3511                              <1> ;	none
  3512                              <1> ; Output:
  3513                              <1> ;	ZF = 0 - no error
  3514                              <1> ;	ZF = 1 - error
  3515                              <1> ;-------------------------------------------------------------------------
  3516                              <1> kbc_aux_disable:
  3517 000016B0 50                  <1> 	push	ax
  3518 000016B1 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3519 000016B3 B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3520                              <1> 					; enable keyboard, disable aux obf
  3521                              <1> 					; interrupt, enable obf interrupt
  3522 000016B5 E840FF              <1> 	call	kbc_send_cmd
  3523 000016B8 58                  <1> 	pop	ax
  3524 000016B9 C3                  <1> 	ret
  3525                              <1> 
  3526                              <1> ;=========================================================================
  3527                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3528                              <1> ; Input:
  3529                              <1> ;	none
  3530                              <1> ; Output:
  3531                              <1> ;	AL = keyboard status register
  3532                              <1> ;	ZF == 0 - data is available
  3533                              <1> ;	ZF == 1 - timed out
  3534                              <1> ;-------------------------------------------------------------------------
  3535                              <1> kbc_wait_aux_full:
  3536 000016BA E889FF              <1> 	call	kbc_wait_output_full
  3537 000016BD 7402                <1> 	jz	.error
  3538 000016BF A820                <1> 	test	al,kbc_stat_aobf
  3539                              <1> .error:
  3540 000016C1 C3                  <1> 	ret
  3541                              <1> 
  3542                              <1> %endif ; PS2_MOUSE
  3543                              <1> 
  3544                              <1> ;=========================================================================
  3545                              <1> ; kbc_flush - flush all data from i8042 buffers
  3546                              <1> ; Input:
  3547                              <1> ;	none
  3548                              <1> ; Output:
  3549                              <1> ;	CF = 0 - flushed successfully
  3550                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3551                              <1> ;-------------------------------------------------------------------------
  3552                              <1> kbc_flush:
  3553 000016C2 50                  <1> 	push	ax
  3554 000016C3 51                  <1> 	push	cx
  3555 000016C4 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3556                              <1> .flush_next_byte:
  3557 000016C7 E464                <1> 	in	al,kbc_status_reg
  3558 000016C9 A801                <1> 	test	al,kbc_stat_obf
  3559 000016CB 740F                <1> 	jz	.flushed
  3560 000016CD 51                  <1> 	push	cx
  3561 000016CE B90400              <1> 	mov	cx,4
  3562 000016D1 E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3563 000016D4 59                  <1> 	pop	cx
  3564 000016D5 E460                <1> 	in	al,kbc_data_reg
  3565 000016D7 E2EE                <1> 	loop	.flush_next_byte
  3566 000016D9 F9                  <1> 	stc				; unable to flush it
  3567 000016DA EB01                <1> 	jmp	.exit
  3568                              <1> .flushed:
  3569 000016DC F8                  <1> 	clc
  3570                              <1> .exit:
  3571 000016DD 59                  <1> 	pop	cx
  3572 000016DE 58                  <1> 	pop	ax
  3573 000016DF C3                  <1> 	ret
  3574                              <1> 
  3575                              <1> ;=========================================================================
  3576                              <1> ; kbc_init - Initialize keyboard controller
  3577                              <1> ;-------------------------------------------------------------------------
  3578                              <1> kbc_init:
  3579 000016E0 50                  <1> 	push	ax
  3580 000016E1 51                  <1> 	push	cx
  3581 000016E2 52                  <1> 	push	dx
  3582                              <1> 
  3583                              <1> ;-------------------------------------------------------------------------
  3584                              <1> ; test keyboard controller
  3585                              <1> 
  3586 000016E3 E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3587                              <1> 
  3588 000016E6 B90A00              <1> 	mov	cx,10			; try 10 times
  3589                              <1> 
  3590                              <1> .kbc_reset_retry:
  3591 000016E9 B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3592 000016EB E83DFF              <1> 	call 	kbc_send_cmd_byte
  3593 000016EE E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3594                              <1> 
  3595 000016F1 E460                <1> 	in	al,kbc_output_reg
  3596 000016F3 3C55                <1> 	cmp	al,55h			; check for success
  3597 000016F5 E0F2                <1> 	loopne	.kbc_reset_retry
  3598 000016F7 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3599                              <1> 
  3600 000016FC B90A00              <1> 	mov	cx,10			; try 10 times
  3601                              <1> 
  3602                              <1> .kbc_test_retry:
  3603 000016FF B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3604 00001701 E827FF              <1> 	call	kbc_send_cmd_byte
  3605 00001704 E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3606                              <1> 
  3607 00001707 E460                <1> 	in	al,kbc_output_reg
  3608 00001709 3C00                <1> 	cmp	al,0			; check for success
  3609 0000170B E0F2                <1> 	loopne	.kbc_test_retry
  3610 0000170D 7403E98E00          <1> 	jne	kbd_int_fail
  3611                              <1> 
  3612                              <1> ;-------------------------------------------------------------------------
  3613                              <1> ; read display type and set equipment bits accordingly
  3614                              <1> 
  3615 00001712 B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3616 00001714 E814FF              <1> 	call	kbc_send_cmd_byte
  3617 00001717 E82CFF              <1> 	call	kbc_wait_output_full
  3618                              <1> 
  3619 0000171A E460                <1> 	in	al,kbc_output_reg
  3620 0000171C A840                <1> 	test	al,kbc_in_display
  3621 0000171E 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3622 00001720 830E100030          <1> 	or	word [equipment_list],equip_mono
  3623 00001725 EB05                <1> 	jmp	.get_disp_done
  3624                              <1> .get_disp_color:
  3625 00001727 830E100020          <1> 	or	word [equipment_list],equip_color
  3626                              <1> .get_disp_done:
  3627                              <1> 
  3628                              <1> ;-------------------------------------------------------------------------
  3629                              <1> ; initialize keyboard controller
  3630                              <1> 
  3631 0000172C B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  3632 0000172E E8FAFE              <1> 	call	kbc_send_cmd_byte
  3633                              <1> 
  3634 00001731 B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  3635 00001733 E8F5FE              <1> 	call	kbc_send_cmd_byte
  3636                              <1> 
  3637 00001736 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  3638 00001738 B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  3639                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  3640                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  3641                              <1> 					; Bit 4 = 0 - Enable keyboard
  3642                              <1> 					; Bit 3 = 1 - Disable inhibit
  3643                              <1> 					; Bit 2 = 0 - system flag = 0
  3644                              <1> 					; Bit 1 = 0 - reserved
  3645                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  3646 0000173A E8BBFE              <1> 	call	kbc_send_cmd
  3647                              <1> 
  3648 0000173D B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  3649 0000173F E8E9FE              <1> 	call	kbc_send_cmd_byte
  3650                              <1> 
  3651 00001742 B90010              <1> 	mov	cx,1000h
  3652 00001745 E8D7F4              <1> 	call	delay_15us
  3653                              <1> 
  3654 00001748 E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  3655 0000174B E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  3656                              <1> 
  3657                              <1> ;-------------------------------------------------------------------------
  3658                              <1> ; check for PS/2 mouse presence
  3659                              <1> 
  3660 0000174D B90A00              <1> 	mov	cx,10			; try 10 times
  3661                              <1> .mouse_reset_retry:
  3662 00001750 B0FF                <1> 	mov	al,0FFh
  3663 00001752 E819FF              <1> 	call	kbc_aux_send
  3664 00001755 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  3665 00001757 80FC03              <1> 	cmp	ah,03h			; timeout error?
  3666 0000175A E1F4                <1> 	loopz	.mouse_reset_retry
  3667 0000175C EB13                <1> 	jmp	.no_mouse
  3668                              <1> .mouse_reset_ok:
  3669 0000175E E8F2FE              <1> 	call	kbc_aux_read
  3670 00001761 720E                <1> 	jc	.no_mouse
  3671 00001763 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  3672 00001765 750A                <1> 	jne	.no_mouse
  3673 00001767 E8E9FE              <1> 	call	kbc_aux_read
  3674 0000176A 7205                <1> 	jc	.no_mouse
  3675                              <1> ; mouse reset successful, update equipment word accordingly
  3676 0000176C 830E100004          <1> 	or      word [equipment_list],equip_mouse
  3677                              <1> .no_mouse:
  3678                              <1> 
  3679                              <1> ;-------------------------------------------------------------------------
  3680                              <1> ; setup keyboard buffer
  3681                              <1> 
  3682 00001771 B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  3683 00001774 A38000              <1>         mov     word [kbd_buffer_start],ax
  3684 00001777 A31A00              <1>         mov     word [kbd_buffer_head],ax
  3685 0000177A A31C00              <1>         mov     word [kbd_buffer_tail],ax
  3686 0000177D 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  3687 00001780 A38200              <1>         mov     word [kbd_buffer_end],ax
  3688 00001783 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  3689 00001785 A31700              <1>         mov     word [kbd_flags_1],ax
  3690 00001788 A31800              <1>         mov     word [kbd_flags_2],ax
  3691 0000178B A39600              <1>         mov     word [kbd_flags_3],ax
  3692 0000178E A39700              <1>         mov     word [kbd_flags_4],ax
  3693 00001791 B010                <1> 	mov	al,e_kbd_ok
  3694 00001793 E680                <1> 	out	post_reg,al
  3695 00001795 5A                  <1> 	pop	dx
  3696 00001796 59                  <1> 	pop	cx
  3697 00001797 58                  <1> 	pop	ax
  3698 00001798 C3                  <1> 	ret
  3699                              <1> 
  3700                              <1> kbd_ctrl_fail:
  3701 00001799 B060                <1> 	mov	al,e_kbd_ctrl_fail
  3702 0000179B E680                <1> 	out	post_reg,al
  3703                              <1> .1:
  3704 0000179D F4                  <1> 	hlt
  3705 0000179E EBFD                <1> 	jmp	.1
  3706                              <1> 
  3707                              <1> kbd_int_fail:
  3708 000017A0 240F                <1> 	and	al,0Fh
  3709 000017A2 0463                <1> 	add	al,e_kbd_int_fail
  3710 000017A4 E680                <1> 	out	post_reg,al
  3711                              <1> .1:
  3712 000017A6 F4                  <1> 	hlt
  3713 000017A7 EBFD                <1> 	jmp	.1
  3714                              <1> 
  3715                              <1> kbd_key_fail:
  3716 000017A9 B061                <1> 	mov	al,e_kbd_key_fail
  3717 000017AB E680                <1> 	out	post_reg,al
  3718                              <1> .1:
  3719 000017AD F4                  <1> 	hlt
  3720 000017AE EBFD                <1> 	jmp	.1
  3721                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  3722                              <1> ;=========================================================================
  3723                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  3724                              <1> ;		 and related INT 16h functions:
  3725                              <1> ;	INT 16h - BIOS Keyboard Services
  3726                              <1> ;		- function AH=00h
  3727                              <1> ;		- function AH=01h
  3728                              <1> ;		- function AH=10h
  3729                              <1> ;		- function AH=11h
  3730                              <1> ;-------------------------------------------------------------------------
  3731                              <1> ;
  3732                              <1> ; Compiles with NASM 2.07, might work with other versions
  3733                              <1> ;
  3734                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  3735                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3736                              <1> ;
  3737                              <1> ; This program is free software: you can redistribute it and/or modify
  3738                              <1> ; it under the terms of the GNU General Public License as published by
  3739                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3740                              <1> ; (at your option) any later version.
  3741                              <1> ;
  3742                              <1> ; This program is distributed in the hope that it will be useful,
  3743                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3744                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3745                              <1> ; GNU General Public License for more details.
  3746                              <1> ;
  3747                              <1> ; You should have received a copy of the GNU General Public License
  3748                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3749                              <1> ;
  3750                              <1> ;=========================================================================
  3751                              <1> 
  3752                              <1> ;=========================================================================
  3753                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  3754                              <1> ;                   BIOS scan code translation table
  3755                              <1> ; Note 1: Table starts with scancode == 1
  3756                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  3757                              <1> ;	00 - no flags
  3758                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  3759                              <1> ;	     x in this case equals digit value
  3760                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  3761                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  3762                              <1> ;	8x - F11, F12 BIOS scan codes
  3763                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  3764                              <1> ;-------------------------------------------------------------------------
  3765                              <1> 
  3766                              <1> scan_xlat_table:
  3767                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3768 000017B0 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  3769 000017B8 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  3770 000017C0 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  3771 000017C8 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  3772 000017D0 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  3773 000017D8 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  3774 000017E0 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  3775 000017E8 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  3776 000017F0 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  3777 000017F8 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  3778 00001800 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  3779 00001808 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  3780 00001810 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  3781 00001818 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  3782 00001820 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  3783 00001828 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  3784                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3785 00001830 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  3786 00001838 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  3787 00001840 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  3788 00001848 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  3789 00001850 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  3790 00001858 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  3791 00001860 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  3792 00001868 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  3793 00001870 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  3794 00001878 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  3795 00001880 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  3796 00001888 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  3797 00001890 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  3798 00001898 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  3799 000018A0 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  3800 000018A8 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  3801                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3802 000018B0 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  3803 000018B8 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  3804 000018C0 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  3805 000018C8 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  3806 000018D0 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  3807 000018D8 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  3808 000018E0 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  3809 000018E8 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  3810 000018F0 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  3811 000018F8 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  3812 00001900 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  3813 00001908 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  3814 00001910 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  3815 00001918 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  3816 00001920 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  3817 00001928 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  3818                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3819 00001930 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  3820 00001938 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  3821 00001940 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  3822 00001948 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  3823 00001950 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  3824 00001958 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  3825 00001960 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  3826 00001968 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  3827 00001970 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  3828 00001978 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  3829 00001980 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  3830 00001988 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  3831 00001990 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  3832 00001998 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  3833 000019A0 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  3834 000019A8 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  3835                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3836 000019B0 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  3837 000019B8 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  3838 000019C0 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  3839 000019C8 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  3840 000019D0 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  3841 000019D8 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  3842 000019E0 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  3843 000019E8 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  3844 000019F0 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  3845 000019F8 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  3846 00001A00 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  3847 00001A08 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  3848 00001A10 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  3849 00001A18 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  3850 00001A20 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  3851 00001A28 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  3852                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  3853 00001A30 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  3854 00001A38 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  3855 00001A40 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  3856 00001A48 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  3857 00001A50 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  3858 00001A58 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  3859 00001A60 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  3860 00001A68 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  3861                              <1> .end:
  3862                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  3863                              <1> 
  3864                              <1> ;=========================================================================
  3865                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  3866                              <1> ; Input:
  3867                              <1> ;	AL - scan code
  3868                              <1> ; Output:
  3869                              <1> ;	AX - ASCII character / scan code pair
  3870                              <1> ;-------------------------------------------------------------------------
  3871                              <1> scan_xlat:
  3872 00001A70 53                  <1> 	push	bx
  3873 00001A71 FEC8                <1> 	dec	al
  3874 00001A73 3C58                <1> 	cmp	al,scan_xlat_table_size
  3875 00001A75 7205                <1> 	jb	.1
  3876 00001A77 31C0                <1> 	xor	ax,ax
  3877 00001A79 E9AB00              <1> 	jmp	.exit
  3878                              <1> 
  3879                              <1> .1:
  3880 00001A7C B700                <1> 	mov	bh,00h				; calculate offset of the key
  3881 00001A7E 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  3882 00001A80 D1E3                <1> 	shl	bx,1				; BX = AL * 8
  3883 00001A82 D1E3                <1> 	shl	bx,1
  3884 00001A84 D1E3                <1> 	shl	bx,1
  3885                              <1> 
  3886 00001A86 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  3887 00001A8B 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  3888 00001A8D 2E8B87[B617]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  3889                              <1> 	; check for numeric Keypad keys
  3890 00001A92 2EF687[B117]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  3891 00001A98 7474                <1> 	jz	.check_extended
  3892 00001A9A F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  3893 00001A9F 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  3894                              <1> 						; and so it is not a keypad key
  3895                              <1> 
  3896 00001AA1 2E8A87[B117]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  3897 00001AA6 240F                <1> 	and	al,0Fh				; get the numeric value
  3898 00001AA8 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  3899 00001AAC D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  3900 00001AAE A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  3901                              <1> 
  3902 00001AB1 31C0                <1> 	xor	ax,ax				; return nothing
  3903 00001AB3 EB72                <1> 	jmp	.exit
  3904                              <1> 
  3905                              <1> .check_ctrl:
  3906 00001AB5 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  3907 00001ABA 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  3908 00001ABC 2E8B87[B417]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  3909 00001AC1 EB4B                <1> 	jmp	.check_extended
  3910                              <1> 
  3911                              <1> .check_locks:
  3912 00001AC3 2EF687[B117]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  3913 00001AC9 741D                <1> 	jz	.check_shift			; not affected by Locks
  3914                              <1> 
  3915 00001ACB 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  3916 00001ACD 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  3917                              <1> 
  3918 00001ACF F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  3919 00001AD4 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  3920 00001AD6 EB07                <1> 	jmp	.lock_active
  3921                              <1> 
  3922                              <1> .check_num_lock:
  3923 00001AD8 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  3924 00001ADD 7409                <1> 	jz	.check_shift			; Num Lock is not active
  3925                              <1> .lock_active:
  3926                              <1> 	; are any of Shift keys active?
  3927 00001ADF F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  3928 00001AE4 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  3929 00001AE6 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  3930                              <1> 
  3931                              <1> .check_shift:
  3932                              <1> 	; are any of Shift keys active?
  3933 00001AE8 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  3934 00001AED 7407                <1> 	jz	.no_shift
  3935                              <1> .shift:
  3936 00001AEF 2E8B87[B217]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  3937 00001AF4 EB18                <1> 	jmp	.check_extended
  3938                              <1> 
  3939                              <1> .no_shift:
  3940 00001AF6 88C4                <1> 	mov	ah,al				; Move scan code to AH
  3941 00001AF8 FEC4                <1> 	inc	ah
  3942 00001AFA 2E8A87[B017]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  3943 00001AFF 2EF687[B117]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  3944 00001B05 7407                <1> 	jz	.check_extended			; not F11 or F12
  3945 00001B07 2E8AA7[B117]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  3946 00001B0C EB19                <1> 	jmp	.exit
  3947                              <1> 
  3948                              <1> .check_extended:
  3949 00001B0E 2EF687[B117]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  3950 00001B14 7411                <1> 	jz	.exit				; no extended key
  3951 00001B16 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  3952 00001B1B 740A                <1> 	jz	.exit				; ... not a 0E0h
  3953 00001B1D 3C00                <1> 	cmp	al,00h
  3954 00001B1F 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  3955 00001B21 B0E0                <1> 	mov	al,0E0h				; indicate extended key
  3956 00001B23 EB02                <1> 	jmp	.exit
  3957                              <1> 
  3958                              <1> .ascii_code:
  3959 00001B25 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  3960                              <1> 						; key with valid ASCII code
  3961                              <1> 						; (Keypad Enter, *, and /)
  3962                              <1> 
  3963                              <1> .exit:
  3964 00001B27 5B                  <1> 	pop	bx
  3965 00001B28 C3                  <1> 	ret
  3966                              <1> 
  3967                              <1> ;=========================================================================
  3968                              <1> ; int_16_fn00 - get keystroke
  3969                              <1> ; Input:
  3970                              <1> ;	AH = 00h
  3971                              <1> ; Output:
  3972                              <1> ;	AH = BIOS scan code
  3973                              <1> ;	AL = ASCII character
  3974                              <1> ; Notes:
  3975                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  3976                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  3977                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  3978                              <1> ;	- Use function AH=10h for extended keystrokes handling
  3979                              <1> ;-------------------------------------------------------------------------
  3980                              <1> int_16_fn00:
  3981 00001B29 FB                  <1> 	sti
  3982                              <1> .1:
  3983 00001B2A 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  3984 00001B2E 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  3985 00001B32 74F6                <1> 	jz	.1			; wait or keystroke
  3986 00001B34 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  3987 00001B36 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  3988                              <1> 					;   location
  3989 00001B39 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  3990 00001B3D 7504                <1> 	jne	.2
  3991 00001B3F 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  3992                              <1> .2:
  3993 00001B43 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  3994 00001B47 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  3995                              <1> 					;   extended key?
  3996 00001B49 7504                <1> 	jne	.3			; not a convertible key
  3997 00001B4B B000                <1> 	mov	al,00h			; convert to a standard key
  3998 00001B4D EB2C                <1> 	jmp	.exit
  3999                              <1> .3:
  4000 00001B4F 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4001 00001B51 74D7                <1> 	je	.1			; an ignored extended key, get next key
  4002 00001B53 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4003                              <1> 					;   (scancode above 84h)
  4004 00001B56 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  4005 00001B58 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4006 00001B5B 751E                <1> 	jne	.exit
  4007 00001B5D 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4008 00001B5F 7504                <1> 	jne	.4
  4009 00001B61 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4010 00001B63 EB16                <1> 	jmp	.exit
  4011                              <1> .4:
  4012 00001B65 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4013 00001B67 7504                <1> 	jne	.5
  4014 00001B69 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4015 00001B6B EB0E                <1> 	jmp	.exit
  4016                              <1> .5:
  4017 00001B6D 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4018 00001B6F 7504                <1> 	jne	.6
  4019 00001B71 B435                <1> 	mov	ah,35h			; standard / scancode
  4020 00001B73 EB06                <1> 	jmp	.exit
  4021                              <1> .6:
  4022 00001B75 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4023 00001B77 7502                <1> 	jne	.exit
  4024 00001B79 B437                <1> 	mov	ah,37h			; standard * scancode
  4025                              <1> .exit:
  4026 00001B7B E9ED4C              <1> 	jmp	int_16_exit
  4027                              <1> 
  4028                              <1> ;=========================================================================
  4029                              <1> ; int_16_fn01 - check for keystroke
  4030                              <1> ; Input:
  4031                              <1> ;	AH = 01h
  4032                              <1> ; Output:
  4033                              <1> ;	ZF = 1 - no keystroke available
  4034                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4035                              <1> ;		AH = BIOS scan code
  4036                              <1> ;		AL = ASCII character
  4037                              <1> ; Notes:
  4038                              <1> ;	- Does not remove keystroke from keyboard buffer
  4039                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4040                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4041                              <1> ;	- Use function AH=11h for extended keystrokes handling
  4042                              <1> ;-------------------------------------------------------------------------
  4043                              <1> int_16_fn01:
  4044 00001B7E 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4045 00001B82 8B07                <1> 	mov	ax,word [bx]
  4046 00001B84 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4047 00001B88 7436                <1> 	jz	.exit			; no keystroke, exit
  4048 00001B8A 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4049                              <1> 					;   extended key?
  4050 00001B8C 7504                <1> 	jne	.1			; not a convertible key
  4051 00001B8E B000                <1> 	mov	al,00h			; convert to a standard key
  4052 00001B90 EB2C                <1> 	jmp	.clear_zf
  4053                              <1> .1:
  4054 00001B92 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4055 00001B94 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  4056 00001B96 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4057                              <1> 					;   (scancode above 84h)
  4058 00001B99 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  4059 00001B9B 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4060 00001B9E 751E                <1> 	jne	.clear_zf
  4061 00001BA0 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4062 00001BA2 7504                <1> 	jne	.2
  4063 00001BA4 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4064 00001BA6 EB16                <1> 	jmp	.clear_zf
  4065                              <1> .2:
  4066 00001BA8 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4067 00001BAA 7504                <1> 	jne	.3
  4068 00001BAC B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4069 00001BAE EB0E                <1> 	jmp	.clear_zf
  4070                              <1> .3:
  4071 00001BB0 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4072 00001BB2 7504                <1> 	jne	.4
  4073 00001BB4 B435                <1> 	mov	ah,35h			; standard / scancode
  4074 00001BB6 EB06                <1> 	jmp	.clear_zf
  4075                              <1> .4:
  4076 00001BB8 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4077 00001BBA 7502                <1> 	jne	.clear_zf
  4078 00001BBC B437                <1> 	mov	ah,37h			; standard * scancode
  4079                              <1> 
  4080                              <1> .clear_zf:
  4081 00001BBE 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4082                              <1> .exit:
  4083 00001BC0 E9AB4C              <1> 	jmp	int_16_exitf
  4084                              <1> 
  4085                              <1> .discard_key:
  4086 00001BC3 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4087                              <1> 					;   location
  4088 00001BC6 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4089 00001BCA 7504                <1> 	jne	.5
  4090 00001BCC 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4091                              <1> .5:
  4092 00001BD0 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4093 00001BD4 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4094                              <1> 	
  4095                              <1> 
  4096                              <1> ;=========================================================================
  4097                              <1> ; int_16_fn10 - get extended keystroke
  4098                              <1> ; Input:
  4099                              <1> ;	AH = 10h
  4100                              <1> ; Output:
  4101                              <1> ;	AH = BIOS scan code
  4102                              <1> ;	AL = ASCII character
  4103                              <1> ; Note:
  4104                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4105                              <1> ;-------------------------------------------------------------------------
  4106                              <1> int_16_fn10:
  4107 00001BD6 FB                  <1> 	sti
  4108                              <1> .1:
  4109 00001BD7 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4110 00001BDB 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4111 00001BDF 74F6                <1> 	jz	.1			; wait or keystroke
  4112 00001BE1 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4113 00001BE3 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4114                              <1> 					;   location
  4115 00001BE6 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4116 00001BEA 7504                <1> 	jne	.2
  4117 00001BEC 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4118                              <1> .2:
  4119 00001BF0 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4120 00001BF4 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4121 00001BF6 7502                <1> 	jne	.exit			; not a extended key
  4122 00001BF8 B000                <1> 	mov	al,00h			; set scancode to zero
  4123                              <1> 
  4124                              <1> .exit:
  4125 00001BFA E96E4C              <1> 	jmp	int_16_exit
  4126                              <1> 
  4127                              <1> ;=========================================================================
  4128                              <1> ; int_16_fn11 - check for extended keystroke
  4129                              <1> ; Input:
  4130                              <1> ;	AH = 01h
  4131                              <1> ; Output:
  4132                              <1> ;	ZF = 1 - no keystroke available
  4133                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4134                              <1> ;		AH = BIOS scan code
  4135                              <1> ;		AL = ASCII character
  4136                              <1> ; Note:
  4137                              <1> ;	- Does not remove keystroke from keyboard buffer
  4138                              <1> ;-------------------------------------------------------------------------
  4139                              <1> int_16_fn11:
  4140 00001BFD 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4141 00001C01 8B07                <1> 	mov	ax,word [bx]
  4142 00001C03 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4143 00001C07 7408                <1> 	jz	.exit			; no keystroke, exit
  4144 00001C09 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4145 00001C0B 7502                <1> 	jne	.clear_zf		; not a extended key
  4146 00001C0D B000                <1> 	mov	al,00h			; set scancode to zero
  4147                              <1> .clear_zf:
  4148 00001C0F 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4149                              <1> .exit:
  4150 00001C11 E95A4C              <1> 	jmp	int_16_exitf
  4151                                  %include	"serial1.inc"		; serial port services & detection
  4152                              <1> ;========================================================================
  4153                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
  4154                              <1> ;       INT 14h, function AH=01h
  4155                              <1> ;	INT 14h, function AH=02h
  4156                              <1> ;	detect_serial
  4157                              <1> ;	serial port related definitions and tables
  4158                              <1> ;	- see serial2.inc for other INT 14h functions
  4159                              <1> ;-------------------------------------------------------------------------
  4160                              <1> ;
  4161                              <1> ; Compiles with NASM 2.07, might work with other versions
  4162                              <1> ;
  4163                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4164                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4165                              <1> ;
  4166                              <1> ; This program is free software: you can redistribute it and/or modify
  4167                              <1> ; it under the terms of the GNU General Public License as published by
  4168                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4169                              <1> ; (at your option) any later version.
  4170                              <1> ;
  4171                              <1> ; This program is distributed in the hope that it will be useful,
  4172                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4173                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4174                              <1> ; GNU General Public License for more details.
  4175                              <1> ;
  4176                              <1> ; You should have received a copy of the GNU General Public License
  4177                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4178                              <1> ;
  4179                              <1> ;=========================================================================
  4180                              <1> 
  4181                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
  4182                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
  4183                              <1> 
  4184                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
  4185                              <1> 
  4186                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
  4187                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
  4188                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
  4189                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
  4190                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
  4191                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
  4192                              <1> 
  4193                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
  4194                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
  4195                              <1> uart_mcr_rts	equ	3		; MCR - request to send (RTS)
  4196                              <1> 
  4197                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
  4198                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
  4199                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
  4200                              <1> 
  4201                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
  4202                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
  4203                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
  4204                              <1> 
  4205                              <1> uart_err_timeout equ	80h		; timeout error
  4206                              <1> 
  4207                              <1> num_serial	equ	4		; number of serial ports
  4208                              <1> 
  4209                              <1> ;=========================================================================
  4210                              <1> ; int_14_fn01 - Send character
  4211                              <1> ; Input:
  4212                              <1> ;	AH = 01h - function 01h - send character
  4213                              <1> ;	AL = character to send
  4214                              <1> ;	DX = serial port number (0-3)
  4215                              <1> ; Output:
  4216                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4217                              <1> ;-------------------------------------------------------------------------
  4218                              <1> int_14_fn01:
  4219 00001C14 50                  <1> 	push	ax
  4220 00001C15 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4221 00001C17 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR
  4222 00001C19 B320                <1> 	mov	bl,uart_lsr_thre	; and for THR empty in LSR
  4223 00001C1B E82200              <1> 	call	uart_wait_status
  4224 00001C1E 59                  <1> 	pop	cx
  4225 00001C1F 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
  4226 00001C21 88C8                <1> 	mov	al,cl
  4227 00001C23 EE                  <1> 	out	dx,al			; sent the character
  4228 00001C24 E93F4B              <1> 	jmp	int_14_exit
  4229                              <1> 
  4230                              <1> int_14_timeout:
  4231 00001C27 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
  4232 00001C29 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
  4233 00001C2C E9374B              <1> 	jmp	int_14_exit
  4234                              <1> 
  4235                              <1> ;=========================================================================
  4236                              <1> ; int_14_fn02 - Receive character
  4237                              <1> ; Input:
  4238                              <1> ;	AH = 02h - function 02h - receive character
  4239                              <1> ;	DX = serial port number (0-3)
  4240                              <1> ; Output:
  4241                              <1> ;	AL = character received
  4242                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4243                              <1> ;-------------------------------------------------------------------------
  4244                              <1> int_14_fn02:
  4245 00001C2F 50                  <1> 	push	ax
  4246 00001C30 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4247 00001C32 B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR
  4248 00001C34 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR
  4249 00001C36 E80700              <1> 	call	uart_wait_status
  4250 00001C39 59                  <1> 	pop	cx
  4251 00001C3A 75EB                <1> 	jnz	int_14_timeout
  4252 00001C3C EC                  <1> 	in	al,dx			; receive the character
  4253 00001C3D E9264B              <1> 	jmp	int_14_exit
  4254                              <1> 
  4255                              <1> ;=========================================================================
  4256                              <1> ; uart_wait_status - wait for modem and line status
  4257                              <1> ; Input:
  4258                              <1> ;	AL = value to write to MCR (Modem Control Register)
  4259                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
  4260                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
  4261                              <1> ;	DX = UART base address
  4262                              <1> ;	SI = serial port number
  4263                              <1> ; Output:
  4264                              <1> ;	AH = line status
  4265                              <1> ;	ZF = 0 - timeout
  4266                              <1> ;	CX,BX - destroyed
  4267                              <1> ;-------------------------------------------------------------------------
  4268                              <1> uart_wait_status:
  4269 00001C40 52                  <1> 	push	dx
  4270 00001C41 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
  4271 00001C44 EE                  <1> 	out	dx,al			; output MCR value
  4272 00001C45 42                  <1> 	inc	dx
  4273 00001C46 42                  <1> 	inc	dx			; DX = UART MSR address
  4274                              <1> 					; OPTIMIZATION:
  4275                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
  4276 00001C47 E80A00              <1> 	call	wait_for_port		; wait for MSR status
  4277 00001C4A 7506                <1> 	jnz	.wait_exit
  4278 00001C4C 4A                  <1> 	dec	dx			; DX = UART LSR address
  4279                              <1> 					; OPTIMIZATION:
  4280                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
  4281 00001C4D 88DF                <1> 	mov	bh,bl			; BH = LSR mask
  4282 00001C4F E80200              <1> 	call	wait_for_port		; wait for LSR status
  4283                              <1> .wait_exit:
  4284 00001C52 5A                  <1> 	pop	dx
  4285 00001C53 C3                  <1> 	ret
  4286                              <1> 
  4287                              <1> ;=========================================================================
  4288                              <1> ; wait_for_port - wait for set bits in a register
  4289                              <1> ;
  4290                              <1> ; Input:
  4291                              <1> ;	BH = mask to wait for (bits that need to be 1)
  4292                              <1> ;	DX = register address
  4293                              <1> ;	SI = address of the timeout value (in seconds)
  4294                              <1> ; Output:
  4295                              <1> ;	AH = last port reading
  4296                              <1> ;	ZF clear on timeout
  4297                              <1> ;	ZF set on success
  4298                              <1> ;	AL - trashed
  4299                              <1> ;	CX - trashed
  4300                              <1> ;-------------------------------------------------------------------------
  4301                              <1> wait_for_port:
  4302 00001C54 53                  <1> 	push	bx
  4303 00001C55 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
  4304                              <1> 
  4305                              <1> .loop_outer:
  4306 00001C57 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
  4307                              <1> 
  4308                              <1> .loop_inner:
  4309 00001C5A EC                  <1> 	in	al,dx			; read the register
  4310 00001C5B 88C4                <1> 	mov	ah,al			; save register in AH
  4311 00001C5D 20F8                <1> 	and	al,bh
  4312 00001C5F 38F8                <1> 	cmp	al,bh			; required bits are set?
  4313 00001C61 7414                <1> 	je	.exit
  4314                              <1> 
  4315                              <1> .zero_loop:
  4316 00001C63 E461                <1> 	in	al,port_b_reg
  4317 00001C65 A810                <1> 	test	al,refresh_flag
  4318 00001C67 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  4319                              <1> 
  4320                              <1> .one_loop:
  4321 00001C69 E461                <1> 	in	al,port_b_reg
  4322 00001C6B A810                <1> 	test	al,refresh_flag
  4323 00001C6D 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  4324 00001C6F E2E9                <1> 	loop	.loop_inner
  4325                              <1> 
  4326 00001C71 FECB                <1> 	dec	bl
  4327 00001C73 75E2                <1> 	jnz	.loop_outer
  4328 00001C75 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
  4329                              <1> 
  4330                              <1> .exit:
  4331 00001C77 5B                  <1> 	pop	bx
  4332 00001C78 C3                  <1> 	ret
  4333                              <1> 
  4334                              <1> ;=========================================================================
  4335                              <1> ; detect_serial - detect and print serial ports
  4336                              <1> ; Input:
  4337                              <1> ;	none
  4338                              <1> ; Output:
  4339                              <1> ;	none (updates BIOS data area)
  4340                              <1> ;-------------------------------------------------------------------------
  4341                              <1> detect_serial:
  4342 00001C79 50                  <1> 	push	ax
  4343 00001C7A 53                  <1> 	push	bx
  4344 00001C7B 52                  <1> 	push	dx
  4345 00001C7C 56                  <1> 	push	si
  4346 00001C7D BE[9902]            <1> 	mov	si,msg_serial
  4347 00001C80 E88F05              <1> 	call	print
  4348 00001C83 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
  4349 00001C86 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
  4350 00001C8A 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
  4351 00001C8E 31DB                <1> 	xor	bx,bx			; BX = 0
  4352                              <1> .detect_loop:
  4353 00001C90 BE[B602]            <1> 	mov	si,msg_serial_com
  4354 00001C93 E87C05              <1> 	call	print
  4355 00001C96 88D8                <1> 	mov	al,bl
  4356 00001C98 D0E8                <1> 	shr	al,1
  4357 00001C9A FEC0                <1> 	inc	al			; AL = COM port number (1..4)
  4358 00001C9C E8D205              <1> 	call	print_digit
  4359 00001C9F BE[8E00]            <1> 	mov	si,msg_colon
  4360 00001CA2 E86D05              <1> 	call	print
  4361 00001CA5 2E8B97[F51C]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
  4362 00001CAA EC                  <1> 	in	al,dx
  4363 00001CAB B00F                <1> 	mov	al,0Fh
  4364 00001CAD EE                  <1> 	out	dx,al			; enable interrupts
  4365 00001CAE B000                <1> 	mov	al,00h
  4366 00001CB0 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
  4367 00001CB2 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4368 00001CB3 3C0F                <1> 	cmp	al,0Fh
  4369 00001CB5 7516                <1> 	jne	.no_port		; no port at this address
  4370 00001CB7 B000                <1> 	mov	al,00h
  4371 00001CB9 EE                  <1> 	out	dx,al			; disable interrupts
  4372 00001CBA B0FF                <1> 	mov	al,0FFh
  4373 00001CBC E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4374 00001CBE EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4375 00001CBF 3C00                <1> 	cmp	al,00h
  4376 00001CC1 750A                <1> 	jne	.no_port		; no port at this address
  4377 00001CC3 4A                  <1> 	dec	dx			; DX = UART base address
  4378                              <1> 					; OPTIMIZATION:
  4379                              <1> 					; uart_base = uart_ier_reg - 1
  4380 00001CC4 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
  4381                              <1> 					; data area
  4382 00001CC6 89D0                <1> 	mov	ax,dx
  4383 00001CC8 E86205              <1> 	call	print_hex
  4384 00001CCB EB0A                <1> 	jmp	.next
  4385                              <1> 
  4386                              <1> .no_port:
  4387 00001CCD C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
  4388 00001CD1 BE[8900]            <1> 	mov	si,msg_none
  4389 00001CD4 E83B05              <1> 	call	print
  4390                              <1> 	
  4391                              <1> .next:
  4392 00001CD7 43                  <1> 	inc	bx
  4393 00001CD8 43                  <1> 	inc	bx
  4394 00001CD9 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
  4395 00001CDC 7408                <1> 	je	.done
  4396 00001CDE BE[9100]            <1> 	mov	si,msg_semicolon
  4397 00001CE1 E82E05              <1> 	call	print
  4398 00001CE4 EBAA                <1> 	jmp	.detect_loop
  4399                              <1> 
  4400                              <1> .done:
  4401 00001CE6 BE[8600]            <1> 	mov	si,msg_crlf
  4402 00001CE9 E82605              <1> 	call	print
  4403                              <1> 
  4404 00001CEC B024                <1> 	mov	al,e_serial_ok		; serial port detection complete
  4405 00001CEE E680                <1> 	out	post_reg,al
  4406                              <1> 
  4407 00001CF0 5E                  <1> 	pop	si
  4408 00001CF1 5A                  <1> 	pop	dx
  4409 00001CF2 5B                  <1> 	pop	bx
  4410 00001CF3 58                  <1> 	pop	ax
  4411 00001CF4 C3                  <1> 	ret
  4412                              <1> 
  4413                              <1> ;-------------------------------------------------------------------------
  4414                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
  4415 00001CF5 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
  4416 00001CF9 E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
  4417                              <1> 
  4418                              <1> ;-------------------------------------------------------------------------
  4419                              <1> ; UART divisor values table
  4420 00001CFD 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
  4421 00001CFF 0003                <1> 		dw	uart_osc/16/150		; 150 bps
  4422 00001D01 8001                <1> 		dw	uart_osc/16/300		; 300 bps
  4423 00001D03 C000                <1> 		dw	uart_osc/16/600		; 600 bps
  4424 00001D05 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
  4425 00001D07 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
  4426 00001D09 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
  4427 00001D0B 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
  4428 00001D0D 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
  4429 00001D0F 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
  4430 00001D11 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
  4431 00001D13 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
  4432                              <1> num_divisors	equ ($-uart_divisors)/2
  4433                                  %include	"printer1.inc"		; parallel printer services & detection
  4434                              <1> ;========================================================================
  4435                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
  4436                              <1> ;	INT 17h, function AH=01h 
  4437                              <1> ;	detect_parallel
  4438                              <1> ;	- see printer2.inc for other INT 17h functions
  4439                              <1> ;-------------------------------------------------------------------------
  4440                              <1> ;
  4441                              <1> ; Compiles with NASM 2.07, might work with other versions
  4442                              <1> ;
  4443                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4444                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4445                              <1> ;
  4446                              <1> ; This program is free software: you can redistribute it and/or modify
  4447                              <1> ; it under the terms of the GNU General Public License as published by
  4448                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4449                              <1> ; (at your option) any later version.
  4450                              <1> ;
  4451                              <1> ; This program is distributed in the hope that it will be useful,
  4452                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4453                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4454                              <1> ; GNU General Public License for more details.
  4455                              <1> ;
  4456                              <1> ; You should have received a copy of the GNU General Public License
  4457                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4458                              <1> ;
  4459                              <1> ;=========================================================================
  4460                              <1> 
  4461                              <1> num_parallel	equ	3		; number of parallel ports
  4462                              <1> 
  4463                              <1> prn_data_reg	equ	0		; printer data register (out)
  4464                              <1> 
  4465                              <1> prn_stat_reg	equ	1		; printer status register (in)
  4466                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
  4467                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
  4468                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
  4469                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
  4470                              <1> 
  4471                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
  4472                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
  4473                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
  4474                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
  4475                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
  4476                              <1> 
  4477                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
  4478                              <1> 
  4479                              <1> ;=========================================================================
  4480                              <1> ; int_17_fn01 - Initialize printer port
  4481                              <1> ; Input:
  4482                              <1> ;	AH = 1 - function 01h - initialize printer port
  4483                              <1> ;	DX = printer port number (0-2)
  4484                              <1> ; Output:
  4485                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  4486                              <1> ;-------------------------------------------------------------------------
  4487                              <1> int_17_fn01:
  4488 00001D15 42                  <1> 	inc	dx
  4489 00001D16 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  4490                              <1> 					; OPTIMIZATION:
  4491                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
  4492 00001D17 B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
  4493 00001D19 EE                  <1> 	out	dx,al
  4494 00001D1A 51                  <1> 	push	cx
  4495 00001D1B B9B509              <1> 	mov	cx,prn_init_delay
  4496 00001D1E E8FEEE              <1> 	call	delay_15us
  4497 00001D21 59                  <1> 	pop	cx
  4498 00001D22 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  4499 00001D24 EE                  <1> 	out	dx,al			; deactivate init bit
  4500 00001D25 4A                  <1> 	dec	dx			; OPTIMIZATION:
  4501                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
  4502 00001D26 E91053              <1> 	jmp	int_17_status		; exit returning status
  4503                              <1> 
  4504                              <1> ;=========================================================================
  4505                              <1> ; detect_parallel - detect and print parallel ports
  4506                              <1> ; Input:
  4507                              <1> ;	none
  4508                              <1> ; Output:
  4509                              <1> ;	none (updates BIOS data area)
  4510                              <1> ; Notes:
  4511                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
  4512                              <1> ;	  enumeration is used:
  4513                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
  4514                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
  4515                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
  4516                              <1> ;-------------------------------------------------------------------------
  4517                              <1> detect_parallel:
  4518 00001D29 50                  <1> 	push	ax
  4519 00001D2A 53                  <1> 	push	bx
  4520 00001D2B 52                  <1> 	push	dx
  4521 00001D2C 56                  <1> 	push	si
  4522 00001D2D BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
  4523 00001D30 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
  4524 00001D34 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
  4525 00001D38 31DB                <1> 	xor	bx,bx			; BX = 0
  4526 00001D3A 31FF                <1> 	xor	di,di			; DI = 0
  4527                              <1> .detect_loop:
  4528 00001D3C 2E8B95[B31D]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
  4529 00001D41 B05A                <1> 	mov	al,05Ah			; just some test value
  4530 00001D43 EE                  <1> 	out	dx,al			; write it to the printer data register
  4531 00001D44 B0FF                <1> 	mov	al,0FFh
  4532 00001D46 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4533 00001D48 EC                  <1> 	in	al,dx
  4534 00001D49 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
  4535 00001D4B 7505                <1> 	jne	.no_port		; no port at this address
  4536 00001D4D 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
  4537                              <1> 					; data area
  4538 00001D50 EB09                <1> 	jmp	.next
  4539                              <1> 
  4540                              <1> .no_port:
  4541 00001D52 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
  4542 00001D57 09FF                <1> 	or	di,di			; no printer port at 3BCh?
  4543 00001D59 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
  4544                              <1> .next:
  4545 00001D5B 43                  <1> 	inc	bx
  4546 00001D5C 43                  <1> 	inc	bx
  4547                              <1> 
  4548                              <1> .next_skip_3BC:
  4549 00001D5D 47                  <1> 	inc	di
  4550 00001D5E 47                  <1> 	inc	di
  4551 00001D5F 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
  4552 00001D62 7402                <1> 	je	.print			; done with detection, print findings
  4553 00001D64 EBD6                <1> 	jmp	.detect_loop
  4554                              <1> 
  4555                              <1> .print:
  4556 00001D66 BE[BA02]            <1> 	mov	si,msg_parallel
  4557 00001D69 E8A604              <1> 	call	print
  4558 00001D6C 31DB                <1> 	xor	bx,bx
  4559                              <1> 
  4560                              <1> .print_loop:
  4561 00001D6E BE[D702]            <1> 	mov	si,msg_parallel_lpt
  4562 00001D71 E89E04              <1> 	call	print
  4563 00001D74 88D8                <1> 	mov	al,bl
  4564 00001D76 D0E8                <1> 	shr	al,1
  4565 00001D78 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
  4566 00001D7A E8F404              <1> 	call	print_digit
  4567 00001D7D BE[8E00]            <1> 	mov	si,msg_colon
  4568 00001D80 E88F04              <1> 	call	print
  4569 00001D83 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
  4570 00001D86 09C0                <1> 	or	ax,ax			; parallel interface installed?
  4571 00001D88 7405                <1> 	jz	.print_no_port
  4572 00001D8A E8A004              <1> 	call	print_hex
  4573 00001D8D EB06                <1> 	jmp	.print_next
  4574                              <1> 
  4575                              <1> .print_no_port:
  4576 00001D8F BE[8900]            <1> 	mov	si,msg_none
  4577 00001D92 E87D04              <1> 	call	print
  4578                              <1> 
  4579                              <1> .print_next:
  4580 00001D95 43                  <1> 	inc	bx
  4581 00001D96 43                  <1> 	inc	bx
  4582 00001D97 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
  4583 00001D9A 7408                <1> 	je	.done
  4584 00001D9C BE[9100]            <1> 	mov	si,msg_semicolon
  4585 00001D9F E87004              <1> 	call	print
  4586 00001DA2 EBCA                <1> 	jmp	.print_loop
  4587                              <1> 
  4588                              <1> .done:
  4589 00001DA4 BE[8600]            <1> 	mov	si,msg_crlf
  4590 00001DA7 E86804              <1> 	call	print
  4591                              <1> 
  4592 00001DAA B025                <1> 	mov	al,e_parallel_ok	; parallel port detection complete
  4593 00001DAC E680                <1> 	out	post_reg,al
  4594                              <1> 
  4595 00001DAE 5E                  <1> 	pop	si
  4596 00001DAF 5A                  <1> 	pop	dx
  4597 00001DB0 5B                  <1> 	pop	bx
  4598 00001DB1 58                  <1> 	pop	ax
  4599 00001DB2 C3                  <1> 	ret
  4600                              <1> 
  4601                              <1> ;-------------------------------------------------------------------------
  4602                              <1> ; parallel port base addresses - used for port detection
  4603 00001DB3 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
  4604                                  %ifdef PS2_MOUSE
  4605                                  %include	"ps2aux.inc"
  4606                              <1> ;=========================================================================
  4607                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  4608                              <1> ;	INT 15h, function AH=0C2h
  4609                              <1> ;	INT 74h - IRQ12 interrupt handler
  4610                              <1> ;-------------------------------------------------------------------------
  4611                              <1> ;
  4612                              <1> ; Compiles with NASM 2.07, might work with other versions
  4613                              <1> ;
  4614                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4615                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4616                              <1> ;
  4617                              <1> ; This program is free software: you can redistribute it and/or modify
  4618                              <1> ; it under the terms of the GNU General Public License as published by
  4619                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4620                              <1> ; (at your option) any later version.
  4621                              <1> ;
  4622                              <1> ; This program is distributed in the hope that it will be useful,
  4623                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4624                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4625                              <1> ; GNU General Public License for more details.
  4626                              <1> ;
  4627                              <1> ; You should have received a copy of the GNU General Public License
  4628                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4629                              <1> ;
  4630                              <1> ;=========================================================================
  4631                              <1> 
  4632                              <1> ;-------------------------------------------------------------------------
  4633                              <1> ; offsets for registers on stack
  4634                              <1> int_15_fnC2_bp	equ	0
  4635                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  4636                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  4637                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  4638                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  4639                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  4640                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  4641                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  4642                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  4643                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  4644                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  4645                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  4646                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  4647                              <1> 
  4648                              <1> ;=========================================================================
  4649                              <1> ; int_15_fnC2 - mouse functions
  4650                              <1> ; Input:
  4651                              <1> ;	AH = 0C2h - mouse functions
  4652                              <1> ;	AL - function:
  4653                              <1> ;		00h - enable / disable PS/2 mouse
  4654                              <1> ;		01h - reset PS/2 mouse
  4655                              <1> ;		02h - set sample rate
  4656                              <1> ;		03h - set resolution
  4657                              <1> ;		04h - read device type
  4658                              <1> ;		05h - initialize PS/2 mouse
  4659                              <1> ;		06h - set scaling or get status
  4660                              <1> ;		07h - set PS/2 mouse driver address
  4661                              <1> ; Output:
  4662                              <1> ;	AH - exit status:
  4663                              <1> ;		00h - no error
  4664                              <1> ;		01h - invalid function call
  4665                              <1> ;		02h - invalid input value
  4666                              <1> ;		03h - interface error
  4667                              <1> ;		04h - request for resend received from 8042
  4668                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  4669                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  4670                              <1> ;-------------------------------------------------------------------------
  4671                              <1> int_15_fnC2:
  4672 00001DB9 50                  <1> 	push	ax
  4673 00001DBA 53                  <1> 	push	bx
  4674 00001DBB 51                  <1> 	push	cx
  4675 00001DBC 52                  <1> 	push	dx
  4676 00001DBD 1E                  <1> 	push	ds
  4677 00001DBE 55                  <1> 	push	bp
  4678 00001DBF 89E5                <1> 	mov	bp,sp			; establish stack addressing
  4679 00001DC1 BB4000              <1> 	mov	bx,biosdseg
  4680 00001DC4 8EDB                <1> 	mov	ds,bx
  4681 00001DC6 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  4682 00001DCA 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  4683 00001DCC 3C08                <1> 	cmp	al,.num_func
  4684 00001DCE 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  4685 00001DD0 E8DDF8              <1> 	call	kbc_aux_disable		; disable auxiliary device
  4686 00001DD3 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  4687 00001DD5 B700                <1> 	mov	bh,0
  4688 00001DD7 D1E3                <1> 	shl	bx,1			; address words
  4689 00001DD9 2EFFA7[DE1D]        <1>     cs	jmp	near [.dispatch+bx]
  4690                              <1> 
  4691                              <1> .dispatch:
  4692 00001DDE [171E]              <1> 	dw	int_15_fnC200
  4693 00001DE0 [381E]              <1> 	dw	int_15_fnC201
  4694 00001DE2 [5B1E]              <1> 	dw	int_15_fnC202
  4695 00001DE4 [821E]              <1> 	dw	int_15_fnC203
  4696 00001DE6 [A41E]              <1> 	dw	int_15_fnC204
  4697 00001DE8 [BC1E]              <1> 	dw	int_15_fnC205
  4698 00001DEA [001F]              <1> 	dw	int_15_fnC206
  4699 00001DEC [511F]              <1> 	dw	int_15_fnC207
  4700                              <1> .num_func	equ ($-.dispatch)/2
  4701                              <1> 
  4702                              <1> int_15_fnC2_ok:
  4703 00001DEE B400                <1> 	mov	ah,00h			; no error
  4704 00001DF0 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  4705 00001DF4 EB14                <1> 	jmp	int_15_fnC2_exit
  4706                              <1> 
  4707                              <1> int_15_fnC2_err1:
  4708 00001DF6 B401                <1> 	mov	ah,01h			; invalid function call
  4709 00001DF8 EB0C                <1> 	jmp	int_15_fnC2_err
  4710                              <1> 
  4711                              <1> int_15_fnC2_err2:
  4712 00001DFA B402                <1> 	mov	ah,02h			; invalid input value
  4713 00001DFC EB08                <1> 	jmp	int_15_fnC2_err
  4714                              <1> 
  4715                              <1> int_15_fnC2_err3:
  4716 00001DFE B403                <1> 	mov	ah,03h			; interface error
  4717 00001E00 EB04                <1> 	jmp	int_15_fnC2_err
  4718                              <1> 
  4719                              <1> int_15_fnC2_err5:
  4720 00001E02 B405                <1> 	mov	ah,05h			; no driver installed
  4721 00001E04 EB00                <1> 	jmp	int_15_fnC2_err
  4722                              <1> 
  4723                              <1> int_15_fnC2_err:
  4724 00001E06 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  4725                              <1> 
  4726                              <1> int_15_fnC2_exit:
  4727 00001E0A 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  4728 00001E0D E896F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
  4729 00001E10 5D                  <1> 	pop	bp
  4730 00001E11 1F                  <1> 	pop	ds
  4731 00001E12 5A                  <1> 	pop	dx
  4732 00001E13 59                  <1> 	pop	cx
  4733 00001E14 5B                  <1> 	pop	bx
  4734 00001E15 58                  <1> 	pop	ax
  4735 00001E16 CF                  <1> 	iret
  4736                              <1> 
  4737                              <1> ;=========================================================================
  4738                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  4739                              <1> ; Input:
  4740                              <1> ;	AX = 0C200h
  4741                              <1> ;	BH - sub-function:
  4742                              <1> ;		00h - disable
  4743                              <1> ;		01h - enable
  4744                              <1> ;-------------------------------------------------------------------------
  4745                              <1> int_15_fnC200:
  4746 00001E17 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4747 00001E1A 80FF01              <1> 	cmp	bh,01h
  4748 00001E1D 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  4749                              <1> 
  4750 00001E1F F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  4751 00001E24 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  4752                              <1> 
  4753 00001E26 80FF00              <1> 	cmp	bh,00h
  4754 00001E29 7404                <1> 	je	.disable
  4755 00001E2B B0F4                <1> 	mov	al,0F4h			; device enable command
  4756 00001E2D EB02                <1> 	jmp	.send_it
  4757                              <1> .disable:
  4758 00001E2F B0F5                <1> 	mov	al,0F5h			; device disable command
  4759                              <1> 
  4760                              <1> .send_it:
  4761 00001E31 E83AF8              <1> 	call	kbc_aux_send
  4762 00001E34 72D0                <1> 	jc	int_15_fnC2_err		; error
  4763 00001E36 EBB6                <1> 	jmp	int_15_fnC2_ok
  4764                              <1> 
  4765                              <1> ;=========================================================================
  4766                              <1> ; int_15_fnC201 - reset PS/2 mouse
  4767                              <1> ; Input:
  4768                              <1> ;	AX = 0C201h
  4769                              <1> ; Output:
  4770                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  4771                              <1> ;	     0AAh - BAT successful XXX test!!!
  4772                              <1> ;	     0FCh - BAT error
  4773                              <1> ;	BH = device ID
  4774                              <1> ;-------------------------------------------------------------------------
  4775                              <1> int_15_fnC201:
  4776 00001E38 B90A00              <1> 	mov	cx,10			; try the reset 10 times
  4777                              <1> .1:
  4778 00001E3B B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  4779 00001E3D E82EF8              <1> 	call	kbc_aux_send
  4780 00001E40 7307                <1> 	jnc	.2			; no error - continue
  4781 00001E42 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4782 00001E45 E1F4                <1> 	loopz	.1			; try again
  4783 00001E47 EBBD                <1> 	jmp	int_15_fnC2_err		; error
  4784                              <1> .2:
  4785 00001E49 E807F8              <1> 	call	kbc_aux_read
  4786 00001E4C 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  4787 00001E4E 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  4788 00001E51 E8FFF7              <1> 	call	kbc_aux_read
  4789 00001E54 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  4790 00001E56 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  4791 00001E59 EB93                <1> 	jmp	int_15_fnC2_ok
  4792                              <1> 
  4793                              <1> ;=========================================================================
  4794                              <1> ; int_15_fnC202 - set sample rate
  4795                              <1> ; Input:
  4796                              <1> ;	AX = 0C202h
  4797                              <1> ;	BH - sample rate:
  4798                              <1> ;		00h - 10 samples per second
  4799                              <1> ;		01h - 20 samples per second
  4800                              <1> ;		02h - 40 samples per second
  4801                              <1> ;		03h - 60 samples per second
  4802                              <1> ;		04h - 80 samples per second
  4803                              <1> ;		05h - 100 samples per second
  4804                              <1> ;		06h - 200 samples per second
  4805                              <1> ;-------------------------------------------------------------------------
  4806                              <1> int_15_fnC202:
  4807 00001E5B 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4808 00001E5E 80FF06              <1> 	cmp	bh,06h
  4809 00001E61 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  4810 00001E63 88FB                <1> 	mov	bl,bh
  4811 00001E65 B700                <1> 	mov	bh,00h			; rate index in BX
  4812                              <1> 
  4813 00001E67 B0F3                <1> 	mov	al,0F3h			; set sample rate
  4814 00001E69 E802F8              <1> 	call	kbc_aux_send
  4815 00001E6C 7298                <1> 	jc	int_15_fnC2_err		; error
  4816                              <1> 
  4817 00001E6E 2E8A87[7B1E]        <1>     cs	mov	al,byte [.rate_table+bx]
  4818 00001E73 E8F8F7              <1> 	call	kbc_aux_send
  4819 00001E76 728E                <1> 	jc	int_15_fnC2_err		; error
  4820 00001E78 E973FF              <1> 	jmp	int_15_fnC2_ok
  4821                              <1> 
  4822 00001E7B 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  4823                              <1> 	
  4824                              <1> ;=========================================================================
  4825                              <1> ; int_15_fnC203 - set resolution
  4826                              <1> ; Input:
  4827                              <1> ;	AX = 0C203h
  4828                              <1> ;	BH - resolution value:
  4829                              <1> ;		00h - 1 count per millimeter
  4830                              <1> ;		01h - 2 counts per millimeter
  4831                              <1> ;		02h - 4 counts per millimeter
  4832                              <1> ;		03h - 8 counts per millimeter
  4833                              <1> ;-------------------------------------------------------------------------
  4834                              <1> int_15_fnC203:
  4835 00001E82 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4836 00001E85 80FF03              <1> 	cmp	bh,03h
  4837 00001E88 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  4838                              <1> 
  4839 00001E8D B0E8                <1> 	mov	al,0E8h			; set resolution
  4840 00001E8F E8DCF7              <1> 	call	kbc_aux_send
  4841 00001E92 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  4842                              <1> 
  4843 00001E97 88F8                <1> 	mov	al,bh
  4844 00001E99 E8D2F7              <1> 	call	kbc_aux_send
  4845 00001E9C 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  4846 00001EA1 E94AFF              <1> 	jmp	int_15_fnC2_ok
  4847                              <1> 
  4848                              <1> ;=========================================================================
  4849                              <1> ; int_15_fnC204 - read device type
  4850                              <1> ; Input:
  4851                              <1> ;	AX = 0C204h
  4852                              <1> ; Output:
  4853                              <1> ;	BH = device type
  4854                              <1> ;-------------------------------------------------------------------------
  4855                              <1> int_15_fnC204:
  4856 00001EA4 B0F2                <1> 	mov	al,0F2h			; read device type
  4857 00001EA6 E8C5F7              <1> 	call	kbc_aux_send
  4858 00001EA9 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  4859 00001EAE E8A2F7              <1> 	call	kbc_aux_read
  4860 00001EB1 7303E948FF          <1> 	jc	int_15_fnC2_err3
  4861 00001EB6 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  4862 00001EB9 E932FF              <1> 	jmp	int_15_fnC2_ok
  4863                              <1> 
  4864                              <1> ;=========================================================================
  4865                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  4866                              <1> ; Input:
  4867                              <1> ;	AX = 0C205h
  4868                              <1> ;	BH = data package size in bytes (03h or 04h)
  4869                              <1> ; Output:
  4870                              <1> ;	none
  4871                              <1> ;-------------------------------------------------------------------------
  4872                              <1> int_15_fnC205:
  4873 00001EBC 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4874 00001EBF 80FF03              <1> 	cmp	bh,03h
  4875 00001EC2 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  4876 00001EC7 80FF04              <1> 	cmp	bh,04h
  4877 00001ECA 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  4878 00001ECF FECF                <1> 	dec	bh
  4879                              <1> 
  4880 00001ED1 A02700              <1> 	mov	al,byte [mouse_flags_2]
  4881 00001ED4 24F8                <1> 	and	al,0F8h			; mask out package size bits
  4882 00001ED6 08F8                <1> 	or	al,bh			; add the new package size
  4883 00001ED8 A22700              <1> 	mov	byte [mouse_flags_2],al
  4884                              <1> 
  4885 00001EDB B90500              <1> 	mov	cx,5			; try the reset 5 times
  4886                              <1> .1:
  4887 00001EDE B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  4888 00001EE0 E88BF7              <1> 	call	kbc_aux_send
  4889 00001EE3 7308                <1> 	jnc	.2			; no error - continue
  4890 00001EE5 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4891 00001EE8 E1F4                <1> 	loopz	.1			; try again
  4892 00001EEA E919FF              <1> 	jmp	int_15_fnC2_err		; error
  4893                              <1> .2:
  4894 00001EED E863F7              <1> 	call	kbc_aux_read
  4895 00001EF0 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  4896 00001EF5 E85BF7              <1> 	call	kbc_aux_read
  4897 00001EF8 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  4898 00001EFD E9EEFE              <1> 	jmp	int_15_fnC2_ok
  4899                              <1> 
  4900                              <1> ;=========================================================================
  4901                              <1> ; int_15_fnC206 - set scaling or get status
  4902                              <1> ; Input:
  4903                              <1> ;	AX = 0C206h
  4904                              <1> ;	BH - sub-function:
  4905                              <1> ;		00h - return status
  4906                              <1> ;		01h - set scaling factor to 1:1
  4907                              <1> ;		02h - set scaling factor to 2:1
  4908                              <1> ; Output:
  4909                              <1> ;	if BH = 00h on entry:
  4910                              <1> ;		BL - status byte 1:
  4911                              <1> ;			bit 0 = 1 - right button pressed
  4912                              <1> ;			bit 1 = 0 - reserved
  4913                              <1> ;			bit 2 = 1 - left button pressed
  4914                              <1> ;			bit 3 = 0 - reserved
  4915                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  4916                              <1> ;			bit 5 = 0 - disable, 1 - enable
  4917                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  4918                              <1> ;			bit 7 = 0 - reserved
  4919                              <1> ;		CL - status byte 2:
  4920                              <1> ;			00h - 1 count per millimeter
  4921                              <1> ;			01h - 2 counts per millimeter
  4922                              <1> ;			02h - 4 counts per millimeter
  4923                              <1> ;			03h - 8 counts per millimeter
  4924                              <1> ;		DL - status byte 3:
  4925                              <1> ;			0Ah - 10 samples per second
  4926                              <1> ;			14h - 20 samples per second
  4927                              <1> ;			3Ch - 40 samples per second
  4928                              <1> ;			3Ch - 60 samples per second
  4929                              <1> ;			50h - 80 samples per second
  4930                              <1> ;			64h - 100 samples per second
  4931                              <1> ;			0C8h - 200 samples per second
  4932                              <1> ;-------------------------------------------------------------------------
  4933                              <1> int_15_fnC206:
  4934 00001F00 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4935 00001F03 80FF02              <1> 	cmp	bh,02h
  4936 00001F06 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  4937 00001F0B 7433                <1> 	je	.scale_2x1
  4938 00001F0D 80FF01              <1> 	cmp	bh,01h
  4939 00001F10 7432                <1> 	je	.scale_1x1
  4940                              <1> 					; BH == 0, return status
  4941 00001F12 B0E9                <1> 	mov	al,0E9h			; request status command
  4942 00001F14 E857F7              <1> 	call	kbc_aux_send
  4943 00001F17 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  4944 00001F1C E834F7              <1> 	call	kbc_aux_read
  4945 00001F1F 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  4946 00001F24 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  4947 00001F27 E829F7              <1> 	call	kbc_aux_read
  4948 00001F2A 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  4949 00001F2F 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  4950 00001F32 E81EF7              <1> 	call	kbc_aux_read
  4951 00001F35 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  4952 00001F3A 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  4953 00001F3D E9AEFE              <1> 	jmp	int_15_fnC2_ok
  4954                              <1> 
  4955                              <1> .scale_2x1:
  4956 00001F40 B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  4957 00001F42 EB02                <1> 	jmp	.send_it
  4958                              <1> .scale_1x1:
  4959 00001F44 B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  4960                              <1> .send_it:
  4961 00001F46 E825F7              <1> 	call	kbc_aux_send
  4962 00001F49 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  4963 00001F4E E99DFE              <1> 	jmp	int_15_fnC2_ok
  4964                              <1> 
  4965                              <1> ;=========================================================================
  4966                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  4967                              <1> ; Input:
  4968                              <1> ;	AX = 0C207h
  4969                              <1> ;	ES:BX - pointer to mouse driver
  4970                              <1> ;-------------------------------------------------------------------------
  4971                              <1> int_15_fnC207:
  4972 00001F51 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  4973 00001F54 891E2200            <1> 	mov	word [mouse_driver],bx
  4974 00001F58 8CC0                <1> 	mov	ax,es
  4975 00001F5A A32400              <1> 	mov	word [mouse_driver+2],ax
  4976 00001F5D 09C0                <1> 	or	ax,ax
  4977 00001F5F 750C                <1> 	jnz	.set_handler
  4978 00001F61 09DB                <1> 	or	bx,bx
  4979 00001F63 7508                <1> 	jnz	.set_handler
  4980                              <1> ; remove handler
  4981 00001F65 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  4982 00001F6A E981FE              <1> 	jmp	int_15_fnC2_ok
  4983                              <1> 
  4984                              <1> .set_handler:
  4985 00001F6D 800E270080          <1> 	or	byte [mouse_flags_2],80h
  4986 00001F72 E979FE              <1> 	jmp	int_15_fnC2_ok
  4987                              <1> 
  4988                              <1> ;=========================================================================
  4989                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  4990                              <1> ;-------------------------------------------------------------------------
  4991                              <1> int_74:
  4992 00001F75 FB                  <1> 	sti
  4993 00001F76 50                  <1> 	push	ax
  4994 00001F77 53                  <1> 	push	bx
  4995 00001F78 1E                  <1> 	push	ds
  4996 00001F79 B84000              <1> 	mov	ax,biosdseg
  4997 00001F7C 8ED8                <1> 	mov	ds,ax
  4998 00001F7E A10E00              <1> 	mov	ax,word [ebda_segment]
  4999 00001F81 8ED8                <1> 	mov	ds,ax
  5000                              <1> 
  5001 00001F83 E464                <1> 	in	al,kbc_status_reg
  5002 00001F85 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  5003 00001F87 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  5004 00001F89 7561                <1> 	jne	.exit			; no mouse data in the buffer
  5005                              <1> 
  5006 00001F8B E460                <1> 	in	al,kbc_data_reg
  5007 00001F8D 88C4                <1> 	mov	ah,al			; save to AH
  5008                              <1> 
  5009 00001F8F A02700              <1> 	mov	al,byte [mouse_flags_2]
  5010 00001F92 A880                <1> 	test	al,80h
  5011 00001F94 7456                <1> 	jz	.exit			; no mouse driver installed
  5012                              <1> 
  5013 00001F96 A02600              <1> 	mov	al,byte [mouse_flags_1]
  5014 00001F99 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  5015 00001F9B BB2800              <1> 	mov	bx,mouse_data
  5016 00001F9E 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  5017 00001FA0 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  5018                              <1> 
  5019 00001FA2 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  5020 00001FA6 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  5021                              <1> 
  5022 00001FA9 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  5023 00001FAB 7306                <1> 	jae	.call_driver
  5024                              <1> 
  5025 00001FAD FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  5026 00001FB1 EB39                <1> 	jmp	.exit
  5027                              <1> 
  5028                              <1> .call_driver:
  5029                              <1> 
  5030                              <1> ;-------------------------------------------------------------------------
  5031                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  5032                              <1> ; package sizes.
  5033                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  5034                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  5035                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  5036                              <1> ;-------------------------------------------------------------------------
  5037                              <1> 
  5038 00001FB3 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  5039 00001FB6 7413                <1> 	jz	.four_bytes
  5040                              <1> 					; put data in stack for 3 bytes format
  5041 00001FB8 31C0                <1> 	xor	ax,ax
  5042 00001FBA A02800              <1> 	mov	al,byte [mouse_data]
  5043 00001FBD 50                  <1> 	push	ax
  5044 00001FBE A02900              <1> 	mov	al,byte [mouse_data+1]
  5045 00001FC1 50                  <1> 	push	ax
  5046 00001FC2 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5047 00001FC5 50                  <1> 	push	ax
  5048 00001FC6 B000                <1> 	mov	al,00h
  5049 00001FC8 50                  <1> 	push	ax
  5050 00001FC9 EB15                <1> 	jmp	.do_call
  5051                              <1> 
  5052                              <1> .four_bytes:				; put data in stack for 4 bytes format
  5053 00001FCB 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  5054 00001FCF A02800              <1> 	mov	al,byte [mouse_data]
  5055 00001FD2 50                  <1> 	push	ax
  5056 00001FD3 B400                <1> 	mov	ah,00h
  5057 00001FD5 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5058 00001FD8 50                  <1> 	push	ax
  5059 00001FD9 A02B00              <1> 	mov	al,byte [mouse_data+3]
  5060 00001FDC 50                  <1> 	push	ax
  5061 00001FDD B000                <1> 	mov	al,00h
  5062 00001FDF 50                  <1> 	push	ax
  5063                              <1> 
  5064                              <1> .do_call:
  5065 00001FE0 FF1E2200            <1> 	call	far [mouse_driver]
  5066 00001FE4 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  5067 00001FE7 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  5068                              <1> 
  5069                              <1> .exit:
  5070 00001FEC B020                <1> 	mov	al,20h
  5071 00001FEE E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  5072 00001FF0 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  5073 00001FF2 1F                  <1> 	pop	ds
  5074 00001FF3 5B                  <1> 	pop	bx
  5075 00001FF4 58                  <1> 	pop	ax
  5076 00001FF5 CF                  <1> 	iret
  5077                                  %endif
  5078                                  %include	"sound.inc"		; sound test
  5079                              <1> ;=========================================================================
  5080                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  5081                              <1> ;-------------------------------------------------------------------------
  5082                              <1> ;
  5083                              <1> ; Compiles with NASM 2.07, might work with other versions
  5084                              <1> ;
  5085                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5086                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5087                              <1> ;
  5088                              <1> ; This program is free software: you can redistribute it and/or modify
  5089                              <1> ; it under the terms of the GNU General Public License as published by
  5090                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5091                              <1> ; (at your option) any later version.
  5092                              <1> ;
  5093                              <1> ; This program is distributed in the hope that it will be useful,
  5094                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5095                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5096                              <1> ; GNU General Public License for more details.
  5097                              <1> ;
  5098                              <1> ; You should have received a copy of the GNU General Public License
  5099                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5100                              <1> ;
  5101                              <1> ;=========================================================================
  5102                              <1> 
  5103 00001FF6 6908                <1> notes	dw	pic_freq/554		; D flat
  5104 00001FF8 FFFF                <1> 	dw	-1			; silent
  5105 00001FFA 8814                <1> 	dw	pic_freq/227		; D flat
  5106 00001FFC 980C                <1> 	dw	pic_freq/370		; G flat
  5107 00001FFE 8814                <1> 	dw	pic_freq/227		; D flat
  5108 00002000 3B0B                <1> 	dw	pic_freq/415		; A flat
  5109 00002002 0000                <1> 	dw	0
  5110                              <1> 
  5111                              <1> ;=========================================================================
  5112                              <1> ; sound - Play power-on sound.
  5113                              <1> ; Input:
  5114                              <1> ;	none
  5115                              <1> ; Output:
  5116                              <1> ;	none, destroys some registers
  5117                              <1> ;-------------------------------------------------------------------------
  5118                              <1> sound:
  5119 00002004 FC                  <1> 	cld
  5120 00002005 BE[F61F]            <1> 	mov	si,notes		; set SI to notes table
  5121                              <1> 
  5122 00002008 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5123 0000200A E643                <1> 	out	pit_ctl_reg,al
  5124                              <1> 
  5125                              <1> .loop:
  5126 0000200C 2EAD                <1>     cs	lodsw				; load next note to AX
  5127 0000200E 83F800              <1> 	cmp	ax,0
  5128 00002011 7422                <1> 	jz	.exit
  5129 00002013 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  5130 00002015 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5131 00002017 88E0                <1> 	mov	al,ah
  5132 00002019 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5133                              <1> 
  5134 0000201B E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5135 0000201D 0C03                <1>         or      al,03h			; turn on the speaker
  5136 0000201F E661                <1>         out     port_b_reg,al		; write the new value
  5137                              <1> 
  5138                              <1> .silent:
  5139 00002021 B90030              <1> 	mov	cx,3000h
  5140 00002024 E8F8EB              <1> 	call	delay_15us		; delay while note is playing
  5141                              <1> 
  5142 00002027 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5143 00002029 24FC                <1> 	and	al,0FCh			; turn off the speaker
  5144 0000202B E661                <1>         out     port_b_reg,al		; write the new value
  5145                              <1> 
  5146 0000202D B90001              <1>         mov     cx,0100h
  5147 00002030 E8ECEB              <1> 	call	delay_15us		; delay after the note
  5148                              <1>         
  5149 00002033 EBD7                <1>         jmp     .loop			; play the next note
  5150                              <1> .exit:
  5151 00002035 C3                  <1> 	ret
  5152                              <1> 
  5153                              <1> ;=========================================================================
  5154                              <1> ; beep - Play a beep sound
  5155                              <1> ; Input:
  5156                              <1> ;	BL - duration in 0.1 second
  5157                              <1> ; Output:
  5158                              <1> ;	BL = 0
  5159                              <1> ;-------------------------------------------------------------------------
  5160                              <1> beep:
  5161 00002036 50                  <1> 	push	ax
  5162 00002037 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5163 00002039 E643                <1> 	out	pit_ctl_reg,al
  5164 0000203B B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  5165 0000203E E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5166 00002040 88E0                <1> 	mov	al,ah
  5167 00002042 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5168 00002044 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5169 00002046 0C03                <1> 	or	al,03h			; turn on the speaker
  5170 00002048 E661                <1> 	out	port_b_reg,al		; write the new value
  5171                              <1> .loop:
  5172 0000204A B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  5173 0000204D E8CFEB              <1> 	call	delay_15us
  5174 00002050 FECB                <1> 	dec	bl
  5175 00002052 75F6                <1> 	jnz	.loop
  5176 00002054 3403                <1> 	xor	al,03h			; turn off the speaker
  5177 00002056 E661                <1> 	out	port_b_reg,al		; write the new value
  5178 00002058 58                  <1> 	pop	ax
  5179 00002059 C3                  <1> 	ret
  5180                                  %include	"cpu.inc"		; CPU and FPU detection
  5181                              <1> ;=========================================================================
  5182                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  5183                              <1> ;-------------------------------------------------------------------------
  5184                              <1> ;
  5185                              <1> ; Compiles with NASM 2.07, might work with other versions
  5186                              <1> ;
  5187                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5188                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5189                              <1> ;
  5190                              <1> ; This program is free software: you can redistribute it and/or modify
  5191                              <1> ; it under the terms of the GNU General Public License as published by
  5192                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5193                              <1> ; (at your option) any later version.
  5194                              <1> ;
  5195                              <1> ; This program is distributed in the hope that it will be useful,
  5196                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5197                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5198                              <1> ; GNU General Public License for more details.
  5199                              <1> ;
  5200                              <1> ; You should have received a copy of the GNU General Public License
  5201                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5202                              <1> ;
  5203                              <1> ;=========================================================================
  5204                              <1> 
  5205                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  5206                              <1> 
  5207                              <1> ;=========================================================================
  5208                              <1> ; detect_cpu - detect and print CPU type
  5209                              <1> ; Note:
  5210                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  5211                              <1> ;	  incorrect results if used on other CPU types.
  5212                              <1> ;-------------------------------------------------------------------------
  5213                              <1> detect_cpu:
  5214 0000205A 50                  <1> 	push	ax
  5215 0000205B 56                  <1> 	push	si
  5216 0000205C BE[9400]            <1> 	mov	si,msg_cpu
  5217 0000205F E8B001              <1> 	call	print
  5218                              <1> 
  5219                              <1> ; test for NEC V20
  5220 00002062 B80101              <1> 	mov	ax,0101h
  5221 00002065 D510                <1> 	aad	10h			; NEC V20 ignores the argument
  5222 00002067 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  5223 00002069 7452                <1> 	je	.nec_v20
  5224                              <1> 
  5225                              <1> ; not NEC V20, test for various 8088 versions
  5226                              <1> .i8088:					; 8088 - NMOS version of 8088
  5227 0000206B FA                  <1> 	cli				; disable interrupts
  5228 0000206C 1E                  <1> 	push	ds
  5229 0000206D 31C0                <1> 	xor	ax,ax
  5230 0000206F 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  5231 00002071 B8[CA20]            <1> 	mov	ax,.int_01		; new int 01h offset
  5232 00002074 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  5233 00002078 50                  <1> 	push	ax			; save to stack
  5234 00002079 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  5235 0000207B 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  5236 0000207F 50                  <1> 	push	ax			; save to stack
  5237 00002080 9C                  <1> 	pushf				; push flags to stack (save)
  5238 00002081 9C                  <1> 	pushf				; push flags to stack (modify)
  5239 00002082 58                  <1> 	pop	ax			; and move them to AX
  5240 00002083 0D0001              <1> 	or	ax,flags_tf		; set TF
  5241 00002086 50                  <1> 	push	ax
  5242 00002087 31C0                <1> 	xor	ax,ax			; AX = 0
  5243 00002089 9D                  <1> 	popf				; load modified value to FLAGS register
  5244                              <1> 					; enable single-step
  5245 0000208A 90                  <1> 	nop
  5246 0000208B 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  5247                              <1> 					; after PUSH SREG instructions
  5248                              <1> .push_sreg:				; and will not single-step to here
  5249 0000208C 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  5250                              <1> 					; after modifying segment registers
  5251                              <1> .pop_sreg:				; and will not single-step to here
  5252 0000208D 90                  <1> 	nop
  5253 0000208E 9D                  <1> 	popf				; restore original FLAGS, disable
  5254                              <1> 					; single-step
  5255                              <1> 
  5256 0000208F 5E                  <1> 	pop	si			; get original int 01h segment
  5257 00002090 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  5258 00002094 5E                  <1> 	pop	si			; get original int 01h offset
  5259 00002095 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  5260 00002099 1F                  <1> 	pop	ds
  5261 0000209A FB                  <1> 	sti				; enable interrupts
  5262 0000209B 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  5263 0000209E 740D                <1> 	jz	.i8088_78
  5264                              <1> 
  5265 000020A0 83F802              <1> 	cmp	ax,0002h
  5266 000020A3 7410                <1> 	jz	.i8088_81
  5267                              <1> 
  5268                              <1> .harris:				; Harris / Intersil 80C88
  5269 000020A5 BE[5F01]            <1> 	mov	si,msg_cpu_harris
  5270 000020A8 E86701              <1> 	call	print
  5271 000020AB EB16                <1> 	jmp	.exit
  5272                              <1> 
  5273                              <1> .i8088_78:
  5274 000020AD BE[CE00]            <1> 	mov	si,msg_cpu_8088_78
  5275 000020B0 E85F01              <1> 	call	print
  5276 000020B3 EB0E                <1> 	jmp	.exit
  5277                              <1> 
  5278                              <1> .i8088_81:
  5279 000020B5 BE[2F01]            <1> 	mov	si,msg_cpu_8088_81
  5280 000020B8 E85701              <1> 	call	print
  5281 000020BB EB06                <1> 	jmp	.exit
  5282                              <1> 
  5283                              <1> .nec_v20:
  5284 000020BD BE[8701]            <1> 	mov	si,msg_cpu_nec_v20
  5285 000020C0 E84F01              <1> 	call	print
  5286                              <1> 
  5287                              <1> .exit:
  5288 000020C3 B021                <1> 	mov	al,e_cpu_detect_ok	; CPU detection finished
  5289 000020C5 E680                <1> 	out	post_reg,al
  5290                              <1> 
  5291 000020C7 5E                  <1> 	pop	si
  5292 000020C8 58                  <1> 	pop	ax
  5293 000020C9 C3                  <1> 	ret
  5294                              <1> 
  5295                              <1> ; stack frame after "push bp"
  5296                              <1> ; BP - word [BP]
  5297                              <1> ; IP - word [BP+2]
  5298                              <1> ; CS - word [BP+4]
  5299                              <1> ; FLAGS - word [BP+6]
  5300                              <1> .int_01:
  5301 000020CA 55                  <1> 	push	bp
  5302 000020CB 89E5                <1> 	mov	bp,sp
  5303 000020CD 817E02[8D20]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  5304 000020D2 7504                <1> 	jne	.1
  5305 000020D4 B001                <1> 	mov	al,01h			; (C) INTEL '79
  5306 000020D6 EB09                <1> 	jmp	.int_01_exit
  5307                              <1> .1:
  5308 000020D8 817E02[8C20]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  5309 000020DD 7502                <1> 	jne	.int_01_exit
  5310 000020DF B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  5311                              <1> .int_01_exit:
  5312 000020E1 5D                  <1> 	pop	bp
  5313 000020E2 CF                  <1> 	iret
  5314                              <1> 
  5315                              <1> ;=========================================================================
  5316                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  5317                              <1> ;-------------------------------------------------------------------------
  5318                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  5319                              <1> detect_fpu:
  5320 000020E3 50                  <1> 	push	ax
  5321 000020E4 51                  <1> 	push	cx
  5322 000020E5 56                  <1> 	push	si
  5323 000020E6 BE[B100]            <1> 	mov	si,msg_fpu
  5324 000020E9 E82601              <1> 	call	print
  5325 000020EC DBE3                <1> 	fninit				; initialize coprocessor
  5326 000020EE B90300              <1> 	mov	cx,3
  5327                              <1> .wait:
  5328 000020F1 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  5329                              <1> 					;   (can't use fwait, since it could
  5330                              <1> 					;   be no coprocessor at all)
  5331 000020F3 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  5332 000020F7 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  5333 000020FD D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  5334 00002101 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  5335 00002107 750D                <1> 	jne	.no_fpu			;   after finit
  5336                              <1> 
  5337                              <1> .fpu:
  5338 00002109 BE[9101]            <1> 	mov	si,msg_fpu_present
  5339 0000210C E80301              <1> 	call	print
  5340 0000210F 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  5341 00002114 EB06                <1> 	jmp	.exit
  5342                              <1> 
  5343                              <1> .no_fpu:
  5344                              <1> 
  5345 00002116 BE[9002]            <1> 	mov	si,msg_absent
  5346 00002119 E8F600              <1> 	call	print
  5347                              <1> 
  5348                              <1> .exit:
  5349 0000211C 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  5350                              <1> 
  5351 00002120 B022                <1> 	mov	al,e_fpu_detect_ok	; FPU detection finished
  5352 00002122 E680                <1> 	out	post_reg,al
  5353                              <1> 
  5354 00002124 5E                  <1> 	pop	si
  5355 00002125 59                  <1> 	pop	cx
  5356 00002126 58                  <1> 	pop	ax
  5357 00002127 C3                  <1> 	ret
  5358                                  
  5359                                  %ifdef AT_COMPAT
  5360                                  
  5361                                  ;=========================================================================
  5362                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  5363                                  ;-------------------------------------------------------------------------
  5364                                  int_ignore2:
  5365 00002128 50                      	push	ax
  5366 00002129 B020                    	mov	al,20h
  5367 0000212B E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5368 0000212D E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5369 0000212F 58                      	pop	ax
  5370 00002130 CF                      	iret
  5371                                  
  5372                                  ;=========================================================================
  5373                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  5374                                  ;-------------------------------------------------------------------------
  5375                                  int_71:
  5376 00002131 50                      	push	ax
  5377 00002132 B020                    	mov	al,20h
  5378 00002134 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5379 00002136 58                      	pop	ax
  5380 00002137 CD0A                    	int	0Ah		; call IRQ2 ISR
  5381 00002139 CF                      	iret
  5382                                  
  5383                                  ;=========================================================================
  5384                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  5385                                  ;-------------------------------------------------------------------------
  5386                                  int_75:
  5387 0000213A 50                      	push	ax
  5388 0000213B B020                    	mov	al,20h
  5389 0000213D E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5390 0000213F E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5391 00002141 58                      	pop	ax
  5392 00002142 CD02                    	int	02h		; call NMI ISR
  5393 00002144 CF                      	iret
  5394                                  
  5395                                  %endif ; AT_COMPAT
  5396                                  
  5397                                  ;=========================================================================
  5398                                  ; extension_scan - scan for BIOS extensions
  5399                                  ; Input:
  5400                                  ;	DX - start segment
  5401                                  ;	BX - end segment
  5402                                  ; Returns:
  5403                                  ;	DX - address for the continuation of the scan
  5404                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  5405                                  ;-------------------------------------------------------------------------
  5406                                  extension_scan:
  5407 00002145 C70667000000            	mov	word [67h],0
  5408 0000214B C70669000000            	mov	word [69h],0
  5409                                  .scan:
  5410 00002151 8EC2                    	mov	es,dx
  5411 00002153 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  5412 0000215A 752C                    	jnz	.next			; no signature, check next 2 KiB
  5413 0000215C 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  5414 00002160 B400                    	mov	ah,0
  5415 00002162 B105                    	mov	cl,5
  5416 00002164 D3E0                    	shl	ax,cl			; convert size to paragraphs
  5417 00002166 01C2                    	add	dx,ax
  5418 00002168 B104                    	mov	cl,4
  5419 0000216A D3E0                    	shl	ax,cl			; convert size to bytes
  5420 0000216C 89C1                    	mov	cx,ax
  5421 0000216E B000                    	mov	al,0
  5422 00002170 31F6                    	xor	si,si
  5423                                  .checksum:
  5424 00002172 260204                      es	add	al,byte [si]
  5425 00002175 46                      	inc	si
  5426 00002176 E2FA                    	loop	.checksum
  5427 00002178 08C0                    	or	al,al			; AL == 0?
  5428 0000217A 750C                    	jnz	.next			; AL not zero - bad checksum
  5429 0000217C C70667000300            	mov	word [67h],3		; extension initialization offset
  5430 00002182 8C066900                	mov	word [69h],es		; extension segment
  5431 00002186 EB08                    	jmp	.exit
  5432                                  .next:
  5433 00002188 81C28000                	add	dx,80h			; add 2 KiB
  5434 0000218C 39DA                    	cmp	dx,bx
  5435 0000218E 72C1                    	jb	.scan
  5436                                  .exit:
  5437 00002190 C3                      	ret
  5438                                  
  5439                                  ;=========================================================================
  5440                                  ; ipl - Initial Program Load - try to read and execute boot sector
  5441                                  ;-------------------------------------------------------------------------
  5442                                  ipl:
  5443 00002191 FB                      	sti
  5444 00002192 31C0                    	xor	ax,ax
  5445 00002194 8ED8                    	mov	ds,ax
  5446 00002196 C7067800[C76F]          	mov	word [78h],int_1E
  5447 0000219C 8C0E7A00                	mov	word [7Ah],cs
  5448                                  
  5449                                  .retry:
  5450 000021A0 B004                    	mov	al,4			; try booting from floppy 4 times
  5451                                  
  5452                                  .fd_loop:
  5453 000021A2 50                      	push	ax
  5454 000021A3 B400                    	mov	ah,00h			; reset disk system
  5455 000021A5 B200                    	mov	dl,00h			; drive 0
  5456 000021A7 CD13                    	int	13h
  5457 000021A9 722C                    	jb	.fd_failed
  5458 000021AB B408                    	mov	ah,08h			; get drive parameters
  5459 000021AD B200                    	mov	dl,00h			; drive 0
  5460 000021AF CD13                    	int	13h
  5461 000021B1 7224                    	jc	.fd_failed
  5462 000021B3 80FA00                  	cmp	dl,00h
  5463 000021B6 741F                    	jz	.fd_failed		; jump if zero drives
  5464 000021B8 B80102                  	mov	ax,0201h		; read one sector
  5465 000021BB 31D2                    	xor	dx,dx			; head 0, drive 0
  5466 000021BD 8EC2                    	mov	es,dx			; to 0000:7C00
  5467 000021BF BB007C                  	mov	bx,7C00h
  5468 000021C2 B90100                  	mov	cx,0001h		; track 0, sector 1
  5469 000021C5 CD13                    	int	13h
  5470 000021C7 720E                    	jc	.fd_failed
  5471 000021C9 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5472 000021D0 7505                    	jnz	.fd_failed
  5473 000021D2 EA007C0000              	jmp	0000h:7C00h
  5474                                  
  5475                                  .fd_failed:
  5476 000021D7 58                      	pop	ax
  5477 000021D8 FEC8                    	dec	al
  5478 000021DA 75C6                    	jnz	.fd_loop
  5479                                  
  5480                                  ; try booting from HDD
  5481                                  
  5482 000021DC B40D                    	mov	ah,0Dh			; reset hard disks
  5483 000021DE B280                    	mov	dl,80h			; drive 80h
  5484 000021E0 CD13                    	int	13h
  5485 000021E2 7222                    	jc	.hd_failed
  5486 000021E4 B80102                  	mov	ax,0201h		; read one sector
  5487 000021E7 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  5488 000021EA 31DB                    	xor	bx,bx
  5489 000021EC 8EC3                    	mov	es,bx			; to 0000:7C00
  5490 000021EE BB007C                  	mov	bx,7C00h
  5491 000021F1 B90100                  	mov	cx,0001h		; track 0, sector 1
  5492 000021F4 CD13                    	int	13h
  5493 000021F6 720E                    	jc	.hd_failed
  5494 000021F8 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5495 000021FF 7505                    	jnz	.hd_failed
  5496 00002201 EA007C0000              	jmp	0000h:7C00h
  5497                                  
  5498                                  .hd_failed:
  5499 00002206 BE[7B03]                	mov	si,msg_boot_failed
  5500 00002209 E80600                  	call	print
  5501 0000220C B400                    	mov	ah,00h
  5502 0000220E CD16                    	int	16h
  5503 00002210 EB8E                    	jmp	.retry
  5504                                  
  5505                                  ;=========================================================================
  5506                                  ; print - print ASCIIZ string to the console
  5507                                  ; Input:
  5508                                  ;	CS:SI - pointer to string to print
  5509                                  ; Output:
  5510                                  ;	none
  5511                                  ;-------------------------------------------------------------------------
  5512                                  print:
  5513 00002212 9C                      	pushf
  5514 00002213 50                      	push	ax
  5515 00002214 53                      	push	bx
  5516 00002215 56                      	push	si
  5517 00002216 1E                      	push	ds
  5518 00002217 0E                      	push	cs
  5519 00002218 1F                      	pop	ds
  5520 00002219 FC                      	cld
  5521                                  .1:
  5522 0000221A AC                      	lodsb
  5523 0000221B 08C0                    	or	al,al
  5524 0000221D 7408                    	jz	.exit
  5525 0000221F B40E                    	mov	ah,0Eh
  5526 00002221 B30F                    	mov	bl,0Fh
  5527 00002223 CD10                    	int	10h
  5528 00002225 EBF3                    	jmp	.1
  5529                                  .exit:
  5530 00002227 1F                      	pop	ds
  5531 00002228 5E                      	pop	si
  5532 00002229 5B                      	pop	bx
  5533 0000222A 58                      	pop	ax
  5534 0000222B 9D                      	popf
  5535 0000222C C3                      	ret
  5536                                  
  5537                                  ;=========================================================================
  5538                                  ; print_hex - print 16-bit number in hexadecimal
  5539                                  ; Input:
  5540                                  ;	AX - number to print
  5541                                  ; Output:
  5542                                  ;	none
  5543                                  ;-------------------------------------------------------------------------
  5544                                  print_hex:
  5545 0000222D 51                      	push	cx
  5546 0000222E 50                      	push	ax
  5547 0000222F B10C                    	mov	cl,12
  5548 00002231 D3E8                    	shr	ax,cl
  5549 00002233 E83B00                  	call	print_digit
  5550 00002236 58                      	pop	ax
  5551 00002237 50                      	push	ax
  5552 00002238 B108                    	mov	cl,8
  5553 0000223A D3E8                    	shr	ax,cl
  5554 0000223C E83200                  	call	print_digit
  5555 0000223F 58                      	pop	ax
  5556 00002240 50                      	push	ax
  5557 00002241 B104                    	mov	cl,4
  5558 00002243 D3E8                    	shr	ax,cl
  5559 00002245 E82900                  	call	print_digit
  5560 00002248 58                      	pop	ax
  5561 00002249 50                      	push	ax
  5562 0000224A E82400                  	call	print_digit
  5563 0000224D 58                      	pop	ax
  5564 0000224E 59                      	pop	cx
  5565 0000224F C3                      	ret
  5566                                  
  5567                                  ;=========================================================================
  5568                                  ; print_dec - print 16-bit number in decimal
  5569                                  ; Input:
  5570                                  ;	AX - number to print
  5571                                  ; Output:
  5572                                  ;	none
  5573                                  ;-------------------------------------------------------------------------
  5574                                  print_dec:
  5575 00002250 50                      	push	ax
  5576 00002251 51                      	push	cx
  5577 00002252 52                      	push	dx
  5578 00002253 B90A00                  	mov	cx,10		; base = 10
  5579 00002256 E80400                  	call	.print_rec
  5580 00002259 5A                      	pop	dx
  5581 0000225A 59                      	pop	cx
  5582 0000225B 58                      	pop	ax
  5583 0000225C C3                      	ret
  5584                                  
  5585                                  .print_rec:			; print all digits recursively
  5586 0000225D 52                      	push	dx
  5587 0000225E 31D2                    	xor	dx,dx		; DX = 0
  5588 00002260 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  5589 00002262 83F800                  	cmp	ax,0
  5590 00002265 7403                    	je	.below10
  5591 00002267 E8F3FF                  	call	.print_rec	; print number / 10 recursively
  5592                                  .below10:
  5593 0000226A 89D0                    	mov	ax,dx		; reminder is in DX
  5594 0000226C E80200                  	call	print_digit	; print reminder
  5595 0000226F 5A                      	pop	dx
  5596 00002270 C3                      	ret
  5597                                  
  5598                                  ;=========================================================================
  5599                                  ; print_digit - print hexadecimal digit
  5600                                  ; Input:
  5601                                  ;	AL - bits 3...0 - digit to print (0...F)
  5602                                  ; Output:
  5603                                  ;	none
  5604                                  ;-------------------------------------------------------------------------
  5605                                  print_digit:
  5606 00002271 50                      	push	ax
  5607 00002272 53                      	push	bx
  5608 00002273 240F                    	and	al,0Fh
  5609 00002275 0430                    	add	al,'0'			; convert to ASCII
  5610 00002277 3C39                    	cmp	al,'9'			; less or equal 9?
  5611 00002279 7602                    	jna	.1
  5612 0000227B 0407                    	add	al,'A'-'9'-1		; a hex digit
  5613                                  .1:
  5614 0000227D B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  5615 0000227F B307                    	mov	bl,07h			; just in case we're in graphic mode
  5616 00002281 CD10                    	int	10h
  5617 00002283 5B                      	pop	bx
  5618 00002284 58                      	pop	ax
  5619 00002285 C3                      	ret
  5620                                  
  5621                                  ;=========================================================================
  5622                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  5623                                  ; Input:
  5624                                  ;	AX = memory size in KiB
  5625                                  ; Notes:
  5626                                  ;	- Assumes that EBDA memory was cleaned
  5627                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  5628                                  ;-------------------------------------------------------------------------
  5629                                  reserve_ebda:
  5630                                  %ifdef PS2_MOUSE
  5631 00002286 50                      	push	ax
  5632 00002287 51                      	push	cx
  5633 00002288 F70610000400            	test	word [equipment_list],equip_mouse
  5634 0000228E 742B                    	jz	.no_mouse
  5635 00002290 A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  5636 00002293 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  5637 00002296 A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  5638 00002299 B106                    	mov	cl,6
  5639 0000229B D3E0                    	shl	ax,cl			; convert to segment
  5640 0000229D A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  5641 000022A0 1E                      	push	ds
  5642 000022A1 8ED8                    	mov	ds,ax
  5643 000022A3 B80100                  	mov	ax,EBDA_SIZE
  5644 000022A6 A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  5645 000022A9 1F                      	pop	ds
  5646 000022AA 56                      	push	si
  5647 000022AB BE[3A03]                	mov	si,msg_ebda
  5648 000022AE E861FF                  	call	print
  5649 000022B1 E89CFF                  	call	print_dec
  5650 000022B4 BE[7403]                	mov	si,msg_kib
  5651 000022B7 E858FF                  	call	print
  5652 000022BA 5E                      	pop	si
  5653                                  .no_mouse:
  5654 000022BB 59                      	pop	cx
  5655 000022BC 58                      	pop	ax
  5656                                  %endif ; PS2_MOUSE
  5657 000022BD C3                      	ret
  5658                                  
  5659                                  ;=========================================================================
  5660                                  ; detect_ram - Determine the size of installed RAM and test it
  5661                                  ; Input:
  5662                                  ;	none
  5663                                  ; Output:
  5664                                  ;	AX = RAM size
  5665                                  ;	CX, SI - trashed
  5666                                  ;-------------------------------------------------------------------------
  5667                                  detect_ram:
  5668 000022BE B030                    	mov	al,e_ram_start		; RAM scan start
  5669 000022C0 E680                    	out	post_reg,al
  5670                                  
  5671 000022C2 1E                      	push	ds
  5672 000022C3 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  5673 000022C5 B82000                  	mov	ax,MIN_RAM_SIZE
  5674                                  
  5675                                  .fill_loop:
  5676 000022C8 50                      	push	ax
  5677 000022C9 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  5678 000022CB 8ED8                    	mov	ds,ax
  5679 000022CD A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  5680 000022D0 58                      	pop	ax
  5681 000022D1 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  5682 000022D4 3D8002                  	cmp	ax,MAX_RAM_SIZE
  5683 000022D7 75EF                    	jne	.fill_loop
  5684 000022D9 B82000                  	mov	ax,MIN_RAM_SIZE
  5685                                  
  5686                                  .size_loop:
  5687 000022DC 50                      	push	ax
  5688 000022DD D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  5689 000022DF 8ED8                    	mov	ds,ax
  5690 000022E1 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  5691 000022E5 750B                    	jne	.size_done
  5692 000022E7 58                      	pop	ax
  5693 000022E8 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  5694 000022EB 3D8002                  	cmp	ax,MAX_RAM_SIZE
  5695 000022EE 7303                    	jnb	.size_exit
  5696 000022F0 EBEA                    	jmp	.size_loop
  5697                                  
  5698                                  .size_done:
  5699 000022F2 58                      	pop	ax
  5700                                  
  5701                                  .size_exit:
  5702 000022F3 1F                      	pop	ds
  5703 000022F4 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  5704                                  
  5705                                  ; AX = detected memory size, now test the RAM
  5706                                  
  5707 000022F7 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  5708 000022FD 7474                    	je	.test_done
  5709                                  
  5710 000022FF BE[DB02]                	mov	si,msg_ram_testing
  5711 00002302 E80DFF                  	call	print
  5712 00002305 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  5713                                  
  5714                                  .test_loop:
  5715 00002308 50                      	push	ax
  5716 00002309 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  5717 0000230B B700                    	mov	bh,00h			; page 0
  5718 0000230D CD10                    	int	10h			; position returned in DX
  5719 0000230F 58                      	pop	ax
  5720 00002310 E83DFF                  	call	print_dec
  5721 00002313 50                      	push	ax
  5722 00002314 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  5723 00002316 B700                    	mov	bh,00h			; page 0
  5724 00002318 CD10                    	int	10h
  5725 0000231A B401                    	mov	ah,01h
  5726 0000231C CD16                    	int	16h
  5727 0000231E 7412                    	jz	.test_no_key
  5728 00002320 B400                    	mov	ah,00h
  5729 00002322 CD16                    	int	16h			; read the keystroke
  5730 00002324 3C1B                    	cmp	al,1Bh			; ESC?
  5731 00002326 7421                    	je	.test_esc
  5732 00002328 3D003B                  	cmp	ax,3B00h		; F1?
  5733 0000232B 7505                    	jne	.test_no_key
  5734 0000232D 800E120001              	or	byte [post_flags],post_setup
  5735                                  
  5736                                  .test_no_key:
  5737 00002332 58                      	pop	ax
  5738 00002333 E83E00                  	call	ram_test_block
  5739 00002336 721D                    	jc	.test_error		; error in last test
  5740 00002338 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  5741 0000233B 3B061300                	cmp	ax,word [memory_size]
  5742 0000233F 72C7                    	jb	.test_loop
  5743                                  
  5744 00002341 50                      	push	ax
  5745 00002342 B031                    	mov	al,e_ram_complete	; RAM scan complete
  5746 00002344 E680                    	out	post_reg,al
  5747 00002346 58                      	pop	ax
  5748                                  
  5749 00002347 EB2A                    	jmp	.test_done
  5750                                  
  5751                                  .test_esc:
  5752 00002349 58                      	pop	ax
  5753 0000234A A11300                  	mov	ax,word [memory_size]
  5754                                  
  5755 0000234D 50                      	push	ax
  5756 0000234E B032                    	mov	al,e_ram_esc		; RAM scan canceled
  5757 00002350 E680                    	out	post_reg,al
  5758 00002352 58                      	pop	ax
  5759                                  
  5760 00002353 EB1E                    	jmp	.test_done
  5761                                  
  5762                                  .test_error:
  5763 00002355 A31300                  	mov	word [memory_size],ax	; store size of good memory
  5764 00002358 BE[F802]                	mov	si,msg_ram_error
  5765 0000235B E8B4FE                  	call	print
  5766 0000235E E8EFFE                  	call	print_dec
  5767 00002361 BE[7403]                	mov	si,msg_kib
  5768 00002364 E8ABFE                  	call	print
  5769 00002367 BE[8600]                	mov	si,msg_crlf
  5770 0000236A E8A5FE                  	call	print
  5771                                  
  5772 0000236D 50                      	push	ax
  5773 0000236E B080                    	mov	al,e_ram_fail		; RAM scan failed
  5774 00002370 E680                    	out	post_reg,al
  5775 00002372 58                      	pop	ax
  5776                                  
  5777                                  .test_done:
  5778 00002373 C3                      	ret
  5779                                  
  5780                                  ;=========================================================================
  5781                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  5782                                  ; Input:
  5783                                  ;	AX = address of the memory to test (in KiB)
  5784                                  ; Output:
  5785                                  ;	CF = status
  5786                                  ;		0 = passed
  5787                                  ;		1 = failed
  5788                                  ;-------------------------------------------------------------------------
  5789                                  ram_test_block:
  5790 00002374 50                      	push	ax
  5791 00002375 53                      	push	bx
  5792 00002376 51                      	push	cx
  5793 00002377 56                      	push	si
  5794 00002378 57                      	push	di
  5795 00002379 1E                      	push	ds
  5796 0000237A 06                      	push	es
  5797 0000237B B106                    	mov	cl,6			; convert KiB to segment address
  5798 0000237D D3E0                    	shl	ax,cl			; (multiply by 64)
  5799 0000237F 8ED8                    	mov	ds,ax
  5800 00002381 8EC0                    	mov	es,ax
  5801 00002383 31F6                    	xor	si,si
  5802 00002385 31FF                    	xor	di,di
  5803 00002387 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  5804 0000238A B8AA55                  	mov	ax,55AAh		; first test pattern
  5805 0000238D 89D9                    	mov	cx,bx
  5806 0000238F F3AB                        rep	stosw				; store test pattern
  5807 00002391 89D9                    	mov	cx,bx			; RAM test block size
  5808                                  .1:
  5809 00002393 AD                      	lodsw
  5810 00002394 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  5811 00002397 7522                    	jne	.fail
  5812 00002399 E2F8                    	loop	.1
  5813 0000239B 31F6                    	xor	si,si
  5814 0000239D 31FF                    	xor	di,di
  5815 0000239F B855AA                  	mov	ax,0AA55h		; second test pattern
  5816 000023A2 89D9                    	mov	cx,bx			; RAM test block size
  5817 000023A4 F3AB                        rep stosw				; store test pattern
  5818 000023A6 89D9                    	mov	cx,bx			; RAM test block size
  5819                                  .2:
  5820 000023A8 AD                      	lodsw
  5821 000023A9 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  5822 000023AC 750D                    	jne	.fail
  5823 000023AE E2F8                    	loop	.2
  5824 000023B0 31FF                    	xor	di,di
  5825 000023B2 31C0                    	xor	ax,ax			; zero
  5826 000023B4 89D9                    	mov	cx,bx			; RAM test block size
  5827 000023B6 F3AB                        rep stosw				; zero the memory
  5828 000023B8 F8                      	clc				; test passed, clear CF
  5829 000023B9 EB01                    	jmp	.exit
  5830                                  
  5831                                  .fail:
  5832 000023BB F9                      	stc				; test failed, set CF
  5833                                  	
  5834                                  .exit:
  5835 000023BC 07                      	pop	es
  5836 000023BD 1F                      	pop	ds
  5837 000023BE 5F                      	pop	di
  5838 000023BF 5E                      	pop	si
  5839 000023C0 59                      	pop	cx
  5840 000023C1 5B                      	pop	bx
  5841 000023C2 58                      	pop	ax
  5842 000023C3 C3                      	ret
  5843                                  
  5844                                  ;=========================================================================
  5845                                  ; print display type
  5846                                  ;-------------------------------------------------------------------------
  5847                                  print_display:
  5848 000023C4 BE[9E01]                	mov	si,msg_disp
  5849 000023C7 E848FE                  	call	print
  5850 000023CA A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  5851 000023CD 2430                    	and	al,equip_video		; get video adapter type
  5852 000023CF BE[E001]                	mov	si,msg_disp_mda
  5853 000023D2 3C30                    	cmp	al,equip_mono		; monochrome?
  5854 000023D4 740A                    	jz	.print_disp
  5855 000023D6 BE[DA01]                	mov	si,msg_disp_cga
  5856 000023D9 3C20                    	cmp	al,equip_color		; CGA?
  5857 000023DB 7403                    	jz	.print_disp
  5858 000023DD BE[BB01]                	mov	si,msg_disp_ega		; otherwise EGA or later
  5859                                  .print_disp:
  5860 000023E0 E82FFE                  	call	print
  5861 000023E3 C3                      	ret
  5862                                  
  5863                                  ;=========================================================================
  5864                                  ; print PS/2 mouse presence
  5865                                  ;-------------------------------------------------------------------------
  5866                                  
  5867                                  print_mouse:
  5868 000023E4 BE[6902]                	mov	si,msg_mouse
  5869 000023E7 E828FE                  	call	print
  5870 000023EA BE[9002]                	mov	si,msg_absent
  5871 000023ED F606100004              	test	byte [equipment_list],equip_mouse
  5872 000023F2 7403                    	jz	.print_mouse
  5873 000023F4 BE[8602]                	mov	si,msg_present
  5874                                  .print_mouse:
  5875 000023F7 E818FE                  	call	print
  5876 000023FA C3                      	ret
  5877                                  
  5878                                  ;=========================================================================
  5879                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  5880                                  ;-------------------------------------------------------------------------
  5881                                  
  5882                                  detect_rom_ext:
  5883 000023FB B040                    	mov	al,e_ext_start		; ROM extension scan start
  5884 000023FD E680                    	out	post_reg,al
  5885                                  
  5886 000023FF BA00C8                  	mov	dx,0C800h
  5887 00002402 BB00F8                  	mov	bx,0F800h
  5888                                  .ext_scan_loop:
  5889 00002405 E83DFD                  	call	extension_scan
  5890 00002408 833E670000              	cmp	word [67h],0
  5891 0000240D 7427                    	jz	.ext_scan_next
  5892 0000240F B041                    	mov	al,e_ext_detect		; ROM extension found
  5893 00002411 E680                    	out	post_reg,al
  5894 00002413 BE[B703]                	mov	si,msg_rom_found
  5895 00002416 E8F9FD                  	call	print
  5896 00002419 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  5897 0000241C E80EFE                  	call	print_hex
  5898 0000241F BE[D403]                	mov	si,msg_rom_init
  5899 00002422 E8EDFD                  	call	print
  5900 00002425 53                      	push	bx
  5901 00002426 52                      	push	dx
  5902 00002427 FF1E6700                	call	far [67h]
  5903 0000242B B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  5904 0000242E 8ED8                    	mov	ds,ax
  5905 00002430 B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  5906 00002432 E680                    	out	post_reg,al
  5907 00002434 5A                      	pop	dx
  5908 00002435 5B                      	pop	bx
  5909                                  .ext_scan_next:
  5910 00002436 39DA                    	cmp	dx,bx
  5911 00002438 72CB                    	jb	.ext_scan_loop
  5912                                  
  5913 0000243A B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  5914 0000243C E680                    	out	post_reg,al
  5915                                  
  5916 0000243E C3                      	ret
  5917                                  
  5918                                  ;=========================================================================	
  5919                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  5920                                  ;-------------------------------------------------------------------------
  5921                                  interrupt_table:
  5922 0000243F [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
  5923 00002441 [537F]                  	dw	int_dummy		; INT 01 - Single step
  5924 00002443 [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  5925 00002445 [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  5926 00002447 [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  5927 00002449 [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
  5928 0000244B [537F]                  	dw	int_dummy		; INT 06
  5929 0000244D [537F]                  	dw	int_dummy		; INT 07
  5930 0000244F [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  5931 00002451 [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  5932 00002453 [237F]                  	dw	int_ignore		; INT 0A - IRQ2
  5933 00002455 [237F]                  	dw	int_ignore		; INT 0B - IRQ3
  5934 00002457 [237F]                  	dw	int_ignore		; INT 0C - IRQ4
  5935 00002459 [237F]                  	dw	int_ignore		; INT 0D - IRQ5
  5936 0000245B [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  5937 0000245D [237F]                  	dw	int_ignore		; INT 0F - IRQ7
  5938 0000245F [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
  5939 00002461 [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  5940 00002463 [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  5941 00002465 [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  5942 00002467 [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  5943 00002469 [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  5944 0000246B [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  5945 0000246D [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  5946 0000246F [4D63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  5947 00002471 [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  5948 00002473 [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
  5949 00002475 [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  5950 00002477 [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
  5951 00002479 [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
  5952 0000247B [C76F]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  5953 0000247D [0806]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  5954                                  
  5955                                  interrupt_table2:
  5956 0000247F [A30D]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  5957 00002481 [3121]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  5958 00002483 [2821]                  	dw	int_ignore2		; INT 72 - IRQ10
  5959 00002485 [2821]                  	dw	int_ignore2		; INT 73 - IRQ11
  5960                                  %ifndef PS2_MOUSE
  5961                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  5962                                  %else
  5963 00002487 [751F]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  5964                                  %endif
  5965 00002489 [3A21]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  5966 0000248B [2821]                  	dw	int_ignore2		; INT 76 - IRQ14
  5967 0000248D [2821]                  	dw	int_ignore2		; INT 77 - IRQ15
  5968                                  
  5969                                  ;=========================================================================
  5970                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  5971                                  ;-------------------------------------------------------------------------	
  5972 0000248F FF<rept>                	setloc	0E05Bh		; POST Entry Point
  5973          ******************       warning: (setloc:7) Inserting 15308 bytes
  5974                                  cold_start:
  5975 0000605B B84000                  	mov	ax,biosdseg
  5976 0000605E 8ED8                    	mov	ds,ax
  5977 00006060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  5978                                  
  5979                                  warm_start:
  5980 00006066 FA                      	cli				; disable interrupts
  5981 00006067 FC                      	cld				; clear direction flag
  5982 00006068 B001                    	mov	al,e_start
  5983 0000606A E680                    	out	post_reg,al		; POST start code
  5984                                  
  5985                                  ;-------------------------------------------------------------------------
  5986                                  ; test CPU's FLAG register
  5987                                  
  5988 0000606C 31C0                    	xor	ax,ax			; AX = 0
  5989 0000606E 724A                    	jb	cpu_fail
  5990 00006070 7048                    	jo	cpu_fail
  5991 00006072 7846                    	js	cpu_fail
  5992 00006074 7544                    	jnz	cpu_fail
  5993 00006076 7B42                    	jpo	cpu_fail
  5994 00006078 83C001                  	add	ax,1			; AX = 1
  5995 0000607B 743D                    	jz	cpu_fail
  5996 0000607D 7A3B                    	jpe	cpu_fail
  5997 0000607F 2D0280                  	sub	ax,8002h
  5998 00006082 7836                    	js	cpu_fail
  5999 00006084 40                      	inc	ax
  6000 00006085 7133                    	jno	cpu_fail
  6001 00006087 D1E0                    	shl	ax,1
  6002 00006089 732F                    	jnb	cpu_fail
  6003 0000608B 752D                    	jnz	cpu_fail
  6004 0000608D D1E0                    	shl	ax,1
  6005 0000608F 7229                    	jb	cpu_fail
  6006                                  
  6007                                  ;-------------------------------------------------------------------------
  6008                                  ; Test CPU registers
  6009                                  
  6010 00006091 B8AAAA                  	mov	ax,0AAAAh
  6011                                  .1:
  6012 00006094 8ED8                    	mov	ds,ax
  6013 00006096 8CDB                    	mov	bx,ds
  6014 00006098 8EC3                    	mov	es,bx
  6015 0000609A 8CC1                    	mov	cx,es
  6016 0000609C 8ED1                    	mov	ss,cx
  6017 0000609E 8CD2                    	mov	dx,ss
  6018 000060A0 89D5                    	mov	bp,dx
  6019 000060A2 89EC                    	mov	sp,bp
  6020 000060A4 89E6                    	mov	si,sp
  6021 000060A6 89F7                    	mov	di,si
  6022 000060A8 81FFAAAA                	cmp	di,0AAAAh
  6023 000060AC 7506                    	jnz	.2
  6024 000060AE 89F8                    	mov	ax,di
  6025 000060B0 F7D0                    	not	ax
  6026 000060B2 EBE0                    	jmp	.1
  6027                                  .2:
  6028 000060B4 81FF5555                	cmp	di,5555h
  6029 000060B8 741A                    	jz	cpu_ok
  6030                                  
  6031                                  cpu_fail:
  6032 000060BA B052                    	mov	al,e_cpu_fail
  6033 000060BC E680                    	out	post_reg,al
  6034                                  
  6035                                  ;-------------------------------------------------------------------------
  6036                                  ; CPU error: continious beep - 400 Hz
  6037                                  
  6038 000060BE B0B6                    	mov	al,0B6h
  6039 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6040 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6041 000060C5 E642                    	out	pit_ch2_reg,al
  6042 000060C7 88E0                    	mov	al,ah
  6043 000060C9 E642                    	out	pit_ch2_reg,al
  6044 000060CB E461                    	in	al,port_b_reg
  6045 000060CD 0C03                    	or	al,3			; turn speaker on and enable
  6046 000060CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6047                                  
  6048                                  .1:
  6049 000060D1 F4                      	hlt
  6050 000060D2 EBFD                    	jmp	.1
  6051                                  
  6052                                  ;-------------------------------------------------------------------------
  6053                                  ; CPU test passed
  6054                                  
  6055                                  cpu_ok:
  6056 000060D4 B002                    	mov	al,e_cpu_ok
  6057 000060D6 E680                    	out	post_reg,al
  6058                                  
  6059                                  ;-------------------------------------------------------------------------
  6060                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  6061                                  
  6062 000060D8 B00D                    	mov	al,0Dh & nmi_disable
  6063 000060DA E670                    	out	rtc_addr_reg,al		; disable NMI
  6064 000060DC EB00                    	jmp	$+2
  6065 000060DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  6066                                  
  6067 000060E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  6068 000060E2 E661                    	out	port_b_reg,al
  6069 000060E4 B000                    	mov	al,00h			; clear turbo bit
  6070 000060E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  6071                                  
  6072 000060E8 BAD803                  	mov	dx,cga_mode_reg
  6073 000060EB EE                      	out	dx,al			; disable video output on CGA
  6074 000060EC FEC0                    	inc	al
  6075 000060EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  6076 000060F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  6077                                  
  6078                                  ;-------------------------------------------------------------------------
  6079                                  ; Initialize DMAC (8237)
  6080                                   
  6081 000060F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  6082 000060F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  6083 000060F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6084 000060F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  6085 000060FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6086 000060FC B042                     	mov	al,42h			; single mode, verify, channel 2
  6087 000060FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6088 00006100 B043                     	mov	al,43h			; single mode, verify, channel 3
  6089 00006102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6090 00006104 B000                     	mov	al,0			; DMA Command register bits:
  6091                                   					; DACK active low, DREQ active high,
  6092                                   					; late write, fixed priority,
  6093                                   					; normal timing, controller enable
  6094                                   					; channel 0 addr hold disable
  6095                                   					; memory to memory disable
  6096 00006106 E608                     	out	08h,al			; DMA Command register
  6097 00006108 E681                     	out	81h,al			; DMA Page, channel 2
  6098 0000610A E682                     	out	82h,al			; DMA Page, channel 3
  6099 0000610C E683                     	out	83h,al			; DMA Page, channels 0,1
  6100 0000610E B003                    	mov	al,e_dmac_ok
  6101 00006110 E680                    	out	post_reg,al
  6102                                  
  6103                                  ;-------------------------------------------------------------------------
  6104                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  6105                                  
  6106                                  low_ram_test:
  6107 00006112 31F6                    	xor	si,si
  6108 00006114 31FF                    	xor	di,di
  6109 00006116 8EDF                    	mov	ds,di
  6110 00006118 8EC7                    	mov	es,di
  6111 0000611A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  6112 0000611E B8AA55                  	mov	ax,55AAh		; first test pattern
  6113 00006121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6114 00006124 F3AB                        rep	stosw				; store test pattern
  6115 00006126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6116                                  .1:
  6117 00006129 AD                      	lodsw
  6118 0000612A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6119 0000612D 7524                    	jne	low_ram_fail
  6120 0000612F E2F8                    	loop	.1
  6121 00006131 31F6                    	xor	si,si
  6122 00006133 31FF                    	xor	di,di
  6123 00006135 B855AA                  	mov	ax,0AA55h		; second test pattern
  6124 00006138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6125 0000613B F3AB                        rep stosw				; store test pattern
  6126 0000613D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6127                                  .2:
  6128 00006140 AD                      	lodsw
  6129 00006141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6130 00006144 750D                    	jne	low_ram_fail
  6131 00006146 E2F8                    	loop	.2
  6132 00006148 31FF                    	xor	di,di
  6133 0000614A 31C0                    	xor	ax,ax			; zero
  6134 0000614C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6135 0000614F F3AB                        rep stosw				; zero the memory
  6136 00006151 EB29                    	jmp	low_ram_ok		; test passed
  6137                                  
  6138                                  low_ram_fail:
  6139 00006153 B054                    	mov	al,e_low_ram_fail	; test failed
  6140 00006155 E680                    	out	post_reg,al
  6141                                  
  6142                                  ;-------------------------------------------------------------------------
  6143                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  6144                                  
  6145 00006157 B0B6                    	mov	al,0B6h
  6146 00006159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6147 0000615B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6148 0000615E E642                    	out	pit_ch2_reg,al
  6149 00006160 88E0                    	mov	al,ah
  6150 00006162 E642                    	out	pit_ch2_reg,al
  6151 00006164 E461                    	in	al,port_b_reg
  6152                                  .1:
  6153 00006166 0C03                    	or	al,3			; turn speaker on and enable
  6154 00006168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6155 0000616A B90000                  	mov	cx,0
  6156                                  .2:
  6157 0000616D 90                      	nop
  6158 0000616E E2FD                    	loop	.2
  6159 00006170 24FC                    	and	al,0FCh			; turn of speaker
  6160 00006172 E661                    	out	port_b_reg,al
  6161 00006174 B90000                  	mov	cx,0
  6162                                  .3:
  6163 00006177 90                      	nop
  6164 00006178 E2FD                    	loop	.3
  6165 0000617A EBEA                    	jmp	.1
  6166                                  
  6167                                  ;-------------------------------------------------------------------------
  6168                                  ; Low memory test passed
  6169                                  
  6170                                  low_ram_ok:
  6171 0000617C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  6172 00006180 B004                    	mov	al,e_low_ram_ok
  6173 00006182 E680                    	out	post_reg,al
  6174                                  
  6175                                  ;-------------------------------------------------------------------------
  6176                                  ; Set up stack - using upper 256 bytes of interrupt table
  6177                                  
  6178 00006184 B83000                  	mov	ax,0030h
  6179 00006187 8ED0                    	mov	ss,ax
  6180 00006189 BC0001                  	mov	sp,0100h
  6181                                  
  6182                                  ;-------------------------------------------------------------------------
  6183                                  ; Initialize interrupt table
  6184                                  
  6185 0000618C 0E                      	push	cs
  6186 0000618D 1F                      	pop	ds
  6187 0000618E 31FF                    	xor	di,di
  6188 00006190 8EC7                    	mov	es,di
  6189 00006192 BE[3F24]                	mov	si,interrupt_table
  6190 00006195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  6191 00006198 B800F0                  	mov	ax,bioscseg
  6192                                  .1:
  6193 0000619B A5                      	movsw				; copy ISR address (offset part)
  6194 0000619C AB                      	stosw				; store segment part
  6195 0000619D E2FC                    	loop	.1
  6196                                  %ifdef AT_COMPAT
  6197 0000619F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  6198 000061A2 BE[7F24]                	mov	si,interrupt_table2
  6199 000061A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  6200                                  .2:
  6201 000061A8 A5                      	movsw				; copy ISR address (offset part)
  6202 000061A9 AB                      	stosw				; store segment part
  6203 000061AA E2FC                    	loop	.2
  6204                                  %endif ; AT_COMPAT
  6205 000061AC B005                    	mov     al,e_int_ok
  6206 000061AE E680                    	out	post_reg,al
  6207                                  
  6208                                  ;-------------------------------------------------------------------------
  6209                                  ; set DS to BIOS data area
  6210                                  
  6211 000061B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6212 000061B3 8ED8                    	mov	ds,ax
  6213                                  
  6214                                  ;-------------------------------------------------------------------------
  6215                                  ; Initialize PIT (8254 timer)
  6216                                  
  6217 000061B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  6218 000061B7 E643                    	out	pit_ctl_reg,al
  6219 000061B9 B000                    	mov	al,0
  6220 000061BB E640                    	out	pit_ch0_reg,al
  6221 000061BD E640                    	out	pit_ch0_reg,al
  6222 000061BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  6223 000061C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  6224 000061C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  6225 000061C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  6226 000061C7 B040                    	mov	al,40h			; XXX timer latch
  6227 000061C9 E643                    	out	pit_ctl_reg,al
  6228                                  
  6229                                  ;-------------------------------------------------------------------------
  6230                                  ; Play "power on" sound - also tests PIT functionality
  6231 000061CB E836BE                  	call	sound
  6232                                  
  6233 000061CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  6234 000061D0 E680                    	out	post_reg,al
  6235                                  
  6236                                  ;-------------------------------------------------------------------------
  6237                                  ; Initialize PIC (8259)
  6238                                  
  6239                                  %ifdef AT_COMPAT
  6240 000061D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  6241 000061D4 E620                    	out	pic1_reg0,al
  6242 000061D6 E6A0                    	out	pic2_reg0,al
  6243 000061D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  6244 000061DA E621                    	out	pic1_reg1,al
  6245 000061DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  6246 000061DE E6A1                    	out	pic2_reg1,al
  6247 000061E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  6248 000061E2 E621                    	out	pic1_reg1,al
  6249 000061E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  6250 000061E6 E6A1                    	out	pic2_reg1,al
  6251 000061E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  6252 000061EA E621                    	out	pic1_reg1,al
  6253 000061EC E6A1                    	out	pic2_reg1,al
  6254                                  %else
  6255                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  6256                                  	out	pic1_reg0,al
  6257                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  6258                                  	out	pic1_reg1,al
  6259                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  6260                                  	out	pic1_reg1,al
  6261                                  	mov	al,e_pic_ok
  6262                                  	out	post_reg,al
  6263                                  %endif ; AT_COMPAT
  6264                                  
  6265                                  ;-------------------------------------------------------------------------
  6266                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  6267                                  
  6268 000061EE E8EFB4                  	call	kbc_init
  6269                                  
  6270                                  ;-------------------------------------------------------------------------
  6271                                  ; enable interrupts
  6272                                  
  6273                                  %ifdef AT_COMPAT
  6274 000061F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  6275 000061F3 E621                    	out	pic1_reg1,al
  6276                                  %ifndef PS2_MOUSE
  6277                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  6278                                  %else
  6279 000061F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  6280                                  %endif ; PS2_MOUSE
  6281 000061F7 E6A1                    	out	pic2_reg1,al
  6282                                  %else
  6283                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  6284                                  	out	pic1_reg1,al
  6285                                  %endif ; AT_COMPAT
  6286 000061F9 FB                      	sti
  6287                                  
  6288                                  ;-------------------------------------------------------------------------
  6289                                  ; look for video BIOS, initialize it if present
  6290                                  
  6291 000061FA BA00C0                  	mov	dx,0C000h
  6292 000061FD BB00C8                  	mov	bx,0C800h
  6293 00006200 E842BF                  	call	extension_scan
  6294 00006203 833E670000              	cmp	word [67h],0
  6295 00006208 7418                    	jz	.no_video_bios
  6296 0000620A B011                    	mov	al,e_video_bios_ok
  6297 0000620C E680                    	out	post_reg,al
  6298 0000620E FF1E6700                	call	far [67h]
  6299 00006212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6300 00006215 8ED8                    	mov	ds,ax
  6301 00006217 B012                    	mov	al,e_video_init_ok
  6302 00006219 E680                    	out	post_reg,al
  6303                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  6304 0000621B 83261000CF              	and	word [equipment_list],~equip_video
  6305 00006220 EB14                    	jmp	.video_initialized
  6306                                  
  6307                                  .no_video_bios:
  6308 00006222 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  6309 00006226 80E430                  	and	ah,equip_video		; get video adapter type
  6310 00006229 B007                    	mov	al,07h			; monochrome 80x25 mode
  6311 0000622B 80FC30                  	cmp	ah,equip_mono		; monochrome?
  6312 0000622E 7402                    	jz	.set_mode
  6313 00006230 B003                    	mov	al,03h			; color 80x25 mode
  6314                                  
  6315                                  .set_mode:
  6316 00006232 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  6317 00006234 CD10                    	int	10h
  6318                                  
  6319                                  .video_initialized:
  6320                                  
  6321                                  ;-------------------------------------------------------------------------
  6322                                  ; print the copyright message
  6323                                  
  6324 00006236 BE[0000]                	mov	si,msg_copyright
  6325 00006239 E8D6BF                  	call	print
  6326                                  
  6327                                  ;-------------------------------------------------------------------------
  6328                                  ; Initialize RTC / NVRAM
  6329                                  
  6330 0000623C E8E3A7                  	call	rtc_init
  6331                                  
  6332                                  ; read equipment byte from CMOS and set it in BIOS data area
  6333                                  
  6334 0000623F BE[5904]                	mov	si,msg_setup
  6335 00006242 E8CDBF                  	call	print
  6336                                  
  6337                                  ;-------------------------------------------------------------------------
  6338                                  ; detect and print availability of various equipment
  6339                                  
  6340 00006245 E812BE                  	call	detect_cpu		; detect and print CPU type
  6341 00006248 E898BE                  	call	detect_fpu		; detect and print FPU presence
  6342                                  
  6343 0000624B E876C1                  	call	print_display		; print display type
  6344 0000624E E893C1                  	call	print_mouse		; print mouse presence
  6345                                  
  6346 00006251 E825BA                  	call	detect_serial		; detect serial ports and print findings
  6347 00006254 E8D2BA                  	call	detect_parallel		; detect parallel ports and print
  6348                                  					; findings
  6349                                  
  6350 00006257 B010                    	mov	al,cmos_floppy
  6351 00006259 E8ACA7                  	call	rtc_read		; floppies type to AL
  6352 0000625C E823B3                  	call	print_floppy		; print floppy drive types
  6353                                  
  6354 0000625F E85CC0                  	call	detect_ram		; test RAM, get RAM size in AX
  6355                                  
  6356 00006262 BE[1C03]                	mov	si,msg_ram_total
  6357 00006265 E8AABF                  	call	print
  6358 00006268 E8E5BF                  	call	print_dec		; print RAM size
  6359 0000626B BE[7403]                	mov	si,msg_kib
  6360 0000626E E8A1BF                  	call	print
  6361                                  
  6362 00006271 E812C0                  	call	reserve_ebda		; reserve EBDA if needed
  6363                                  
  6364 00006274 BE[5703]                	mov	si,msg_ram_avail
  6365 00006277 E898BF                  	call	print
  6366 0000627A A11300                  	mov	ax,word [memory_size]
  6367 0000627D E8D0BF                  	call	print_dec		; print remaining RAM size
  6368 00006280 BE[7403]                	mov	si,msg_kib
  6369 00006283 E88CBF                  	call	print
  6370                                  
  6371 00006286 E872C1                  	call	detect_rom_ext		; detect and initialize extension ROMs
  6372                                  
  6373                                  ;-------------------------------------------------------------------------
  6374                                  ; Check for F1 (setup key), run setup utility if pressed
  6375                                  
  6376 00006289 B401                    	mov	ah,01h
  6377 0000628B CD16                    	int	16h
  6378 0000628D 740E                    	jz	.no_key
  6379 0000628F B400                    	mov	ah,00h
  6380 00006291 CD16                    	int	16h			; read the keystroke
  6381 00006293 3D003B                  	cmp	ax,3B00h		; F1?
  6382 00006296 7505                    	jne	.no_key
  6383 00006298 800E120001              	or	byte [post_flags],post_setup
  6384                                  .no_key:
  6385                                  
  6386 0000629D F606120001              	test	byte [post_flags],post_setup
  6387 000062A2 7403                    	jz	.no_setup
  6388 000062A4 E896A8                  	call	rtc_setup
  6389                                  
  6390                                  .no_setup:
  6391                                  
  6392                                  ;-------------------------------------------------------------------------
  6393                                  ; boot the OS
  6394                                  
  6395 000062A7 B049                    	mov	al,e_boot		; boot the OS POST code
  6396 000062A9 E680                    	out	post_reg,al
  6397                                  
  6398 000062AB BE[E903]                	mov	si,msg_boot
  6399 000062AE E861BF                  	call	print
  6400 000062B1 CD19                    	int	19h			; boot the OS
  6401                                  
  6402                                  ;=========================================================================
  6403                                  ; int_02 - NMI
  6404                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  6405                                  ;	implemented
  6406                                  ;-------------------------------------------------------------------------
  6407 000062B3 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  6408          ******************       warning: (setloc:7) Inserting 16 bytes
  6409                                  int_02:
  6410 000062C3 50                      	push	ax
  6411 000062C4 B00D                    	mov	al,0Dh & nmi_disable
  6412 000062C6 E83FA7                  	call	rtc_read		; disable NMI
  6413 000062C9 E461                    	in	al,port_b_reg		; read Port B
  6414 000062CB 88C4                    	mov	ah,al
  6415 000062CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  6416 000062CF E661                    	out	port_b_reg,al
  6417 000062D1 A840                    	test	al,iochk_status
  6418 000062D3 7506                    	jnz	.iochk_nmi
  6419 000062D5 88E0                    	mov	al,ah
  6420 000062D7 E661                    	out	port_b_reg,al		; restore original bits
  6421 000062D9 EB24                    	jmp	.exit
  6422                                  
  6423                                  .iochk_nmi:
  6424 000062DB 56                      	push	si
  6425 000062DC BE[0663]                	mov	si,msg_iochk_nmi
  6426 000062DF E830BF                  	call	print
  6427 000062E2 5E                      	pop	si
  6428                                  .1:
  6429 000062E3 B400                    	mov	ah,0h
  6430 000062E5 CD16                    	int	16h
  6431 000062E7 3C69                    	cmp	al,'i'			; exit from NMI
  6432 000062E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  6433 000062EB 3C49                    	cmp	al,'I'
  6434 000062ED 7410                    	je	.exit
  6435 000062EF 3C72                    	cmp	al,'r'
  6436 000062F1 7503E965FD              	je	cold_start
  6437 000062F6 3C52                    	cmp	al,'R'
  6438 000062F8 7503E95EFD              	je	cold_start
  6439 000062FD EBE4                    	jmp	.1
  6440                                  .exit:
  6441 000062FF B08D                    	mov	al,0Dh | nmi_enable
  6442 00006301 E804A7                  	call	rtc_read		; enable NMI
  6443 00006304 58                      	pop	ax
  6444 00006305 CF                      	iret
  6445                                  
  6446                                  msg_iochk_nmi:
  6447 00006306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  6448 0000630F 206465746563746564-
  6449 00006318 2E2054797065202769-
  6450 00006321 2720746F2069676E6F-
  6451 0000632A 726520494F43484B20-
  6452 00006333 4E4D49732C206F7220-
  6453 0000633C 27722720746F207265-
  6454 00006345 626F6F742E         
  6455 0000634A 0D0A00                  	db	0Dh, 0Ah, 00h
  6456                                  
  6457                                  ;=========================================================================
  6458                                  ; int_18 - execute ROM BASIC
  6459                                  ; Note:
  6460                                  ;	Prints an error message since we don't have ROM BASIC
  6461                                  ;-------------------------------------------------------------------------
  6462                                  int_18:
  6463 0000634D BE[A803]                	mov	si,msg_no_basic
  6464 00006350 E8BFBE                  	call	print
  6465                                  .1:
  6466 00006353 F4                      	hlt
  6467 00006354 EBFD                    	jmp	.1
  6468                                  
  6469                                  ;=========================================================================
  6470                                  ; int_19 - load and execute the boot sector
  6471                                  ;-------------------------------------------------------------------------
  6472 00006356 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  6473          ******************       warning: (setloc:7) Inserting 924 bytes
  6474                                  int_19:
  6475 000066F2 E99CBA                  	jmp	ipl
  6476                                  
  6477                                  ;=========================================================================
  6478                                  ; configuration data table
  6479                                  ;-------------------------------------------------------------------------
  6480                                  	setloc	0E6F5h
  6481                                  config_table:
  6482 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  6483                                  .bytes:
  6484                                  %ifdef AT_COMPAT
  6485 000066F7 FC                      	db	0FCh			; byte 2: model = AT
  6486 000066F8 00                      	db	00h			; byte 3: submodel = 0
  6487 000066F9 00                      	db	00h			; byte 4: release = 0
  6488 000066FA 70                      	db	01110000b		; byte 5: feature byte 1
  6489                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  6490                                  ;		||||||`-- bus is Micro Channel instead of ISA
  6491                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  6492                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  6493                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  6494                                  ;		||`-- real time clock installed
  6495                                  ;		|`-- 2nd interrupt controller installed
  6496                                  ;		`-- DMA channel 3 used by hard disk BIOS
  6497 000066FB 00                      	db	00h			; byte 6: feature byte 2
  6498 000066FC 00                      	db	00h			; byte 7: feature byte 3
  6499 000066FD 00                      	db	00h			; byte 8: feature byte 4
  6500 000066FE 00                      	db	00h			; byte 9: feature byte 5
  6501                                  %else
  6502                                  	db	0FEh			; byte 2: model = XT
  6503                                  	db	00h			; byte 3: submodel = 0
  6504                                  	db	00h			; byte 4: release = 0
  6505                                  	db	00000000b		; byte 5: feature byte 1
  6506                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  6507                                  ;		||||||`-- bus is Micro Channel instead of ISA
  6508                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  6509                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  6510                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  6511                                  ;		||`-- real time clock installed
  6512                                  ;		|`-- 2nd interrupt controller installed
  6513                                  ;		`-- DMA channel 3 used by hard disk BIOS
  6514                                  	db	00h			; byte 6: feature byte 2
  6515                                  	db	00h			; byte 7: feature byte 3
  6516                                  	db	00h			; byte 8: feature byte 4
  6517                                  	db	00h			; byte 9: feature byte 5
  6518                                  %endif ; AT_COMPAT
  6519                                  .size	equ	$-.bytes
  6520                                  
  6521                                  ;=========================================================================
  6522                                  ; Includes with fixed entry points (for IBM compatibility)
  6523                                  ;-------------------------------------------------------------------------
  6524                                  
  6525                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  6526                              <1> ;========================================================================
  6527                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  6528                              <1> ;       INT 14h, function AH=00h
  6529                              <1> ;       INT 14h, function AH=03h
  6530                              <1> ;       INT 14h, function AH=04h
  6531                              <1> ;       INT 14h, function AH=05h
  6532                              <1> ;	- see serial1.inc for other INT 14h functions
  6533                              <1> ;-------------------------------------------------------------------------
  6534                              <1> ;
  6535                              <1> ; Compiles with NASM 2.07, might work with other versions
  6536                              <1> ;
  6537                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  6538                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  6539                              <1> ;
  6540                              <1> ; This program is free software: you can redistribute it and/or modify
  6541                              <1> ; it under the terms of the GNU General Public License as published by
  6542                              <1> ; the Free Software Foundation, either version 3 of the License, or
  6543                              <1> ; (at your option) any later version.
  6544                              <1> ;
  6545                              <1> ; This program is distributed in the hope that it will be useful,
  6546                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6547                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6548                              <1> ; GNU General Public License for more details.
  6549                              <1> ;
  6550                              <1> ; You should have received a copy of the GNU General Public License
  6551                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  6552                              <1> ;
  6553                              <1> ;=========================================================================
  6554                              <1> 
  6555                              <1> ;=========================================================================
  6556                              <1> ; int_14 - BIOS Serial Port Communication Services
  6557                              <1> ;-------------------------------------------------------------------------
  6558 000066FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  6559          ******************  <1>  warning: (setloc:7) Inserting 42 bytes
  6560                              <1> int_14:
  6561 00006729 FB                  <1> 	sti
  6562 0000672A 51                  <1> 	push	cx
  6563 0000672B 52                  <1> 	push	dx
  6564 0000672C 56                  <1> 	push	si
  6565 0000672D 1E                  <1> 	push	ds
  6566 0000672E 53                  <1> 	push	bx
  6567 0000672F BB4000              <1> 	mov	bx,biosdseg
  6568 00006732 8EDB                <1> 	mov	ds,bx
  6569 00006734 80FC06              <1> 	cmp	ah,.max/2
  6570 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
  6571 00006739 83FA04              <1> 	cmp	dx,num_serial
  6572 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
  6573 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  6574 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  6575 00006743 89D3                <1> 	mov	bx,dx
  6576 00006745 D1E3                <1> 	shl	bx,1
  6577 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  6578 00006749 09D2                <1> 	or	dx,dx
  6579 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
  6580 0000674D B700                <1> 	mov	bh,0
  6581 0000674F 88E3                <1> 	mov	bl,ah
  6582 00006751 D1E3                <1> 	shl	bx,1
  6583 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
  6584                              <1> .dispatch:
  6585 00006758 [6C67]              <1> 	dw	int_14_fn00
  6586 0000675A [141C]              <1> 	dw	int_14_fn01
  6587 0000675C [2F1C]              <1> 	dw	int_14_fn02
  6588 0000675E [A167]              <1> 	dw	int_14_fn03
  6589 00006760 [AB67]              <1> 	dw	int_14_fn04
  6590 00006762 [0568]              <1> 	dw	int_14_fn05
  6591                              <1> .max	equ	$-.dispatch
  6592                              <1> 
  6593                              <1> int_14_error:
  6594 00006764 31C0                <1> 	xor	ax,ax
  6595                              <1> 
  6596                              <1> int_14_exit:
  6597 00006766 5B                  <1> 	pop	bx
  6598 00006767 1F                  <1> 	pop	ds
  6599 00006768 5E                  <1> 	pop	si
  6600 00006769 5A                  <1> 	pop	dx
  6601 0000676A 59                  <1> 	pop	cx
  6602 0000676B CF                  <1> 	iret
  6603                              <1> 
  6604                              <1> ;=========================================================================
  6605                              <1> ; int_14_fn00 - Initialize serial port
  6606                              <1> ; Input:
  6607                              <1> ;	AH = 0 - function 00h - initialize serial port
  6608                              <1> ;	AL - initialization parameters
  6609                              <1> ;		bit 1,0	= 10	- 7 data bits
  6610                              <1> ;			= 11	- 8 data bits
  6611                              <1> ;		bit 2	= 0	- 1 stop bit
  6612                              <1> ;			= 1	- 2 stop bits
  6613                              <1> ;		bit 3	= 0	- parity disable
  6614                              <1> ;			= 1	- parity enable
  6615                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  6616                              <1> ;			= 1	- even parity (if parity enabled)
  6617                              <1> ;		bit 7-5 = 000	- 110 bps
  6618                              <1> ;			= 001	- 150 bps
  6619                              <1> ;			= 010	- 300 bps
  6620                              <1> ;			= 011	- 600 bps
  6621                              <1> ;			= 100	- 1200 bps
  6622                              <1> ;			= 101	- 2400 bps
  6623                              <1> ;			= 110	- 4800 bps
  6624                              <1> ;			= 111	- 9600 bps
  6625                              <1> ;	DX = serial port number (0-3)
  6626                              <1> ; Output:
  6627                              <1> ;	AL = modem status
  6628                              <1> ;		bit 0	= 1	- delta clear to send
  6629                              <1> ;		bit 1	= 1	- delta data set ready
  6630                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  6631                              <1> ;		bit 3	= 1	- delta data carrier detect
  6632                              <1> ;		bit 4	= 1	- clear to send
  6633                              <1> ;		bit 5	= 1	- data set ready
  6634                              <1> ;		bit 6	= 1	- ring indicator
  6635                              <1> ;		bit 7	= 1	- data carrier detect
  6636                              <1> ;	AH = line status
  6637                              <1> ;		bit 0	= 1	- data ready
  6638                              <1> ;		bit 1	= 1	- overrun error
  6639                              <1> ;		bit 2	= 1	- parity error
  6640                              <1> ;		bit 3	= 1	- framing error
  6641                              <1> ;		bit 4	= 1	- break interrupt
  6642                              <1> ;		bit 5	= 1	- transmitter holding register
  6643                              <1> ;		bit 6	= 1	- transmitter empty
  6644                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  6645                              <1> ;-------------------------------------------------------------------------
  6646                              <1> int_14_fn00:
  6647 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  6648 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  6649 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  6650 00006773 EE                  <1> 	out	dx,al
  6651 00006774 31DB                <1> 	xor	bx,bx
  6652 00006776 88E3                <1> 	mov	bl,ah
  6653 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  6654 0000677B D0EB                <1> 	shr	bl,1
  6655 0000677D D0EB                <1> 	shr	bl,1
  6656 0000677F D0EB                <1> 	shr	bl,1
  6657 00006781 D0EB                <1> 	shr	bl,1
  6658 00006783 2E8B9F[FD1C]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  6659 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6660 0000678B 88D8                <1> 	mov	al,bl
  6661 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  6662 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  6663 0000678F 88F8                <1> 	mov	al,bh
  6664 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  6665 00006792 42                  <1> 	inc	dx
  6666 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  6667 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  6668 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  6669                              <1> 					; get control bits
  6670 00006798 EE                  <1> 	out	dx,al			; set LCR
  6671 00006799 4A                  <1> 	dec	dx
  6672 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  6673                              <1> 					; OPTIMIZATION:
  6674                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  6675 0000679B B000                <1> 	mov	al,0
  6676 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  6677 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  6678                              <1> 					; OPTIMIZATION:
  6679                              <1> 					; uart_base = uart_ier_reg - 1
  6680 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6681                              <1> 
  6682                              <1> ;=========================================================================
  6683                              <1> ; int_14_fn03 - Return serial port status
  6684                              <1> ; Input:
  6685                              <1> ;	AH = 03h - function 03h - return serial port status
  6686                              <1> ;	DX = serial port number (0-3)
  6687                              <1> ; Output:
  6688                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  6689                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  6690                              <1> ;-------------------------------------------------------------------------
  6691                              <1> int_14_fn03:
  6692 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  6693 000067A4 EC                  <1> 	in	al,dx
  6694 000067A5 88C4                <1> 	mov	ah,al
  6695 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  6696 000067A8 EC                  <1> 	in	al,dx
  6697 000067A9 EBBB                <1> 	jmp	int_14_exit
  6698                              <1> 
  6699                              <1> ;=========================================================================
  6700                              <1> ; int_14_fn04 - Extended initialize serial port
  6701                              <1> ; Input:
  6702                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  6703                              <1> ;	AL - break status:
  6704                              <1> ;		00h = no break
  6705                              <1> ;		01h = break
  6706                              <1> ;	BH - parity:
  6707                              <1> ;		00h = no parity
  6708                              <1> ;		01h = odd parity
  6709                              <1> ;		02h = even parity
  6710                              <1> ;		03h = stick parity odd
  6711                              <1> ;		04h = stick parity even
  6712                              <1> ;	BL - stop bits:
  6713                              <1> ;		00h = 1 stop bit
  6714                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  6715                              <1> ;	CH - word length:
  6716                              <1> ;		00h = 5 bits
  6717                              <1> ;		01h = 6 bits
  6718                              <1> ;		02h = 7 bits
  6719                              <1> ;		03h = 8 bits
  6720                              <1> ;	CL - bps rate:
  6721                              <1> ;		00h = 110 bps
  6722                              <1> ;		01h = 150 bps
  6723                              <1> ;		02h = 300 bps
  6724                              <1> ;		03h = 600 bps
  6725                              <1> ;		04h = 1200 bps
  6726                              <1> ;		05h = 2400 bps
  6727                              <1> ;		06h = 6000 bps
  6728                              <1> ;		07h = 9600 bps
  6729                              <1> ;		08h = 19200 bps
  6730                              <1> ;		09h = 38400 bps
  6731                              <1> ;		0Ah = 57600 bps
  6732                              <1> ;		0Bh = 115200 bps
  6733                              <1> ;	DX = serial port number (0-3)
  6734                              <1> ; Output:
  6735                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  6736                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  6737                              <1> ;-------------------------------------------------------------------------
  6738                              <1> int_14_fn04:
  6739 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  6740 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  6741 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  6742                              <1> 					; exit returning modem and line status
  6743 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  6744 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  6745 000067B7 EE                  <1> 	out	dx,al
  6746 000067B8 31DB                <1> 	xor	bx,bx
  6747 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  6748 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  6749 000067BE 2E8B9F[FD1C]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  6750 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6751 000067C6 88D8                <1> 	mov	al,bl
  6752 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  6753 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  6754 000067CA 88F8                <1> 	mov	al,bh
  6755 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  6756 000067CD 42                  <1> 	inc	dx
  6757 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  6758                              <1> 
  6759 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  6760 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  6761                              <1> 
  6762 000067D4 D0E0                <1> 	shl	al,1
  6763 000067D6 D0E0                <1> 	shl	al,1
  6764 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  6765                              <1> 	
  6766 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  6767 000067DB 53                  <1> 	push	bx			; push it back to the stack
  6768                              <1> 
  6769 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  6770 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  6771 000067E1 FECF                <1> 	dec	bh
  6772 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  6773 000067E6 D0E7                <1> 	shl	bh,1
  6774 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  6775                              <1> 
  6776                              <1> .set_parity:
  6777 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  6778                              <1> 
  6779 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  6780                              <1> 	
  6781 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  6782 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  6783                              <1> 
  6784 000067F3 D0E0                <1> 	shl	al,1
  6785 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  6786                              <1> 
  6787 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  6788 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  6789                              <1> 
  6790 000067FC EE                  <1> 	out	dx,al			; set LCR
  6791 000067FD 4A                  <1> 	dec	dx
  6792 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  6793                              <1> 					; OPTIMIZATION:
  6794                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  6795 000067FF B000                <1> 	mov	al,0
  6796 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  6797 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  6798                              <1> 					; OPTIMIZATION:
  6799                              <1> 					; uart_base = uart_ier_reg - 1
  6800 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6801                              <1> 
  6802                              <1> ;=========================================================================
  6803                              <1> ; int_14_fn05 - Extended serial port control
  6804                              <1> ; Input:
  6805                              <1> ;	AH = 05h - function 05h - extended serial port control
  6806                              <1> ;	AL - sub-function:
  6807                              <1> ;		00h = read modem control register
  6808                              <1> ;		01h = write modem control register
  6809                              <1> ;			BL = modem control register
  6810                              <1> ;	DX = serial port number (0-3)
  6811                              <1> ; Output:
  6812                              <1> ;	AX = status	
  6813                              <1> ;	sub-function AL = 00h:
  6814                              <1> ;		BL = modem control register
  6815                              <1> ;-------------------------------------------------------------------------
  6816                              <1> int_14_fn05:
  6817 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  6818 00006807 750D                <1> 	jnz	int_14_fn05_01
  6819                              <1> 
  6820                              <1> ;-------------------------------------------------------------------------
  6821                              <1> ; sub-function 00h - read modem control register
  6822                              <1> ; int_14_fn05_00:
  6823 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  6824 0000680C EC                  <1> 	in	al,dx
  6825 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  6826 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  6827 00006810 53                  <1> 	push	bx			; put BX back to the stack
  6828 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6829 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6830                              <1> 
  6831                              <1> ;-------------------------------------------------------------------------
  6832                              <1> ; sub-function 01h - write modem control register
  6833                              <1> int_14_fn05_01:
  6834 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  6835 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  6836 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  6837 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  6838 0000681D EE                  <1> 	out	dx,al
  6839 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6840 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6841                                  %include	"atkbd.inc"		; INT 16, INT 09
  6842                              <1> ;=========================================================================
  6843                              <1> ; atkbd.inc - AT keyboard support
  6844                              <1> ;       INT 16h - BIOS Keyboard Services
  6845                              <1> ;		- function AH=02h
  6846                              <1> ;		- function AH=03h
  6847                              <1> ;		- function AH=05h
  6848                              <1> ;		- function AH=12h
  6849                              <1> ;		- see scancode.inc for other (scancode related)
  6850                              <1> ;                 INT 16h functions
  6851                              <1> ;       INT 09h - IRQ1 interrupt handler
  6852                              <1> ;-------------------------------------------------------------------------
  6853                              <1> ;
  6854                              <1> ; Compiles with NASM 2.07, might work with other versions
  6855                              <1> ;
  6856                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  6857                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  6858                              <1> ;
  6859                              <1> ; This program is free software: you can redistribute it and/or modify
  6860                              <1> ; it under the terms of the GNU General Public License as published by
  6861                              <1> ; the Free Software Foundation, either version 3 of the License, or
  6862                              <1> ; (at your option) any later version.
  6863                              <1> ;
  6864                              <1> ; This program is distributed in the hope that it will be useful,
  6865                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6866                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6867                              <1> ; GNU General Public License for more details.
  6868                              <1> ;
  6869                              <1> ; You should have received a copy of the GNU General Public License
  6870                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  6871                              <1> ;
  6872                              <1> ;=========================================================================
  6873                              <1> 
  6874                              <1> ;=========================================================================
  6875                              <1> ; Scan codes and keyboard flags
  6876                              <1> ;-------------------------------------------------------------------------
  6877                              <1> 
  6878                              <1> ; scancodes for special keys
  6879                              <1> 
  6880                              <1> kbd_num_code	equ	45h
  6881                              <1> kbd_scroll_code	equ	46h
  6882                              <1> kbd_caps_code	equ	3ah
  6883                              <1> kbd_ctrl_code	equ	1dh
  6884                              <1> kbd_alt_code	equ	38h
  6885                              <1> kbd_rshift_code	equ	36h
  6886                              <1> kbd_prtsc_code	equ	37h
  6887                              <1> kbd_lshift_code	equ	2ah
  6888                              <1> kbd_ins_code	equ	52h
  6889                              <1> kbd_del_code	equ	53h
  6890                              <1> 
  6891                              <1> ; Bits for the various modifier keys
  6892                              <1> 
  6893                              <1> kbd_rshft_bit	equ	1
  6894                              <1> kbd_lshft_bit	equ	2
  6895                              <1> kbd_ctrl_bit	equ	4
  6896                              <1> kbd_alt_bit	equ	8
  6897                              <1> kbd_scroll_bit	equ	10h
  6898                              <1> kbd_num_bit	equ	20h
  6899                              <1> kbd_caps_bit	equ	40h
  6900                              <1> kbd_ins_bit	equ	80h
  6901                              <1> 
  6902                              <1> ;=========================================================================
  6903                              <1> ; int_16 - BIOS keyboard functions
  6904                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  6905                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  6906                              <1> ;	conditions
  6907                              <1> ;-------------------------------------------------------------------------
  6908 00006824 FF<rept>            <1> 	setloc	0E82Eh
  6909          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  6910                              <1> int_16:
  6911 0000682E 53                  <1> 	push	bx
  6912 0000682F 1E                  <1> 	push	ds
  6913 00006830 BB4000              <1> 	mov	bx,biosdseg
  6914 00006833 8EDB                <1> 	mov	ds,bx
  6915 00006835 80FC13              <1> 	cmp	ah,.num_func
  6916 00006838 7331                <1> 	jae	int_16_exit
  6917 0000683A B700                <1> 	mov	bh,0
  6918 0000683C 88E3                <1> 	mov	bl,ah
  6919 0000683E D1E3                <1> 	shl	bx,1
  6920 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
  6921                              <1> 
  6922                              <1> .dispatch:
  6923 00006845 [291B]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  6924 00006847 [7E1B]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  6925 00006849 [7468]              <1> 	dw	int_16_fn02		; get shift status
  6926 0000684B [7968]              <1> 	dw	int_16_fn03		; set delays
  6927 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
  6928 0000684F [A668]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  6929 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
  6930 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
  6931 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
  6932 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
  6933 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
  6934 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  6935 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  6936 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  6937 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  6938 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  6939 00006865 [D61B]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  6940 00006867 [FD1B]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  6941 00006869 [CF68]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  6942                              <1> .num_func	equ	($-.dispatch)/2
  6943                              <1> 
  6944                              <1> int_16_exit:
  6945 0000686B 1F                  <1> 	pop	ds
  6946 0000686C 5B                  <1> 	pop	bx
  6947 0000686D CF                  <1> 	iret
  6948                              <1> 
  6949                              <1> int_16_exitf:
  6950 0000686E 1F                  <1> 	pop	ds
  6951 0000686F 5B                  <1> 	pop	bx
  6952 00006870 FB                  <1> 	sti
  6953 00006871 CA0200              <1> 	retf	2
  6954                              <1> 
  6955                              <1> ;=========================================================================
  6956                              <1> ; int_16_fn02 - get shift flags
  6957                              <1> ; Input:
  6958                              <1> ;	AH = 02h
  6959                              <1> ; Output:
  6960                              <1> ;	AL - shift flags
  6961                              <1> ;            AL bits:
  6962                              <1> ;		7 - Insert active
  6963                              <1> ;		6 - Caps Lock active
  6964                              <1> ;		5 - Num Lock active
  6965                              <1> ;		4 - Scroll Lock active
  6966                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  6967                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  6968                              <1> ;		1 - left shift key pressed
  6969                              <1> ;		0 - right shift key pressed
  6970                              <1> ;-------------------------------------------------------------------------
  6971                              <1> int_16_fn02:
  6972 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  6973 00006877 EBF2                <1> 	jmp	int_16_exit
  6974                              <1> 
  6975                              <1> ;=========================================================================
  6976                              <1> ; int_16_fn03 - set keyboard typematic rate
  6977                              <1> ; Input:
  6978                              <1> ;	AH = 03
  6979                              <1> ;	AL - subfunction
  6980                              <1> ;	     00 - set typematic rate to default
  6981                              <1> ;	     01 - increase initial delay
  6982                              <1> ;	     02 - slow typematic rate by 1/2
  6983                              <1> ;	     04 - turn off typematic chars
  6984                              <1> ;	     05 - set typematic rate/delay
  6985                              <1> ;	BH - repeat delay (AL=5)
  6986                              <1> ;		0 - 250ms	2 - 750ms
  6987                              <1> ;		1 - 500ms	3 - 1000ms
  6988                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  6989                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  6990                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  6991                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  6992                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  6993                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  6994                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  6995                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  6996                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  6997                              <1> ; Output:
  6998                              <1> ;	none
  6999                              <1> ;-------------------------------------------------------------------------
  7000                              <1> int_16_fn03:
  7001 00006879 3C05                <1> 	cmp	al,05
  7002 0000687B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  7003 0000687D 53                  <1> 	push	bx
  7004 0000687E 51                  <1> 	push	cx
  7005 0000687F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7006 00006881 E8A7AD              <1> 	call	kbc_send_cmd_byte
  7007 00006884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  7008 00006887 B105                <1> 	mov	cl,5
  7009 00006889 D2E7                <1> 	shl	bh,cl
  7010 0000688B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  7011 0000688E B0F3                <1> 	mov	al,0F3h
  7012 00006890 E834AD              <1> 	call	kbc_kb_send
  7013 00006893 88F8                <1> 	mov	al,bh
  7014 00006895 E82FAD              <1> 	call	kbc_kb_send
  7015 00006898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7016 0000689A E88EAD              <1> 	call	kbc_send_cmd_byte
  7017 0000689D B004                <1> 	mov	al,04h
  7018 0000689F E825AD              <1> 	call	kbc_kb_send
  7019 000068A2 59                  <1> 	pop	cx
  7020 000068A3 5B                  <1> 	pop	bx
  7021                              <1> .exit:
  7022 000068A4 EBC5                <1> 	jmp	int_16_exit
  7023                              <1> 
  7024                              <1> ;=========================================================================
  7025                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  7026                              <1> ; Input:
  7027                              <1> ;	AH = 05h
  7028                              <1> ;	CH = BIOS scan code
  7029                              <1> ;	CL = ACII character
  7030                              <1> ; Output:
  7031                              <1> ;	AL - status
  7032                              <1> ;	     00h - success
  7033                              <1> ;	     01h - keyboard buffer full
  7034                              <1> ;-------------------------------------------------------------------------
  7035                              <1> int_16_fn05:
  7036 000068A6 56                  <1> 	push	si
  7037 000068A7 B001                <1> 	mov	al,1			; assume no space
  7038 000068A9 FA                  <1> 	cli				; critical section
  7039 000068AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7040 000068AE 89DE                <1> 	mov	si,bx
  7041 000068B0 83C302              <1> 	add	bx,2
  7042 000068B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7043 000068B7 7504                <1> 	jne	.1
  7044 000068B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7045                              <1> .1:
  7046 000068BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7047 000068C1 7408                <1> 	je	.no_space		; no space in buffer
  7048 000068C3 890C                <1> 	mov	word [si],cx
  7049 000068C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7050 000068C9 B000                <1> 	mov	al,0			; stored successfully
  7051                              <1> .no_space:
  7052 000068CB FB                  <1> 	sti
  7053 000068CC 5E                  <1> 	pop	si
  7054 000068CD EB9C                <1> 	jmp	int_16_exit
  7055                              <1> 
  7056                              <1> ;=========================================================================
  7057                              <1> ; int_16_fn12 - get extended shift flags
  7058                              <1> ; Input:
  7059                              <1> ;	AH = 12h
  7060                              <1> ; Output:
  7061                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  7062                              <1> ;	AH - shift flags 2
  7063                              <1> ;            AH bits:
  7064                              <1> ;		7 - SysRq key pressed
  7065                              <1> ;		6 - Caps Lock pressed
  7066                              <1> ;		5 - Num Lock pressed
  7067                              <1> ;		4 - Scroll Lock pressed
  7068                              <1> ;		3 - right Alt key pressed
  7069                              <1> ;		2 - right Ctrl key pressed
  7070                              <1> ;		1 - left Alt key pressed
  7071                              <1> ;		0 - left Ctrl key pressed
  7072                              <1> ;-------------------------------------------------------------------------
  7073                              <1> int_16_fn12:
  7074 000068CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  7075 000068D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  7076 000068D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  7077 000068D9 7403                <1> 	je	.1
  7078 000068DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  7079                              <1> .1:
  7080 000068DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  7081 000068E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  7082 000068E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  7083 000068E6 08C4                <1> 	or	ah,al			; copy to AH
  7084 000068E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7085 000068EB E97DFF              <1> 	jmp	int_16_exit
  7086                              <1> 
  7087                              <1> ;=========================================================================
  7088                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  7089                              <1> ;-------------------------------------------------------------------------
  7090 000068EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  7091          ******************  <1>  warning: (setloc:7) Inserting 153 bytes
  7092                              <1> int_09:
  7093 00006987 50                  <1> 	push	ax
  7094 00006988 53                  <1> 	push	bx
  7095 00006989 1E                  <1> 	push	ds
  7096                              <1> 
  7097 0000698A B84000              <1> 	mov	ax,biosdseg
  7098 0000698D 8ED8                <1> 	mov	ds,ax
  7099                              <1> 
  7100                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7101                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7102                              <1> 	call    kbc_send_cmd_byte
  7103                              <1> %endif
  7104 0000698F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  7105 00006991 FB                  <1> 	sti
  7106 00006992 B44F                <1> 	mov	ah,4Fh
  7107 00006994 F9                  <1> 	stc
  7108 00006995 CD15                <1> 	int	15h			; keyboard intercept
  7109 00006997 7203E9C401          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  7110                              <1> 
  7111                              <1> ; check for KBC response codes
  7112                              <1> 
  7113 0000699C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  7114 0000699E 7503E9BD01          <1> 	je      keyboard_int_exit
  7115 000069A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  7116 000069A5 7508                <1> 	jne     .2
  7117 000069A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  7118 000069AC E9B101              <1> 	jmp	keyboard_int_exit
  7119                              <1> .2:
  7120 000069AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  7121 000069B1 7508                <1> 	jne	.3
  7122 000069B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  7123 000069B8 E9A501              <1> 	jmp	keyboard_int_exit
  7124                              <1> 
  7125                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  7126                              <1> 
  7127                              <1> .3:
  7128                              <1> 
  7129                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  7130                              <1> 
  7131 000069BB 3CE0                <1> 	cmp	al,0e0h
  7132 000069BD 750D                <1> 	jne	.4
  7133 000069BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  7134 000069C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  7135 000069C9 E99401              <1> 	jmp	keyboard_int_exit
  7136                              <1> .4:
  7137 000069CC 3CE1                <1> 	cmp	al,0e1h
  7138 000069CE 750D                <1> 	jne	.5
  7139 000069D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  7140 000069D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  7141 000069DA E98301              <1> 	jmp	keyboard_int_exit
  7142                              <1> 
  7143                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  7144                              <1> 
  7145                              <1> .5:
  7146 000069DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  7147 000069E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  7148 000069E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  7149 000069E7 7529                <1> 	jne	.6
  7150 000069E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  7151 000069EB 750B                <1> 	jne	.check_minus
  7152 000069ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  7153 000069F3 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  7154                              <1> 
  7155                              <1> .check_minus:
  7156 000069F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  7157 000069FA 7509                <1> 	jne	.check_plus
  7158                              <1> 
  7159                              <1> .turbo_off:
  7160 000069FC E461                <1> 	in	al,port_b_reg
  7161 000069FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  7162 00006A00 E661                <1> 	out	port_b_reg,al
  7163 00006A02 E95B01              <1> 	jmp	keyboard_int_exit
  7164                              <1> 
  7165                              <1> .check_plus:
  7166 00006A05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  7167 00006A07 7509                <1> 	jne	.6
  7168                              <1> 
  7169                              <1> .turbo_on:
  7170 00006A09 E461                <1> 	in	al,port_b_reg
  7171 00006A0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  7172 00006A0D E661                <1> 	out	port_b_reg,al
  7173 00006A0F E94E01              <1> 	jmp	keyboard_int_exit
  7174                              <1> 
  7175                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  7176                              <1> ; in the keyboard flags variables.
  7177                              <1> 
  7178                              <1> .6:
  7179 00006A12 3C52                <1> 	cmp	al,kbd_ins_code
  7180 00006A14 7508                <1> 	jne	.7
  7181 00006A16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  7182 00006A1B E90301              <1> 	jmp	.translate	   	; pass on INS key
  7183                              <1> 
  7184                              <1> .7:
  7185 00006A1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  7186 00006A20 750D                <1> 	jne     .8
  7187 00006A22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  7188 00006A27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  7189 00006A2C E92C01              <1> 	jmp     .no_buffer
  7190                              <1> 
  7191                              <1> ; handle the left and right Shift keys
  7192                              <1> 
  7193                              <1> .8:
  7194 00006A2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  7195 00006A31 7508                <1> 	jne	.9
  7196 00006A33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  7197 00006A38 E92001              <1> 	jmp	.no_buffer
  7198                              <1> .9:
  7199 00006A3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  7200 00006A3D 7508                <1> 	jne     .10
  7201 00006A3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  7202 00006A44 E91401              <1> 	jmp     .no_buffer
  7203                              <1> .10:
  7204 00006A47 3C36                <1> 	cmp	al,kbd_rshift_code
  7205 00006A49 7508                <1> 	jne	.11
  7206 00006A4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  7207 00006A50 E90801              <1> 	jmp	.no_buffer
  7208                              <1> .11:
  7209 00006A53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  7210 00006A55 7508                <1> 	jne     .12
  7211 00006A57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  7212 00006A5C E9FC00              <1> 	jmp	.no_buffer
  7213                              <1> 
  7214                              <1> ; handle the Alt key
  7215                              <1> 
  7216                              <1> .12:
  7217 00006A5F 3C38                <1> 	cmp	al,kbd_alt_code
  7218 00006A61 7508                <1> 	jne	.13
  7219 00006A63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  7220 00006A68 E9F000              <1> 	jmp	.no_buffer
  7221                              <1> .13:
  7222 00006A6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  7223 00006A6D 751C                <1> 	jne	.14
  7224 00006A6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  7225 00006A74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  7226 00006A79 7503E9DD00          <1> 	je	.no_buffer				; nothing there - exit
  7227 00006A7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  7228 00006A81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  7229 00006A86 B400                <1> 	mov	ah,0
  7230 00006A88 E9AF00              <1> 	jmp	.put_in_buffer
  7231                              <1> 
  7232                              <1> ; handle the Ctrl key
  7233                              <1> 
  7234                              <1> .14:
  7235 00006A8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  7236 00006A8D 7508                <1> 	jne	.15
  7237 00006A8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  7238 00006A94 E9C400              <1> 	jmp	.no_buffer
  7239                              <1> .15:
  7240 00006A97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  7241 00006A99 7508                <1> 	jne	.16
  7242 00006A9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  7243 00006AA0 E9B800              <1> 	jmp	.no_buffer
  7244                              <1> 
  7245                              <1> ; handle the Caps Lock key
  7246                              <1> 
  7247                              <1> .16:
  7248 00006AA3 3C3A                <1> 	cmp	al,kbd_caps_code
  7249 00006AA5 750D                <1> 	jne	.17
  7250 00006AA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  7251 00006AAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  7252 00006AB1 E9A700              <1> 	jmp	.no_buffer
  7253                              <1> .17:
  7254 00006AB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  7255 00006AB6 7508                <1> 	jne	.18
  7256 00006AB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  7257 00006ABD E9C400              <1> 	jmp	set_LEDs
  7258                              <1> 
  7259                              <1> ; check if print screen key was pressed
  7260                              <1> 
  7261                              <1> .18:
  7262 00006AC0 3C37                <1> 	cmp	al,kbd_prtsc_code
  7263 00006AC2 7503                <1> 	jne	.test_scroll_loc
  7264 00006AC4 E9B500              <1> 	jmp	print_screen
  7265                              <1> 
  7266                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  7267                              <1> 
  7268                              <1> .test_scroll_loc:
  7269 00006AC7 3C46                <1> 	cmp	al,kbd_scroll_code
  7270 00006AC9 7528                <1> 	jne	.19
  7271 00006ACB F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7272 00006AD0 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  7273                              <1> 
  7274                              <1> ; handle Ctrl-Break
  7275                              <1> 
  7276 00006AD2 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  7277 00006AD6 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  7278 00006ADA 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7279 00006ADE 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  7280 00006AE3 CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  7281 00006AE5 EB74                <1> 	jmp	.no_buffer
  7282                              <1> 
  7283                              <1> ; handle Scroll Lock
  7284                              <1> 
  7285                              <1> .scroll_lock:
  7286 00006AE7 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  7287 00006AEC 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  7288 00006AF1 EB68                <1> 	jmp	.no_buffer
  7289                              <1> .19:
  7290 00006AF3 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  7291 00006AF5 7508                <1> 	jne	.20
  7292 00006AF7 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  7293 00006AFC E98500              <1> 	jmp	set_LEDs
  7294                              <1> 
  7295                              <1> ; handle the Num Lock
  7296                              <1> 
  7297                              <1> .20:
  7298 00006AFF 3C45                <1> 	cmp	al,kbd_num_code
  7299 00006B01 7513                <1> 	jne	.21
  7300 00006B03 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  7301 00006B08 755E                <1> 	jnz	pause			; jump if pause
  7302 00006B0A 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  7303 00006B0F 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  7304 00006B14 EB45                <1> 	jmp	.no_buffer
  7305                              <1> .21:
  7306 00006B16 3CC5                <1> 	cmp	al,kbd_num_code+80h
  7307 00006B18 7507                <1> 	jne	.translate
  7308 00006B1A 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  7309 00006B1F EB63                <1> 	jmp	set_LEDs
  7310                              <1> 
  7311                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  7312                              <1> 
  7313                              <1> .translate:
  7314 00006B21 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  7315 00006B26 7407                <1> 	jz	.check_release
  7316 00006B28 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  7317 00006B2D EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  7318                              <1> .check_release:
  7319 00006B2F A880                <1> 	test	al,80h			; ignore key release and KBC responses
  7320 00006B31 7528                <1> 	jnz	.no_buffer
  7321                              <1> 
  7322 00006B33 E83AAF              <1> 	call	scan_xlat
  7323 00006B36 85C0                <1> 	test	ax,ax		 	; check for bad code
  7324 00006B38 7421                <1> 	je	.no_buffer
  7325                              <1> 
  7326                              <1> .put_in_buffer:
  7327 00006B3A 56                  <1> 	push	si			; XXX - use Int 16h/05?
  7328 00006B3B 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7329 00006B3F 89DE                <1> 	mov	si,bx
  7330 00006B41 83C302              <1> 	add	bx,2
  7331 00006B44 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7332 00006B48 7504                <1> 	jne	.1
  7333 00006B4A 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7334                              <1> .1:
  7335 00006B4E 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7336 00006B52 7406                <1> 	je	.no_space		; no space in buffer
  7337 00006B54 8904                <1> 	mov	word [si],ax
  7338 00006B56 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7339                              <1> 
  7340                              <1> .no_space:
  7341 00006B5A 5E                  <1> 	pop	si
  7342                              <1> 
  7343                              <1> .no_buffer:
  7344 00006B5B 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  7345                              <1> 
  7346                              <1> keyboard_int_exit:
  7347                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7348                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7349                              <1> 	call	kbc_send_cmd_byte
  7350                              <1> %endif
  7351 00006B60 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7352 00006B62 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  7353                              <1> 
  7354                              <1> keyboard_int_exit1:
  7355 00006B64 1F                  <1> 	pop	ds
  7356 00006B65 5B                  <1> 	pop	bx
  7357 00006B66 58                  <1> 	pop	ax
  7358 00006B67 CF                  <1> 	iret
  7359                              <1> 
  7360                              <1> pause:
  7361 00006B68 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  7362 00006B6D 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  7363                              <1> 
  7364 00006B6F B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7365 00006B71 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7366                              <1> 
  7367                              <1> .pause_loop:
  7368 00006B73 F606180008          <1> 	test	byte [kbd_flags_2],08h
  7369 00006B78 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  7370 00006B7A EBE8                <1> 	jmp	keyboard_int_exit1
  7371                              <1> 
  7372                              <1> print_screen:
  7373 00006B7C B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7374 00006B7E E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7375 00006B80 CD05                <1> 	int	5h			; INT 5 - print screen
  7376 00006B82 EBE0                <1> 	jmp	keyboard_int_exit1
  7377                              <1> 
  7378                              <1> ;=========================================================================
  7379                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  7380                              <1> ; 	     variable and update LEDs on the keyboard
  7381                              <1> ;-------------------------------------------------------------------------
  7382                              <1> set_LEDs:
  7383                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7384                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7385                              <1> 	call	kbc_send_cmd_byte
  7386                              <1> %endif
  7387                              <1> 
  7388 00006B84 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7389 00006B86 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7390                              <1> 
  7391 00006B88 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7392 00006B8B D0E8                <1> 	shr	al,1
  7393 00006B8D D0E8                <1> 	shr	al,1
  7394 00006B8F D0E8                <1> 	shr	al,1
  7395 00006B91 D0E8                <1> 	shr	al,1
  7396 00006B93 2407                <1> 	and	al,111b
  7397 00006B95 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  7398 00006B9A 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  7399 00006B9E 88C4                <1> 	mov	ah,al			; save LED bits
  7400                              <1> 
  7401 00006BA0 B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7402 00006BA2 E886AA              <1> 	call	kbc_send_cmd_byte
  7403                              <1> 
  7404 00006BA5 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  7405 00006BA7 E81DAA              <1> 	call	kbc_kb_send		; send the command to the keyboard
  7406 00006BAA 88E0                <1> 	mov	al,ah			; get parameter byte
  7407 00006BAC E818AA              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  7408                              <1> 
  7409 00006BAF B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7410 00006BB1 E877AA              <1> 	call	kbc_send_cmd_byte
  7411 00006BB4 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  7412 00006BB6 E80EAA              <1> 	call	kbc_kb_send
  7413 00006BB9 EBA9                <1> 	jmp	keyboard_int_exit1
  7414                              <1> 
  7415                                  %include	"floppy2.inc"		; INT 13
  7416                              <1> ;=========================================================================
  7417                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  7418                              <1> ;       INT 13h, function AH=02h
  7419                              <1> ;       INT 13h, function AH=03h
  7420                              <1> ;       INT 13h, function AH=04h
  7421                              <1> ;       INT 13h, function AH=05h
  7422                              <1> ;	- see floppy1.inc for other INT 13h functions
  7423                              <1> ;-------------------------------------------------------------------------
  7424                              <1> ;
  7425                              <1> ; Compiles with NASM 2.07, might work with other versions
  7426                              <1> ;
  7427                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7428                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7429                              <1> ;
  7430                              <1> ; This program is free software: you can redistribute it and/or modify
  7431                              <1> ; it under the terms of the GNU General Public License as published by
  7432                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7433                              <1> ; (at your option) any later version.
  7434                              <1> ;
  7435                              <1> ; This program is distributed in the hope that it will be useful,
  7436                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7437                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7438                              <1> ; GNU General Public License for more details.
  7439                              <1> ;
  7440                              <1> ; You should have received a copy of the GNU General Public License
  7441                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7442                              <1> ;
  7443                              <1> ;=========================================================================
  7444                              <1> 
  7445                              <1> ;-------------------------------------------------------------------------
  7446                              <1> ; offsets for registers on stack
  7447                              <1> int_13_bp	equ	0
  7448                              <1> int_13_ds	equ	int_13_bp+2
  7449                              <1> int_13_di	equ	int_13_ds+2
  7450                              <1> int_13_si	equ	int_13_di+2
  7451                              <1> int_13_dx	equ	int_13_si+2
  7452                              <1> int_13_dl	equ	int_13_dx
  7453                              <1> int_13_dh	equ	int_13_dx+1
  7454                              <1> int_13_cx	equ	int_13_dx+2
  7455                              <1> int_13_cl	equ	int_13_cx
  7456                              <1> int_13_ch	equ	int_13_cx+1
  7457                              <1> int_13_bx	equ	int_13_cx+2
  7458                              <1> int_13_bl	equ	int_13_bx
  7459                              <1> int_13_bh	equ	int_13_bx+1
  7460                              <1> int_13_ax	equ	int_13_bx+2
  7461                              <1> int_13_al	equ	int_13_ax
  7462                              <1> int_13_ah	equ	int_13_ax+1
  7463                              <1> int_13_ip	equ	int_13_ax+2
  7464                              <1> int_13_cs	equ	int_13_ip+2
  7465                              <1> int_13_flags	equ	int_13_cs+2
  7466                              <1> int_13_flags_l	equ	int_13_flags
  7467                              <1> 
  7468                              <1> ;=========================================================================
  7469                              <1> ; int_13 - BIOS floppy disk services
  7470                              <1> ; Input:
  7471                              <1> ;	AH = function
  7472                              <1> ;		00h - Reset disk system
  7473                              <1> ;		01h - Get status of last operation
  7474                              <1> ;		02h - Read disk sectors
  7475                              <1> ;		03h - Write disk sectors
  7476                              <1> ;		04h - Verify disk sectors
  7477                              <1> ;		05h - Format track
  7478                              <1> ;		08h - Get drive parameters
  7479                              <1> ;		15h - Get disk type
  7480                              <1> ;		16h - Detect disk change
  7481                              <1> ;		17h - Set disk type for format
  7482                              <1> ;		18h - Set media type for format
  7483                              <1> ; Output:
  7484                              <1> ;	- depends on function
  7485                              <1> ;	- for most functions:
  7486                              <1> ;		CF clear if successful
  7487                              <1> ;			AH = 00h - successful completion
  7488                              <1> ;		CF set on error
  7489                              <1> ;			AH = error code
  7490                              <1> ;-------------------------------------------------------------------------
  7491 00006BBB FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  7492          ******************  <1>  warning: (setloc:7) Inserting 158 bytes
  7493                              <1> int_13:
  7494 00006C59 FB                  <1> 	sti
  7495 00006C5A 50                  <1> 	push	ax
  7496 00006C5B 53                  <1> 	push	bx
  7497 00006C5C 51                  <1> 	push	cx
  7498 00006C5D 52                  <1> 	push	dx
  7499 00006C5E 56                  <1> 	push	si
  7500 00006C5F 57                  <1> 	push	di
  7501 00006C60 1E                  <1> 	push	ds
  7502 00006C61 55                  <1> 	push	bp
  7503 00006C62 89E5                <1> 	mov	bp,sp
  7504 00006C64 80FC19              <1> 	cmp	ah,.num_func
  7505 00006C67 7743                <1> 	ja	.invalid_function
  7506 00006C69 88E0                <1> 	mov	al,ah
  7507 00006C6B 98                  <1> 	cbw
  7508 00006C6C 89C7                <1> 	mov	di,ax
  7509 00006C6E D1E7                <1> 	shl	di,1
  7510 00006C70 B84000              <1> 	mov	ax,biosdseg
  7511 00006C73 8ED8                <1> 	mov	ds,ax
  7512 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  7513                              <1> 
  7514                              <1> .dispatch:
  7515 00006C7A [B70D]              <1> 	dw	int_13_fn00		; Reset disk system
  7516 00006C7C [260E]              <1> 	dw	int_13_fn01		; Get status of last operation
  7517 00006C7E [EF6C]              <1> 	dw	int_13_fn02		; Read disk sectors
  7518 00006C80 [EF6C]              <1> 	dw	int_13_fn03		; Write disk sectors
  7519 00006C82 [EF6C]              <1> 	dw	int_13_fn04		; Verify disk sectors
  7520 00006C84 [5D6E]              <1> 	dw	int_13_fn05		; Format track
  7521 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  7522 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  7523 00006C8A [320E]              <1> 	dw	int_13_fn08		; Get drive parameters
  7524 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  7525 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  7526 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  7527 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  7528 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  7529 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  7530 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  7531 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  7532 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  7533 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  7534 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  7535 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  7536 00006CA4 [DF0E]              <1> 	dw	int_13_fn15		; Get disk type
  7537 00006CA6 [000F]              <1> 	dw	int_13_fn16		; Detect disk change
  7538 00006CA8 [4C0F]              <1> 	dw	int_13_fn17		; Set disk type for format
  7539 00006CAA [B70F]              <1> 	dw	int_13_fn18		; Set media type for format
  7540                              <1> .num_func	equ ($-.dispatch)/2
  7541                              <1> 
  7542                              <1> .invalid_function:
  7543 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  7544 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  7545 00006CB2 F9                  <1> 	stc				; error condition
  7546 00006CB3 EB21                <1> 	jmp	int_13_exit
  7547                              <1> 
  7548                              <1> ;-------------------------------------------------------------------------
  7549                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  7550                              <1> 
  7551                              <1> int_13_upd_exit:
  7552 00006CB5 9C                  <1> 	pushf
  7553 00006CB6 50                  <1> 	push	ax
  7554 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  7555 00006CBA 3C01                <1> 	cmp	al,1
  7556 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  7557 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  7558 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  7559 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  7560 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  7561 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  7562 00006CCA 08C0                <1> 	or	al,al
  7563 00006CCC 7402                <1> 	jz	.drive_0
  7564 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  7565                              <1> 
  7566                              <1> .drive_0:
  7567 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  7568                              <1> 
  7569                              <1> .no_update:
  7570 00006CD4 58                  <1> 	pop	ax
  7571 00006CD5 9D                  <1> 	popf
  7572                              <1> 
  7573                              <1> int_13_exit:
  7574 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  7575 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  7576 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  7577 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  7578 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  7579                              <1> 
  7580                              <1> .set_error:
  7581 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  7582 00006CE6 5D                  <1> 	pop	bp
  7583 00006CE7 1F                  <1> 	pop	ds
  7584 00006CE8 5F                  <1> 	pop	di
  7585 00006CE9 5E                  <1> 	pop	si
  7586 00006CEA 5A                  <1> 	pop	dx
  7587 00006CEB 59                  <1> 	pop	cx
  7588 00006CEC 5B                  <1> 	pop	bx
  7589 00006CED 58                  <1> 	pop	ax
  7590 00006CEE CF                  <1> 	iret
  7591                              <1> 
  7592                              <1> ;=========================================================================
  7593                              <1> ; int_13_fn02 - Read disk sectors
  7594                              <1> ; int_13_fn03 - Write disk sectors
  7595                              <1> ; int_13_fn04 - Verify disk sectors
  7596                              <1> ; Input:
  7597                              <1> ;	AH = function
  7598                              <1> ;		02h - read
  7599                              <1> ;		03h - write
  7600                              <1> ;		04h - verify
  7601                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  7602                              <1> ;	CH = cylinder number
  7603                              <1> ;	CL = sector number
  7604                              <1> ;	DH = head number (0 or 1)
  7605                              <1> ;	DL = drive number (0 or 1)
  7606                              <1> ;	ES:BX -> data buffer
  7607                              <1> ; Output:
  7608                              <1> ;	CF clear if successful
  7609                              <1> ;		AH = 00h - successful completion
  7610                              <1> ;		AL = number of sectors transferred or verified
  7611                              <1> ;	CF set on error
  7612                              <1> ;		AH = error code
  7613                              <1> ;-------------------------------------------------------------------------
  7614                              <1> int_13_fn02:
  7615                              <1> int_13_fn03:
  7616                              <1> int_13_fn04:
  7617 00006CEF 80FA01              <1> 	cmp	dl,1
  7618 00006CF2 7603E94801          <1> 	ja	.invalid_drive
  7619 00006CF7 BE9000              <1> 	mov	si,fdc_media_state
  7620 00006CFA 52                  <1> 	push	dx
  7621 00006CFB B600                <1> 	mov	dh,00h
  7622 00006CFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  7623 00006CFF 5A                  <1> 	pop	dx
  7624                              <1> 
  7625 00006D00 E804A7              <1> 	call	read_cmos_type		; get drive type in AL
  7626 00006D03 7303E93701          <1> 	jc	.invalid_drive
  7627                              <1> 
  7628 00006D08 BF3F00              <1> 	mov	di,fdc_motor_state
  7629 00006D0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  7630 00006D0E 80FC03              <1> 	cmp	ah,03h			; write function
  7631 00006D11 7503                <1> 	jne	.motor_on		; jump if not write function
  7632 00006D13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  7633                              <1> 
  7634                              <1> .motor_on:
  7635 00006D16 E85FA4              <1> 	call	fdc_motor_on
  7636 00006D19 3C01                <1> 	cmp	al,cmos_360
  7637 00006D1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  7638 00006D20 3C03                <1> 	cmp	al,cmos_720
  7639 00006D22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  7640                              <1> 
  7641 00006D27 E808A5              <1> 	call	fdc_disk_change
  7642 00006D2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  7643                              <1> 
  7644 00006D2F F60410              <1> 	test	byte [si],fdc_m_established
  7645 00006D32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  7646                              <1> 
  7647 00006D37 E8BDA7              <1> 	call	fdc_select_rate		; select transfer rate
  7648                              <1> 	
  7649                              <1> .fdc_send_specify:
  7650 00006D3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  7651                              <1> 					; 0BFh - specify byte 0 for 1.44M
  7652 00006D3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  7653 00006D40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  7654 00006D42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  7655 00006D44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  7656 00006D47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  7657 00006D49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  7658                              <1> 
  7659                              <1> .fdc_send_specify_cmd:
  7660 00006D4B BE0200              <1> 	mov	si,2			; specify byte 1
  7661 00006D4E B103                <1> 	mov	cl,3			; 3 bytes command
  7662 00006D50 E885A5              <1> 	call	fdc_send_cmd
  7663 00006D53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  7664 00006D58 1E                  <1> 	push	ds
  7665 00006D59 31F6                <1> 	xor	si,si
  7666 00006D5B 8EDE                <1> 	mov	ds,si
  7667 00006D5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  7668 00006D61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  7669 00006D64 B400                <1> 	mov	ah,00h
  7670 00006D66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  7671 00006D68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  7672 00006D6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  7673 00006D6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  7674 00006D70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  7675 00006D72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  7676                              <1> 
  7677                              <1> .calc_dma_count:
  7678 00006D75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  7679 00006D78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  7680 00006D7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  7681 00006D7D 1F                  <1> 	pop	ds
  7682 00006D7E 48                  <1> 	dec	ax			; minus one byte
  7683 00006D7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  7684                              <1> 
  7685 00006D81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  7686 00006D84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  7687 00006D86 80FC02              <1> 	cmp	ah,02h			; read function?
  7688 00006D89 7409                <1> 	je	.configure_dma		; jump if read function
  7689 00006D8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  7690 00006D8D 80FC03              <1> 	cmp	ah,03h			; write function?
  7691 00006D90 7402                <1> 	je	.configure_dma		; jump if write function
  7692 00006D92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  7693                              <1> 
  7694                              <1> .configure_dma:
  7695 00006D94 E8E3A4              <1> 	call	fdc_configure_dma
  7696 00006D97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  7697 00006D9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  7698                              <1> 
  7699 00006D9F E81FA3              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  7700 00006DA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  7701                              <1> 
  7702 00006DA7 1E                  <1> 	push	ds
  7703 00006DA8 31C0                <1> 	xor	ax,ax
  7704 00006DAA 8ED8                <1> 	mov	ds,ax
  7705 00006DAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  7706 00006DB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  7707 00006DB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  7708 00006DB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  7709 00006DB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  7710 00006DBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  7711 00006DBD 1F                  <1> 	pop	ds
  7712                              <1> 
  7713 00006DBE BE9000              <1> 	mov	si,fdc_media_state
  7714 00006DC1 B600                <1> 	mov	dh,00h
  7715 00006DC3 01D6                <1> 	add	si,dx
  7716 00006DC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  7717 00006DC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  7718 00006DC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  7719 00006DCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  7720 00006DCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  7721 00006DD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  7722 00006DD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  7723 00006DD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  7724 00006DD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  7725 00006DDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  7726 00006DDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  7727 00006DDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  7728                              <1> 	
  7729                              <1> .gap_set:
  7730 00006DE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  7731 00006DE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  7732 00006DE7 88F4                <1> 	mov	ah,dh			; head
  7733 00006DE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  7734 00006DEB D0E4                <1> 	shl	ah,1
  7735 00006DED D0E4                <1> 	shl	ah,1
  7736 00006DEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  7737 00006DF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  7738 00006DF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  7739 00006DF7 7502                <1> 	jne	.send_command		; jump if not write 
  7740 00006DF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  7741                              <1> 
  7742                              <1> .send_command:
  7743 00006DFB B109                <1> 	mov	cl,9			; 9 bytes command
  7744 00006DFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  7745 00006E02 E8D3A4              <1> 	call	fdc_send_cmd
  7746 00006E05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  7747 00006E07 E81FA7              <1> 	call	fdc_wait_irq
  7748 00006E0A 7228                <1> 	jc	.error_fdc_get_result
  7749 00006E0C B107                <1> 	mov	cl,7
  7750 00006E0E E82CA5              <1> 	call	fdc_get_result		; read result bytes
  7751 00006E11 7228                <1> 	jc	.error_end_io
  7752                              <1> 
  7753 00006E13 E87CA5              <1> 	call	fdc_get_error
  7754                              <1> 
  7755                              <1> .exit_end_io:
  7756 00006E16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  7757                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  7758 00006E19 E8EBA3              <1> 	call	fdc_end_io		; return number of last sector in BL
  7759 00006E1C 08C0                <1> 	or	al,al
  7760 00006E1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  7761 00006E20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  7762 00006E22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  7763                              <1> 
  7764                              <1> .zero_sectors:
  7765 00006E25 08E4                <1> 	or	ah,ah
  7766 00006E27 7401                <1> 	jz	.exit			; jump if no errors
  7767                              <1> 
  7768                              <1> .error:
  7769 00006E29 F9                  <1> 	stc				; indicate error
  7770                              <1> 
  7771                              <1> .exit:
  7772 00006E2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  7773 00006E2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  7774 00006E31 E981FE              <1> 	jmp	int_13_upd_exit
  7775                              <1> 
  7776                              <1> .error_fdc_get_result:
  7777 00006E34 B107                <1> 	mov	cl,7
  7778 00006E36 50                  <1> 	push	ax
  7779 00006E37 E803A5              <1> 	call	fdc_get_result		; read result bytes
  7780 00006E3A 58                  <1> 	pop	ax
  7781                              <1> 
  7782                              <1> .error_end_io:
  7783 00006E3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  7784 00006E3D EBD7                <1> 	jmp	.exit_end_io
  7785                              <1> 
  7786                              <1> .invalid_drive:
  7787 00006E3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  7788 00006E42 EBE5                <1> 	jmp	.error
  7789                              <1> 
  7790                              <1> ; 360K and 720K drives don't support change line, and only support
  7791                              <1> ; one media type - set it here
  7792                              <1> 
  7793                              <1> .set_media_360:
  7794 00006E44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  7795 00006E46 EB02                <1> 	jmp	.set_media
  7796                              <1> 
  7797                              <1> .set_media_720:
  7798 00006E48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  7799                              <1> 
  7800                              <1> .set_media:
  7801 00006E4A 8804                <1> 	mov	byte [si],al		; save media state
  7802 00006E4C E8CFA6              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  7803 00006E4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  7804 00006E52 E9E5FE              <1> 	jmp	.fdc_send_specify
  7805                              <1> 
  7806                              <1> ; establish media type
  7807                              <1> 
  7808                              <1> .establish_media:
  7809 00006E55 E8D2A5              <1> 	call	fdc_detect_media
  7810 00006E58 72E1                <1> 	jc	.error_end_io
  7811 00006E5A E9DDFE              <1> 	jmp	.fdc_send_specify
  7812                              <1> 	
  7813                              <1> 
  7814                              <1> ;=========================================================================
  7815                              <1> ; int_13_fn05 - Format track
  7816                              <1> ; Input:
  7817                              <1> ;	AH = 05h
  7818                              <1> ;	CH = track number
  7819                              <1> ;	DH = head number (0 or 1)
  7820                              <1> ;	DL = drive number (0 or 1)
  7821                              <1> ;	ES:BX -> address field buffer
  7822                              <1> ; Output:
  7823                              <1> ;	CF clear if successful
  7824                              <1> ;		AH = 00h - successful completion
  7825                              <1> ;	CF set on error
  7826                              <1> ;		AH = error code 
  7827                              <1> ;-------------------------------------------------------------------------
  7828                              <1> int_13_fn05:
  7829 00006E5D 80FA01              <1> 	cmp	dl,1
  7830 00006E60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  7831 00006E65 E89FA5              <1> 	call	read_cmos_type		; get drive type in AL
  7832 00006E68 7303E99500          <1> 	jc	.invalid_drive
  7833 00006E6D BE9000              <1> 	mov	si,fdc_media_state
  7834 00006E70 52                  <1> 	push	dx
  7835 00006E71 B600                <1> 	mov	dh,00h
  7836 00006E73 01D6                <1> 	add	si,dx			; SI -> drive media state
  7837 00006E75 5A                  <1> 	pop	dx
  7838 00006E76 803C00              <1> 	cmp	byte [si],0
  7839 00006E79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  7840 00006E7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  7841 00006E83 E8F2A2              <1> 	call	fdc_motor_on
  7842 00006E86 E8A9A3              <1> 	call	fdc_disk_change		; read disk change line
  7843 00006E89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  7844 00006E8B E869A6              <1> 	call	fdc_select_rate		; select transfer rate
  7845 00006E8E E8769F              <1> 	call	fdc_send_specify	; send FDC Specify command
  7846 00006E91 1E                  <1> 	push	ds
  7847 00006E92 31F6                <1> 	xor	si,si
  7848 00006E94 8EDE                <1> 	mov	ds,si
  7849 00006E96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  7850 00006E9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  7851 00006E9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  7852 00006EA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  7853 00006EA3 1F                  <1> 	pop	ds
  7854 00006EA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  7855 00006EA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  7856 00006EA8 D1E1                <1> 	shl	cx,1
  7857 00006EAA 49                  <1> 	dec	cx	 		; minus one byte...
  7858 00006EAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  7859 00006EAD E8CAA3              <1> 	call	fdc_configure_dma
  7860 00006EB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  7861 00006EB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  7862 00006EB5 56                  <1> 	push	si
  7863 00006EB6 E808A2              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  7864 00006EB9 5E                  <1> 	pop	si
  7865 00006EBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  7866                              <1> 
  7867 00006EBC 88F4                <1> 	mov	ah,dh
  7868 00006EBE D0E4                <1> 	shl	ah,1
  7869 00006EC0 D0E4                <1> 	shl	ah,1
  7870 00006EC2 08D4                <1> 	or	ah,dl
  7871 00006EC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  7872                              <1> 
  7873 00006EC6 B106                <1> 	mov	cl,6			; 6 byte command
  7874 00006EC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  7875 00006ECD E808A4              <1> 	call	fdc_send_cmd
  7876 00006ED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  7877 00006ED2 E854A6              <1> 	call	fdc_wait_irq
  7878 00006ED5 720A                <1> 	jc	.exit_end_io
  7879 00006ED7 B107                <1> 	mov	cl,7
  7880 00006ED9 E861A4              <1> 	call	fdc_get_result		; read result bytes
  7881 00006EDC 7203                <1> 	jc	.exit_end_io
  7882 00006EDE E8B1A4              <1> 	call	fdc_get_error		; get error code
  7883                              <1> 
  7884                              <1> .exit_end_io:
  7885 00006EE1 E823A3              <1> 	call	fdc_end_io
  7886 00006EE4 08E4                <1> 	or	ah,ah
  7887 00006EE6 7401                <1> 	jz	.exit			; jump if no errors
  7888                              <1> 
  7889                              <1> .error:
  7890 00006EE8 F9                  <1> 	stc				; indicate error
  7891                              <1> 
  7892                              <1> .exit:
  7893 00006EE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  7894 00006EED E9C5FD              <1> 	jmp	int_13_upd_exit
  7895                              <1> 
  7896                              <1> .error_fdc_get_result:
  7897 00006EF0 B107                <1> 	mov	cl,7
  7898 00006EF2 50                  <1> 	push	ax
  7899 00006EF3 E847A4              <1> 	call	fdc_get_result		; read result bytes
  7900 00006EF6 58                  <1> 	pop	ax
  7901 00006EF7 EBE8                <1> 	jmp	.exit_end_io
  7902                              <1> 
  7903                              <1> .error_end_io:
  7904 00006EF9 E80BA3              <1> 	call	fdc_end_io
  7905 00006EFC EBEA                <1> 	jmp	.error
  7906                              <1> 
  7907                              <1> .timeout:
  7908 00006EFE B480                <1> 	mov	ah,fdc_e_timeout
  7909 00006F00 EBE6                <1> 	jmp	.error
  7910                              <1> 
  7911                              <1> .invalid_drive:
  7912 00006F02 B401                <1> 	mov	ah,fdc_e_invalid
  7913 00006F04 EBE2                <1> 	jmp	.error
  7914                              <1> 
  7915                              <1> ;=========================================================================
  7916                              <1> ; int_0E - IRQ6 (FDC) service routine
  7917                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  7918                              <1> ;-------------------------------------------------------------------------
  7919 00006F06 FF<rept>            <1> 	setloc	0EF57h
  7920          ******************  <1>  warning: (setloc:7) Inserting 81 bytes
  7921                              <1> 
  7922                              <1> int_0E:
  7923 00006F57 50                  <1> 	push	ax
  7924 00006F58 1E                  <1> 	push	ds
  7925 00006F59 B84000              <1> 	mov	ax,biosdseg
  7926 00006F5C 8ED8                <1> 	mov	ds,ax
  7927 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  7928 00006F63 1F                  <1> 	pop	ds
  7929 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  7930 00006F66 E620                <1> 	out	pic1_reg0,al
  7931 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  7932 00006F6B CD15                <1> 	int	15h
  7933 00006F6D 58                  <1> 	pop	ax
  7934 00006F6E CF                  <1> 	iret
  7935                              <1> 
  7936                              <1> ;=========================================================================
  7937                              <1> ; Disk parameter tables in INT 1Eh format
  7938                              <1> ; Byte 0: First byte for specify command:
  7939                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  7940                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  7941                              <1> ; Byte 1: Second byte for specify command:
  7942                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  7943                              <1> ;	bit 0: non-DMA mode (always 0)
  7944                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  7945                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  7946                              <1> ; Byte 4: sectors per track
  7947                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  7948                              <1> ; Byte 6: special sector size (0FFh - not used)
  7949                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  7950                              <1> ; Byte 8: format filler byte (default 0F6h)
  7951                              <1> ; Byte 9: head settle time in milliseconds
  7952                              <1> ; Byte A: motor start time, in 1/8 seconds
  7953                              <1> ; Byte B: number of cylinders minus one
  7954                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  7955                              <1> ;-------------------------------------------------------------------------
  7956                              <1> media_360_in_360:
  7957 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  7958 00006F78 0F08                <1>
  7959 00006F7A 2780                <1> 	db	27h, 80h
  7960                              <1> media_1200:
  7961 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  7962 00006F85 0F08                <1>
  7963 00006F87 4F00                <1> 	db	4Fh, 00h
  7964                              <1> media_720:
  7965 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  7966 00006F92 0F08                <1>
  7967 00006F94 4F80                <1> 	db	4Fh, 80h
  7968                              <1> media_1440:
  7969 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  7970 00006F9F 0F08                <1>
  7971 00006FA1 4F00                <1> 	db	4Fh, 00h
  7972                              <1> media_360_in_1200:
  7973 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  7974 00006FAC 0F08                <1>
  7975 00006FAE 2740                <1> 	db	27h, 40h
  7976                              <1> media_2880:
  7977 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  7978 00006FB9 0F08                <1>
  7979 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  7980                              <1> 
  7981                              <1> ;=========================================================================
  7982                              <1> ; Disk parameter table for IBM compatibility
  7983                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  7984                              <1> ;-------------------------------------------------------------------------
  7985 00006FBD FF<rept>            <1> 	setloc	0EFC7h
  7986          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  7987                              <1> int_1E:
  7988 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  7989 00006FD0 0F08                <1>
  7990                                  %include	"printer2.inc"		; INT 17
  7991                              <1> ;=========================================================================
  7992                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  7993                              <1> ;       INT 17h, function AH=00h
  7994                              <1> ;	INT 17h, function AH=02h
  7995                              <1> ;	- see printer1.inc for other INT 17h functions
  7996                              <1> ;-------------------------------------------------------------------------
  7997                              <1> ;
  7998                              <1> ; Compiles with NASM 2.07, might work with other versions
  7999                              <1> ;
  8000                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8001                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8002                              <1> ;
  8003                              <1> ; This program is free software: you can redistribute it and/or modify
  8004                              <1> ; it under the terms of the GNU General Public License as published by
  8005                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8006                              <1> ; (at your option) any later version.
  8007                              <1> ;
  8008                              <1> ; This program is distributed in the hope that it will be useful,
  8009                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8010                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8011                              <1> ; GNU General Public License for more details.
  8012                              <1> ;
  8013                              <1> ; You should have received a copy of the GNU General Public License
  8014                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8015                              <1> ;
  8016                              <1> ;=========================================================================
  8017                              <1> 
  8018                              <1> ;=========================================================================
  8019                              <1> ; int_17  - BIOS Printer Services
  8020                              <1> ;-------------------------------------------------------------------------
  8021                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  8022                              <1> int_17:
  8023 00006FD2 FB                  <1> 	sti
  8024 00006FD3 53                  <1> 	push	bx
  8025 00006FD4 52                  <1> 	push	dx
  8026 00006FD5 56                  <1> 	push	si
  8027 00006FD6 1E                  <1> 	push	ds
  8028 00006FD7 BB4000              <1> 	mov	bx,biosdseg
  8029 00006FDA 8EDB                <1> 	mov	ds,bx
  8030 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
  8031 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  8032 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  8033 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  8034 00006FE6 89D3                <1> 	mov	bx,dx
  8035 00006FE8 D1E3                <1> 	shl	bx,1
  8036 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  8037 00006FED 09D2                <1> 	or	dx,dx
  8038 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  8039                              <1> 
  8040 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  8041                              <1> 
  8042 00006FF3 08E4                <1> 	or	ah,ah
  8043 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  8044 00006FF7 FECC                <1> 	dec	ah
  8045 00006FF9 7503E917AD          <1> 	jz	int_17_fn01		; AH = 01h
  8046 00006FFE FECC                <1> 	dec	ah
  8047 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  8048                              <1> 
  8049                              <1> int_17_exit:
  8050 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  8051 00007005 88D8                <1> 	mov	al,bl			; restore AL
  8052                              <1> 
  8053                              <1> int_17_error:
  8054 00007007 1F                  <1> 	pop	ds
  8055 00007008 5E                  <1> 	pop	si
  8056 00007009 5A                  <1> 	pop	dx
  8057 0000700A 5B                  <1> 	pop	bx
  8058 0000700B CF                  <1> 	iret
  8059                              <1> 
  8060                              <1> ;=========================================================================
  8061                              <1> ; int_17_fn00 - Print character
  8062                              <1> ; Input:
  8063                              <1> ;	AH = 0 - function 00h - print character
  8064                              <1> ;	AL = character to print
  8065                              <1> ;	DX = printer port number (0-2)
  8066                              <1> ; Output:
  8067                              <1> ;	AH = printer status:
  8068                              <1> ;		bit 0	= 1	- timeout error
  8069                              <1> ;		bit 1,2		- reserved
  8070                              <1> ;		bit 3	= 1	- I/O error
  8071                              <1> ;		bit 4	= 1	- printed selected
  8072                              <1> ;		bit 5	= 1	- out of paper
  8073                              <1> ;		bit 6	= 1	- acknowledge from printer
  8074                              <1> ;		bit 7	= 1	- printer not busy
  8075                              <1> ;-------------------------------------------------------------------------
  8076                              <1> int_17_fn00:
  8077 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  8078 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8079                              <1> 					; OPTIMIZATION:
  8080                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8081 0000700E EC                  <1> 	in	al,dx			; read status
  8082 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  8083 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  8084 00007014 750C                <1>         jnz     .not_busy
  8085                              <1> 
  8086 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  8087 00007019 CD15                <1> 	int	15h			; call OS hook
  8088                              <1> 
  8089 0000701B B780                <1> 	mov	bh,prn_stat_busy
  8090 0000701D E834AC              <1> 	call	wait_for_port		; wait for printer to be ready
  8091 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  8092                              <1> 
  8093                              <1> .not_busy:
  8094 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  8095                              <1> 					; OPTIMIZATION:
  8096                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  8097 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  8098 00007025 EE                  <1> 	out	dx,al			; activate strobe
  8099 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  8100 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  8101 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  8102 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  8103 0000702E EBD2                <1> 	jmp	int_17_exit
  8104                              <1> 
  8105                              <1> .timeout:
  8106 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  8107 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  8108 00007036 EBCA                <1> 	jmp	int_17_exit
  8109                              <1> 
  8110                              <1> ;=========================================================================
  8111                              <1> ; int_17_fn02 - Return printer status
  8112                              <1> ; Input:
  8113                              <1> ;	AH = 2 - function 02h - return printer status
  8114                              <1> ;	DX = printer port number (0-2)
  8115                              <1> ; Output:
  8116                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  8117                              <1> ;-------------------------------------------------------------------------
  8118                              <1> int_17_fn02:
  8119 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8120                              <1> 					; OPTIMIZATION:
  8121                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8122                              <1> int_17_status:
  8123 00007039 EC                  <1> 	in	al,dx			; read the status
  8124 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  8125 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  8126 0000703F EBC1                <1> 	jmp	int_17_exit
  8127                                  %include	"video.inc"		; INT 10
  8128                              <1> ;=========================================================================
  8129                              <1> ; video.inc - BIOS video services
  8130                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  8131                              <1> ;-------------------------------------------------------------------------
  8132                              <1> ;
  8133                              <1> ; Compiles with NASM 2.07, might work with other versions
  8134                              <1> ;
  8135                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  8136                              <1> ;
  8137                              <1> ; This program is free software: you can redistribute it and/or modify
  8138                              <1> ; it under the terms of the GNU General Public License as published by
  8139                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8140                              <1> ; (at your option) any later version.
  8141                              <1> ;
  8142                              <1> ; This program is distributed in the hope that it will be useful,
  8143                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8144                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8145                              <1> ; GNU General Public License for more details.
  8146                              <1> ;
  8147                              <1> ; You should have received a copy of the GNU General Public License
  8148                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8149                              <1> ;
  8150                              <1> ;=========================================================================
  8151                              <1> 
  8152                              <1> ;-------------------------------------------------------------------------
  8153                              <1> ; CRTC registers
  8154                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  8155                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  8156                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  8157                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  8158                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  8159                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  8160                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  8161                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  8162                              <1> 
  8163                              <1> ;-------------------------------------------------------------------------
  8164                              <1> ; control characters
  8165                              <1> bel	equ	07h
  8166                              <1> bs	equ	08h
  8167                              <1> lf	equ	0Ah
  8168                              <1> cr	equ	0Dh
  8169                              <1> 
  8170 00007041 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  8171          ******************  <1>  warning: (setloc:7) Inserting 4 bytes
  8172                              <1> 
  8173                              <1> int_10_dispatch:
  8174 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
  8175 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  8176 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
  8177 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  8178 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
  8179 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
  8180 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
  8181 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
  8182 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
  8183 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
  8184 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
  8185 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
  8186 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  8187 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  8188 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
  8189 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
  8190                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  8191                              <1> 
  8192                              <1> 
  8193                              <1> ;-------------------------------------------------------------------------
  8194                              <1> ; offsets for registers on stack
  8195                              <1> 
  8196                              <1> int_10_ax	equ	0
  8197                              <1> int_10_al	equ	int_10_ax
  8198                              <1> int_10_ah	equ	int_10_ax+1
  8199                              <1> int_10_bx	equ	int_10_ax+2
  8200                              <1> int_10_bl	equ	int_10_bx
  8201                              <1> int_10_bh	equ	int_10_bx+1
  8202                              <1> int_10_cx	equ	int_10_bx+2
  8203                              <1> int_10_ch	equ	int_10_cx+1
  8204                              <1> int_10_dx	equ	int_10_cx+2
  8205                              <1> 
  8206                              <1> ;=========================================================================
  8207                              <1> ; int_10 - BIOS video services
  8208                              <1> ; Input:
  8209                              <1> ;	AH - Function
  8210                              <1> ;		00h - Set video mode
  8211                              <1> ;		01h - Set text mode cursor shape
  8212                              <1> ;		02h - Set cursor position
  8213                              <1> ;		03h - Get cursor position and shape
  8214                              <1> ;		04h - Read light pen position
  8215                              <1> ;		05h - Select active display page
  8216                              <1> ;		06h - Scroll up window
  8217                              <1> ;		07h - Scroll down window
  8218                              <1> ;		08h - Read character and attribute at cursor position
  8219                              <1> ;		09h - Write character and attribute at cursor position
  8220                              <1> ;		0Ah - Write character only at cursor position
  8221                              <1> ;		0Bh -
  8222                              <1> ;			BH = 00h - Set background/border color
  8223                              <1> ;			BH = 01h - Set palette
  8224                              <1> ;		0Ch - Write graphics pixel
  8225                              <1> ;		0Dh - Read graphics pixel
  8226                              <1> ;		0Eh - Teletype output
  8227                              <1> ;		0Fh - Get current video mode
  8228                              <1> ;-------------------------------------------------------------------------
  8229                              <1> 	setloc	0F065h			; int 10 Entry Point
  8230                              <1> int_10:
  8231 00007065 FB                  <1> 	sti
  8232 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  8233 00007067 55                  <1> 	push	bp
  8234 00007068 06                  <1> 	push	es
  8235 00007069 1E                  <1> 	push	ds
  8236 0000706A 56                  <1> 	push	si
  8237 0000706B 57                  <1> 	push	di
  8238 0000706C 52                  <1> 	push	dx
  8239 0000706D 51                  <1> 	push	cx
  8240 0000706E 53                  <1> 	push	bx
  8241 0000706F 50                  <1> 	push	ax
  8242 00007070 BB4000              <1> 	mov	bx,biosdseg
  8243 00007073 8EDB                <1> 	mov	ds,bx
  8244 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  8245 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  8246 0000707C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  8247 0000707F 7202                <1> 	jb	.color			; it is CGA
  8248 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  8249                              <1> 
  8250                              <1> .color:
  8251 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  8252 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  8253 00007087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  8254 0000708A 730B                <1> 	jae	.exit			; invalid function
  8255 0000708C B700                <1> 	mov	bh,0
  8256 0000708E 88E3                <1> 	mov	bl,ah
  8257 00007090 D1E3                <1> 	shl	bx,1
  8258 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  8259                              <1> 
  8260                              <1> .exit:
  8261 00007097 58                  <1> 	pop	ax
  8262 00007098 5B                  <1> 	pop	bx
  8263 00007099 59                  <1> 	pop	cx
  8264 0000709A 5A                  <1> 	pop	dx
  8265 0000709B 5F                  <1> 	pop	di
  8266 0000709C 5E                  <1> 	pop	si
  8267 0000709D 1F                  <1> 	pop	ds
  8268 0000709E 07                  <1> 	pop	es
  8269 0000709F 5D                  <1> 	pop	bp
  8270 000070A0 CF                  <1> 	iret
  8271                              <1> 
  8272                              <1> 
  8273                              <1> ;=========================================================================
  8274                              <1> ; int_1D - Video parameters tables
  8275                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  8276                              <1> ; video mode initialization
  8277                              <1> ;-------------------------------------------------------------------------
  8278 000070A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  8279          ******************  <1>  warning: (setloc:7) Inserting 3 bytes
  8280                              <1> int_1D:
  8281                              <1> 	; CGA test 40x25 modes
  8282 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  8283 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8284                              <1> 
  8285                              <1> 	; CGA text 80x25 modes
  8286 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  8287 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8288                              <1> 
  8289                              <1> 	; CGA graphics modes
  8290 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  8291 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  8292                              <1> 
  8293                              <1> 	; MDA text 80x25 mode
  8294 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  8295 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  8296                              <1> 
  8297                              <1> page_size:
  8298 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  8299 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  8300 000070E8 0040                <1> 	dw	4000h			; graphics modes
  8301 000070EA 0040                <1> 	dw	4000h
  8302                              <1> 
  8303                              <1> columns:
  8304 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  8305 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  8306 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  8307 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  8308                              <1> 
  8309 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  8310                              <1> 
  8311 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  8312                              <1> 
  8313                              <1> ;=========================================================================
  8314                              <1> ; int_10_fn00 - Set video mode
  8315                              <1> ; Input:
  8316                              <1> ;	AH = 00h
  8317                              <1> ;	AL = video mode
  8318                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  8319                              <1> ;		01h - CGA - text 40x25, 16 colors
  8320                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  8321                              <1> ;		03h - CGA - text 80x25, 16 colors
  8322                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  8323                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  8324                              <1> ;		06h - CGA - graphics 640x200, monochrome
  8325                              <1> ;		07h - MDA - text 80x25, monochrome
  8326                              <1> ;-------------------------------------------------------------------------
  8327                              <1> int_10_fn00:
  8328 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  8329 00007107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  8330 0000710A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  8331 0000710D B000                <1> 	mov	al,0
  8332 0000710F 80FB07              <1> 	cmp	bl,07h
  8333 00007112 7206                <1> 	jb	.color			; jump if monochrome mode
  8334 00007114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  8335 00007116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  8336 00007118 FEC0                <1> 	inc	al
  8337                              <1> 
  8338                              <1> .color:
  8339 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  8340 0000711C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  8341 00007120 80C204              <1> 	add	dl,4
  8342 00007123 EE                  <1> 	out	dx,al			; Reset the video
  8343 00007124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  8344 00007128 B700                <1> 	mov	bh,0
  8345 0000712A 53                  <1> 	push	bx
  8346 0000712B 06                  <1> 	push	es
  8347 0000712C 31C0                <1> 	xor	ax,ax
  8348 0000712E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  8349 00007130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  8350 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  8351 0000713A 01DE                <1> 	add	si,bx
  8352                              <1> 
  8353 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  8354 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  8355 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  8356                              <1> 
  8357 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  8358                              <1> 
  8359                              <1> .setup_crt_loop:
  8360 00007149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  8361 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  8362 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  8363 00007151 46                  <1> 	inc	si			;  ...point to next
  8364 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  8365 00007154 07                  <1> 	pop	es
  8366 00007155 31FF                <1> 	xor	di,di
  8367 00007157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  8368 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  8369 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  8370 0000715F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  8371 00007161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  8372 00007163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  8373                              <1> 
  8374                              <1> .text_fill:
  8375 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  8376                              <1> 
  8377                              <1> .clear_screen:
  8378 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  8379                              <1> 
  8380 0000716B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  8381 0000716F 80C204              <1> 	add	dl,4
  8382 00007172 5B                  <1> 	pop	bx
  8383 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  8384 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  8385 00007179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  8386 0000717C 42                  <1> 	inc	dx
  8387 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  8388 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  8389 00007182 7502                <1> 	jnz	.set_palette
  8390 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  8391                              <1> 
  8392                              <1> .set_palette:
  8393 00007186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  8394 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  8395                              <1> 
  8396 0000718A 8CD8                <1> 	mov	ax,ds
  8397 0000718C 8EC0                <1> 	mov	es,ax
  8398 0000718E 31C0                <1> 	xor	ax,ax
  8399 00007190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  8400 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  8401 00007196 BF4E00              <1> 	mov	di,video_page_offt
  8402 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  8403                              <1> 
  8404 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  8405 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  8406 000071A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  8407                              <1> 					; but it means that for mode 7
  8408                              <1> 					; we'll get graphics page size?!
  8409 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  8410 000071AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  8411 000071AE C3                  <1> 	ret
  8412                              <1> 
  8413                              <1> ;=========================================================================
  8414                              <1> ; int_10_fn01 - Set text-mode cursor shape
  8415                              <1> ; Input:
  8416                              <1> ;	AH = 01h
  8417                              <1> ;	CH = cursor scan line start
  8418                              <1> ;	CL = cursor scan line end
  8419                              <1> ; Output:
  8420                              <1> ;	none
  8421                              <1> ;-------------------------------------------------------------------------
  8422                              <1> int_10_fn01:
  8423 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  8424 000071B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  8425 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  8426 000071B8 C3                  <1> 	ret
  8427                              <1> 
  8428                              <1> ;=========================================================================
  8429                              <1> ; int_10_fn02 - Set cursor position
  8430                              <1> ; Input:
  8431                              <1> ;	AH = 02h
  8432                              <1> ;	BH = page number
  8433                              <1> ;	DH = cursor row (00h is top)
  8434                              <1> ;	DL = cursor column (00h is left)
  8435                              <1> ; Output:
  8436                              <1> ;	none
  8437                              <1> ;-------------------------------------------------------------------------
  8438                              <1> int_10_fn02:
  8439 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8440 000071BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  8441 000071C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  8442                              <1> 
  8443                              <1> ;=========================================================================
  8444                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  8445                              <1> ;	BL = page
  8446                              <1> ;	DH = cursor row (00h is top)
  8447                              <1> ;	DL = cursor column (00h is left)
  8448                              <1> ;-------------------------------------------------------------------------
  8449                              <1> set_cur_pos:
  8450 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  8451 000071C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  8452 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  8453 000071CB D1E8                <1> 	shr	ax,1
  8454 000071CD 89C1                <1> 	mov	cx,ax
  8455 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  8456 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  8457                              <1> bios_set_cur_pos:
  8458 000071D4 B700                <1> 	mov	bh,0
  8459 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  8460 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  8461 000071DB C3                  <1> 	ret
  8462                              <1> 
  8463                              <1> ;=========================================================================
  8464                              <1> ; int_10_fn03 - Get cursor position and shape
  8465                              <1> ; Input:
  8466                              <1> ;	AH = 03h
  8467                              <1> ;	BH = page number
  8468                              <1> ; Output:
  8469                              <1> ;	CH = cursor start scan line
  8470                              <1> ;	CL = cursor end scan line
  8471                              <1> ;	DH = cursor row (00h is top)
  8472                              <1> ;	DL = cursor column (00h is left)
  8473                              <1> ;-------------------------------------------------------------------------
  8474                              <1> int_10_fn03:
  8475 000071DC B700                <1> 	mov	bh,0
  8476 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8477 000071E1 D0E3                <1> 	shl	bl,1
  8478 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  8479 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  8480 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  8481 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  8482 000071EF C3                  <1> 	ret
  8483                              <1> 
  8484                              <1> ;=========================================================================
  8485                              <1> ; int_10_fn04 - Read light pen position
  8486                              <1> ; Input:
  8487                              <1> ;	AH = 04h
  8488                              <1> ; Output:
  8489                              <1> ;	AH - light pen trigger flag
  8490                              <1> ;		00h not down/triggered
  8491                              <1> ;		01h down/triggered
  8492                              <1> ;	If light pen is triggered:
  8493                              <1> ;		DH = character row
  8494                              <1> ;		DL = character column
  8495                              <1> ;		CH = pixel row
  8496                              <1> ;		BX = pixel column
  8497                              <1> ;-------------------------------------------------------------------------
  8498                              <1> int_10_fn04:
  8499 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  8500 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  8501 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  8502 000071FB EC                  <1> 	in	al,dx			; read it
  8503 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  8504 000071FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  8505 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  8506 00007202 7501                <1> 	jnz	.read_pen		; continue if triggered
  8507 00007204 C3                  <1> 	ret				; not triggered - return
  8508                              <1> 
  8509                              <1> .read_pen:
  8510 00007205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  8511 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  8512 0000720B EE                  <1> 	out	dx,al			; select it
  8513 0000720C 42                  <1> 	inc	dx			; CRTC data register
  8514 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  8515 0000720E 88C4                <1> 	mov	ah,al
  8516 00007210 4A                  <1> 	dec	dx			; CRTC index register
  8517 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  8518 00007213 EE                  <1> 	out	dx,al			; select it
  8519 00007214 42                  <1> 	inc	dx			; CRTC data register
  8520 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  8521                              <1> 
  8522 00007216 B700                <1> 	mov	bh,0
  8523 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  8524 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  8525 00007221 29D8                <1> 	sub	ax,bx
  8526 00007223 7902                <1> 	jns	.1
  8527 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  8528                              <1> 
  8529                              <1> .1:
  8530 00007227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  8531 0000722A 7325                <1> 	jnb	.text			; calculate character position if text
  8532 0000722C B228                <1> 	mov	dl,40			; divide by 40
  8533 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  8534 00007230 B700                <1> 	mov	bh,0
  8535 00007232 88E3                <1> 	mov	bl,ah
  8536 00007234 B103                <1> 	mov	cl,3
  8537 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  8538 00007238 88C5                <1> 	mov	ch,al
  8539 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  8540 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  8541 0000723E 88C6                <1> 	mov	dh,al
  8542 00007240 D0EE                <1> 	shr	dh,1
  8543 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  8544 00007244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  8545 00007249 751A                <1> 	jnz	.exit
  8546 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  8547 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  8548 0000724F EB14                <1> 	jmp	.exit
  8549                              <1> 
  8550                              <1> .text:
  8551 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  8552 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  8553 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  8554 00007259 B103                <1> 	mov	cl,3
  8555 0000725B D2E4                <1> 	shl	ah,cl
  8556 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  8557 0000725F B700                <1> 	mov	bh,0
  8558 00007261 88C3                <1> 	mov	bl,al
  8559 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  8560                              <1> 
  8561                              <1> .exit:
  8562 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  8563 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  8564 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  8565 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  8566                              <1> 
  8567                              <1> .reset_pen:
  8568 00007272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  8569 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  8570 00007279 EE                  <1> 	out	dx,al			; reset it
  8571 0000727A C3                  <1> 	ret
  8572                              <1> 
  8573                              <1> .correction:
  8574 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  8575                              <1> 
  8576                              <1> ;=========================================================================
  8577                              <1> ; int_10_fn05 - Select active display page
  8578                              <1> ; Input:
  8579                              <1> ;	AH = 05h
  8580                              <1> ;	AL - new page number (00h is the first page)
  8581                              <1> ; Output:
  8582                              <1> ;	none
  8583                              <1> ;-------------------------------------------------------------------------
  8584                              <1> int_10_fn05:
  8585 00007283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  8586 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  8587 00007288 B400                <1> 	mov	ah,0
  8588 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  8589 0000728E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  8590 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  8591 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  8592 00007295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  8593 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  8594                              <1> 
  8595 0000729A B700                <1> 	mov	bh,0
  8596 0000729C D1E3                <1> 	shl	bx,1
  8597 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  8598 000072A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  8599 000072A4 D1E8                <1> 	shr	ax,1
  8600 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  8601 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  8602 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  8603 000072AD C3                  <1> 	ret
  8604                              <1> 
  8605                              <1> ;=========================================================================
  8606                              <1> ; int_10_fn06 - scroll up window
  8607                              <1> ; int_10_fn07 - scroll down window
  8608                              <1> ; Input:
  8609                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  8610                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  8611                              <1> ;	BH = attribute used to write blank rows at bottom of window
  8612                              <1> ;	CH,CL = row,column of window's upper left corner
  8613                              <1> ;	DH,DL = row,column of window's lower right corner
  8614                              <1> ; Output:
  8615                              <1> ;	none
  8616                              <1> ; TODO:
  8617                              <1> ;	optimize graphics fill
  8618                              <1> ;-------------------------------------------------------------------------
  8619                              <1> int_10_fn06:
  8620                              <1> int_10_fn07:
  8621 000072AE E86604              <1> 	call	vid_check_mode
  8622 000072B1 7303E9D900          <1> 	jb	.graphics_scroll
  8623                              <1> 
  8624 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  8625 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  8626 000072BD 720A                <1> 	jb	.no_snow
  8627 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  8628 000072C4 7703                <1> 	ja	.no_snow
  8629 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  8630                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  8631                              <1> .no_snow:
  8632 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  8633 000072CC 50                  <1> 	push	ax
  8634 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  8635 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  8636 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  8637                              <1> 
  8638                              <1> .1:
  8639 000072D6 E89804              <1> 	call	vid_position_to_offset
  8640 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  8641 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  8642                              <1> 
  8643                              <1> ; calculate scroll window size (DX)
  8644                              <1> 
  8645 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  8646 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  8647 000072E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  8648                              <1> 
  8649                              <1> ; calculate offset between the source and the destination (AX)
  8650                              <1> 
  8651 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  8652 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  8653 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  8654 000072F0 52                  <1> 	push    dx
  8655 000072F1 B400                <1>         mov     ah,0
  8656 000072F3 F7E3                <1>         mul     bx
  8657 000072F5 5A                  <1>         pop     dx
  8658                              <1> 
  8659 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  8660 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  8661 000072FA 1E                  <1> 	push	ds
  8662 000072FB 8CC1                <1> 	mov	cx,es
  8663 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  8664 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  8665 00007303 7405                <1> 	jz	.2			; jump if scroll up
  8666 00007305 F7D8                <1> 	neg	ax			; negate offset
  8667 00007307 F7DB                <1> 	neg	bx			; negate distance
  8668 00007309 FD                  <1> 	std				; copy backwards
  8669                              <1> 
  8670                              <1> .2:
  8671 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  8672 0000730D 08C9                <1> 	or	cl,cl
  8673 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  8674 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  8675 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  8676 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  8677                              <1> 
  8678 00007316 09DB                <1> 	or	bx,bx
  8679 00007318 7434                <1> 	jz	.text_full_row_scroll
  8680                              <1> 
  8681                              <1> .text_scroll_loop:
  8682 0000731A B500                <1> 	mov	ch,0
  8683 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  8684                              <1> 
  8685 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  8686 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  8687 00007322 E85800              <1> 	call	.retrace_wait
  8688                              <1> 
  8689                              <1> .text_scroll_no_retrace:
  8690 00007325 F3A5                <1> 	repz	movsw			; copy one row
  8691                              <1> 
  8692                              <1> ;.text_scroll_next_row:
  8693 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  8694 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  8695 0000732B FECE                <1> 	dec	dh			; decrement row counter
  8696 0000732D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  8697                              <1> 
  8698                              <1> .text_fill:
  8699 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  8700 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  8701                              <1> 
  8702                              <1> .text_fill_only:
  8703 00007334 B500                <1> 	mov	ch,0
  8704 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  8705 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  8706                              <1> 
  8707                              <1> .text_fill_loop:
  8708 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  8709 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  8710 0000733F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  8711 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  8712                              <1> 
  8713                              <1> .text_fill_no_retrace:
  8714 00007344 F3AB                <1> 	repz	stosw			; fill one row
  8715 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  8716 00007348 FECE                <1> 	dec	dh			; decrement row counter
  8717 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  8718                              <1> 
  8719 0000734C 1F                  <1> 	pop	ds
  8720 0000734D C3                  <1> 	ret
  8721                              <1> 
  8722                              <1> .text_full_row_scroll:
  8723 0000734E 09C0                <1> 	or	ax,ax
  8724 00007350 741F                <1> 	jz	.text_full_row_no_snow
  8725 00007352 50                  <1> 	push	ax
  8726 00007353 88D0                <1> 	mov	al,dl
  8727 00007355 F6E6                <1> 	mul	dh
  8728                              <1> 
  8729                              <1> .text_full_row_loop:
  8730 00007357 B9F000              <1> 	mov	cx,240
  8731 0000735A 39C8                <1> 	cmp	ax,cx
  8732 0000735C 7705                <1> 	ja	.copy_chunk
  8733 0000735E 91                  <1> 	xchg	ax,cx
  8734 0000735F 31C0                <1> 	xor	ax,ax
  8735 00007361 EB02                <1> 	jmp	.do_copy
  8736                              <1> 
  8737                              <1> .copy_chunk:
  8738 00007363 29C8                <1> 	sub	ax,cx
  8739                              <1> 
  8740                              <1> .do_copy:
  8741 00007365 E81500              <1> 	call	.retrace_wait
  8742 00007368 F3A5                <1> 	rep	movsw
  8743 0000736A 09C0                <1> 	or	ax,ax
  8744 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  8745 0000736E 58                  <1> 	pop	ax
  8746 0000736F EBBE                <1> 	jmp	.text_fill
  8747                              <1> 
  8748                              <1> .text_full_row_no_snow:
  8749 00007371 50                  <1> 	push	ax
  8750 00007372 88D0                <1> 	mov	al,dl
  8751 00007374 F6E6                <1> 	mul	dh
  8752 00007376 89C1                <1> 	mov	cx,ax
  8753 00007378 F3A5                <1> 	rep	movsw
  8754 0000737A 58                  <1> 	pop	ax
  8755 0000737B EBB2                <1> 	jmp	.text_fill
  8756                              <1> 
  8757                              <1> ;-------------------------------------------------------------------------
  8758                              <1> ; .retrace_wait - next till the next vertical retrace
  8759                              <1> 
  8760                              <1> .retrace_wait:
  8761 0000737D 50                  <1> 	push	ax
  8762 0000737E 52                  <1> 	push	dx
  8763 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  8764                              <1> 
  8765                              <1> .retrace_wait_not_set:
  8766 00007382 EC                  <1> 	in	al,dx
  8767 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8768 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  8769                              <1> 
  8770                              <1> .retrace_wait_set:
  8771 00007387 EC                  <1> 	in	al,dx
  8772 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8773 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  8774 0000738C 5A                  <1> 	pop	dx
  8775 0000738D 58                  <1> 	pop	ax
  8776                              <1> 
  8777                              <1> .retrace_exit:
  8778 0000738E C3                  <1> 	ret
  8779                              <1> 
  8780                              <1> ;-------------------------------------------------------------------------
  8781                              <1> ; .graphics_scroll - scroll for graphics modes
  8782                              <1> 
  8783                              <1> .graphics_scroll:
  8784 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  8785 00007392 50                  <1> 	push	ax
  8786 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  8787 00007397 7403                <1> 	jz	.3			; jump if scroll down
  8788 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  8789                              <1> 
  8790                              <1> .3:
  8791 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  8792 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  8793                              <1> 
  8794                              <1> ; calculate scroll windows size (DX)
  8795                              <1> 
  8796 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  8797 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  8798 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  8799 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  8800 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  8801 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  8802 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  8803 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  8804 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  8805 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  8806 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  8807 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  8808 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  8809                              <1> 
  8810                              <1> .4:
  8811 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  8812 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  8813 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  8814                              <1> 					;   for copying backwards
  8815                              <1> 
  8816                              <1> .5:
  8817 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  8818 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  8819 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  8820 000073CF 53                  <1> 	push	bx
  8821 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  8822 000073D2 B050                <1> 	mov	al,50h
  8823 000073D4 F6E3                <1> 	mul	bl
  8824 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  8825 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  8826 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  8827 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  8828 000073E1 BB5020              <1> 	mov	bx,2050h
  8829 000073E4 FD                  <1> 	std				; copy backwards
  8830                              <1> 
  8831                              <1> .6:
  8832 000073E5 89FE                <1> 	mov	si,di
  8833 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  8834 000073E9 58                  <1> 	pop	ax
  8835 000073EA 8CC1                <1> 	mov	cx,es
  8836 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  8837 000073EE 08C0                <1> 	or	al,al
  8838 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  8839 000073F2 50                  <1> 	push	ax
  8840                              <1> 
  8841                              <1> .graphics_scroll_loop:
  8842 000073F3 B500                <1> 	mov	ch,0
  8843 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  8844 000073F7 56                  <1> 	push	si
  8845 000073F8 57                  <1> 	push	di
  8846 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  8847 000073FB 5F                  <1> 	pop	di
  8848 000073FC 5E                  <1> 	pop	si
  8849 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  8850 00007401 81C70020            <1> 	add	di,2000h
  8851 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  8852 00007407 56                  <1> 	push	si
  8853 00007408 57                  <1> 	push	di
  8854 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  8855 0000740B 5F                  <1> 	pop	di
  8856 0000740C 5E                  <1> 	pop	si
  8857 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  8858 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  8859 00007411 FECE                <1> 	dec	dh			; decrement row counter
  8860 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  8861                              <1> 
  8862 00007415 58                  <1> 	pop	ax
  8863 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  8864                              <1> 
  8865                              <1> .graphics_fill:
  8866 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  8867 0000741B B500                <1> 	mov	ch,0
  8868                              <1> 
  8869                              <1> .graphics_fill_loop:
  8870 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  8871 0000741F 57                  <1> 	push	di
  8872 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  8873 00007422 5F                  <1> 	pop	di
  8874 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  8875 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  8876 00007429 57                  <1> 	push	di
  8877 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  8878 0000742C 5F                  <1> 	pop	di
  8879 0000742D 29DF                <1> 	sub	di,bx
  8880 0000742F FECE                <1> 	dec	dh			; decrement row counter
  8881 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  8882 00007433 C3                  <1> 	ret
  8883                              <1> 
  8884                              <1> ;=========================================================================
  8885                              <1> ; int_10_fn08 - Read character and attribute
  8886                              <1> ; Input:
  8887                              <1> ;	AH = 08h
  8888                              <1> ; Output:
  8889                              <1> ;	AL - character read
  8890                              <1> ;	BH - video attribute (text modes only)
  8891                              <1> ; int_10_fn09 - Write character and attribute
  8892                              <1> ; Input:
  8893                              <1> ;	AH = 09h
  8894                              <1> ;	AL - character to write
  8895                              <1> ;	BH - page number
  8896                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  8897                              <1> ;	CX - number of times to write character
  8898                              <1> ; Output:
  8899                              <1> ;	none
  8900                              <1> ; int_10_fn0A - Write character only
  8901                              <1> ; Input:
  8902                              <1> ;	AH = 0Ah
  8903                              <1> ;	AL - character to write
  8904                              <1> ;	BH - page number
  8905                              <1> ;	CX - repeat count
  8906                              <1> ; Output:
  8907                              <1> ;	none
  8908                              <1> ;-------------------------------------------------------------------------
  8909                              <1> int_10_fn08:
  8910                              <1> int_10_fn09:
  8911                              <1> int_10_fn0A:
  8912 00007434 E8E002              <1> 	call	vid_check_mode
  8913 00007437 7277                <1> 	jb	.graphics		; jump if graphics mode
  8914 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8915 0000743C B700                <1> 	mov	bh,0
  8916 0000743E 53                  <1> 	push	bx
  8917 0000743F E82803              <1> 	call	vid_current_offset
  8918 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  8919 00007444 58                  <1> 	pop	ax			; AX = page number
  8920 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  8921 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  8922 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  8923 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  8924 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  8925 00007454 1E                  <1> 	push	ds
  8926 00007455 8CC3                <1> 	mov	bx,es
  8927 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  8928 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  8929 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  8930 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  8931                              <1> 
  8932                              <1> .read_retrace_wait:
  8933 00007460 EC                  <1> 	in	al,dx
  8934 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8935 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  8936 00007465 FA                  <1> 	cli
  8937                              <1> 
  8938                              <1> .read_no_retrace_wait:
  8939 00007466 EC                  <1> 	in	al,dx
  8940 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8941 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  8942                              <1> 
  8943 0000746B AD                  <1> 	lodsw				; read character and attribute
  8944 0000746C FB                  <1> 	sti
  8945 0000746D 1F                  <1> 	pop	ds
  8946 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  8947 00007471 C3                  <1> 	ret
  8948                              <1> 
  8949                              <1> .text_write:
  8950 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  8951 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  8952 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  8953 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  8954 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  8955                              <1> 
  8956                              <1> .write_char_retrace:
  8957 0000747F EC                  <1> 	in	al,dx
  8958 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8959 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  8960                              <1> 
  8961                              <1> .write_retrace_wait1:
  8962 00007484 EC                  <1> 	in	al,dx
  8963 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8964 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  8965 00007489 FA                  <1> 	cli
  8966                              <1> 
  8967                              <1> .write_no_retrace_wait1:
  8968 0000748A EC                  <1> 	in	al,dx
  8969 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8970 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  8971                              <1> 
  8972                              <1> .do_write_char_attr:
  8973 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  8974 00007491 AB                  <1> 	stosw				; write it to video memory
  8975 00007492 FB                  <1> 	sti
  8976 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  8977 00007495 1F                  <1> 	pop	ds
  8978 00007496 C3                  <1> 	ret
  8979                              <1> 
  8980                              <1> .text_write_char_only:
  8981 00007497 EC                  <1> 	in	al,dx
  8982 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8983 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  8984                              <1> 
  8985                              <1> .write_retrace_wait2:
  8986 0000749C EC                  <1> 	in	al,dx
  8987 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8988 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  8989 000074A1 FA                  <1> 	cli
  8990                              <1> 
  8991                              <1> .write_no_retrace_wait2:
  8992 000074A2 EC                  <1> 	in	al,dx
  8993 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8994 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  8995                              <1> 
  8996                              <1> .do_write_char_only:
  8997 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  8998 000074A9 AA                  <1> 	stosb				; write it to video memory
  8999 000074AA FB                  <1> 	sti
  9000 000074AB 47                  <1> 	inc	di			; skip attribute
  9001 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  9002 000074AE 1F                  <1> 	pop	ds
  9003 000074AF C3                  <1> 	ret
  9004                              <1> 
  9005                              <1> .graphics:
  9006 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  9007 000074B4 7503E9B300          <1> 	jz	.graphics_read
  9008                              <1> 
  9009 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  9010 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  9011 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  9012 000074C1 1E                  <1> 	push	ds
  9013 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  9014 000074C5 B400                <1> 	mov	ah,0
  9015 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  9016 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  9017 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  9018 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  9019 000074D0 EB0C                <1> 	jmp	.CG9_03
  9020                              <1> 
  9021                              <1> .CG9_02:
  9022 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  9023 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  9024 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  9025 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  9026 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  9027                              <1> 
  9028                              <1> .CG9_03:
  9029 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  9030 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  9031 000074E1 D3E0                <1> 	shl	ax,cl
  9032 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  9033 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  9034 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  9035 000074ED 1E                  <1> 	push	ds
  9036 000074EE 8EDA                <1> 	mov	ds,dx
  9037 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  9038 000074F2 D1E7                <1> 	shl	di,1
  9039 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  9040 000074F7 83E003              <1> 	and	ax,3
  9041 000074FA BB5555              <1> 	mov	bx,5555h
  9042 000074FD F7E3                <1> 	mul	bx
  9043 000074FF 89C2                <1> 	mov	dx,ax
  9044 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  9045                              <1> 
  9046                              <1> .CG9_04:
  9047 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  9048 00007506 57                  <1> 	push	di
  9049 00007507 56                  <1> 	push	si
  9050                              <1> 
  9051                              <1> .CG9_05:
  9052 00007508 AC                  <1> 	lodsb				; Read the screen
  9053 00007509 51                  <1> 	push	cx
  9054 0000750A 53                  <1> 	push	bx
  9055 0000750B 31DB                <1> 	xor	bx,bx
  9056 0000750D B90800              <1> 	mov	cx,8
  9057                              <1> 
  9058                              <1> .CG9_06:
  9059 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  9060 00007512 D1DB                <1> 	rcr	bx,1
  9061 00007514 D1FB                <1> 	sar	bx,1
  9062 00007516 E2F8                <1> 	loop	.CG9_06
  9063                              <1> 
  9064 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  9065 0000751A 5B                  <1> 	pop	bx
  9066 0000751B 59                  <1> 	pop	cx
  9067 0000751C 21D0                <1> 	and	ax,dx
  9068 0000751E 86E0                <1> 	xchg	ah,al
  9069 00007520 08DB                <1> 	or	bl,bl
  9070 00007522 7903                <1> 	jns	.CG9_07
  9071 00007524 263305              <1>     es	xor	ax,word [di]
  9072                              <1> 
  9073                              <1> .CG9_07:
  9074 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  9075 0000752A 81F70020            <1> 	xor	di,2000h
  9076 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  9077 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  9078 00007534 83C750              <1> 	add	di,50h			; Else advance character
  9079                              <1> 
  9080                              <1> .CG9_08:
  9081 00007537 FECF                <1> 	dec	bh			; Show another char written
  9082 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  9083 0000753B 5E                  <1> 	pop	si
  9084 0000753C 5F                  <1> 	pop	di
  9085 0000753D 47                  <1> 	inc	di
  9086 0000753E 47                  <1> 	inc	di
  9087 0000753F E2C3                <1> 	loop	.CG9_04
  9088 00007541 1F                  <1> 	pop	ds
  9089 00007542 C3                  <1> 	ret
  9090                              <1> 
  9091                              <1> .CG8_02:
  9092 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  9093 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  9094                              <1> 
  9095                              <1> .CG8_03:
  9096 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  9097 0000754B 57                  <1> 	push	di
  9098 0000754C 56                  <1> 	push	si
  9099                              <1> 
  9100                              <1> .CG8_04:
  9101 0000754D AC                  <1> 	lodsb				; Read from one plane
  9102 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  9103 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  9104 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  9105                              <1> 
  9106                              <1> .CG8_05:
  9107 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  9108 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  9109 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  9110 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  9111 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  9112                              <1> 
  9113                              <1> .CG8_06:
  9114 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  9115 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  9116 00007565 5E                  <1> 	pop	si
  9117 00007566 5F                  <1> 	pop	di
  9118 00007567 47                  <1> 	inc	di
  9119 00007568 E2DF                <1> 	loop	.CG8_03
  9120 0000756A 1F                  <1> 	pop	ds
  9121 0000756B C3                  <1> 	ret
  9122                              <1> 
  9123                              <1> .graphics_read:
  9124 0000756C FC                  <1> 	cld				; Increment upwards
  9125 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  9126 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  9127 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  9128 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  9129 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  9130 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  9131 0000757F 8CC0                <1> 	mov	ax,es
  9132 00007581 1E                  <1> 	push	ds
  9133 00007582 57                  <1> 	push	di
  9134 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  9135 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  9136 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  9137 00007589 D1E6                <1> 	shl	si,1
  9138 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  9139                              <1> 
  9140                              <1> CGR_02:
  9141 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  9142 00007590 86E0                <1> 	xchg	ah,al
  9143 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  9144 00007595 B200                <1> 	mov	dl,0
  9145                              <1> 
  9146                              <1> CGR_03:
  9147 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  9148 00007599 F8                  <1> 	clc
  9149 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  9150 0000759C F9                  <1> 	stc				; Else show not set
  9151                              <1> 
  9152                              <1> CGR_04:
  9153 0000759D D0D2                <1> 	rcl	dl,1
  9154 0000759F D1E9                <1> 	shr	cx,1
  9155 000075A1 D1E9                <1> 	shr	cx,1
  9156 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  9157 000075A5 368815              <1>     ss	mov	byte [di],dl
  9158 000075A8 47                  <1> 	inc	di
  9159 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  9160 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  9161 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  9162 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  9163                              <1> 
  9164                              <1> CGR_05:
  9165 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  9166 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  9167 000075B6 EB17                <1> 	jmp	short	CGR_08
  9168                              <1> 
  9169                              <1> CGR_06:
  9170 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  9171                              <1> 
  9172                              <1> CGR_07:
  9173 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  9174 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  9175 000075BF 47                  <1> 	inc	di			;  ...advance
  9176 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  9177 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  9178 000075C7 47                  <1> 	inc	di			;  ...advance
  9179 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  9180 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  9181 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  9182                              <1> 
  9183                              <1> CGR_08:
  9184 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  9185 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  9186 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  9187 000075D6 8CD2                <1> 	mov	dx,ss
  9188 000075D8 8EDA                <1> 	mov	ds,dx
  9189 000075DA 5E                  <1> 	pop	si
  9190 000075DB B000                <1> 	mov	al,0
  9191                              <1> 
  9192                              <1> CGR_09:
  9193 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  9194                              <1> 
  9195                              <1> CGR_10:
  9196 000075E0 56                  <1> 	push	si
  9197 000075E1 57                  <1> 	push	di
  9198 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  9199 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  9200 000075E7 5F                  <1> 	pop	di
  9201 000075E8 5E                  <1> 	pop	si
  9202 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  9203 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  9204 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  9205 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  9206 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  9207                              <1> 
  9208 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  9209 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  9210 000075F7 31DB                <1> 	xor	bx,bx
  9211 000075F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  9212 000075FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  9213 000075FF 8CC3                <1> 	mov	bx,es
  9214 00007601 09FB                <1> 	or	bx,di
  9215 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  9216 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  9217                              <1> 
  9218                              <1> CGR_11:
  9219 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  9220 0000760A 1F                  <1> 	pop	ds
  9221 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  9222 0000760E C3                  <1> 	ret
  9223                              <1> 
  9224                              <1> ;=========================================================================
  9225                              <1> ; int_10_fn0B - Set background color or palette
  9226                              <1> ; Input:
  9227                              <1> ; 	AH - 0Bh
  9228                              <1> ;	BH = 00h - set background / border color
  9229                              <1> ;		BL - background (graphics modes) or border (text modes)
  9230                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  9231                              <1> ;		BL - palette ID:
  9232                              <1> ;			00h - background, green, red, and yellow (brown)
  9233                              <1> ;			01h - background, cyan, magenta, and white
  9234                              <1> ; Output:
  9235                              <1> ;	none
  9236                              <1> ;-------------------------------------------------------------------------
  9237                              <1> int_10_fn0B:
  9238 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  9239 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  9240 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  9241 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  9242                              <1> 
  9243 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  9244 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  9245 00007620 08E0                <1> 	or	al,ah			; apply new color
  9246 00007622 EB09                <1> 	jmp	.write_palet_reg
  9247                              <1> 
  9248                              <1> .set_palette:
  9249 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  9250 00007626 F6C401              <1> 	test	ah,01h
  9251 00007629 7402                <1> 	jz	.write_palet_reg
  9252 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  9253                              <1> 
  9254                              <1> .write_palet_reg:
  9255 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  9256 00007630 8B166300            <1> 	mov	dx,word [video_port]
  9257 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  9258 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  9259 00007638 C3                  <1> 	ret
  9260                              <1> 
  9261                              <1> ;=========================================================================
  9262                              <1> ; int_10_fn0C - Write graphics pixel
  9263                              <1> ; Input:
  9264                              <1> ;	AH = 0Ch
  9265                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  9266                              <1> ;	CX = column
  9267                              <1> ;	DX = row
  9268                              <1> ; Output:
  9269                              <1> ;	none
  9270                              <1> ;-------------------------------------------------------------------------
  9271                              <1> int_10_fn0C:
  9272 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  9273 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9274 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9275 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  9276 00007643 2401                <1> 	and	al,1			; one bit per pixel
  9277 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9278 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  9279 00007649 EB0F                <1> 	jmp	.prepare_mask
  9280                              <1> 
  9281                              <1> .mode_320x200:
  9282 0000764B D0E1                <1> 	shl	cl,1
  9283 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9284 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  9285 00007652 2403                <1> 	and	al,3			; two bit per pixel
  9286 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9287 00007656 D0C8                <1> 	ror	al,1
  9288 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  9289                              <1> 
  9290                              <1> .prepare_mask:
  9291 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  9292 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  9293 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  9294 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  9295 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  9296 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  9297 00007667 EB04                <1> 	jmp	.write_pixel
  9298                              <1> 
  9299                              <1> .set_color:
  9300 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  9301 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  9302                              <1> 
  9303                              <1> .write_pixel:
  9304 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  9305 00007670 C3                  <1> 	ret
  9306                              <1> 
  9307                              <1> ;=========================================================================
  9308                              <1> ; int_10_fn0D - Read graphics pixel
  9309                              <1> ; Input:
  9310                              <1> ;	AH = 0Dh
  9311                              <1> ;	CX = column
  9312                              <1> ;	DX = row
  9313                              <1> ; Output:
  9314                              <1> ;	AL = pixel color 
  9315                              <1> ;-------------------------------------------------------------------------
  9316                              <1> int_10_fn0D:
  9317 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  9318 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  9319 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9320 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  9321 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  9322 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  9323 0000767F EB0A                <1> 	jmp	.exit
  9324                              <1> 
  9325                              <1> .mode_320x200:
  9326 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  9327 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  9328 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  9329 00007687 D0C0                <1> 	rol	al,1
  9330 00007689 2403                <1> 	and	al,3			; two bits per pixel
  9331                              <1> 
  9332                              <1> .exit:
  9333 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  9334 0000768E C3                  <1> 	ret
  9335                              <1> 
  9336                              <1> ;=========================================================================
  9337                              <1> ; int_10_fn0E - Teletype output
  9338                              <1> ; Input:
  9339                              <1> ;	AH = 0Eh
  9340                              <1> ;	AL = character to write
  9341                              <1> ;	BL = foreground color (graphics modes only)
  9342                              <1> ; Output:
  9343                              <1> ;	none
  9344                              <1> ; Notes:
  9345                              <1> ;	- writes character to the active video page
  9346                              <1> ;	- support following control characters: BEL, BS, LF, CR
  9347                              <1> ;-------------------------------------------------------------------------
  9348                              <1> int_10_fn0E:
  9349 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9350 00007693 B700                <1> 	mov	bh,0
  9351 00007695 D0E3                <1> 	shl	bl,1			; word index
  9352 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  9353                              <1> 
  9354 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  9355 0000769D 3C08                <1> 	cmp	al,bs
  9356 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  9357 000076A1 3C0A                <1> 	cmp	al,lf
  9358 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  9359 000076A5 3C07                <1> 	cmp	al,bel
  9360 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  9361 000076A9 3C0D                <1> 	cmp	al,cr
  9362 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  9363 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  9364 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  9365 000076B2 B90100              <1> 	mov	cx,1			; one character
  9366 000076B5 CD10                <1> 	int	10h			; write character
  9367 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  9368 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  9369 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  9370 000076BF B200                <1> 	mov	dl,0			; move to the first position
  9371                              <1> 
  9372                              <1> .lf:
  9373 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  9374 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  9375 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  9376 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  9377                              <1> 
  9378                              <1> .bs:
  9379 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  9380 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  9381 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
  9382 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  9383                              <1> 
  9384                              <1> .cr:
  9385 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  9386                              <1> 
  9387                              <1> .set_cursor_pos:
  9388 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9389 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  9390                              <1> 
  9391                              <1> .bel:
  9392 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
  9393 000076DE E855A9              <1> 	call	beep
  9394 000076E1 C3                  <1> 	ret
  9395                              <1> 
  9396                              <1> .scroll:
  9397 000076E2 B402                <1> 	mov	ah,02h
  9398 000076E4 CD10                <1> 	int	10h			; set new cursor position
  9399 000076E6 E82E00              <1> 	call	vid_check_mode
  9400 000076E9 B700                <1> 	mov	bh,0
  9401 000076EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
  9402 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  9403 000076EF CD10                <1> 	int	10h			; read attirbute at current position
  9404 000076F1 88E7                <1> 	mov	bh,ah
  9405                              <1> 
  9406                              <1> .do_scroll:
  9407 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  9408 000076F5 B001                <1> 	mov	al,1			; scroll one line
  9409 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  9410 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
  9411 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  9412 000076FF FECA                <1> 	dec	dl
  9413 00007701 CD10                <1> 	int	10h			; scroll page up
  9414 00007703 C3                  <1> 	ret
  9415                              <1> 
  9416                              <1> ;=========================================================================
  9417                              <1> ; int_10_fn0F - Get current video mode
  9418                              <1> ; Input:
  9419                              <1> ;	AH = 0Fh
  9420                              <1> ; Output:
  9421                              <1> ;	AL = video mode
  9422                              <1> ;	AH = characters per column
  9423                              <1> ;	BH = active video page
  9424                              <1> ;-------------------------------------------------------------------------
  9425                              <1> int_10_fn0F:
  9426 00007704 A04A00              <1> 	mov	al,byte [video_columns]
  9427 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
  9428 0000770A A04900              <1> 	mov	al,byte [video_mode]
  9429 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
  9430 00007710 A06200              <1> 	mov	al,byte [video_page]
  9431 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
  9432 00007716 C3                  <1> 	ret
  9433                              <1> 
  9434                              <1> ;=========================================================================
  9435                              <1> ; vid_check_mode - Check current video mode
  9436                              <1> ; Input:
  9437                              <1> ;	none
  9438                              <1> ; Output:
  9439                              <1> ;	ZF set if monochrome mode (mode 07h)
  9440                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  9441                              <1> ;-------------------------------------------------------------------------
  9442                              <1> vid_check_mode:
  9443 00007717 50                  <1> 	push	ax
  9444 00007718 A04900              <1> 	mov	al,byte [video_mode]
  9445 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  9446 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
  9447 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  9448 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  9449 00007722 7303                <1> 	jnb	.exit			; jump if not graphics
  9450 00007724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
  9451 00007726 F9                  <1> 	stc				; XXX
  9452                              <1> 
  9453                              <1> .exit:
  9454 00007727 58                  <1> 	pop	ax
  9455 00007728 C3                  <1> 	ret
  9456                              <1> 
  9457                              <1> ;=========================================================================
  9458                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  9459                              <1> ; Input:
  9460                              <1> ;	AH = register number
  9461                              <1> ;	CX = word to write
  9462                              <1> ; Output:
  9463                              <1> ;	AX trashed
  9464                              <1> ; Note:
  9465                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  9466                              <1> ;-------------------------------------------------------------------------
  9467                              <1> vid_crtc_writew:
  9468 00007729 88E8                <1> 	mov	al,ch
  9469 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  9470 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
  9471 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  9472                              <1> 
  9473                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  9474                              <1> 
  9475                              <1> ;=========================================================================
  9476                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  9477                              <1> ; Input:
  9478                              <1> ;	AH = register number
  9479                              <1> ;	AL = byte to write
  9480                              <1> ; Output:
  9481                              <1> ;	none
  9482                              <1> ;-------------------------------------------------------------------------
  9483                              <1> vid_crtc_writeb:
  9484 00007732 52                  <1> 	push	dx
  9485 00007733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  9486 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  9487 00007739 EE                  <1> 	out	dx,al			; write register number
  9488 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  9489 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
  9490 0000773E EE                  <1> 	out	dx,al			; write byte
  9491 0000773F 5A                  <1> 	pop	dx
  9492 00007740 C3                  <1> 	ret
  9493                              <1> 
  9494                              <1> ;=========================================================================
  9495                              <1> ; vid_pixel_address - calculate pixel address and mask
  9496                              <1> ; Input:
  9497                              <1> ;	CX - column
  9498                              <1> ;	DX - row
  9499                              <1> ; Output:
  9500                              <1> ;	SI - pixel address
  9501                              <1> ;	CH - pixel mask
  9502                              <1> ;	CL - pixel position in the byte
  9503                              <1> ;	ZF - mode
  9504                              <1> ;		0 = 320x200
  9505                              <1> ;		1 = 640x200
  9506                              <1> ;-------------------------------------------------------------------------
  9507                              <1> vid_pixel_address:
  9508 00007741 31F6                <1> 	xor	si,si			; SI = 0
  9509 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
  9510 00007745 7303                <1> 	jnb	.even			; jump if on even row 
  9511 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  9512                              <1> 
  9513                              <1> .even:
  9514 0000774A B050                <1> 	mov	al,50h			; bytes in each row
  9515 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
  9516                              <1> 
  9517 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
  9518 00007750 89CA                <1> 	mov	dx,cx			; DX - column
  9519 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  9520 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  9521 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
  9522 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
  9523 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  9524                              <1> 
  9525                              <1> .1:
  9526 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  9527 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  9528 00007764 01D6                <1> 	add	si,dx			; add column address to SI
  9529 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  9530 00007768 9D                  <1> 	popf
  9531 00007769 C3                  <1> 	ret
  9532                              <1> 
  9533                              <1> ;=========================================================================
  9534                              <1> ; vid_current_offset - convert current cursor position to offset
  9535                              <1> ;		       relative to page starting address
  9536                              <1> ; Input:
  9537                              <1> ;	BL = page
  9538                              <1> ; Output:
  9539                              <1> ;	AX = offset
  9540                              <1> ;-------------------------------------------------------------------------
  9541                              <1> vid_current_offset:
  9542 0000776A B700                <1> 	mov	bh,0
  9543 0000776C D1E3                <1> 	shl	bx,1				; word index
  9544 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  9545                              <1> 
  9546                              <1> ; fall through to vid_position_to_offset
  9547                              <1> 
  9548                              <1> ;=========================================================================
  9549                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  9550                              <1> ;			   relative to page starting address
  9551                              <1> ; Input:
  9552                              <1> ;	AH = row
  9553                              <1> ;	AL = column
  9554                              <1> ; Output:
  9555                              <1> ;	AX = offset
  9556                              <1> ;-------------------------------------------------------------------------
  9557                              <1> vid_position_to_offset:
  9558 00007771 53                  <1> 	push	bx
  9559 00007772 88C3                <1> 	mov	bl,al			; BL = column
  9560 00007774 88E0                <1> 	mov	al,ah			; AL = row
  9561 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  9562 0000777A B700                <1> 	mov	bh,0			;
  9563 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  9564 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  9565 00007780 5B                  <1> 	pop	bx
  9566 00007781 C3                  <1> 	ret
  9567                              <1> 
  9568                              <1> ;=========================================================================
  9569                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  9570                              <1> ; Input:
  9571                              <1> ;	AH = row
  9572                              <1> ;	AL = column
  9573                              <1> ; Output:
  9574                              <1> ;	AX = offset
  9575                              <1> ;-------------------------------------------------------------------------
  9576                              <1> vid_gfx_pos_to_offset:
  9577 00007782 53                  <1> 	push	bx
  9578 00007783 88C3                <1> 	mov	bl,al			; BL = column
  9579 00007785 88E0                <1> 	mov	al,ah			; AL = row
  9580 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  9581 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  9582 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  9583 0000778F B700                <1> 	mov	bh,0
  9584 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  9585 00007793 5B                  <1> 	pop	bx
  9586 00007794 C3                  <1> 	ret
  9587                                  
  9588                                  ;=========================================================================
  9589                                  ; int_12 - Get memory size
  9590                                  ; Input:
  9591                                  ;	none
  9592                                  ; Output:
  9593                                  ;	AX = memory size
  9594                                  ;-------------------------------------------------------------------------
  9595 00007795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
  9596          ******************       warning: (setloc:7) Inserting 172 bytes
  9597                                  int_12:
  9598 00007841 FB                      	sti
  9599 00007842 1E                      	push	ds
  9600 00007843 B84000                  	mov	ax,biosdseg
  9601 00007846 8ED8                    	mov	ds,ax
  9602 00007848 A11300                  	mov	ax,word [memory_size]
  9603 0000784B 1F                      	pop	ds
  9604 0000784C CF                      	iret
  9605                                  
  9606                                  ;=========================================================================
  9607                                  ; int_11 - Get equipment list
  9608                                  ; Input:
  9609                                  ;	none
  9610                                  ; Output:
  9611                                  ;	AX = equipment list
  9612                                  ;-------------------------------------------------------------------------
  9613                                  	setloc	0F84Dh			; INT 11 Entry Point
  9614                                  int_11:
  9615 0000784D FB                      	sti
  9616 0000784E 1E                      	push	ds
  9617 0000784F B84000                  	mov	ax,biosdseg
  9618 00007852 8ED8                    	mov	ds,ax
  9619 00007854 A11000                  	mov	ax,word [equipment_list]
  9620 00007857 1F                      	pop	ds
  9621 00007858 CF                      	iret
  9622                                  
  9623                                  ;=========================================================================
  9624                                  ; Includes with fixed entry points (for IBM compatibility)
  9625                                  ;-------------------------------------------------------------------------
  9626                                  
  9627                                  %include	"misc.inc"
  9628                              <1> ;=========================================================================
  9629                              <1> ; misc.inc - Miscellaneous BIOS Services
  9630                              <1> ;       INT 15h, functions:
  9631                              <1> ;       	4Fh	- OS hook keyboard intercept
  9632                              <1> ;		90h	- Device busy loop
  9633                              <1> ;		91h	- Interrupt completed
  9634                              <1> ;		0C0h	- Get system configruation
  9635                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  9636                              <1> ;		
  9637                              <1> ;-------------------------------------------------------------------------
  9638                              <1> ;
  9639                              <1> ; Compiles with NASM 2.07, might work with other versions
  9640                              <1> ;
  9641                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  9642                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  9643                              <1> ;
  9644                              <1> ; This program is free software: you can redistribute it and/or modify
  9645                              <1> ; it under the terms of the GNU General Public License as published by
  9646                              <1> ; the Free Software Foundation, either version 3 of the License, or
  9647                              <1> ; (at your option) any later version.
  9648                              <1> ;
  9649                              <1> ; This program is distributed in the hope that it will be useful,
  9650                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9651                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9652                              <1> ; GNU General Public License for more details.
  9653                              <1> ;
  9654                              <1> ; You should have received a copy of the GNU General Public License
  9655                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  9656                              <1> ;
  9657                              <1> ;=========================================================================
  9658                              <1> 
  9659                              <1> ;-------------------------------------------------------------------------
  9660                              <1> ; offsets for registers on stack
  9661                              <1> int_15_bp	equ	0
  9662                              <1> int_15_ip	equ	int_15_bp+2
  9663                              <1> int_15_cs	equ	int_15_ip+2
  9664                              <1> int_15_flags	equ	int_15_cs+2
  9665                              <1> 
  9666                              <1> ;=========================================================================
  9667                              <1> ; int_15 - Miscellaneous BIOS services
  9668                              <1> ; Input:
  9669                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  9670                              <1> ;		- Does nothing
  9671                              <1> ;	AH = 0C2h - PS/2 mouse services
  9672                              <1> ;		- Implemented in ps2aux.inc
  9673                              <1> ;-------------------------------------------------------------------------
  9674                              <1> 	setloc	0F859h			; INT 15 Entry Point
  9675                              <1> int_15:
  9676 00007859 FB                  <1> 	sti
  9677 0000785A 80FC4F              <1> 	cmp	ah,4Fh
  9678 0000785D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
  9679 0000785F 80FCC0              <1> 	cmp	ah,0C0h
  9680 00007862 742E                <1> 	je	int_15_fnC0
  9681 00007864 3D0190              <1> 	cmp	ax,9001h
  9682 00007867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
  9683 00007869 3DFD90              <1> 	cmp	ax,90FDh
  9684 0000786C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
  9685 0000786E 3D0191              <1> 	cmp	ax,9101h
  9686 00007871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  9687                              <1> 
  9688                              <1> %ifdef PS2_MOUSE
  9689 00007873 80FCC2              <1> 	cmp	ah,0C2h
  9690 00007876 7503                <1> 	jne	.1
  9691 00007878 E93EA5              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  9692                              <1> .1:
  9693                              <1> %endif
  9694                              <1> 
  9695 0000787B B486                <1> 	mov	ah,86h			; no cassete present
  9696                              <1> 
  9697                              <1> int_15_err:
  9698 0000787D 55                  <1> 	push	bp
  9699 0000787E 89E5                <1> 	mov	bp,sp
  9700 00007880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  9701 00007884 5D                  <1> 	pop	bp
  9702 00007885 CF                  <1> 	iret
  9703                              <1> 
  9704                              <1> int_15_ok:
  9705 00007886 55                  <1> 	push	bp
  9706 00007887 89E5                <1> 	mov	bp,sp
  9707 00007889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  9708 0000788D 5D                  <1> 	pop	bp
  9709 0000788E CF                  <1> 	iret
  9710                              <1> 
  9711                              <1> int_15_os_hook:
  9712 0000788F B400                <1> 	mov	ah,00h
  9713                              <1> 
  9714                              <1> int_15_exit:
  9715 00007891 CF                  <1> 	iret
  9716                              <1> 
  9717                              <1> ;=========================================================================
  9718                              <1> ; int_15_fnC0 - Get configuration
  9719                              <1> ; Input:
  9720                              <1> ;	AH = 0C0h - get configuration
  9721                              <1> ; Output:
  9722                              <1> ;	AH = 00h - function supported
  9723                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  9724                              <1> ;	CF = 0 (success)
  9725                              <1> ;-------------------------------------------------------------------------
  9726                              <1> int_15_fnC0:
  9727 00007892 B400                <1> 	mov	ah,00h
  9728 00007894 BB00F0              <1> 	mov	bx,bioscseg
  9729 00007897 8EC3                <1> 	mov	es,bx
  9730 00007899 BB[F566]            <1> 	mov	bx,config_table
  9731 0000789C EBE8                <1> 	jmp	int_15_ok
  9732                                  %include	"fnt00-7F.inc"
  9733                              <1> ;=========================================================================
  9734                              <1> ; fnt00-7F.inc - Font for graphics modes
  9735                              <1> ;       Characters from 00h to 7Fh
  9736                              <1> ;-------------------------------------------------------------------------
  9737                              <1> ;
  9738                              <1> ; Compiles with NASM 2.07, might work with other versions
  9739                              <1> ;
  9740                              <1> ; This font is borrowed from kbd package (alt-8x8)
  9741                              <1> ;
  9742                              <1> ; This program is free software: you can redistribute it and/or modify
  9743                              <1> ; it under the terms of the GNU General Public License as published by
  9744                              <1> ; the Free Software Foundation, either version 3 of the License, or
  9745                              <1> ; (at your option) any later version.
  9746                              <1> ;
  9747                              <1> ; This program is distributed in the hope that it will be useful,
  9748                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9749                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9750                              <1> ; GNU General Public License for more details.
  9751                              <1> ;
  9752                              <1> ; You should have received a copy of the GNU General Public License
  9753                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  9754                              <1> ;
  9755                              <1> ;=========================================================================
  9756 0000789E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
  9757          ******************  <1>  warning: (setloc:7) Inserting 464 bytes
  9758                              <1> gfx_font:
  9759 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  9760 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  9761 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  9762 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  9763 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  9764 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  9765 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  9766 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  9767 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  9768 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  9769 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  9770 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  9771 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  9772 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  9773 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  9774 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  9775 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  9776 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  9777 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  9778 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  9779 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  9780 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  9781 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  9782 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  9783 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  9784 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  9785 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  9786 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  9787 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  9788 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  9789 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  9790 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  9791 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  9792 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  9793 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  9794 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  9795 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  9796 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  9797 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  9798 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  9799 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  9800 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  9801 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  9802 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  9803 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  9804 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  9805 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  9806 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  9807 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  9808 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  9809 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  9810 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  9811 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  9812 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  9813 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  9814 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  9815 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  9816 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  9817 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  9818 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  9819 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  9820 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  9821 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  9822 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  9823 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  9824 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  9825 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  9826 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  9827 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  9828 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  9829 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  9830 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  9831 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  9832 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  9833 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  9834 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  9835 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  9836 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  9837 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  9838 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  9839 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  9840 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  9841 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  9842 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  9843 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  9844 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  9845 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  9846 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  9847 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  9848 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  9849 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  9850 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  9851 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  9852 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  9853 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  9854 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  9855 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  9856 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  9857 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  9858 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  9859 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  9860 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  9861 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  9862 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  9863 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  9864 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  9865 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  9866 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  9867 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  9868 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  9869 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  9870 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  9871 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  9872 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  9873 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  9874 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  9875 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  9876 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  9877 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  9878 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  9879 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  9880 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  9881 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  9882 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  9883 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  9884 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  9885 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  9886 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  9887                                  %include	"time2.inc"
  9888                              <1> ;=========================================================================
  9889                              <1> ; time2.int - BIOS Time Services
  9890                              <1> ;       INT 1Ah - BIOS Time Serivces
  9891                              <1> ;		dispatcher
  9892                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  9893                              <1> ;-------------------------------------------------------------------------
  9894                              <1> ;
  9895                              <1> ; Compiles with NASM 2.07, might work with other versions
  9896                              <1> ;
  9897                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  9898                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  9899                              <1> ;
  9900                              <1> ; This program is free software: you can redistribute it and/or modify
  9901                              <1> ; it under the terms of the GNU General Public License as published by
  9902                              <1> ; the Free Software Foundation, either version 3 of the License, or
  9903                              <1> ; (at your option) any later version.
  9904                              <1> ;
  9905                              <1> ; This program is distributed in the hope that it will be useful,
  9906                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9907                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9908                              <1> ; GNU General Public License for more details.
  9909                              <1> ;
  9910                              <1> ; You should have received a copy of the GNU General Public License
  9911                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  9912                              <1> ;
  9913                              <1> ;=========================================================================
  9914                              <1> 
  9915                              <1> ;=========================================================================
  9916                              <1> ; int_1A - BIOS Time Services
  9917                              <1> ; Note: see time1.inc for functions implementation
  9918                              <1> ;-------------------------------------------------------------------------
  9919                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  9920                              <1> int_1A:
  9921 00007E6E 53                  <1> 	push	bx
  9922 00007E6F 1E                  <1> 	push	ds
  9923 00007E70 BB4000              <1> 	mov	bx,biosdseg
  9924 00007E73 8EDB                <1> 	mov	ds,bx
  9925 00007E75 80FC08              <1> 	cmp	ah,.max/2
  9926 00007E78 731B                <1> 	jae	int_1A_exit
  9927 00007E7A B700                <1> 	mov	bh,0
  9928 00007E7C 88E3                <1> 	mov	bl,ah
  9929 00007E7E D1E3                <1> 	shl	bx,1
  9930 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
  9931                              <1> .dispatch:
  9932 00007E85 [360C]              <1> 	dw	int_1A_fn00
  9933 00007E87 [480C]              <1> 	dw	int_1A_fn01
  9934 00007E89 [580C]              <1> 	dw	int_1A_fn02
  9935 00007E8B [8A0C]              <1> 	dw	int_1A_fn03
  9936 00007E8D [CF0C]              <1> 	dw	int_1A_fn04
  9937 00007E8F [FF0C]              <1> 	dw	int_1A_fn05
  9938 00007E91 [3E0D]              <1> 	dw	int_1A_fn06
  9939 00007E93 [8F0D]              <1> 	dw	int_1A_fn07
  9940                              <1> .max	equ	$-.dispatch
  9941                              <1> int_1A_exit:
  9942 00007E95 1F                  <1> 	pop	ds
  9943 00007E96 5B                  <1> 	pop	bx
  9944 00007E97 CF                  <1> 	iret
  9945                              <1> int_1A_exitf:
  9946 00007E98 1F                  <1> 	pop	ds
  9947 00007E99 5B                  <1> 	pop	bx
  9948 00007E9A CA0200              <1> 	retf	2
  9949                              <1> 
  9950                              <1> ;=========================================================================
  9951                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  9952                              <1> ;-------------------------------------------------------------------------
  9953 00007E9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
  9954          ******************  <1>  warning: (setloc:7) Inserting 8 bytes
  9955                              <1> int_08:
  9956 00007EA5 50                  <1> 	push	ax
  9957 00007EA6 1E                  <1> 	push	ds
  9958 00007EA7 B84000              <1> 	mov	ax,biosdseg
  9959 00007EAA 8ED8                <1> 	mov	ds,ax
  9960 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  9961 00007EB1 7413                <1> 	jz	.1
  9962 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  9963 00007EB7 750D                <1> 	jnz	.1
  9964 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  9965 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  9966 00007EC0 52                  <1> 	push	dx
  9967 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  9968 00007EC4 EE                  <1> 	out	dx,al
  9969 00007EC5 5A                  <1> 	pop	dx
  9970                              <1> .1:
  9971 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
  9972 00007ECA 7504                <1> 	jnz	.2
  9973 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
  9974                              <1> .2:
  9975 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  9976 00007ED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  9977 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  9978 00007EDD 7512                <1> 	jnz	.3
  9979 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
  9980 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
  9981 00007EEB C70670000100        <1> 	mov	word [new_day],1
  9982                              <1> .3:
  9983 00007EF1 CD1C                <1> 	int	1Ch			; User timer interrupt
  9984 00007EF3 B020                <1> 	mov	al,20h
  9985 00007EF5 E620                <1> 	out	pic1_reg0,al
  9986 00007EF7 1F                  <1> 	pop	ds
  9987 00007EF8 58                  <1> 	pop	ax
  9988 00007EF9 CF                  <1> 	iret
  9989                                  
  9990                                  ;=========================================================================
  9991                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  9992                                  ;-------------------------------------------------------------------------
  9993 00007EFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  9994          ******************       warning: (setloc:7) Inserting 41 bytes
  9995                                  int_ignore:
  9996 00007F23 50                      	push	ax
  9997 00007F24 1E                      	push	ds
  9998 00007F25 B84000                  	mov	ax,biosdseg
  9999 00007F28 8ED8                    	mov	ds,ax
 10000 00007F2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
 10001 00007F2C E620                    	out	pic1_reg0,al
 10002 00007F2E 90                      	nop
 10003 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
 10004 00007F31 88C4                    	mov	ah,al
 10005 00007F33 08C0                    	or	al,al
 10006 00007F35 7504                    	jnz	.1
 10007 00007F37 B4FF                    	mov	ah,0FFh
 10008 00007F39 EB0A                    	jmp	.2
 10009                                  .1:
 10010 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
 10011 00007F3D 08E0                    	or	al,ah
 10012 00007F3F E621                    	out	pic1_reg1,al
 10013 00007F41 B020                    	mov	al,20h			; end of interrupt
 10014 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
 10015                                  .2:
 10016 00007F45 88266B00                	mov	byte [last_irq],ah
 10017 00007F49 1F                      	pop	ds
 10018 00007F4A 58                      	pop	ax
 10019 00007F4B CF                      	iret
 10020                                  
 10021                                  ;=========================================================================
 10022                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
 10023                                  ;-------------------------------------------------------------------------
 10024 00007F4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
 10025          ******************       warning: (setloc:7) Inserting 7 bytes
 10026                                  int_dummy:
 10027 00007F53 CF                      	iret
 10028                                  
 10029                                  ;=========================================================================
 10030                                  ; int_05 - BIOS Print Screen
 10031                                  ;-------------------------------------------------------------------------
 10032                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
 10033                                  int_05:
 10034 00007F54 FB                      	sti
 10035 00007F55 50                      	push	ax
 10036 00007F56 53                      	push	bx
 10037 00007F57 51                      	push	cx
 10038 00007F58 52                      	push	dx
 10039 00007F59 1E                      	push	ds
 10040 00007F5A B84000                  	mov	ax,biosdseg
 10041 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
 10042 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
 10043 00007F64 746A                    	je	.exit			; print screen is already in progress
 10044 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
 10045                                  					; signal that print screen is running
 10046                                  
 10047 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
 10048 00007F6D CD10                    	int	10h			; returns number of columns in AH
 10049                                  					; and active display page in BH
 10050 00007F6F 88E1                    	mov	cl,ah			; store number columns
 10051                                  
 10052 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
 10053 00007F75 08ED                    	or	ch,ch
 10054 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
 10055                                  
 10056 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
 10057 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
 10058 00007F7E 7602                    	jbe	.get_cursor_pos
 10059                                  
 10060                                  .wrong_num_rows:
 10061 00007F80 B519                    	mov	ch,25			; assume 25 rows
 10062                                  
 10063                                  .get_cursor_pos:
 10064 00007F82 B403                    	mov	ah,03h			; get cursor position and size
 10065 00007F84 CD10                    	int	10h			; returns cursor position in DX
 10066 00007F86 52                      	push	dx			; save original position / DX in stack
 10067                                  
 10068                                  	
 10069 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
 10070 00007F89 E85100                  	call	.print_char
 10071 00007F8C 7548                    	jnz	.error
 10072 00007F8E B40A                    	mov	ah,0Ah
 10073 00007F90 E84A00                  	call	.print_char
 10074 00007F93 7541                    	jnz	.error
 10075                                  
 10076 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
 10077                                  
 10078                                  .row_loop:
 10079 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
 10080                                  
 10081                                  .column_loop:
 10082 00007F99 B402                    	mov	ah,02h
 10083 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
 10084                                  
 10085 00007F9D B408                    	mov	ah,08h
 10086 00007F9F CD10                    	int	10h			; read character at cursor position
 10087                                  
 10088 00007FA1 3C20                    	cmp	al,20h			; control character?
 10089 00007FA3 7302                    	jae	.continue		; no, print it
 10090 00007FA5 B020                    	mov	al,20h			; print space instead
 10091                                  
 10092                                  .continue:
 10093 00007FA7 E83300                  	call	.print_char
 10094 00007FAA 752A                    	jnz	.error
 10095 00007FAC FEC2                    	inc	dl
 10096 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
 10097 00007FB0 72E7                    	jb	.column_loop		; print next column
 10098                                  
 10099 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
 10100 00007FB4 E82600                  	call	.print_char
 10101 00007FB7 751D                    	jnz	.error
 10102 00007FB9 B40A                    	mov	ah,0Ah
 10103 00007FBB E81F00                  	call	.print_char
 10104 00007FBE 7516                    	jnz	.error
 10105                                  
 10106 00007FC0 FEC6                    	inc	dh
 10107 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
 10108 00007FC4 72D1                    	jb	.row_loop		; print next row
 10109                                  
 10110 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
 10111                                  					; ready for the next call
 10112                                  
 10113                                  .restore_cursor:
 10114 00007FCB 5A                      	pop	dx			; DX = original cursor position
 10115 00007FCC B402                    	mov	ah,02h
 10116 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
 10117                                  
 10118                                  .exit:
 10119 00007FD0 1F                      	pop	ds
 10120 00007FD1 5A                      	pop	dx
 10121 00007FD2 59                      	pop	cx
 10122 00007FD3 5B                      	pop	bx
 10123 00007FD4 58                      	pop	ax
 10124 00007FD5 CF                      	iret
 10125                                  
 10126                                  .error:
 10127 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
 10128                                  					; signal failure
 10129 00007FDB EBEE                    	jmp	.restore_cursor
 10130                                  	
 10131                                  
 10132                                  .print_char:
 10133 00007FDD 52                      	push	dx
 10134 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
 10135 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
 10136 00007FE2 CD17                    	int	17h
 10137 00007FE4 5A                      	pop	dx
 10138 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
 10139 00007FE8 C3                      	ret
 10140                                  
 10141                                  ;=========================================================================
 10142                                  ; start - at power up or reset execution starts here (F000:FFF0)
 10143                                  ;-------------------------------------------------------------------------
 10144 00007FE9 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
 10145          ******************       warning: (setloc:7) Inserting 7 bytes
 10146                                  start:
 10147 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
 10148                                  
 10149                                  	setloc	0FFF5h			; ROM Date in ASCII
 10150 00007FF5 31322F32362F3132        	db	DATE			; BIOS release date MM/DD/YY
 10151 00007FFD 20                      	db	20h
 10152                                  
 10153                                  	setloc	0FFFEh			; System Model
 10154                                  %ifdef AT_COMPAT
 10155 00007FFE FC                      	db	0fch			; system is an IBM AT compatible
 10156                                  %else
 10157                                  	db	0feh			; system is an IBM PC/XT compatible
 10158                                  %endif ; AT_COMPAT
 10159 00007FFF FF                      	db	0ffh
