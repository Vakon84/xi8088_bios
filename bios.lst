     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 - 2014 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.07, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
   108                                  %include "config.inc"
   109                              <1> ;=========================================================================
   110                              <1> ; config.inc - Compilation time settings and settings
   111                              <1> ;-------------------------------------------------------------------------
   112                              <1> ;
   113                              <1> ; Compiles with NASM 2.07, might work with other versions
   114                              <1> ;
   115                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   116                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   117                              <1> ;
   118                              <1> ; This program is free software: you can redistribute it and/or modify
   119                              <1> ; it under the terms of the GNU General Public License as published by
   120                              <1> ; the Free Software Foundation, either version 3 of the License, or
   121                              <1> ; (at your option) any later version.
   122                              <1> ;
   123                              <1> ; This program is distributed in the hope that it will be useful,
   124                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   125                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   126                              <1> ; GNU General Public License for more details.
   127                              <1> ;
   128                              <1> ; You should have received a copy of the GNU General Public License
   129                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   130                              <1> ;
   131                              <1> ;=========================================================================
   132                              <1> 
   133                              <1> %define DATE		'12/12/16'	; BIOS release date MM/DD/YY
   134                              <1> %define VERSION		'0.9.1'		; BIOS version
   135                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   136                              <1> 
   137                              <1> 
   138                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
   139                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   140                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   141                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   142                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   143                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   144                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   145                              <1> 					; EBDA is required for PS/2 aux support
   146                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   147                              <1> 
   148                              <1> 
   149                              <1> ;; %define TANDY_ID		; setup for minial Tandy 1000 id
   150                              <1> 
   151                                  %include "errno.inc"
   152                              <1> ;=========================================================================
   153                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   154                              <1> ;-------------------------------------------------------------------------
   155                              <1> ;
   156                              <1> ; Compiles with NASM 2.07, might work with other versions
   157                              <1> ;
   158                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   159                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   160                              <1> ;
   161                              <1> ; This program is free software: you can redistribute it and/or modify
   162                              <1> ; it under the terms of the GNU General Public License as published by
   163                              <1> ; the Free Software Foundation, either version 3 of the License, or
   164                              <1> ; (at your option) any later version.
   165                              <1> ;
   166                              <1> ; This program is distributed in the hope that it will be useful,
   167                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   168                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   169                              <1> ; GNU General Public License for more details.
   170                              <1> ;
   171                              <1> ; You should have received a copy of the GNU General Public License
   172                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   173                              <1> ;
   174                              <1> ;=========================================================================
   175                              <1> 
   176                              <1> e_boot		equ	00h		; Boot the OS
   177                              <1> e_start		equ	01h		; BIOS POST started
   178                              <1> e_cpu_ok	equ	02h		; CPU test passed
   179                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   180                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   181                              <1> e_int_ok	equ	05h		; interrupt table initialized
   182                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   183                              <1> e_pic_ok	equ	08h		; PIC initialized
   184                              <1> e_kbd_ok	equ	10h		; KBD test passed
   185                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   186                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   187                              <1> e_rtc_init_ok	equ	20h		; RTC initialized
   188                              <1> e_cpu_detect_ok	equ	21h		; CPU type detected
   189                              <1> e_fpu_detect_ok	equ	22h		; FPU type detected
   190                              <1> e_serial_ok	equ	24h		; Serial port scan finished
   191                              <1> e_parallel_ok	equ	25h		; Parallel port scan finished
   192                              <1> e_ram_start	equ	30h		; RAM test start
   193                              <1> e_ram_complete	equ	31h		; RAM test completed
   194                              <1> e_ram_esc	equ	32h		; RAM test canceled
   195                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   196                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found
   197                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   198                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   199                              <1> e_cpu_fail	equ	52h		; CPU test failed
   200                              <1> e_low_ram_fail	equ	54h		; low RAM test failed
   201                              <1> e_kbd_ctrl_fail	equ	60h		; KBD test - controller selftest failed
   202                              <1> e_kbd_key_fail	equ	61h		; KBD test - echo test failed
   203                              <1> e_kbd_timeout	equ	62h		; KBD timeout
   204                              <1> e_kbd_int_fail	equ	63h		; KBD test - interface test failed
   205                              <1> e_ram_fail	equ	80h		; RAM test failed
   206                                  
   207                                  bioscseg	equ	0F000h
   208                                  biosdseg	equ	0040h
   209                                  
   210                                  pic1_reg0	equ	20h
   211                                  pic1_reg1	equ	21h
   212                                  pit_ch0_reg	equ	40h
   213                                  pit_ch1_reg	equ	41h
   214                                  pit_ch2_reg	equ	42h
   215                                  pit_ctl_reg	equ	43h
   216                                  port_b_reg	equ	61h
   217                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   218                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   219                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   220                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   221                                  post_reg	equ	80h	; POST status output port
   222                                  pic2_reg0	equ	0A0h
   223                                  pic2_reg1	equ	0A1h
   224                                  
   225                                  %ifdef TANDY_ID
   226                                  unused_reg	equ 0xEE	; dont use 0xC0 for Tandy Sound card
   227                                  %else
   228                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   229                                  %endif
   230                                  
   231                                  cga_mode_reg	equ	3D8h
   232                                  mda_mode_reg	equ	3B8h
   233                                  
   234                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   235                                  
   236                                  ;========================================================================
   237                                  ; BIOS data area variables
   238                                  ;------------------------------------------------------------------------
   239                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   240                                  				; or 0 if port doesn't exist
   241                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   242                                  				; or 0 if port doesn't exist
   243                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   244                                  equipment_list	equ	10h	; word - equpment list
   245                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   246                                  equip_fpu	equ	0000000000000010b	; FPU installed
   247                                  equip_mouse	equ	0000000000000100b
   248                                  equip_video	equ	0000000000110000b	; video type bit mask
   249                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   250                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   251                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   252                                  		;			|||||||||||||||`-- floppy drives installed
   253                                  		;			||||||||||||||`-- FPU installed
   254                                  		;			|||||||||||||`-- PS/2 mouse installed
   255                                  		;			||||||||||||`-- reserved
   256                                  		;			||||||||||`--- initial video mode
   257                                  		;			||||||||`---- number of floppy drives - 1
   258                                  		;			|||||||`---- O = DMA installed
   259                                  		;			||||`------ number of serial ports
   260                                  		;			|||`------ game adapter installed
   261                                  		;			||`------ internal modem?!
   262                                  		;			`------- number of parallel ports
   263                                  
   264                                  post_flags	equ	12h	; byte - post flags
   265                                  post_setup	equ	01h	; run NVRAM setup
   266                                  memory_size	equ	13h	; word - memory size in KiB
   267                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   268                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   269                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   270                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   271                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   272                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   273                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   274                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   275                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   276                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   277                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   278                                  video_mode	equ	49h	; byte - active video mode number
   279                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   280                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   281                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   282                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   283                                  video_cur_shape	equ	60h	; word - cursor shape
   284                                  video_page	equ	62h	; byte - active video page
   285                                  video_port	equ	63h	; word - I/O port for the display adapter
   286                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   287                                  video_palet_reg	equ	66h	; byte - color palette
   288                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   289                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   290                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   291                                  new_day		equ	70h	; byte - 1 = new day flag
   292                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   293                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   294                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   295                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   296                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   297                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   298                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   299                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   300                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   301                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   302                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   303                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   304                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   305                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   306                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   307                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   308                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   309                                  
   310                                  ;=========================================================================
   311                                  ; Extended BIOS data area variables
   312                                  ;-------------------------------------------------------------------------
   313                                  ebda_size	equ	0h
   314                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   315                                  mouse_flags_1	equ	26h
   316                                  mouse_flags_2	equ	27h
   317                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   318                                  
   319                                  	org	START		; Use only upper 32 KiB of ROM
   320                                  
   321                                  ;=========================================================================
   322                                  ; Includes
   323                                  ;-------------------------------------------------------------------------
   324                                  %include	"messages.inc"		; POST messages
   325                              <1> ;=========================================================================
   326                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   327                              <1> ;-------------------------------------------------------------------------
   328                              <1> ;
   329                              <1> ; Compiles with NASM 2.07, might work with other versions
   330                              <1> ;
   331                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   332                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   333                              <1> ;
   334                              <1> ; This program is free software: you can redistribute it and/or modify
   335                              <1> ; it under the terms of the GNU General Public License as published by
   336                              <1> ; the Free Software Foundation, either version 3 of the License, or
   337                              <1> ; (at your option) any later version.
   338                              <1> ;
   339                              <1> ; This program is distributed in the hope that it will be useful,
   340                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   341                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   342                              <1> ; GNU General Public License for more details.
   343                              <1> ;
   344                              <1> ; You should have received a copy of the GNU General Public License
   345                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   346                              <1> ;
   347                              <1> ;=========================================================================
   348                              <1> 
   349 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   350 00000002 586920383038382042- <1> 				db	"Xi 8088 BIOS, Version "
   351 0000000B 494F532C2056657273- <1>
   352 00000014 696F6E20            <1>
   353 00000018 302E392E31          <1> 				db	VERSION
   354 0000001D 2E20                <1> 				db	". "
   355 0000001F 436F70797269676874- <1> 				db	"Copyright (C) 2010 - 2014 Sergey Kiselev", 0Dh, 0Ah
   356 00000028 202843292032303130- <1>
   357 00000031 202D20323031342053- <1>
   358 0000003A 6572676579204B6973- <1>
   359 00000043 656C65760D0A        <1>
   360 00000049 446973747269627574- <1> 				db	"Distributed under the terms of the GNU General Public License", 0Dh, 0Ah
   361 00000052 656420756E64657220- <1>
   362 0000005B 746865207465726D73- <1>
   363 00000064 206F66207468652047- <1>
   364 0000006D 4E552047656E657261- <1>
   365 00000076 6C205075626C696320- <1>
   366 0000007F 4C6963656E73650D0A  <1>
   367 00000088 0D0A00              <1> msg_crlf		db      0Dh, 0Ah, 00h
   368 0000008B 6E6F6E6500          <1> msg_none		db	'none', 00h
   369 00000090 3A2000              <1> msg_colon		db	': ', 00h
   370 00000093 3B2000              <1> msg_semicolon	db	'; ', 00h
   371 00000096 50726F636573736F72- <1> msg_cpu			db      'Processor:                  ', 00h
   372 0000009F 3A2020202020202020- <1>
   373 000000A8 202020202020202020- <1>
   374 000000B1 2000                <1>
   375                              <1> ;msg_fpu		db      'Mathematics Co-processor:   ', 00h
   376                              <1> 
   377 000000B3 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78 (buggy)", 0 
   378 000000BC 382027373820286275- <1>
   379 000000C5 6767792900          <1>
   380 000000CA 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81+, or OKI 80C88", 0
   381 000000D3 38202738312B2C206F- <1>
   382 000000DC 72204F4B4920383043- <1>
   383 000000E5 383800              <1>
   384 000000E8 486172726973203830- <1> msg_cpu_harris  db      'Harris 80C88', 0
   385 000000F1 43383800            <1>
   386 000000F5 4E45432056323000    <1> msg_cpu_nec_v20 db      'NEC V20', 0
   387 000000FD 2C2038303837204650- <1> msg_fpu_present db      ', 8087 FPU', 0Dh, 0Ah, 00h
   388 00000106 550D0A00            <1>
   389 0000010A 2C204E6F204650550D- <1> msg_no_fpu		db      ', No FPU', 0Dh, 0Ah, 0
   390 00000113 0A00                <1>
   391                              <1> 
   392 00000115 2028547572626F204F- <1> msg_turbo		db      ' (Turbo O',0
   393 0000011E 00                  <1>
   394 0000011F 4E2900              <1> msg_turbo_on	db      'N)', 0
   395 00000122 46462900            <1> msg_turbo_off	db      'FF)', 0
   396                              <1> 
   397 00000126 446973706C61792041- <1> msg_disp		db      'Display Adapter Type:       ', 00h
   398 0000012F 646170746572205479- <1>
   399 00000138 70653A202020202020- <1>
   400 00000141 2000                <1>
   401 00000143 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   402 0000014C 566964656F2042494F- <1>
   403 00000155 532050726573656E74- <1>
   404 0000015E 290D0A00            <1>
   405 00000162 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   406 00000168 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   407 00000171 7263756C65730D0A00  <1>
   408 0000017A 52544320285265616C- <1> msg_rtc			db	'RTC (Real Time Clock) time: ', 00h
   409 00000183 2054696D6520436C6F- <1>
   410 0000018C 636B292074696D653A- <1>
   411 00000195 2000                <1>
   412 00000197 466C6F707079206469- <1> msg_floppy		db	'Floppy disk drives:         Drive 0: ', 00h
   413 000001A0 736B20647269766573- <1>
   414 000001A9 3A2020202020202020- <1>
   415 000001B2 20447269766520303A- <1>
   416 000001BB 2000                <1>
   417 000001BD 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   418 000001C6 3A2000              <1>
   419 000001C9 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   420 000001D2 2E32352200          <1>
   421 000001D7 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   422 000001E0 2E32352200          <1>
   423 000001E5 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   424 000001EE 2E352200            <1>
   425 000001F2 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   426 000001FB 332E352200          <1>
   427 00000200 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   428 00000209 332E352200          <1>
   429 0000020E 50532F322041757820- <1> msg_mouse		db      'PS/2 Aux Device (Mouse):    ', 00h
   430 00000217 44657669636520284D- <1>
   431 00000220 6F757365293A202020- <1>
   432 00000229 2000                <1>
   433 0000022B 50726573656E740D0A- <1> msg_present		db      'Present', 0Dh, 0Ah, 00h
   434 00000234 00                  <1>
   435 00000235 416273656E740D0A00  <1> msg_absent		db      'Absent', 0Dh, 0Ah, 00h
   436 0000023E 53657269616C20506F- <1> msg_serial		db	'Serial Ports:               ', 00h
   437 00000247 7274733A2020202020- <1>
   438 00000250 202020202020202020- <1>
   439 00000259 2000                <1>
   440 0000025B 434F4D00            <1> msg_serial_com	db	'COM', 00h
   441 0000025F 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   442 00000268 506F7274733A202020- <1>
   443 00000271 202020202020202020- <1>
   444 0000027A 2000                <1>
   445 0000027C 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   446 00000280 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   447 00000289 414D20284553432074- <1>
   448 00000292 6F20736B6970293A20- <1>
   449 0000029B 2000                <1>
   450 0000029D 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   451 000002A6 4661756C7479206D65- <1>
   452 000002AF 6D6F72792064657465- <1>
   453 000002B8 637465642061742000  <1>
   454                              <1> 
   455 000002C1 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   456 000002CA 6E76656E74696F6E61- <1>
   457 000002D3 6C2052414D3A202020- <1>
   458 000002DC 202000              <1>
   459 000002DF 2C20454244413A2000  <1> msg_ebda		db      ', EBDA: ', 0
   460 000002E8 2C20417661696C6162- <1> msg_ram_avail	db      ', Available: ', 00h
   461 000002F1 6C653A2000          <1>
   462 000002F6 206B6200            <1> msg_kibx		db      ' kb', 00h
   463                              <1> 
   464 000002FA 206B620D0A00        <1> msg_kib			db      ' kb', 0Dh, 0Ah, 00h
   465                              <1> 
   466 00000300 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   467 00000309 65642C207072657373- <1>
   468 00000312 20616E79206B657920- <1>
   469 0000031B 746F20747279206167- <1>
   470 00000324 61696E2E2E2E0D0A00  <1>
   471 0000032D 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   472 00000336 5349430D0A00        <1>
   473 0000033C 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   474 00000345 5320657874656E7369- <1>
   475 0000034E 6F6E20524F4D206174- <1>
   476 00000357 2000                <1>
   477 00000359 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   478 00000362 6C697A696E672E2E2E- <1>
   479 0000036B 0D0A00              <1>
   480 0000036E 426F6F74696E67204F- <1> msg_boot		db      'Booting OS...', 0Dh, 0Ah, 0
   481 00000377 532E2E2E0D0A00      <1>
   482 0000037E 4552524F523A205254- <1> msg_rtc_bad		db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   483 00000387 432062617474657279- <1>
   484 00000390 206973206261640D0A- <1>
   485 00000399 00                  <1>
   486 0000039A 4552524F523A204E56- <1> msg_rtc_sum		db	'ERROR: NVRAM checksum is invalid, '
   487 000003A3 52414D20636865636B- <1>
   488 000003AC 73756D20697320696E- <1>
   489 000003B5 76616C69642C20      <1>
   490 000003BC 6C6F6164696E672064- <1> 				db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   491 000003C5 656661756C74207661- <1>
   492 000003CE 6C75657320746F204E- <1>
   493 000003D7 5652414D0D0A00      <1>
   494 000003DE 507265737320463120- <1> msg_setup		db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   495 000003E7 746F2072756E204E56- <1>
   496 000003F0 52414D207365747570- <1>
   497 000003F9 2E2E2E0D0A0D0A00    <1>
   498 00000401 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the NVRAM setup utility', 00h
   499 0000040A 20746F20746865204E- <1>
   500 00000413 5652414D2073657475- <1>
   501 0000041C 70207574696C697479- <1>
   502 00000425 00                  <1>
   503 00000426 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   504 00000428 4E5652414D20736574- <1> 				db	'NVRAM setup commands:', 0Dh, 0Ah
   505 00000431 757020636F6D6D616E- <1>
   506 0000043A 64733A0D0A          <1>
   507 0000043F 74202D205365742074- <1> 				db	't - Set time', 0Dh, 0Ah
   508 00000448 696D650D0A          <1>
   509 0000044D 64202D205365742064- <1> 				db	'd - Set date', 0Dh, 0Ah
   510 00000456 6174650D0A          <1>
   511 0000045B 66202D204368616E67- <1> 				db	'f - Change first floppy drive type', 0Dh, 0Ah
   512 00000464 652066697273742066- <1>
   513 0000046D 6C6F70707920647269- <1>
   514 00000476 766520747970650D0A  <1>
   515 0000047F 67202D204368616E67- <1> 				db	'g - Change second floppy drive type', 0Dh, 0Ah
   516 00000488 65207365636F6E6420- <1>
   517 00000491 666C6F707079206472- <1>
   518 0000049A 69766520747970650D- <1>
   519 000004A3 0A                  <1>
   520 000004A4 70202D205072696E74- <1> 				db	'p - Print current settings', 0Dh, 0Ah
   521 000004AD 2063757272656E7420- <1>
   522 000004B6 73657474696E67730D- <1>
   523 000004BF 0A                  <1>
   524 000004C0 77202D205361766520- <1> 				db	'w - Save changes and exit', 0Dh, 0Ah
   525 000004C9 6368616E6765732061- <1>
   526 000004D2 6E6420657869740D0A  <1>
   527 000004DB 71202D204578697420- <1> 				db	'q - Exit without saving changes', 0Dh, 0Ah
   528 000004E4 776974686F75742073- <1>
   529 000004ED 6176696E6720636861- <1>
   530 000004F6 6E6765730D0A        <1>
   531 000004FC 68202D2053686F7720- <1> 				db	'h - Show this help', 0Dh, 0Ah, 00h
   532 00000505 746869732068656C70- <1>
   533 0000050E 0D0A00              <1>
   534 00000511 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   535 0000051A 6F6D6D616E64202868- <1>
   536 00000523 20666F722068656C70- <1>
   537 0000052C 293A2000            <1>
   538 00000530 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   539 00000539 65202868683A6D6D3A- <1>
   540 00000542 7373293A2000        <1>
   541 00000548 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   542 00000551 652028595959592D4D- <1>
   543 0000055A 4D2D4444293A2000    <1>
   544 00000562 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   545 0000056B 76616C69642074696D- <1>
   546 00000574 652E0D0A00          <1>
   547 00000579 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   548 00000582 76616C696420646174- <1>
   549 0000058B 652E0D0A00          <1>
   550 00000590 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   551 00000592 466C6F707079206472- <1> 				db	'Floppy drive types:', 0Dh, 0Ah
   552 0000059B 697665207479706573- <1>
   553 000005A4 3A0D0A              <1>
   554 000005A7 30202D204E6F742069- <1> 				db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   555 000005B0 6E7374616C6C656420- <1>
   556 000005B9 202033202D20373230- <1>
   557 000005C2 204B422C20332E3522- <1>
   558 000005CB 0D0A                <1>
   559 000005CD 31202D20333630204B- <1> 				db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   560 000005D6 422C20352E32352220- <1>
   561 000005DF 202034202D20312E34- <1>
   562 000005E8 34204D422C20332E35- <1>
   563 000005F1 220D0A              <1>
   564 000005F4 32202D20312E32204D- <1> 				db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   565 000005FD 422C20352E32352220- <1>
   566 00000606 202036202D20322E38- <1>
   567 0000060F 38204D422C20332E35- <1>
   568 00000618 220D0A              <1>
   569 0000061B 536574757020636F6D- <1> 				db	'Setup commands:', 0Dh, 0Ah
   570 00000624 6D616E64733A0D0A    <1>
   571 0000062C 72202D205265747572- <1> 				db	'r - Return to the main menu', 0Dh, 0Ah
   572 00000635 6E20746F2074686520- <1>
   573 0000063E 6D61696E206D656E75- <1>
   574 00000647 0D0A                <1>
   575 00000649 68202D2053686F7720- <1> 				db	'h - Show this help', 0Dh, 0Ah, 00h
   576 00000652 746869732068656C70- <1>
   577 0000065B 0D0A00              <1>
   578 0000065E 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   579 00000667 6C6F70707920647269- <1>
   580 00000670 766520747970652028- <1>
   581 00000679 6820666F722068656C- <1>
   582 00000682 70293A20            <1>
   583 00000686 00                  <1> 		db	00h
   584 00000687 [8B00]              <1> tbl_floppy	dw	msg_none
   585 00000689 [C901]              <1> 		dw	msg_floppy_360
   586 0000068B [D701]              <1> 		dw	msg_floppy_1200
   587 0000068D [E501]              <1> 		dw	msg_floppy_720
   588 0000068F [F201]              <1> 		dw	msg_floppy_1440
   589 00000691 [8B00]              <1> 		dw	msg_none
   590 00000693 [0002]              <1> 		dw	msg_floppy_2880
   591 00000695 [8B00]              <1> 		dw	msg_none
   592                                  %include	"fnt80-FF.inc"		; font for graphics modes
   593                              <1> ;=========================================================================
   594                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   595                              <1> ;       Characters from 80h to 0FFh
   596                              <1> ;-------------------------------------------------------------------------
   597                              <1> ;
   598                              <1> ; Compiles with NASM 2.07, might work with other versions
   599                              <1> ;
   600                              <1> ; This font is borrowed from kbd package (alt-8x8)
   601                              <1> ;
   602                              <1> ; This program is free software: you can redistribute it and/or modify
   603                              <1> ; it under the terms of the GNU General Public License as published by
   604                              <1> ; the Free Software Foundation, either version 3 of the License, or
   605                              <1> ; (at your option) any later version.
   606                              <1> ;
   607                              <1> ; This program is distributed in the hope that it will be useful,
   608                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   609                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   610                              <1> ; GNU General Public License for more details.
   611                              <1> ;
   612                              <1> ; You should have received a copy of the GNU General Public License
   613                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   614                              <1> ;
   615                              <1> ;=========================================================================
   616                              <1> int_1F:
   617 00000697 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   618 0000069F 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   619 000006A7 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   620 000006AF 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   621 000006B7 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   622 000006BF 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   623 000006C7 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   624 000006CF 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   625 000006D7 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   626 000006DF 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   627 000006E7 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   628 000006EF 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   629 000006F7 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   630 000006FF 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   631 00000707 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   632 0000070F 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   633 00000717 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   634 0000071F 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   635 00000727 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   636 0000072F 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   637 00000737 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   638 0000073F 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   639 00000747 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   640 0000074F 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   641 00000757 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   642 0000075F DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   643 00000767 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   644 0000076F C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   645 00000777 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   646 0000077F 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   647 00000787 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   648 0000078F 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   649 00000797 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   650 0000079F 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   651 000007A7 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   652 000007AF 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   653 000007B7 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   654 000007BF 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   655 000007C7 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   656 000007CF 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   657 000007D7 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   658 000007DF 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   659 000007E7 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   660 000007EF 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   661 000007F7 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   662 000007FF 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   663 00000807 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   664 0000080F 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   665 00000817 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   666 0000081F 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   667 00000827 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   668 0000082F 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   669 00000837 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   670 0000083F 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   671 00000847 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   672 0000084F 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   673 00000857 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   674 0000085F 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   675 00000867 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   676 0000086F 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   677 00000877 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   678 0000087F 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   679 00000887 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   680 0000088F 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   681 00000897 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   682 0000089F 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   683 000008A7 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   684 000008AF 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   685 000008B7 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   686 000008BF 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   687 000008C7 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   688 000008CF 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   689 000008D7 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   690 000008DF 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   691 000008E7 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   692 000008EF 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   693 000008F7 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   694 000008FF 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   695 00000907 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   696 0000090F 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   697 00000917 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   698 0000091F 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   699 00000927 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   700 0000092F 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   701 00000937 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   702 0000093F 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   703 00000947 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   704 0000094F 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   705 00000957 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   706 0000095F 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   707 00000967 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   708 0000096F FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   709 00000977 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   710 0000097F F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   711 00000987 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   712 0000098F FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   713 00000997 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   714 0000099F 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   715 000009A7 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   716 000009AF 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   717 000009B7 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   718 000009BF 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   719 000009C7 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   720 000009CF 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   721 000009D7 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   722 000009DF 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   723 000009E7 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   724 000009EF 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   725 000009F7 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   726 000009FF 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   727 00000A07 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   728 00000A0F 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   729 00000A17 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   730 00000A1F 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   731 00000A27 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   732 00000A2F 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   733 00000A37 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   734 00000A3F 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   735 00000A47 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   736 00000A4F 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   737 00000A57 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   738 00000A5F 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   739 00000A67 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   740 00000A6F 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   741 00000A77 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   742 00000A7F 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   743 00000A87 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   744 00000A8F 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   745                                  ;%include	"inttrace.inc"		; XXX
   746                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   747                              <1> ;=========================================================================
   748                              <1> ; rtc.inc - RTC/CMOS read and write functions
   749                              <1> ;-------------------------------------------------------------------------
   750                              <1> ;
   751                              <1> ; Compiles with NASM 2.07, might work with other versions
   752                              <1> ;
   753                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   754                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   755                              <1> ;
   756                              <1> ; This program is free software: you can redistribute it and/or modify
   757                              <1> ; it under the terms of the GNU General Public License as published by
   758                              <1> ; the Free Software Foundation, either version 3 of the License, or
   759                              <1> ; (at your option) any later version.
   760                              <1> ;
   761                              <1> ; This program is distributed in the hope that it will be useful,
   762                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   763                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   764                              <1> ; GNU General Public License for more details.
   765                              <1> ;
   766                              <1> ; You should have received a copy of the GNU General Public License
   767                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   768                              <1> ;
   769                              <1> ;=========================================================================
   770                              <1> 
   771                              <1> ;-------------------------------------------------------------------------
   772                              <1> ; RTC ports
   773                              <1> rtc_addr_reg	equ	70h	; RTC address port
   774                              <1> rtc_data_reg	equ	71h	; RTC data port
   775                              <1> 
   776                              <1> ;-------------------------------------------------------------------------
   777                              <1> ; locations in RTC and NVRAM
   778                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   779                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   780                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   781                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   782                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   783                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   784                              <1> cmos_day	equ	06h	; day location in RTC
   785                              <1> cmos_date	equ	07h	; date location in RTC
   786                              <1> cmos_month	equ	08h	; month location in RTC
   787                              <1> cmos_year	equ	09h	; year location in RTC
   788                              <1> cmos_floppy	equ	10h	; floppy type byte
   789                              <1> cmos_equip	equ	14h	; equipment byte
   790                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   791                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   792                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   793                              <1> 
   794                              <1> ;-------------------------------------------------------------------------
   795                              <1> ; RTC control register and their bits
   796                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   797                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   798                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   799                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   800                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   801                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   802                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   803                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   804                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   805                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   806                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   807                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   808                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   809                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   810                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   811                              <1> 
   812                              <1> ;-------------------------------------------------------------------------
   813                              <1> ; NMI flag
   814                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   815                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   816                              <1> 
   817                              <1> ;=========================================================================
   818                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   819                              <1> ; Input:
   820                              <1> ;	AL - address and NMI enable bit
   821                              <1> ;		bits 6-0 - address of byte to read
   822                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   823                              <1> ; Output:
   824                              <1> ;	AL = byte from RTC
   825                              <1> ;-------------------------------------------------------------------------
   826                              <1> rtc_read:
   827 00000A97 FA                  <1> 	cli
   828 00000A98 E670                <1> 	out	rtc_addr_reg,al
   829 00000A9A EB00                <1> 	jmp	$+2
   830 00000A9C EB00                <1> 	jmp	$+2
   831                              <1> 	;; SGEO increased pause here, seems to fix my FF byte issue...
   832 00000A9E EB00                <1> 	jmp	$+2
   833 00000AA0 EB00                <1> 	jmp	$+2
   834 00000AA2 E471                <1> 	in	al,rtc_data_reg
   835 00000AA4 FB                  <1> 	sti
   836 00000AA5 C3                  <1> 	ret
   837                              <1> 
   838                              <1> ;=========================================================================
   839                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   840                              <1> ; Input:
   841                              <1> ;	AL - address and NMI enable bit
   842                              <1> ;		bits 6-0 - address of byte to read
   843                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   844                              <1> ;	AH = byte to write to RTC
   845                              <1> ;-------------------------------------------------------------------------
   846                              <1> rtc_write:
   847 00000AA6 FA                  <1> 	cli
   848 00000AA7 E670                <1> 	out	rtc_addr_reg,al
   849 00000AA9 EB00                <1> 	jmp	$+2
   850 00000AAB EB00                <1> 	jmp	$+2
   851 00000AAD 86E0                <1> 	xchg	ah,al
   852 00000AAF E671                <1> 	out	rtc_data_reg,al
   853 00000AB1 86E0                <1> 	xchg	ah,al
   854 00000AB3 FB                  <1> 	sti
   855 00000AB4 C3                  <1> 	ret
   856                              <1> 
   857                              <1> ;=========================================================================
   858                              <1> ; rtc_init - Initialize RTC
   859                              <1> ; Notes:
   860                              <1> ;	- makes sure RTC battery is OK, resets time if not
   861                              <1> ;	- disables RTC interrupts
   862                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   863                              <1> ;-------------------------------------------------------------------------
   864                              <1> rtc_init:
   865 00000AB5 50                  <1> 	push	ax
   866 00000AB6 53                  <1> 	push	bx
   867 00000AB7 51                  <1> 	push	cx
   868 00000AB8 52                  <1> 	push	dx
   869 00000AB9 56                  <1> 	push	si
   870 00000ABA 57                  <1> 	push	di
   871 00000ABB B00A                <1> 	mov	al,cmos_control_a	; select control A register
   872 00000ABD B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   873                              <1> 					; set SQW frequency to 1.024 KHz
   874 00000ABF E8E4FF              <1> 	call	rtc_write		; write control register A
   875                              <1> 
   876 00000AC2 B00B                <1> 	mov	al,cmos_control_b
   877 00000AC4 B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   878                              <1> 					; interrupts disabled
   879 00000AC6 E8DDFF              <1> 	call	rtc_write		; write control register B
   880                              <1> 
   881 00000AC9 B00C                <1> 	mov	al,cmos_control_c
   882 00000ACB E8C9FF              <1> 	call	rtc_read		; read control register C - reset
   883                              <1> 					; interrupt flags
   884                              <1> 
   885 00000ACE B00D                <1> 	mov	al,cmos_control_d
   886 00000AD0 E8C4FF              <1> 	call	rtc_read		; read control register D
   887 00000AD3 A880                <1> 	test	al,cmos_vrt
   888 00000AD5 7518                <1> 	jnz	.1			; RTC battery is OK
   889 00000AD7 BE[7E03]            <1> 	mov	si,msg_rtc_bad
   890 00000ADA E8B31A              <1> 	call	print
   891                              <1> ; RTC is bad, set initial time
   892 00000ADD B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   893 00000ADF 31C9                <1> 	xor	cx,cx
   894 00000AE1 31D2                <1> 	xor	dx,dx
   895 00000AE3 CD1A                <1> 	int	1Ah
   896 00000AE5 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   897 00000AE7 B91020              <1> 	mov	cx,2010h		; year 2010
   898 00000AEA BA0101              <1> 	mov	dx,0101h		; January 1st
   899 00000AED CD1A                <1> 	int	1Ah
   900                              <1> 
   901                              <1> .1:
   902                              <1> ; set timer variables to RTC time
   903 00000AEF B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   904 00000AF1 CD1A                <1> 	int	1Ah
   905                              <1> 
   906                              <1> ; convert time to ticks * 2^11
   907                              <1> 
   908                              <1> ; ticks = seconds * 37287
   909 00000AF3 88F0                <1> 	mov	al,dh
   910 00000AF5 E8AE00              <1> 	call	bcd_to_binary		; convert seconds to binary
   911                              <1> 
   912 00000AF8 BAA791              <1> 	mov	dx,37287
   913 00000AFB F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   914                              <1> 
   915 00000AFD 89C6                <1> 	mov	si,ax
   916 00000AFF 89D7                <1> 	mov	di,dx
   917                              <1> 
   918                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   919 00000B01 88C8                <1> 	mov	al,cl
   920 00000B03 E8A000              <1> 	call	bcd_to_binary		; convert minutes to binary
   921                              <1> 
   922 00000B06 89C3                <1> 	mov	bx,ax
   923 00000B08 BA2023              <1> 	mov	dx,8992
   924 00000B0B F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   925                              <1> 
   926 00000B0D 01C6                <1> 	add	si,ax
   927 00000B0F 11D7                <1> 	adc	di,dx
   928                              <1> 
   929 00000B11 89D8                <1> 	mov	ax,bx
   930 00000B13 BA2200              <1> 	mov	dx,34
   931 00000B16 F7E2                <1> 	mul	dx
   932                              <1> 
   933 00000B18 01C7                <1> 	add	di,ax
   934                              <1> 
   935                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   936 00000B1A 88E8                <1> 	mov	al,ch
   937 00000B1C E88700              <1> 	call	bcd_to_binary		; convert hours to binary
   938                              <1> 
   939 00000B1F 89C3                <1> 	mov	bx,ax
   940 00000B21 BA6A3B              <1> 	mov	dx,15210
   941 00000B24 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   942                              <1> 
   943 00000B26 01C6                <1> 	add	si,ax
   944 00000B28 11D7                <1> 	adc	di,dx
   945                              <1> 
   946 00000B2A 89D8                <1> 	mov	ax,bx
   947 00000B2C BA0008              <1> 	mov	dx,2048
   948 00000B2F F7E2                <1> 	mul	dx			; AX = hours * 2048
   949                              <1> 
   950 00000B31 01C7                <1> 	add	di,ax
   951                              <1> 
   952                              <1> ; CX:DX = DI:SI / 2048
   953 00000B33 B10B                <1> 	mov	cl,11
   954 00000B35 D3EE                <1> 	shr	si,cl
   955 00000B37 89FA                <1> 	mov	dx,di
   956 00000B39 B105                <1> 	mov	cl,5
   957 00000B3B D3E2                <1> 	shl	dx,cl
   958 00000B3D 09F2                <1> 	or	dx,si
   959                              <1> 
   960 00000B3F B10B                <1> 	mov	cl,11
   961 00000B41 D3EF                <1> 	shr	di,cl
   962 00000B43 89F9                <1> 	mov	cx,di
   963                              <1> 
   964                              <1> 					; CX = high word of tick count
   965                              <1> 					; DX = low word of tick count
   966                              <1> 	
   967 00000B45 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   968 00000B47 CD1A                <1> 	int	1Ah	
   969                              <1> 
   970                              <1> 
   971                              <1> ; compare NVRAM checksum with stored value
   972                              <1> 
   973 00000B49 E86C00              <1> 	call	rtc_checksum
   974                              <1> 
   975 00000B4C B02E                <1> 	mov	al,cmos_sum_hi
   976 00000B4E E846FF              <1> 	call	rtc_read
   977 00000B51 88C4                <1> 	mov	ah,al
   978 00000B53 B02F                <1> 	mov	al,cmos_sum_lo
   979 00000B55 E83FFF              <1> 	call	rtc_read
   980 00000B58 39C3                <1> 	cmp	bx,ax
   981 00000B5A 742F                <1> 	je	.update_equipment
   982                              <1> 
   983 00000B5C BE[9A03]            <1> 	mov	si,msg_rtc_sum
   984 00000B5F E82E1A              <1> 	call	print
   985                              <1> 
   986                              <1> ; clear NVRAM
   987                              <1> 
   988 00000B62 B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   989                              <1> 
   990                              <1> .nvram_clear_loop:
   991 00000B65 E83EFF              <1> 	call	rtc_write
   992 00000B68 FEC0                <1> 	inc	al
   993 00000B6A 3C20                <1> 	cmp	al,20h			; last address is 20h
   994 00000B6C 76F7                <1> 	jbe	.nvram_clear_loop
   995                              <1> 
   996 00000B6E B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   997 00000B71 E832FF              <1> 	call	rtc_write
   998                              <1> 
   999 00000B74 B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
  1000 00000B77 E82CFF              <1> 	call	rtc_write
  1001                              <1> 
  1002                              <1> ; update checksum
  1003                              <1> 
  1004 00000B7A E83B00              <1> 	call	rtc_checksum
  1005                              <1> 
  1006 00000B7D B02E                <1> 	mov	al,cmos_sum_hi
  1007 00000B7F 88FC                <1> 	mov	ah,bh
  1008 00000B81 E822FF              <1> 	call	rtc_write
  1009                              <1> 
  1010 00000B84 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1011 00000B86 88DC                <1> 	mov	ah,bl
  1012 00000B88 E81BFF              <1> 	call	rtc_write
  1013                              <1> 
  1014                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
  1015                              <1> 
  1016                              <1> .update_equipment:
  1017 00000B8B B014                <1> 	mov	al,cmos_equip
  1018 00000B8D E807FF              <1> 	call	rtc_read
  1019 00000B90 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
  1020 00000B92 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
  1021 00000B97 08061000            <1> 	or	byte [equipment_list],al
  1022                              <1> 
  1023 00000B9B B020                <1> 	mov	al,e_rtc_init_ok	; RTC initialzied successfully
  1024 00000B9D E680                <1> 	out	post_reg,al
  1025                              <1> 
  1026 00000B9F 5F                  <1> 	pop	di
  1027 00000BA0 5E                  <1> 	pop	si
  1028 00000BA1 5A                  <1> 	pop	dx
  1029 00000BA2 59                  <1> 	pop	cx
  1030 00000BA3 5B                  <1> 	pop	bx
  1031 00000BA4 58                  <1> 	pop	ax
  1032 00000BA5 C3                  <1> 	ret
  1033                              <1> 
  1034                              <1> bcd_to_binary:
  1035 00000BA6 51                  <1> 	push	cx
  1036 00000BA7 88C5                <1> 	mov	ch,al
  1037 00000BA9 80E50F              <1> 	and	ch,0Fh
  1038 00000BAC B104                <1> 	mov	cl,4
  1039 00000BAE D2E8                <1> 	shr	al,cl
  1040 00000BB0 B10A                <1> 	mov	cl,10
  1041 00000BB2 F6E1                <1> 	mul	cl
  1042 00000BB4 00E8                <1> 	add	al,ch
  1043 00000BB6 59                  <1> 	pop	cx
  1044 00000BB7 C3                  <1> 	ret
  1045                              <1> 
  1046                              <1> ;=========================================================================
  1047                              <1> ; rtc_checksum - calculate NVRAM checksum
  1048                              <1> ; Input:
  1049                              <1> ;	none
  1050                              <1> ; Output:
  1051                              <1> ;	BX = NVRAM checksum
  1052                              <1> ;-------------------------------------------------------------------------
  1053                              <1> rtc_checksum:
  1054 00000BB8 50                  <1> 	push	ax
  1055 00000BB9 31DB                <1> 	xor	bx,bx
  1056 00000BBB B410                <1> 	mov	ah,10h			; start from 10h
  1057                              <1> 
  1058                              <1> .checksum_loop:
  1059 00000BBD 88E0                <1> 	mov	al,ah
  1060 00000BBF E8D5FE              <1> 	call	rtc_read
  1061 00000BC2 00C3                <1> 	add	bl,al			; BX += AL
  1062 00000BC4 80D700              <1> 	adc	bh,0
  1063 00000BC7 FEC4                <1> 	inc	ah
  1064 00000BC9 80FC20              <1> 	cmp	ah,20h			; last address is 20h
  1065 00000BCC 76EF                <1> 	jbe	.checksum_loop
  1066 00000BCE 58                  <1> 	pop	ax
  1067 00000BCF C3                  <1> 	ret
  1068                              <1> 
  1069                              <1> ;=========================================================================
  1070                              <1> ; rtc_setup - NVRAM configuration utility
  1071                              <1> ; Input:
  1072                              <1> ;	none
  1073                              <1> ; Output:
  1074                              <1> ;	none
  1075                              <1> ;-------------------------------------------------------------------------
  1076                              <1> rtc_setup:
  1077 00000BD0 50                  <1> 	push	ax
  1078 00000BD1 53                  <1> 	push	bx
  1079 00000BD2 51                  <1> 	push	cx
  1080 00000BD3 52                  <1> 	push	dx
  1081 00000BD4 56                  <1> 	push	si
  1082                              <1> 
  1083 00000BD5 B010                <1> 	mov	al,cmos_floppy
  1084 00000BD7 E8BDFE              <1> 	call	rtc_read		; read currently configured floppies
  1085 00000BDA 88C1                <1> 	mov	cl,al			; save it to CL
  1086 00000BDC BE[0104]            <1> 	mov	si,msg_set_welcome
  1087 00000BDF E8AE19              <1> 	call	print
  1088                              <1> 
  1089                              <1> .menu_loop:
  1090 00000BE2 BE[1105]            <1> 	mov	si,msg_set_prompt
  1091 00000BE5 E8A819              <1> 	call	print
  1092                              <1> 
  1093                              <1> .menu_input:
  1094 00000BE8 B400                <1> 	mov	ah,00h
  1095 00000BEA CD16                <1> 	int	16h
  1096 00000BEC 0C20                <1> 	or	al,20h			; convert to lower case
  1097 00000BEE B200                <1> 	mov	dl,0			; floppy 0
  1098 00000BF0 3C66                <1> 	cmp	al,'f'
  1099 00000BF2 743E                <1> 	je	.set_floppy
  1100 00000BF4 FEC2                <1> 	inc	dl			; floppy 1
  1101 00000BF6 3C67                <1> 	cmp	al,'g'
  1102 00000BF8 7438                <1> 	je	.set_floppy
  1103 00000BFA 3C70                <1> 	cmp	al,'p'
  1104 00000BFC 7503E99100          <1> 	je	.print_settings
  1105 00000C01 3C74                <1> 	cmp	al,'t'
  1106 00000C03 7503E9A200          <1> 	je	.set_time
  1107 00000C08 3C64                <1> 	cmp	al,'d'
  1108 00000C0A 7503E91301          <1> 	je	.set_date
  1109 00000C0F 3C77                <1> 	cmp	al,'w'
  1110 00000C11 7503E9D401          <1> 	je	.save
  1111 00000C16 3C71                <1> 	cmp	al,'q'
  1112 00000C18 7503E90702          <1> 	je	.exit
  1113 00000C1D 3C68                <1> 	cmp	al,'h'
  1114 00000C1F 7402                <1> 	je	.help
  1115 00000C21 EBC5                <1> 	jmp	.menu_input
  1116                              <1> 
  1117                              <1> .help:
  1118 00000C23 B40E                <1> 	mov	ah,0Eh			; echo
  1119 00000C25 BB0700              <1> 	mov	bx,0007h
  1120 00000C28 CD10                <1> 	int	10h
  1121 00000C2A BE[2604]            <1> 	mov	si,msg_set_help
  1122 00000C2D E86019              <1> 	call	print
  1123 00000C30 EBB0                <1> 	jmp	.menu_loop
  1124                              <1> 
  1125                              <1> .set_floppy:
  1126 00000C32 B40E                <1> 	mov	ah,0Eh			; echo
  1127 00000C34 BB0700              <1> 	mov	bx,0007h
  1128 00000C37 CD10                <1> 	int	10h
  1129                              <1> 
  1130                              <1> .set_floppy_prompt:
  1131 00000C39 BE[5E06]            <1> 	mov	si,msg_set_fd_prmt
  1132 00000C3C E85119              <1> 	call	print
  1133                              <1> 
  1134                              <1> .floppy_input:
  1135 00000C3F B400                <1> 	mov	ah,00h
  1136 00000C41 CD16                <1> 	int	16h
  1137 00000C43 0C20                <1> 	or	al,20h			; convert to lower case
  1138 00000C45 3C72                <1> 	cmp	al,'r'
  1139 00000C47 7430                <1> 	je	.floppy_exit
  1140 00000C49 3C68                <1> 	cmp	al,'h'
  1141 00000C4B 7436                <1> 	je	.floppy_help
  1142 00000C4D 3C30                <1> 	cmp	al,'0'
  1143 00000C4F 72EE                <1> 	jb	.floppy_input
  1144 00000C51 3C36                <1> 	cmp	al,'6'
  1145 00000C53 77EA                <1> 	ja	.floppy_input
  1146 00000C55 3C35                <1> 	cmp	al,'5'
  1147 00000C57 74E6                <1> 	je	.floppy_input
  1148 00000C59 B40E                <1> 	mov	ah,0Eh			; echo
  1149 00000C5B BB0700              <1> 	mov	bx,0007h
  1150 00000C5E CD10                <1> 	int	10h
  1151 00000C60 2C30                <1> 	sub	al,'0'
  1152 00000C62 B6F0                <1> 	mov	dh,0F0h
  1153 00000C64 08D2                <1> 	or	dl,dl			; drive	0?
  1154 00000C66 750A                <1> 	jnz	.drive_1
  1155 00000C68 D0E0                <1> 	shl	al,1
  1156 00000C6A D0E0                <1> 	shl	al,1
  1157 00000C6C D0E0                <1> 	shl	al,1
  1158 00000C6E D0E0                <1> 	shl	al,1
  1159 00000C70 B60F                <1> 	mov	dh,0Fh
  1160                              <1> .drive_1:
  1161 00000C72 20F1                <1> 	and	cl,dh
  1162 00000C74 08C1                <1> 	or	cl,al
  1163 00000C76 E969FF              <1> 	jmp	.menu_loop
  1164                              <1> 
  1165                              <1> .floppy_exit:
  1166 00000C79 B40E                <1> 	mov	ah,0Eh			; echo
  1167 00000C7B BB0700              <1> 	mov	bx,0007h
  1168 00000C7E CD10                <1> 	int	10h
  1169 00000C80 E95FFF              <1> 	jmp	.menu_loop
  1170                              <1> 
  1171                              <1> .floppy_help:
  1172 00000C83 B40E                <1> 	mov	ah,0Eh			; echo
  1173 00000C85 BB0700              <1> 	mov	bx,0007h
  1174 00000C88 CD10                <1> 	int	10h
  1175 00000C8A BE[9005]            <1> 	mov	si,msg_set_fd_help
  1176 00000C8D E80019              <1> 	call	print
  1177 00000C90 EBA7                <1> 	jmp	.set_floppy_prompt
  1178                              <1> 
  1179                              <1> .print_settings:
  1180 00000C92 B40E                <1> 	mov	ah,0Eh			; echo
  1181 00000C94 BB0700              <1> 	mov	bx,0007h
  1182 00000C97 CD10                <1> 	int	10h
  1183 00000C99 BE[8800]            <1> 	mov	si,msg_crlf
  1184 00000C9C E8F118              <1> 	call	print
  1185 00000C9F E89501              <1> 	call	print_rtc		; print current RTC time
  1186 00000CA2 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1187 00000CA4 E8580B              <1> 	call	print_floppy
  1188 00000CA7 E938FF              <1> 	jmp	.menu_loop
  1189                              <1> 
  1190                              <1> .set_time:
  1191 00000CAA 51                  <1> 	push	cx
  1192 00000CAB 57                  <1> 	push	di
  1193 00000CAC 06                  <1> 	push	es
  1194 00000CAD B40E                <1> 	mov	ah,0Eh			; echo
  1195 00000CAF BB0700              <1> 	mov	bx,0007h
  1196 00000CB2 CD10                <1> 	int	10h
  1197 00000CB4 BE[8800]            <1> 	mov	si,msg_crlf
  1198 00000CB7 E8D618              <1> 	call	print
  1199                              <1> 
  1200 00000CBA BE[3005]            <1> 	mov	si,msg_set_time
  1201 00000CBD E8D018              <1> 	call	print
  1202                              <1> 
  1203 00000CC0 B402                <1> 	mov	ah,02h
  1204 00000CC2 CD1A                <1> 	int	1Ah			; get current time
  1205                              <1> 
  1206 00000CC4 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1207 00000CC7 8EC0                <1> 	mov	es,ax
  1208 00000CC9 31FF                <1> 	xor	di,di
  1209 00000CCB B80800              <1> 	mov	ax,8			; length of the time string
  1210                              <1> 
  1211 00000CCE E80718              <1> 	call	get_line
  1212                              <1> 
  1213 00000CD1 09C0                <1> 	or	ax,ax			; empty string?
  1214 00000CD3 743F                <1> 	jz	.set_time_exit
  1215                              <1> 
  1216 00000CD5 E87218              <1> 	call	atoi
  1217                              <1> 
  1218 00000CD8 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
  1219 00000CDB 773D                <1> 	ja	.set_time_invalid
  1220                              <1> 
  1221 00000CDD E88F18              <1> 	call	bin_to_bcd		; convert to BCD
  1222                              <1> 
  1223 00000CE0 88C5                <1> 	mov	ch,al			; CH = hours
  1224                              <1> 
  1225 00000CE2 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1226 00000CE6 7532                <1> 	jne	.set_time_invalid
  1227                              <1> 
  1228 00000CE8 47                  <1> 	inc	di
  1229                              <1> 
  1230 00000CE9 E85E18              <1> 	call	atoi
  1231                              <1> 
  1232 00000CEC 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
  1233 00000CEF 7729                <1> 	ja	.set_time_invalid
  1234                              <1> 
  1235 00000CF1 E87B18              <1> 	call	bin_to_bcd
  1236                              <1> 
  1237 00000CF4 88C1                <1> 	mov	cl,al			; CL = minutes
  1238                              <1> 
  1239 00000CF6 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1240 00000CFA 751E                <1> 	jne	.set_time_invalid
  1241                              <1> 
  1242 00000CFC 47                  <1> 	inc	di
  1243                              <1> 
  1244 00000CFD E84A18              <1> 	call	atoi
  1245                              <1> 
  1246 00000D00 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
  1247 00000D03 7715                <1> 	ja	.set_time_invalid
  1248                              <1> 
  1249 00000D05 E86718              <1> 	call	bin_to_bcd
  1250                              <1> 
  1251 00000D08 88C6                <1> 	mov	dh,al			; DH = seconds
  1252                              <1> 
  1253 00000D0A 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1254 00000D0E 750A                <1> 	jne	.set_time_invalid
  1255                              <1> 
  1256 00000D10 B403                <1> 	mov	ah,03h			; set RTC time
  1257 00000D12 CD1A                <1> 	int	1Ah
  1258                              <1> 
  1259                              <1> .set_time_exit:
  1260 00000D14 07                  <1> 	pop	es
  1261 00000D15 5F                  <1> 	pop	di
  1262 00000D16 59                  <1> 	pop	cx
  1263 00000D17 E9C8FE              <1> 	jmp	.menu_loop
  1264                              <1> 
  1265                              <1> .set_time_invalid:
  1266 00000D1A BE[6205]            <1> 	mov	si,msg_time_inval
  1267 00000D1D E87018              <1> 	call	print
  1268 00000D20 EBF2                <1> 	jmp	.set_time_exit
  1269                              <1> 
  1270                              <1> .set_date:
  1271 00000D22 51                  <1> 	push	cx
  1272 00000D23 57                  <1> 	push	di
  1273 00000D24 06                  <1> 	push	es
  1274 00000D25 B40E                <1> 	mov	ah,0Eh			; echo
  1275 00000D27 BB0700              <1> 	mov	bx,0007h
  1276 00000D2A CD10                <1> 	int	10h
  1277 00000D2C BE[8800]            <1> 	mov	si,msg_crlf
  1278 00000D2F E85E18              <1> 	call	print
  1279 00000D32 BE[4805]            <1> 	mov	si,msg_set_date
  1280 00000D35 E85818              <1> 	call	print
  1281                              <1> 
  1282 00000D38 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1283 00000D3B 8EC0                <1> 	mov	es,ax
  1284 00000D3D 31FF                <1> 	xor	di,di
  1285 00000D3F B80A00              <1> 	mov	ax,10			; length of the date string
  1286                              <1> 
  1287 00000D42 E89317              <1> 	call	get_line
  1288                              <1> 
  1289 00000D45 09C0                <1> 	or	ax,ax			; empty string?
  1290 00000D47 7503E99000          <1> 	jz	.set_date_exit
  1291                              <1> 
  1292 00000D4C E8FB17              <1> 	call	atoi
  1293                              <1> 
  1294 00000D4F 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
  1295 00000D52 7603E98B00          <1> 	ja	.set_date_invalid
  1296                              <1> 
  1297 00000D57 89C3                <1> 	mov	bx,ax			; store binary year in BX
  1298                              <1> 
  1299 00000D59 E81318              <1> 	call	bin_to_bcd		; convert to BCD
  1300                              <1> 
  1301 00000D5C 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
  1302                              <1> 	
  1303 00000D5E 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1304 00000D62 757E                <1> 	jne	.set_date_invalid
  1305                              <1> 
  1306 00000D64 47                  <1> 	inc	di
  1307                              <1> 
  1308 00000D65 E8E217              <1> 	call	atoi
  1309                              <1> 
  1310 00000D68 83F801              <1> 	cmp	ax,1			; month is lower than 1?
  1311 00000D6B 7275                <1> 	jb	.set_date_invalid
  1312                              <1> 
  1313 00000D6D 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
  1314 00000D70 7770                <1> 	ja	.set_date_invalid
  1315                              <1> 
  1316 00000D72 E8FA17              <1> 	call	bin_to_bcd
  1317                              <1> 
  1318 00000D75 88C6                <1> 	mov	dh,al			; DH = month
  1319                              <1> 
  1320 00000D77 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1321 00000D7B 7565                <1> 	jne	.set_date_invalid
  1322                              <1> 
  1323 00000D7D 47                  <1> 	inc	di
  1324                              <1> 
  1325 00000D7E E8C917              <1> 	call	atoi
  1326                              <1> 
  1327 00000D81 83F801              <1> 	cmp	ax,1			; day is lower than 1?
  1328 00000D84 725C                <1> 	jb	.set_date_invalid
  1329                              <1> 
  1330 00000D86 80FE02              <1> 	cmp	dh,02h			; February
  1331 00000D89 7430                <1> 	je	.set_date_february
  1332                              <1> 
  1333 00000D8B 80FE04              <1> 	cmp	dh,04h			; April
  1334 00000D8E 7416                <1> 	je	.set_date_30_days
  1335                              <1> 
  1336 00000D90 80FE06              <1> 	cmp	dh,06h			; July
  1337 00000D93 7411                <1> 	je	.set_date_30_days
  1338                              <1> 
  1339 00000D95 80FE09              <1> 	cmp	dh,09h			; September
  1340 00000D98 740C                <1> 	je	.set_date_30_days
  1341                              <1> 
  1342 00000D9A 80FE11              <1> 	cmp	dh,11h			; November
  1343 00000D9D 7407                <1> 	je	.set_date_30_days
  1344                              <1> 
  1345                              <1> .set_date_31_days:
  1346 00000D9F 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
  1347 00000DA2 773E                <1> 	ja	.set_date_invalid
  1348 00000DA4 EB27                <1> 	jmp	.set_date_set_day
  1349                              <1> 
  1350                              <1> .set_date_30_days:
  1351 00000DA6 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
  1352 00000DA9 7737                <1> 	ja	.set_date_invalid
  1353 00000DAB EB20                <1> 	jmp	.set_date_set_day
  1354                              <1> 
  1355                              <1> .set_date_29_days:
  1356 00000DAD 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
  1357 00000DB0 7730                <1> 	ja	.set_date_invalid
  1358 00000DB2 EB19                <1> 	jmp	.set_date_set_day
  1359                              <1> 
  1360                              <1> .set_date_28_days:
  1361 00000DB4 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
  1362 00000DB7 7729                <1> 	ja	.set_date_invalid
  1363 00000DB9 EB12                <1> 	jmp	.set_date_set_day
  1364                              <1> 
  1365                              <1> .set_date_february:
  1366 00000DBB F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
  1367 00000DBF 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
  1368                              <1> 
  1369 00000DC1 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
  1370 00000DC4 75E7                <1> 	jne	.set_date_29_days	; a leap year
  1371                              <1> 
  1372 00000DC6 F6C503              <1> 	test	ch,03h			; check if century divides by 4
  1373 00000DC9 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
  1374 00000DCB EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
  1375                              <1> 
  1376                              <1> .set_date_set_day:
  1377 00000DCD E89F17              <1> 	call	bin_to_bcd
  1378                              <1> 
  1379 00000DD0 88C2                <1> 	mov	dl,al			; DL = date (day of month)
  1380                              <1> 
  1381 00000DD2 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1382 00000DD6 750A                <1> 	jne	.set_date_invalid
  1383                              <1> 
  1384 00000DD8 B405                <1> 	mov	ah,05h			; set RTC date
  1385 00000DDA CD1A                <1> 	int	1Ah
  1386                              <1> 
  1387                              <1> .set_date_exit:
  1388 00000DDC 07                  <1> 	pop	es
  1389 00000DDD 5F                  <1> 	pop	di
  1390 00000DDE 59                  <1> 	pop	cx
  1391 00000DDF E900FE              <1> 	jmp	.menu_loop
  1392                              <1> 
  1393                              <1> .set_date_invalid:
  1394 00000DE2 BE[7905]            <1> 	mov	si,msg_date_inval
  1395 00000DE5 E8A817              <1> 	call	print
  1396 00000DE8 EBF2                <1> 	jmp	.set_date_exit
  1397                              <1> 
  1398                              <1> .save:
  1399 00000DEA 50                  <1> 	push	ax
  1400                              <1> 
  1401 00000DEB B010                <1> 	mov	al,cmos_floppy
  1402 00000DED 88CC                <1> 	mov	ah,cl
  1403 00000DEF E8B4FC              <1> 	call	rtc_write
  1404                              <1> 
  1405 00000DF2 8A261000            <1> 	mov	ah,byte [equipment_list]
  1406 00000DF6 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1407                              <1> 
  1408 00000DF9 F6C170              <1> 	test	cl,70h
  1409 00000DFC 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1410 00000DFE 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1411                              <1> 
  1412                              <1> .second_floppy:
  1413 00000E01 F6C107              <1> 	test	cl,07h
  1414 00000E04 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1415 00000E06 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1416                              <1> 					; (even if the first one is missing)
  1417                              <1> 
  1418                              <1> .save_equipment:
  1419 00000E09 88261000            <1> 	mov	byte [equipment_list],ah
  1420 00000E0D B014                <1> 	mov	al,cmos_equip
  1421 00000E0F E894FC              <1> 	call	rtc_write
  1422                              <1> 
  1423 00000E12 E8A3FD              <1> 	call	rtc_checksum
  1424                              <1> 
  1425 00000E15 B02E                <1> 	mov	al,cmos_sum_hi
  1426 00000E17 88FC                <1> 	mov	ah,bh
  1427 00000E19 E88AFC              <1> 	call	rtc_write
  1428                              <1> 
  1429 00000E1C FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1430 00000E1E 88DC                <1> 	mov	ah,bl
  1431 00000E20 E883FC              <1> 	call	rtc_write
  1432                              <1> 	
  1433 00000E23 58                  <1> 	pop	ax
  1434                              <1> 
  1435                              <1> .exit:
  1436 00000E24 B40E                <1> 	mov	ah,0Eh			; echo
  1437 00000E26 BB0700              <1> 	mov	bx,0007h
  1438 00000E29 CD10                <1> 	int	10h
  1439 00000E2B BE[8800]            <1> 	mov	si,msg_crlf
  1440 00000E2E E85F17              <1> 	call	print
  1441 00000E31 5E                  <1> 	pop	si
  1442 00000E32 5A                  <1> 	pop	dx
  1443 00000E33 59                  <1> 	pop	cx
  1444 00000E34 5B                  <1> 	pop	bx
  1445 00000E35 58                  <1> 	pop	ax
  1446 00000E36 C3                  <1> 	ret
  1447                              <1> 
  1448                              <1> ;=========================================================================
  1449                              <1> ; print_rtc - print current RTC date and time
  1450                              <1> ; Input:
  1451                              <1> ;	none
  1452                              <1> ; Output:
  1453                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
  1454                              <1> ; Notes:
  1455                              <1> ;	There is a slight probability of getting inconsistent printout.
  1456                              <1> ;	In case the function is called just before midnight, it could
  1457                              <1> ;	print the previos day's date and next day's time.
  1458                              <1> ;-------------------------------------------------------------------------
  1459                              <1> print_rtc:
  1460 00000E37 50                  <1> 	push	ax
  1461 00000E38 53                  <1> 	push	bx
  1462 00000E39 51                  <1> 	push	cx
  1463 00000E3A 52                  <1> 	push	dx
  1464 00000E3B 56                  <1> 	push	si
  1465 00000E3C BE[7A01]            <1> 	mov	si,msg_rtc
  1466 00000E3F E84E17              <1> 	call	print
  1467                              <1> 
  1468                              <1> ; print date
  1469 00000E42 B404                <1> 	mov	ah,04h
  1470 00000E44 CD1A                <1> 	int	1Ah			; read RTC date
  1471                              <1> 					; CH = BCD century
  1472                              <1> 					; CL = BCD year
  1473                              <1> 					; DH = BCD month
  1474                              <1> 					; DL = BCD date (day of month)
  1475 00000E46 89C8                <1> 	mov	ax,cx
  1476 00000E48 E86017              <1> 	call	print_hex		; print 4-digit year
  1477 00000E4B B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1478 00000E4E BB0700              <1> 	mov	bx,0007h
  1479 00000E51 CD10                <1> 	int	10h			; print dash (-)
  1480                              <1> 
  1481 00000E53 88F0                <1> 	mov	al,dh
  1482 00000E55 E85E17              <1> 	call	print_byte		; print 2-digit month
  1483 00000E58 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1484 00000E5B BB0700              <1> 	mov	bx,0007h
  1485 00000E5E CD10                <1> 	int	10h			; print dash (-)
  1486                              <1> 
  1487 00000E60 88D0                <1> 	mov	al,dl
  1488 00000E62 E85117              <1> 	call	print_byte		; print 2-digit date (day of month)
  1489                              <1> 
  1490 00000E65 B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
  1491 00000E68 BB0700              <1> 	mov	bx,0007h
  1492 00000E6B CD10                <1> 	int	10h			; print space ( )
  1493                              <1> 
  1494                              <1> ; print time
  1495 00000E6D B402                <1> 	mov	ah,02h
  1496 00000E6F CD1A                <1> 	int	1Ah			; read RTC time
  1497                              <1> 					; CH = BCD hours
  1498                              <1> 					; CL = BCD minutes
  1499                              <1> 					; DH = BCD seconds
  1500                              <1> 					; DL = daylight saving flag (ignored)
  1501 00000E71 88E8                <1> 	mov	al,ch
  1502 00000E73 E84017              <1> 	call	print_byte		; print 2-digit hours
  1503                              <1> 	
  1504 00000E76 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1505 00000E79 BB0700              <1> 	mov	bx,0007h
  1506 00000E7C CD10                <1> 	int	10h			; print colon (:)
  1507                              <1> 
  1508 00000E7E 88C8                <1> 	mov	al,cl
  1509 00000E80 E83317              <1> 	call	print_byte		; print 2-digit minutes
  1510                              <1> 	
  1511 00000E83 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1512 00000E86 BB0700              <1> 	mov	bx,0007h
  1513 00000E89 CD10                <1> 	int	10h			; print colon (:)
  1514                              <1> 
  1515 00000E8B 88F0                <1> 	mov	al,dh
  1516 00000E8D E82617              <1> 	call	print_byte		; print 2-digit seconds
  1517                              <1> 
  1518 00000E90 BE[8800]            <1> 	mov	si,msg_crlf
  1519 00000E93 E8FA16              <1> 	call	print
  1520 00000E96 5E                  <1> 	pop	si
  1521 00000E97 5A                  <1> 	pop	dx
  1522 00000E98 59                  <1> 	pop	cx
  1523 00000E99 5B                  <1> 	pop	bx
  1524 00000E9A 58                  <1> 	pop	ax
  1525 00000E9B C3                  <1> 	ret
  1526                              <1> 
  1527                              <1> ;=========================================================================
  1528                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1529                              <1> ; Input:
  1530                              <1> ;	CX = time to delay (in 15 microsecond units)
  1531                              <1> ; Notes:
  1532                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1533                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1534                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1535                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1536                              <1> ;-------------------------------------------------------------------------
  1537                              <1> delay_15us:
  1538 00000E9C 50                  <1> 	push	ax
  1539 00000E9D 51                  <1> 	push	cx
  1540                              <1> .zero:
  1541 00000E9E E461                <1> 	in	al,port_b_reg
  1542 00000EA0 A810                <1> 	test	al,refresh_flag
  1543 00000EA2 74FA                <1> 	jz	.zero
  1544 00000EA4 49                  <1> 	dec	cx
  1545 00000EA5 7409                <1> 	jz	.exit
  1546                              <1> .one:
  1547 00000EA7 E461                <1> 	in	al,port_b_reg
  1548 00000EA9 A810                <1> 	test	al,refresh_flag
  1549 00000EAB 75FA                <1> 	jnz	.one
  1550 00000EAD 49                  <1> 	dec	cx
  1551 00000EAE 75EE                <1> 	jnz	.zero
  1552                              <1> .exit:
  1553 00000EB0 59                  <1> 	pop	cx
  1554 00000EB1 58                  <1> 	pop	ax
  1555 00000EB2 C3                  <1> 	ret
  1556                              <1> 
  1557                              <1> %if 0
  1558                              <1> ;=========================================================================
  1559                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1560                              <1> ; Input:
  1561                              <1> ;	DX:AX	- dividend
  1562                              <1> ;	CX	- divisor
  1563                              <1> ; Output:
  1564                              <1> ;	DX:AX	- quotient
  1565                              <1> ;-------------------------------------------------------------------------
  1566                              <1> divide_32:
  1567                              <1> 	or	dx,dx
  1568                              <1> 	jnz	.1
  1569                              <1> 	div	cx
  1570                              <1> 	xor	dx,dx
  1571                              <1> 	ret
  1572                              <1> .1:
  1573                              <1> 	push	bx
  1574                              <1> 	mov	bx,ax
  1575                              <1> 	mov	ax,dx
  1576                              <1> 	xor	dx,dx
  1577                              <1> 	div	cx
  1578                              <1> 	xchg	bx,ax
  1579                              <1> 	div	cx
  1580                              <1> 	mov	dx,bx
  1581                              <1> 	pop	bx
  1582                              <1> 	ret
  1583                              <1> %endif ; 0
  1584                                  %include	"time1.inc"		; time services
  1585                              <1> ;=========================================================================
  1586                              <1> ; time1.inc - BIOS Time Services
  1587                              <1> ;       INT 1Ah - BIOS Time Services
  1588                              <1> ;		functions AH=00h to AH=07h
  1589                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1590                              <1> ;-------------------------------------------------------------------------
  1591                              <1> ;
  1592                              <1> ; Compiles with NASM 2.07, might work with other versions
  1593                              <1> ;
  1594                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1595                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1596                              <1> ;
  1597                              <1> ; This program is free software: you can redistribute it and/or modify
  1598                              <1> ; it under the terms of the GNU General Public License as published by
  1599                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1600                              <1> ; (at your option) any later version.
  1601                              <1> ;
  1602                              <1> ; This program is distributed in the hope that it will be useful,
  1603                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1604                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1605                              <1> ; GNU General Public License for more details.
  1606                              <1> ;
  1607                              <1> ; You should have received a copy of the GNU General Public License
  1608                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1609                              <1> ;
  1610                              <1> ;=========================================================================
  1611                              <1> 
  1612                              <1> ;=========================================================================
  1613                              <1> ; int_1A_fn00 - Read current time
  1614                              <1> ; Input:
  1615                              <1> ;	AH = 0 - read current time
  1616                              <1> ; Output:
  1617                              <1> ;	CX = high word of tick count
  1618                              <1> ;	DX = low word of tick count
  1619                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1620                              <1> ;-------------------------------------------------------------------------
  1621                              <1> int_1A_fn00:
  1622 00000EB3 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1623 00000EB7 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1624 00000EBB A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1625 00000EBE 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1626 00000EC2 E9D06F              <1> 	jmp	int_1A_exit
  1627                              <1> 
  1628                              <1> ;=========================================================================
  1629                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1630                              <1> ; Input:
  1631                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1632                              <1> ;	CX = high word of tick count
  1633                              <1> ;	DX = low word of tick count
  1634                              <1> ; Output:
  1635                              <1> ;	None
  1636                              <1> ;-------------------------------------------------------------------------
  1637                              <1> int_1A_fn01:
  1638 00000EC5 89166C00            <1> 	mov	word [ticks_lo],dx
  1639 00000EC9 890E6E00            <1> 	mov	word [ticks_hi],cx
  1640 00000ECD C606700000          <1> 	mov	byte [new_day],00h
  1641 00000ED2 E9C06F              <1> 	jmp	int_1A_exit
  1642                              <1> 
  1643                              <1> ;=========================================================================
  1644                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1645                              <1> ; Input:
  1646                              <1> ;	AH = 02h - function 02h - read RTC time
  1647                              <1> ; Output:
  1648                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1649                              <1> ;	CH = BCD hours
  1650                              <1> ;	CL = BCD minutes
  1651                              <1> ;	DH = BCD seconds
  1652                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1653                              <1> ;-------------------------------------------------------------------------
  1654                              <1> int_1A_fn02:
  1655 00000ED5 50                  <1> 	push	ax
  1656 00000ED6 B00A                <1> 	mov	al,cmos_control_a
  1657 00000ED8 E8BCFB              <1> 	call	rtc_read		; read control A register
  1658 00000EDB A880                <1> 	test	al,cmos_uip
  1659 00000EDD 7405                <1> 	jz	.1			; no update in progess
  1660 00000EDF F9                  <1> 	stc
  1661 00000EE0 58                  <1> 	pop	ax
  1662 00000EE1 E9B46F              <1> 	jmp	int_1A_exitf
  1663                              <1> .1:
  1664 00000EE4 B00B                <1> 	mov	al,cmos_control_b
  1665 00000EE6 E8AEFB              <1> 	call	rtc_read		; read control B register
  1666 00000EE9 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1667 00000EEB 88C2                <1> 	mov	dl,al
  1668 00000EED B000                <1> 	mov	al,cmos_seconds
  1669 00000EEF E8A5FB              <1> 	call	rtc_read		; read seconds
  1670 00000EF2 88C6                <1> 	mov	dh,al
  1671 00000EF4 B002                <1> 	mov	al,cmos_minutes
  1672 00000EF6 E89EFB              <1> 	call	rtc_read		; read minutes
  1673 00000EF9 88C1                <1> 	mov	cl,al
  1674 00000EFB B004                <1> 	mov	al,cmos_hours
  1675 00000EFD E897FB              <1> 	call	rtc_read		; read hours
  1676 00000F00 88C5                <1> 	mov	ch,al
  1677 00000F02 F8                  <1> 	clc
  1678 00000F03 58                  <1> 	pop	ax
  1679 00000F04 E9916F              <1> 	jmp	int_1A_exitf
  1680                              <1> 
  1681                              <1> ;=========================================================================
  1682                              <1> ; int_1A_fn03 - Set real time clock
  1683                              <1> ; Input:
  1684                              <1> ;	AH = 03h - function 03h - set RTC time
  1685                              <1> ;	CH = BCD hours
  1686                              <1> ;	CL = BCD minutes
  1687                              <1> ;	DH = BCD seconds
  1688                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1689                              <1> ; Output:
  1690                              <1> ;	None
  1691                              <1> ;-------------------------------------------------------------------------
  1692                              <1> int_1A_fn03:
  1693 00000F07 50                  <1> 	push	ax
  1694 00000F08 B00B                <1> 	mov	al,cmos_control_b
  1695 00000F0A E88AFB              <1> 	call	rtc_read		; read control B register
  1696 00000F0D 88C4                <1> 	mov	ah,al
  1697 00000F0F 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1698 00000F12 B00B                <1> 	mov	al,cmos_control_b
  1699 00000F14 E88FFB              <1> 	call	rtc_write		; write control B register
  1700                              <1> 
  1701 00000F17 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1702 00000F1A 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1703 00000F1D 08D4                <1> 	or	ah,dl			; add it from the input
  1704 00000F1F B00B                <1> 	mov	al,cmos_control_b
  1705 00000F21 E882FB              <1> 	call	rtc_write		; write control B register
  1706                              <1> 
  1707 00000F24 B000                <1> 	mov	al,cmos_seconds
  1708 00000F26 88F4                <1> 	mov	ah,dh
  1709 00000F28 E87BFB              <1> 	call	rtc_write		; write seconds
  1710 00000F2B B002                <1> 	mov	al,cmos_minutes
  1711 00000F2D 88CC                <1> 	mov	ah,cl
  1712 00000F2F E874FB              <1> 	call	rtc_write		; write minutes
  1713 00000F32 B004                <1> 	mov	al,cmos_hours
  1714 00000F34 88EC                <1> 	mov	ah,ch
  1715 00000F36 E86DFB              <1> 	call	rtc_write		; write hours
  1716                              <1> 
  1717 00000F39 B00B                <1> 	mov	al,cmos_control_b
  1718 00000F3B E859FB              <1> 	call	rtc_read		; read control B register
  1719 00000F3E 88C4                <1> 	mov	ah,al
  1720 00000F40 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1721 00000F43 B00B                <1> 	mov	al,cmos_control_b
  1722 00000F45 E85EFB              <1> 	call	rtc_write		; write control B register
  1723 00000F48 58                  <1> 	pop	ax
  1724 00000F49 E9496F              <1> 	jmp	int_1A_exit
  1725                              <1> 
  1726                              <1> ;=========================================================================
  1727                              <1> ; int_1A_fn04 - Read date from real time clock
  1728                              <1> ; Input:
  1729                              <1> ;	AH = 04h - function 04h - read RTC date
  1730                              <1> ; Output:
  1731                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1732                              <1> ;	CH = BCD century
  1733                              <1> ;	CL = BCD year
  1734                              <1> ;	DH = BCD month
  1735                              <1> ;	DL = BCD date
  1736                              <1> ;-------------------------------------------------------------------------
  1737                              <1> int_1A_fn04:
  1738 00000F4C 50                  <1> 	push	ax
  1739 00000F4D B00A                <1> 	mov	al,cmos_control_a
  1740 00000F4F E845FB              <1> 	call	rtc_read		; read control A register
  1741 00000F52 A880                <1> 	test	al,cmos_uip
  1742 00000F54 7405                <1> 	jz	.1			; no update in progess
  1743 00000F56 F9                  <1> 	stc
  1744 00000F57 58                  <1> 	pop	ax
  1745 00000F58 E93D6F              <1> 	jmp	int_1A_exitf
  1746                              <1> .1:
  1747 00000F5B B007                <1> 	mov	al,cmos_date
  1748 00000F5D E837FB              <1> 	call	rtc_read		; read date
  1749 00000F60 88C2                <1> 	mov	dl,al
  1750 00000F62 B008                <1> 	mov	al,cmos_month
  1751 00000F64 E830FB              <1> 	call	rtc_read		; read month
  1752 00000F67 88C6                <1> 	mov	dh,al
  1753 00000F69 B009                <1> 	mov	al,cmos_year
  1754 00000F6B E829FB              <1> 	call	rtc_read		; read year
  1755 00000F6E 88C1                <1> 	mov	cl,al
  1756 00000F70 B032                <1> 	mov	al,cmos_century
  1757 00000F72 E822FB              <1> 	call	rtc_read		; read century
  1758 00000F75 88C5                <1> 	mov	ch,al
  1759 00000F77 F8                  <1> 	clc
  1760 00000F78 58                  <1> 	pop	ax
  1761 00000F79 E91C6F              <1> 	jmp	int_1A_exitf
  1762                              <1> 
  1763                              <1> ;=========================================================================
  1764                              <1> ; int_1A_fn05 - Set date in real time clock
  1765                              <1> ; Input:
  1766                              <1> ;	AH = 05h - function 05h - set RTC date
  1767                              <1> ;	CH = BCD century
  1768                              <1> ;	CL = BCD year
  1769                              <1> ;	DH = BCD month
  1770                              <1> ;	DL = BCD date
  1771                              <1> ; Output:
  1772                              <1> ;	None
  1773                              <1> ;-------------------------------------------------------------------------
  1774                              <1> int_1A_fn05:
  1775 00000F7C 50                  <1> 	push	ax
  1776 00000F7D B00B                <1> 	mov	al,cmos_control_b
  1777 00000F7F E815FB              <1> 	call	rtc_read		; read control B register
  1778 00000F82 88C4                <1> 	mov	ah,al
  1779 00000F84 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1780 00000F87 B00B                <1> 	mov	al,cmos_control_b
  1781 00000F89 E81AFB              <1> 	call	rtc_write		; write control B register
  1782                              <1> 
  1783 00000F8C B007                <1> 	mov	al,cmos_date
  1784 00000F8E 88D4                <1> 	mov	ah,dl
  1785 00000F90 E813FB              <1> 	call	rtc_write		; write date
  1786                              <1> 
  1787 00000F93 B008                <1> 	mov	al,cmos_month
  1788 00000F95 88F4                <1> 	mov	ah,dh
  1789 00000F97 E80CFB              <1> 	call	rtc_write		; write month
  1790 00000F9A B009                <1> 	mov	al,cmos_year
  1791 00000F9C 88CC                <1> 	mov	ah,cl
  1792 00000F9E E805FB              <1> 	call	rtc_write		; write year
  1793 00000FA1 B032                <1> 	mov	al,cmos_century
  1794 00000FA3 88EC                <1> 	mov	ah,ch
  1795 00000FA5 E8FEFA              <1> 	call	rtc_write		; write centry
  1796                              <1> 
  1797 00000FA8 B00B                <1> 	mov	al,cmos_control_b
  1798 00000FAA E8EAFA              <1> 	call	rtc_read		; read control B register
  1799 00000FAD 88C4                <1> 	mov	ah,al
  1800 00000FAF 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1801 00000FB2 B00B                <1> 	mov	al,cmos_control_b
  1802 00000FB4 E8EFFA              <1> 	call	rtc_write		; write control B register
  1803 00000FB7 58                  <1> 	pop	ax
  1804 00000FB8 E9DA6E              <1> 	jmp	int_1A_exit
  1805                              <1> 
  1806                              <1> ;=========================================================================
  1807                              <1> ; int_1A_fn06 - Set real time clock alarm
  1808                              <1> ; Input:
  1809                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1810                              <1> ;	CH = BCD hours
  1811                              <1> ;	CL = BCD minutes
  1812                              <1> ;	DH = BCD seconds
  1813                              <1> ; Output:
  1814                              <1> ;	CF = 1 - alarm already set
  1815                              <1> ;-------------------------------------------------------------------------
  1816                              <1> int_1A_fn06:
  1817 00000FBB 50                  <1> 	push	ax
  1818 00000FBC B00B                <1> 	mov	al,cmos_control_b
  1819 00000FBE E8D6FA              <1> 	call	rtc_read		; read control B register
  1820 00000FC1 A820                <1> 	test	al,cmos_aie
  1821 00000FC3 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1822 00000FC5 F9                  <1> 	stc
  1823 00000FC6 58                  <1> 	pop	ax
  1824 00000FC7 E9CE6E              <1> 	jmp	int_1A_exitf
  1825                              <1> .1:
  1826 00000FCA 88C4                <1> 	mov	ah,al
  1827 00000FCC 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1828 00000FCF B00B                <1> 	mov	al,cmos_control_b
  1829 00000FD1 E8D2FA              <1> 	call	rtc_write		; write control B register
  1830                              <1> 
  1831 00000FD4 B001                <1> 	mov	al,cmos_alarm_secs
  1832 00000FD6 88F4                <1> 	mov	ah,dh
  1833 00000FD8 E8CBFA              <1> 	call	rtc_write		; write alarm seconds
  1834 00000FDB B003                <1> 	mov	al,cmos_alarm_mins
  1835 00000FDD 88CC                <1> 	mov	ah,cl
  1836 00000FDF E8C4FA              <1> 	call	rtc_write		; write alarm minutes
  1837 00000FE2 B005                <1> 	mov	al,cmos_alarm_hrs
  1838 00000FE4 88EC                <1> 	mov	ah,ch
  1839 00000FE6 E8BDFA              <1> 	call	rtc_write		; write alarm hours
  1840                              <1> 
  1841 00000FE9 B00B                <1> 	mov	al,cmos_control_b
  1842 00000FEB E8A9FA              <1> 	call	rtc_read		; read control B register
  1843 00000FEE 88C4                <1> 	mov	ah,al
  1844 00000FF0 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1845 00000FF3 B00B                <1> 	mov	al,cmos_control_b
  1846 00000FF5 E8AEFA              <1> 	call	rtc_write		; write control B register
  1847                              <1> 
  1848 00000FF8 B00B                <1> 	mov	al,cmos_control_b
  1849 00000FFA E89AFA              <1> 	call	rtc_read		; read control B register
  1850 00000FFD 88C4                <1> 	mov	ah,al
  1851 00000FFF 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1852 00001002 B00B                <1> 	mov	al,cmos_control_b
  1853 00001004 E89FFA              <1> 	call	rtc_write		; write control B register with AIE set
  1854                              <1> 
  1855 00001007 58                  <1> 	pop	ax
  1856 00001008 F8                  <1> 	clc
  1857 00001009 E98C6E              <1> 	jmp	int_1A_exitf
  1858                              <1> 
  1859                              <1> ;=========================================================================
  1860                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1861                              <1> ; Input:
  1862                              <1> ;	AH = 07h - function 07h - set RTC time
  1863                              <1> ; Output:
  1864                              <1> ;	None
  1865                              <1> ;-------------------------------------------------------------------------
  1866                              <1> int_1A_fn07:
  1867 0000100C 50                  <1> 	push	ax
  1868                              <1> 
  1869 0000100D B00B                <1> 	mov	al,cmos_control_b
  1870 0000100F E885FA              <1> 	call	rtc_read		; read control B register
  1871 00001012 88C4                <1> 	mov	ah,al
  1872 00001014 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1873 00001017 B00B                <1> 	mov	al,cmos_control_b
  1874 00001019 E88AFA              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1875                              <1> 
  1876 0000101C 58                  <1> 	pop	ax
  1877 0000101D E9756E              <1> 	jmp	int_1A_exit
  1878                              <1> 	
  1879                              <1> ;=========================================================================
  1880                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1881                              <1> ; Notes:
  1882                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1883                              <1> ;-------------------------------------------------------------------------
  1884                              <1> int_70:
  1885 00001020 50                  <1> 	push	ax
  1886 00001021 B020                <1> 	mov	al,20h
  1887 00001023 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1888 00001025 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1889 00001027 B00C                <1> 	mov	al,cmos_control_c
  1890 00001029 E86BFA              <1> 	call	rtc_read		; read control C register
  1891 0000102C A840                <1> 	test	al,cmos_af		; check for alarm flag
  1892 0000102E 7402                <1> 	jz	.1
  1893 00001030 CD4A                <1> 	int	4Ah			; call INT 4Ah
  1894                              <1> .1:
  1895 00001032 58                  <1> 	pop	ax
  1896 00001033 CF                  <1> 	iret
  1897                                  %include	"floppy1.inc"		; floppy services
  1898                              <1> ;=========================================================================
  1899                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
  1900                              <1> ;       INT 13h, function AH=00h
  1901                              <1> ;       INT 13h, function AH=01h
  1902                              <1> ;       INT 13h, function AH=08h
  1903                              <1> ;       INT 13h, function AH=15h
  1904                              <1> ;       INT 13h, function AH=16h
  1905                              <1> ;       INT 13h, function AH=17h
  1906                              <1> ;       INT 13h, function AH=18h
  1907                              <1> ;       INT 13h, function AH=08h
  1908                              <1> ;	- see floppy2.inc for other INT 13h functions
  1909                              <1> ;-------------------------------------------------------------------------
  1910                              <1> ;
  1911                              <1> ; Compiles with NASM 2.07, might work with other versions
  1912                              <1> ;
  1913                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1914                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1915                              <1> ;
  1916                              <1> ; This program is free software: you can redistribute it and/or modify
  1917                              <1> ; it under the terms of the GNU General Public License as published by
  1918                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1919                              <1> ; (at your option) any later version.
  1920                              <1> ;
  1921                              <1> ; This program is distributed in the hope that it will be useful,
  1922                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1923                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1924                              <1> ; GNU General Public License for more details.
  1925                              <1> ;
  1926                              <1> ; You should have received a copy of the GNU General Public License
  1927                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1928                              <1> ;
  1929                              <1> ;=========================================================================
  1930                              <1> 
  1931                              <1> ;-------------------------------------------------------------------------
  1932                              <1> ; FDC registers
  1933                              <1> 
  1934                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1935                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1936                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1937                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1938                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1939                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1940                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1941                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1942                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1943                              <1> 
  1944                              <1> ;-------------------------------------------------------------------------
  1945                              <1> ; DMAC registers
  1946                              <1> 
  1947                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1948                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1949                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1950                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1951                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1952                              <1> 					; first / last flip-flop
  1953                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1954                              <1> 
  1955                              <1> ;-------------------------------------------------------------------------
  1956                              <1> ; Floppy disk services - error codes
  1957                              <1> 
  1958                              <1> fdc_e_success	equ	00h		; successful completion
  1959                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1960                              <1> fdc_e_address	equ	02h		; address mark not found
  1961                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1962                              <1> fdc_e_notfound	equ	04h		; sector not found
  1963                              <1> fdc_e_changed	equ	06h		; disk changed
  1964                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1965                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1966                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1967                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1968                              <1> fdc_e_failure	equ	20h		; controller failure
  1969                              <1> fdc_e_seek	equ	40h		; seek failed
  1970                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1971                              <1> 
  1972                              <1> ;-------------------------------------------------------------------------
  1973                              <1> ; Drive media state for fdc_media_state
  1974                              <1> 
  1975                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1976                              <1> 					; 00b = 500 Kbit/sec
  1977                              <1> 					; 01b = 300 Kbit/sec
  1978                              <1> 					; 10b = 250 Kbit/sec
  1979                              <1> 					; 11b = 1 Mbit/sec
  1980                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
  1981                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
  1982                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1983                              <1> 					; 000b = trying 360K in 360K drive
  1984                              <1> 					; 001b = trying 360K in 1.2M drive
  1985                              <1> 					; 010b = trying 1.2M in 1.2M drive
  1986                              <1> 					; 011b = known 360K in 360K drive
  1987                              <1> 					; 100b = known 360K in 1.2M drive
  1988                              <1> 					; 101b = known 1.2M in 1.2M drive
  1989                              <1> 					; 110b = not used
  1990                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
  1991                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1992                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1993                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
  1994                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1995                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1996                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1997                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1998                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1999                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  2000                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  2001                              <1> 
  2002                              <1> ;-------------------------------------------------------------------------
  2003                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  2004                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  2005                              <1> 
  2006                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  2007                              <1> 
  2008                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  2009                              <1> ;	       unset for read or verify
  2010                              <1> 
  2011                              <1> fdc_write_flag	equ	80h		; write or format operation
  2012                              <1> 
  2013                              <1> ;-------------------------------------------------------------------------
  2014                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  2015                              <1> 
  2016                              <1> cmos_no_floppy	equ	00h
  2017                              <1> cmos_360	equ	01h
  2018                              <1> cmos_1200	equ	02h
  2019                              <1> cmos_720	equ	03h
  2020                              <1> cmos_1440	equ	04h
  2021                              <1> cmos_2880	equ	06h
  2022                              <1> 
  2023                              <1> ;=========================================================================
  2024                              <1> ; int_13_fn00: Reset disk system
  2025                              <1> ; Input:
  2026                              <1> ;	AH = 00h
  2027                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2028                              <1> ; Output:
  2029                              <1> ;	CF clear if successful
  2030                              <1> ;		AH = 00h - successful completion
  2031                              <1> ;	CF set on error
  2032                              <1> ;		AH = 20h - controller failure
  2033                              <1> ;		AH = 80h - timeout / device not ready
  2034                              <1> ; Note:
  2035                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2036                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2037                              <1> ;-------------------------------------------------------------------------
  2038                              <1> int_13_fn00:
  2039 00001034 E80700              <1> 	call	fdc_init
  2040 00001037 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2041 0000103B E9985C              <1> 	jmp	int_13_exit
  2042                              <1> 
  2043                              <1> ;=========================================================================
  2044                              <1> ; fdc_init - Initialize floppy disk controller
  2045                              <1> ; Input:
  2046                              <1> ;	none
  2047                              <1> ; Output:
  2048                              <1> ;	CF clear on success
  2049                              <1> ;		AH = 00h - successful completion
  2050                              <1> ;	CF set if error
  2051                              <1> ;		AH = 20h - controller failure
  2052                              <1> ;		AH = 80h - timeout / device not ready
  2053                              <1> ;-------------------------------------------------------------------------
  2054                              <1> fdc_init:
  2055 0000103E 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  2056 00001043 E80906              <1> 	call	fdc_reset		; reset FDC
  2057 00001046 7257                <1> 	jc	fdc_init_error
  2058 00001048 BAF403              <1> 	mov	dx,fdc_status_reg
  2059 0000104B EC                  <1> 	in	al,dx
  2060 0000104C A880                <1> 	test	al,80h
  2061 0000104E 7404                <1> 	jz	.try_again		; try again if FDC not ready
  2062 00001050 A840                <1> 	test	al,40h
  2063 00001052 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  2064                              <1> .try_again:
  2065 00001054 E8F805              <1> 	call	fdc_reset
  2066 00001057 BAF403              <1> 	mov	dx,fdc_status_reg
  2067 0000105A EC                  <1> 	in	al,dx
  2068 0000105B A880                <1> 	test	al,80h
  2069 0000105D 7440                <1> 	jz	fdc_init_error
  2070 0000105F A840                <1> 	test	al,40h
  2071 00001061 753C                <1> 	jnz	fdc_init_error
  2072                              <1> .fdc_ready:
  2073 00001063 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2074 00001065 E83905              <1> 	call	fdc_write		; send the command
  2075 00001068 7235                <1> 	jc	fdc_init_error
  2076 0000106A E88105              <1> 	call	fdc_read		; read ST0
  2077 0000106D 7230                <1> 	jc	fdc_init_error
  2078 0000106F A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  2079 00001072 88C4                <1> 	mov	ah,al			; save AL to AH
  2080 00001074 E87705              <1> 	call	fdc_read		; read current cylinder
  2081 00001077 7226                <1> 	jc	fdc_init_error
  2082 00001079 A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  2083 0000107C 80E4C0              <1> 	and	ah,0C0h
  2084 0000107F 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  2085 00001082 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  2086                              <1> 
  2087                              <1> ; fall through to fdc_send_specify
  2088                              <1> 
  2089                              <1> ;=========================================================================
  2090                              <1> ; fdc_send_specify - Send specify command to FDC
  2091                              <1> ; Input:
  2092                              <1> ;	none
  2093                              <1> ; Output:
  2094                              <1> ;	CF clear on success
  2095                              <1> ;		AH = 00 - successful completion
  2096                              <1> ;	CF set if error
  2097                              <1> ;		AH = 20h - controller failure
  2098                              <1> ;	AX,CL,SI trashed
  2099                              <1> ; Note:
  2100                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  2101                              <1> ;-------------------------------------------------------------------------
  2102                              <1> fdc_send_specify:
  2103                              <1> 
  2104 00001084 1E                  <1> 	push	ds
  2105 00001085 31C0                <1> 	xor	ax,ax
  2106 00001087 8ED8                <1> 	mov	ds,ax
  2107 00001089 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2108 0000108D B003                <1> 	mov	al,3		 	; FDC Specify command
  2109 0000108F 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  2110 00001091 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  2111 00001094 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  2112 00001096 1F                  <1> 	pop	ds
  2113 00001097 E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  2114 0000109A 7203                <1> 	jc	fdc_init_error
  2115 0000109C B400                <1> 	mov	ah,fdc_e_success	; successful completion
  2116 0000109E C3                  <1> 	ret
  2117                              <1> 
  2118                              <1> fdc_init_error:
  2119 0000109F B420                <1> 	mov	ah,fdc_e_failure
  2120 000010A1 F9                  <1> 	stc
  2121 000010A2 C3                  <1> 	ret
  2122                              <1> 
  2123                              <1> ;=========================================================================
  2124                              <1> ; int_13_fn01 - Get status of last operation
  2125                              <1> ; Input:
  2126                              <1> ;	AH = 01h
  2127                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2128                              <1> ; Output:
  2129                              <1> ;	CF clear if last operation was successful
  2130                              <1> ;		AH = 00h - successful completion
  2131                              <1> ;	CF set on error
  2132                              <1> ;		AH - error code of the last operation
  2133                              <1> ; Note:
  2134                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2135                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2136                              <1> ;-------------------------------------------------------------------------
  2137                              <1> int_13_fn01:
  2138 000010A3 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  2139 000010A7 08E4                <1> 	or	ah,ah
  2140 000010A9 7401                <1> 	jz	.no_error
  2141 000010AB F9                  <1> 	stc
  2142                              <1> .no_error:
  2143 000010AC E9275C              <1> 	jmp	int_13_exit
  2144                              <1> 
  2145                              <1> ;=========================================================================
  2146                              <1> ; int_13_fn08: Get drive parameters
  2147                              <1> ; Input:
  2148                              <1> ;	AH = 08h
  2149                              <1> ;	DL = drive number (0 - 7Fh)
  2150                              <1> ; Output:
  2151                              <1> ;	CF clear if successful
  2152                              <1> ;		AX = 0000h
  2153                              <1> ;		BH = 00h
  2154                              <1> ;		BL = CMOS drive type
  2155                              <1> ;		CH = maximal cylinder number - 1
  2156                              <1> ;		CL = maximal sector number
  2157                              <1> ;		DH = maximal head number
  2158                              <1> ;		DL = number of drives
  2159                              <1> ;		ES:DI -> diskette parameter table
  2160                              <1> ;	CF set on error
  2161                              <1> ;		AH = 01h - drive number is greater than 7Fh
  2162                              <1> ; Notes:
  2163                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  2164                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  2165                              <1> ;	- If media type is not established function sets media parameters 
  2166                              <1> ;	based on CMOS drive type
  2167                              <1> ;-------------------------------------------------------------------------
  2168                              <1> int_13_fn08:
  2169 000010AF 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  2170 000010B2 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  2171 000010B7 A01000              <1> 	mov	al,byte [equipment_list]
  2172 000010BA 2441                <1> 	and	al,equip_floppies|equip_floppy2
  2173 000010BC B402                <1> 	mov	ah,2			; assume two floppy drives
  2174 000010BE 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  2175 000010C0 7406                <1> 	je	.check_drive_number
  2176 000010C2 FECC                <1> 	dec	ah			; assume one floppy drive
  2177 000010C4 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  2178 000010C6 757C                <1> 	jne	.no_drives
  2179                              <1> 
  2180                              <1> .check_drive_number:
  2181 000010C8 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  2182 000010CB 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  2183                              <1> 					; than number of disks?
  2184 000010CD 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  2185 000010CF E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  2186 000010D2 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  2187                              <1> 
  2188 000010D4 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  2189 000010D8 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  2190 000010DB 8CC9                <1> 	mov	cx,cs
  2191 000010DD 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  2192                              <1> 
  2193 000010DF 3C01                <1> 	cmp	al,cmos_360
  2194 000010E1 7417                <1> 	je	.set_360
  2195 000010E3 3C03                <1> 	cmp	al,cmos_720
  2196 000010E5 741E                <1> 	je	.set_720
  2197 000010E7 3C02                <1> 	cmp	al,cmos_1200
  2198 000010E9 7425                <1> 	je	.set_1200
  2199 000010EB 3C04                <1> 	cmp	al,cmos_1440
  2200 000010ED 742C                <1> 	je	.set_1440
  2201                              <1> 
  2202                              <1> .set_2880:
  2203 000010EF B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  2204 000010F1 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  2205 000010F5 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  2206 000010F8 EB2A                <1> 	jmp	.set_media_type
  2207                              <1> 
  2208                              <1> .set_360:
  2209 000010FA B093                <1> 	mov	al,fdc_m_360in360
  2210 000010FC 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2211 00001100 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  2212 00001103 EB1F                <1> 	jmp	.set_media_type
  2213                              <1> 
  2214                              <1> .set_720:
  2215 00001105 B097                <1> 	mov	al,fdc_m_720
  2216 00001107 8D3E[896F]          <1> 	lea	di,[media_720]
  2217 0000110B B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  2218 0000110E EB14                <1> 	jmp	.set_media_type
  2219                              <1> 
  2220                              <1> .set_1200:
  2221 00001110 B002                <1> 	mov	al,fdc_m_try_1200in1200
  2222 00001112 8D3E[7C6F]          <1> 	lea	di,[media_1200]
  2223 00001116 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  2224 00001119 EB09                <1> 	jmp	.set_media_type
  2225                              <1> 
  2226                              <1> .set_1440:
  2227 0000111B B007                <1> 	mov	al,fdc_m_try_1440
  2228 0000111D 8D3E[966F]          <1> 	lea	di,[media_1440]
  2229 00001121 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  2230                              <1> 
  2231                              <1> .set_media_type:
  2232 00001124 BB9000              <1> 	mov	bx,fdc_media_state
  2233 00001127 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2234 00001129 F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  2235 0000112C 7502                <1> 	jnz	.set_parameters		; no need to update if established
  2236 0000112E 8807                <1> 	mov	[bx],al
  2237                              <1> 
  2238                              <1> .set_parameters:
  2239 00001130 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  2240 00001132 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  2241 00001135 A24100              <1> 	mov	byte [fdc_last_error],al
  2242 00001138 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  2243 0000113B 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  2244 0000113E 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  2245 00001141 E9925B              <1> 	jmp	int_13_exit
  2246                              <1> 
  2247                              <1> .no_drives:
  2248 00001144 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  2249                              <1> 
  2250                              <1> .non_existent_drive:
  2251 00001148 31C9                <1> 	xor	cx,cx
  2252 0000114A 31FF                <1> 	xor	di,di
  2253 0000114C 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  2254 0000114F 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  2255 00001152 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  2256 00001154 EBDA                <1> 	jmp	.set_parameters
  2257                              <1> 
  2258                              <1> .invalid_drive:
  2259 00001156 B401                <1> 	mov	ah,fdc_e_invalid
  2260 00001158 F9                  <1> 	stc
  2261 00001159 E97A5B              <1> 	jmp	int_13_exit
  2262                              <1> 
  2263                              <1> ;=========================================================================
  2264                              <1> ; int_13_fn15: Get disk type
  2265                              <1> ; Input:
  2266                              <1> ;	AH = 15h
  2267                              <1> ;	DL = drive number (0 or 1)
  2268                              <1> ; Output:
  2269                              <1> ;	AH = type code:
  2270                              <1> ;		00h - no such drive (invalid drive specified)
  2271                              <1> ;		01h - floppy without change-line support
  2272                              <1> ;		02h - floppy with change-line support
  2273                              <1> ;-------------------------------------------------------------------------
  2274                              <1> int_13_fn15:
  2275 0000115C B400                <1> 	mov	ah,00h			; assume no drive
  2276 0000115E 80FA01              <1> 	cmp	dl,1
  2277 00001161 7711                <1> 	ja	.exit			; jump if invalid drive number
  2278 00001163 E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  2279 00001166 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  2280 00001168 B401                <1> 	mov	ah,01h			; assume no change-line support
  2281 0000116A 3C01                <1> 	cmp	al,cmos_360
  2282 0000116C 7406                <1> 	je	.exit
  2283 0000116E 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  2284 00001170 7402                <1> 	je	.exit
  2285 00001172 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  2286                              <1> 
  2287                              <1> .exit:
  2288 00001174 F8                  <1> 	clc
  2289 00001175 C606410000          <1> 	mov	byte [fdc_last_error],0
  2290 0000117A E9595B              <1> 	jmp	int_13_exit
  2291                              <1> 
  2292                              <1> ;=========================================================================
  2293                              <1> ; int_13_fn16 - Detect disk change
  2294                              <1> ; Input:
  2295                              <1> ;	AH = 16h
  2296                              <1> ;	DL = drive number (0 or 1)
  2297                              <1> ; Output:
  2298                              <1> ;	CF clear if change line inactive
  2299                              <1> ;		AH = 00h - disk not changed
  2300                              <1> ;	CF set if change line active or error
  2301                              <1> ;		AH = 01h - invalid drive number
  2302                              <1> ;		AH = 06h - disk changed or change line not supported
  2303                              <1> ;		AH = 80h - timeout / device not ready
  2304                              <1> ;-------------------------------------------------------------------------
  2305                              <1> int_13_fn16:
  2306 0000117D 80FA01              <1> 	cmp	dl,1
  2307 00001180 7741                <1> 	ja	.invalid_drive
  2308 00001182 E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  2309 00001185 723C                <1> 	jc	.invalid_drive
  2310                              <1> 
  2311 00001187 3C01                <1> 	cmp	al,cmos_360
  2312 00001189 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  2313 0000118B 3C03                <1> 	cmp	al,cmos_720
  2314 0000118D 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  2315                              <1> 
  2316 0000118F E86302              <1> 	call	fdc_motor_on		; turn motor on
  2317 00001192 30E4                <1> 	xor	ah,ah			; assume disk not changed
  2318 00001194 BAF703              <1> 	mov	dx,fdc_dir_reg
  2319 00001197 EC                  <1> 	in	al,dx			; read disk change line
  2320 00001198 D0E0                <1> 	shl	al,1			; bit 7 to CF
  2321 0000119A 7303                <1> 	jnc	.exit
  2322 0000119C B406                <1> 	mov	ah,fdc_e_changed
  2323 0000119E F9                  <1> 	stc
  2324                              <1> 
  2325                              <1> .exit:
  2326 0000119F 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2327 000011A3 9C                  <1> 	pushf
  2328 000011A4 1E                  <1> 	push	ds
  2329 000011A5 31F6                <1> 	xor	si,si
  2330 000011A7 8EDE                <1> 	mov	ds,si
  2331 000011A9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2332 000011AD 8A4C02              <1> 	mov	cl,byte [si+2]
  2333 000011B0 1F                  <1> 	pop	ds
  2334 000011B1 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  2335 000011B5 9D                  <1> 	popf
  2336 000011B6 E91D5B              <1> 	jmp	int_13_exit
  2337                              <1> 
  2338                              <1> 
  2339                              <1> .no_change_line:
  2340 000011B9 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  2341 000011BB F9                  <1> 	stc
  2342 000011BC 88264100            <1> 	mov	byte [fdc_last_error],ah
  2343 000011C0 E9135B              <1> 	jmp	int_13_exit
  2344                              <1> 
  2345                              <1> .invalid_drive:
  2346 000011C3 B401                <1> 	mov	ah,fdc_e_invalid
  2347 000011C5 F9                  <1> 	stc
  2348 000011C6 E90D5B              <1> 	jmp	int_13_exit
  2349                              <1> 
  2350                              <1> ;=========================================================================
  2351                              <1> ; int_13_fn17 - Set disk type for format
  2352                              <1> ; Input:
  2353                              <1> ;	AH = 17h
  2354                              <1> ;	AL = format type
  2355                              <1> ;		01h - 320K / 360K disk in 360K drive
  2356                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  2357                              <1> ;		03h - 1.2M disk in 1.2M drive
  2358                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  2359                              <1> ;	DL = drive number (0 or 1)
  2360                              <1> ; Output:
  2361                              <1> ;	CF clear if successful
  2362                              <1> ;		AH = 00h - successful completion
  2363                              <1> ;	CF set on error
  2364                              <1> ;		AH = 01h - invalid drive number
  2365                              <1> ;		AH = 06h - disk changed
  2366                              <1> ;		AH = 80h - timeout / device not ready
  2367                              <1> ;-------------------------------------------------------------------------
  2368                              <1> int_13_fn17:
  2369 000011C9 80FA01              <1> 	cmp	dl,1
  2370 000011CC 7762                <1> 	ja	.invalid_parameters
  2371 000011CE E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  2372 000011D1 725D                <1> 	jc	.invalid_parameters
  2373 000011D3 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  2374 000011D6 80F900              <1> 	cmp	cl,0			; validate parameters
  2375 000011D9 7455                <1> 	je	.invalid_parameters
  2376 000011DB 80F904              <1> 	cmp	cl,4
  2377 000011DE 7750                <1> 	ja	.invalid_parameters
  2378 000011E0 BB9000              <1> 	mov	bx,fdc_media_state
  2379 000011E3 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2380 000011E5 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  2381 000011E8 7507                <1> 	jne	.not_360in360
  2382 000011EA C60793              <1> 	mov	byte [bx],fdc_m_360in360
  2383 000011ED B400                <1> 	mov	ah,0			; no error
  2384 000011EF EB33                <1> 	jmp	.exit_check_error
  2385                              <1> 
  2386                              <1> .not_360in360:
  2387 000011F1 E80102              <1> 	call	fdc_motor_on
  2388 000011F4 89DE                <1> 	mov	si,bx
  2389 000011F6 E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  2390 000011F9 80FC06              <1> 	cmp	ah,fdc_e_changed
  2391 000011FC 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  2392 000011FE 80FC80              <1> 	cmp	ah,fdc_e_timeout
  2393 00001201 750A                <1> 	jne	.set_type		; floppy disk is installed
  2394 00001203 803F97              <1> 	cmp	byte [bx],fdc_m_720	; 250 Kbps and not 5.25?
  2395 00001206 741C                <1> 	je	.exit_check_error
  2396 00001208 C60761              <1> 	mov	byte [bx],fdc_m_try_360in1200 ; 300 Kpbs, try 360 in 1.2M
  2397 0000120B EB17                <1> 	jmp	.exit_check_error
  2398                              <1> 
  2399                              <1> .set_type:
  2400 0000120D 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  2401 00001210 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  2402 00001212 C60797              <1> 	mov	byte [bx],fdc_m_720
  2403 00001215 EB0D                <1> 	jmp	.exit_check_error
  2404                              <1> 
  2405                              <1> .check_360in1200:
  2406 00001217 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  2407 0000121A 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  2408 0000121C C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  2409 0000121F EB03                <1> 	jmp	.exit_check_error
  2410                              <1> 
  2411                              <1> .set_1200in1200:
  2412 00001221 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  2413                              <1> 
  2414                              <1> .exit_check_error:
  2415 00001224 88264100            <1> 	mov	byte [fdc_last_error],ah
  2416 00001228 08E4                <1> 	or	ah,ah
  2417 0000122A 7401                <1> 	jz	.exit			; jump if no error
  2418 0000122C F9                  <1> 	stc				; indicate error
  2419                              <1> 
  2420                              <1> .exit:
  2421 0000122D E9855A              <1> 	jmp	int_13_upd_exit
  2422                              <1> 
  2423                              <1> .invalid_parameters:
  2424 00001230 B401                <1> 	mov	ah,fdc_e_invalid
  2425 00001232 EBF9                <1> 	jmp	.exit
  2426                              <1> 
  2427                              <1> ;=========================================================================
  2428                              <1> ; int_13_fn18 - Set media type for format
  2429                              <1> ; Input:
  2430                              <1> ;	AH = 18h
  2431                              <1> ;	DL = drive number (0 or 1)
  2432                              <1> ;	CH = number of cylinders - 1
  2433                              <1> ;	CL = sectors per track
  2434                              <1> ; Output:
  2435                              <1> ;	CF = clear if successful
  2436                              <1> ;		AH = 00h - requested format is supported
  2437                              <1> ;		ES:DI -> diskette parameter table
  2438                              <1> ;	CF = set on error
  2439                              <1> ;		AH = 01h - invalid drive number specified
  2440                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  2441                              <1> ;-------------------------------------------------------------------------
  2442                              <1> int_13_fn18:
  2443 00001234 80FA01              <1> 	cmp	dl,1
  2444 00001237 7603E99900          <1> 	ja	.invalid_drive
  2445 0000123C E84504              <1> 	call	read_cmos_type		; get drive type in AL
  2446 0000123F 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  2447                              <1> 
  2448 00001244 BB9000              <1> 	mov	bx,fdc_media_state
  2449 00001247 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2450                              <1> 
  2451 00001249 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  2452 0000124B 7511                <1> 	jne	.try_drive_1200
  2453 0000124D 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  2454 00001251 7403E98300          <1> 	jnz	.unsupported_format
  2455 00001256 B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
  2456 00001258 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2457 0000125C EB54                <1> 	jmp	.set_media
  2458                              <1> 
  2459                              <1> .try_drive_1200:
  2460 0000125E 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2461 00001260 751C                <1> 	jne	.try_drive_2880
  2462 00001262 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2463 00001266 7508                <1> 	jne	.try_media_360_in_1200
  2464 00001268 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
  2465 0000126A 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
  2466 0000126E EB42                <1> 	jmp	.set_media
  2467                              <1> 
  2468                              <1> .try_media_360_in_1200:
  2469 00001270 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2470 00001274 7563                <1> 	jne	.unsupported_format
  2471 00001276 B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
  2472 00001278 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2473 0000127C EB34                <1> 	jmp	.set_media
  2474                              <1> 
  2475                              <1> .try_drive_2880:
  2476 0000127E 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2477 00001280 750E                <1> 	jne	.try_drive_1440
  2478 00001282 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2479 00001286 750C                <1> 	jne	.try_media_1440
  2480 00001288 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2481 0000128A 8D3E[B06F]          <1> 	lea	di,[media_2880]
  2482 0000128E EB22                <1> 	jmp	.set_media
  2483                              <1> 
  2484                              <1> .try_drive_1440:
  2485 00001290 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2486 00001292 750E                <1> 	jne	.try_drive_720
  2487                              <1> 
  2488                              <1> .try_media_1440:
  2489 00001294 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2490 00001298 750C                <1> 	jne	.try_media_720
  2491 0000129A B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2492 0000129C 8D3E[966F]          <1> 	lea	di,[media_1440]
  2493 000012A0 EB10                <1> 	jmp	.set_media
  2494                              <1> 
  2495                              <1> .try_drive_720:
  2496 000012A2 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2497 000012A4 7533                <1> 	jne	.unsupported_format	; should never happen...
  2498                              <1> 
  2499                              <1> .try_media_720:	
  2500 000012A6 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2501 000012AA 752D                <1> 	jne	.unsupported_format
  2502 000012AC B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
  2503 000012AE 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
  2504                              <1> 
  2505                              <1> .set_media:
  2506 000012B2 8807                <1> 	mov	byte [bx],al		; set physical media
  2507 000012B4 E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2508 000012B7 D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2509 000012B9 D0C8                <1> 	ror	al,1
  2510 000012BB 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2511 000012C0 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2512 000012C4 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2513 000012C7 8CC9                <1> 	mov	cx,cs
  2514 000012C9 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2515 000012CB C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2516 000012D0 30E4                <1> 	xor	ah,ah
  2517 000012D2 E9E059              <1> 	jmp	int_13_upd_exit
  2518                              <1> 
  2519                              <1> .invalid_drive:
  2520 000012D5 B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2521 000012D7 EB02                <1> 	jmp	.error
  2522                              <1> 
  2523                              <1> .unsupported_format:
  2524 000012D9 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2525                              <1> 
  2526                              <1> .error:
  2527 000012DB F9                  <1> 	stc
  2528 000012DC E9D659              <1> 	jmp	int_13_upd_exit
  2529                              <1> 
  2530                              <1> ;=========================================================================
  2531                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2532                              <1> ; Input:
  2533                              <1> ;	DL = drive number (0 or 1)
  2534                              <1> ; Output:
  2535                              <1> ;	CF clear if successful
  2536                              <1> ;		AH = 00h - successful completion
  2537                              <1> ;	CF set on error
  2538                              <1> ;		AH = 20h - controller failure
  2539                              <1> ;		AH = 20h - timeout
  2540                              <1> ;	AH trashed
  2541                              <1> ;-------------------------------------------------------------------------
  2542                              <1> fdc_recalibrate:
  2543 000012DF 56                  <1> 	push	si
  2544 000012E0 51                  <1> 	push	cx
  2545 000012E1 52                  <1> 	push	dx
  2546 000012E2 B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2547 000012E4 88D4                <1> 	mov	ah,dl			; drive number
  2548 000012E6 B102                <1> 	mov	cl,2			; 2 bytes command
  2549 000012E8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2550 000012ED E86502              <1> 	call	fdc_send_cmd
  2551 000012F0 7244                <1> 	jc	recal_end		; failure
  2552 000012F2 E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2553 000012F5 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2554 000012F7 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2555 000012F9 B101                <1> 	mov	cl,1			; 1 byte command
  2556 000012FB E85702              <1> 	call	fdc_send_cmd
  2557 000012FE 7236                <1> 	jc	recal_end		; failure
  2558 00001300 B90200              <1> 	mov	cx,2			; 2 bytes result
  2559 00001303 E8B402              <1> 	call	fdc_get_result		; store result
  2560 00001306 722E                <1> 	jc	recal_end		; failure
  2561 00001308 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2562 0000130B B440                <1> 	mov	ah,fdc_e_seek
  2563 0000130D 8A17                <1> 	mov	dl,[bx]			; ST0
  2564 0000130F 80E260              <1> 	and	dl,60h
  2565 00001312 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2566 00001315 F9                  <1> 	stc				; indicate error
  2567 00001316 741E                <1> 	je	recal_end		; failure
  2568 00001318 5A                  <1> 	pop	dx
  2569 00001319 52                  <1> 	push	dx
  2570 0000131A 30F6                <1> 	xor	dh,dh				 
  2571 0000131C BB9400              <1> 	mov	bx,fdc_cylinder
  2572 0000131F 01D3                <1> 	add	bx,dx
  2573 00001321 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2574 00001324 88D1                <1> 	mov	cl,dl
  2575 00001326 B201                <1> 	mov	dl,1
  2576 00001328 D2E2                <1> 	shl	dl,cl
  2577 0000132A 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2578 0000132E B94300              <1> 	mov	cx,43h
  2579 00001331 E868FB              <1> 	call	delay_15us		; 1 ms delay
  2580 00001334 30E4                <1> 	xor	ah,ah
  2581                              <1> 
  2582                              <1> recal_end:
  2583 00001336 88264100            <1> 	mov	byte [fdc_last_error],ah
  2584 0000133A 5A                  <1> 	pop	dx
  2585 0000133B 59                  <1> 	pop	cx
  2586 0000133C 5E                  <1> 	pop	si
  2587 0000133D C3                  <1> 	ret
  2588                              <1> 
  2589                              <1> ;=========================================================================
  2590                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2591                              <1> ; Input:
  2592                              <1> ;	DL = drive number
  2593                              <1> ;	DH = head number
  2594                              <1> ;	CH = cylinder
  2595                              <1> ; Output:
  2596                              <1> ;	CF clear if successful
  2597                              <1> ;		AH = 00h - successful completion
  2598                              <1> ;	CF set on error
  2599                              <1> ;		AH = 20h - controller failure
  2600                              <1> ;		AH = 40h - seek failed
  2601                              <1> ;		AH = 80h - timeout / device not ready
  2602                              <1> ;-------------------------------------------------------------------------
  2603                              <1> fdc_seek:
  2604 0000133E 53                  <1> 	push	bx
  2605 0000133F 51                  <1> 	push	cx
  2606 00001340 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2607 00001344 88D1                <1> 	mov	cl,dl
  2608 00001346 FEC1                <1> 	inc	cl
  2609 00001348 D2EC                <1> 	shr	ah,cl
  2610 0000134A 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2611 0000134C E890FF              <1> 	call	fdc_recalibrate
  2612 0000134F 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2613 00001351 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2614 00001354 727F                <1> 	jc	.exit			; no luck...
  2615                              <1> 
  2616                              <1> .skip_recalibrate:
  2617 00001356 B700                <1> 	mov	bh,00h
  2618 00001358 88D3                <1> 	mov	bl,dl			; BX = drive number
  2619 0000135A F687900020          <1> 	test	byte [fdc_media_state+bx],fdc_m_double_step ; check double
  2620                              <1> 					; steppig bit
  2621 0000135F 7402                <1> 	jz	.no_double_stepping
  2622 00001361 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2623                              <1> 
  2624                              <1> .no_double_stepping:
  2625 00001363 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2626 00001367 750B                <1> 	jne	.do_seek		; jump if seek is required
  2627 00001369 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2628 0000136E 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2629 00001370 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2630 00001372 EB61                <1> 	jmp	.exit
  2631                              <1> 
  2632                              <1> .do_seek:
  2633 00001374 88E8                <1> 	mov	al,ch			; cylinder
  2634 00001376 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2635 00001378 B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2636 0000137A 88F4                <1> 	mov	ah,dh			; head
  2637 0000137C D0E4                <1> 	shl	ah,1
  2638 0000137E D0E4                <1> 	shl	ah,1
  2639 00001380 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2640 00001382 B103                <1> 	mov	cl,3			; 3 bytes command
  2641 00001384 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2642 00001389 E8C901              <1> 	call	fdc_send_cmd
  2643 0000138C 7243                <1> 	jc	.set_result		; seek error
  2644 0000138E E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2645 00001391 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2646                              <1> 
  2647 00001393 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2648 00001395 B101                <1> 	mov	cl,1			; 1 byte command
  2649 00001397 E8BB01              <1> 	call	fdc_send_cmd
  2650 0000139A 7235                <1> 	jc	.set_result		; failure
  2651 0000139C B102                <1> 	mov	cl,2
  2652 0000139E 53                  <1> 	push	bx
  2653 0000139F E81802              <1> 	call	fdc_get_result		; read result bytes
  2654 000013A2 5B                  <1> 	pop	bx
  2655 000013A3 722C                <1> 	jc	.set_result		; error
  2656 000013A5 B440                <1> 	mov	ah,fdc_e_seek
  2657 000013A7 A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2658 000013AA 2460                <1> 	and	al,60h
  2659 000013AC 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2660 000013AE F9                  <1> 	stc
  2661 000013AF 7420                <1> 	je	.set_result		; seek error
  2662 000013B1 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2663                              <1> 
  2664 000013B5 1E                  <1> 	push	ds
  2665 000013B6 31F6                <1> 	xor	si,si
  2666 000013B8 8EDE                <1> 	mov	ds,si
  2667 000013BA C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2668 000013BE 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2669 000013C1 1F                  <1> 	pop	ds
  2670                              <1> 
  2671 000013C2 08C0                <1> 	or	al,al			; head settle time is zero?!
  2672 000013C4 7412                <1> 	jz	.get_settle_time
  2673                              <1> 
  2674 000013C6 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2675 000013C8 F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2676 000013CA 89C1                <1> 	mov	cx,ax
  2677                              <1> 
  2678                              <1> .wait:
  2679 000013CC E8CDFA              <1> 	call	delay_15us
  2680                              <1> 
  2681                              <1> .wait_end:
  2682 000013CF 30E4                <1> 	xor	ah,ah
  2683                              <1> 
  2684                              <1> .set_result:
  2685 000013D1 88264100            <1> 	mov	byte [fdc_last_error],ah
  2686                              <1> 
  2687                              <1> .exit:
  2688 000013D5 59                  <1> 	pop	cx
  2689 000013D6 5B                  <1> 	pop	bx
  2690 000013D7 C3                  <1> 	ret
  2691                              <1> 
  2692                              <1> .get_settle_time:
  2693 000013D8 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2694 000013DD 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2695                              <1> 	
  2696 000013DF 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2697 000013E3 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2698 000013E6 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2699 000013E9 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2700 000013EB 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2701 000013EE 74DC                <1> 	je	.wait			; jump if 360K, media established
  2702 000013F0 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2703 000013F3 EBD7                <1> 	jmp	.wait
  2704                              <1> 
  2705                              <1> ;=========================================================================
  2706                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2707                              <1> ; Input:
  2708                              <1> ;	DL = drive number (0 or 1)
  2709                              <1> ; Output:
  2710                              <1> ;	none
  2711                              <1> ;-------------------------------------------------------------------------
  2712                              <1> fdc_motor_on:
  2713 000013F5 50                  <1> 	push	ax
  2714 000013F6 51                  <1> 	push	cx
  2715 000013F7 52                  <1> 	push	dx
  2716 000013F8 FA                  <1> 	cli				; entering critical section
  2717 000013F9 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2718 000013FE 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2719 00001403 88D1                <1> 	mov	cl,dl			; CL = drive number
  2720 00001405 D0E2                <1> 	shl	dl,1
  2721 00001407 D0E2                <1> 	shl	dl,1
  2722 00001409 D0E2                <1> 	shl	dl,1
  2723 0000140B D0E2                <1> 	shl	dl,1
  2724 0000140D 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2725 00001411 FEC1                <1> 	inc	cl
  2726 00001413 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2727 00001417 D2EA                <1> 	shr	dl,cl
  2728 00001419 7255                <1> 	jc	.already_on
  2729 0000141B B201                <1> 	mov	dl,1
  2730 0000141D FEC9                <1> 	dec	cl
  2731 0000141F D2E2                <1> 	shl	dl,cl
  2732 00001421 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2733 00001425 FB                  <1> 	sti				; end of critical section
  2734 00001426 A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2735 00001429 D0C8                <1> 	ror	al,1
  2736 0000142B D0C8                <1> 	ror	al,1
  2737 0000142D D0C8                <1> 	ror	al,1
  2738 0000142F D0C8                <1> 	ror	al,1
  2739 00001431 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2740 00001433 BAF203              <1> 	mov	dx,fdc_dor_reg
  2741 00001436 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2742 00001437 B8FD90              <1> 	mov	ax,90FDh
  2743 0000143A CD15                <1> 	int	15h			; call OS hook
  2744 0000143C 722E                <1> 	jc	.exit
  2745 0000143E 1E                  <1> 	push	ds
  2746 0000143F 56                  <1> 	push	si
  2747 00001440 31F6                <1> 	xor	si,si
  2748 00001442 8EDE                <1> 	mov	ds,si
  2749 00001444 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2750 00001448 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2751 0000144B 5E                  <1> 	pop	si
  2752 0000144C 1F                  <1> 	pop	ds
  2753                              <1> 
  2754 0000144D F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2755 00001452 7408                <1> 	jz	.read_verify		; jump if not write operation
  2756 00001454 3C08                <1> 	cmp	al,8
  2757 00001456 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2758 00001458 B008                <1> 	mov	al,8			; wait at least 1 second for write
  2759 0000145A EB06                <1> 	jmp	.wait_loop
  2760                              <1> 
  2761                              <1> .read_verify:
  2762 0000145C 3C05                <1> 	cmp	al,5
  2763 0000145E 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2764 00001460 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2765                              <1> 
  2766                              <1> .wait_loop:
  2767 00001462 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2768 00001465 E834FA              <1> 	call	delay_15us		; wait 125 ms
  2769 00001468 FEC8                <1> 	dec	al
  2770 0000146A 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2771                              <1> 
  2772                              <1> .exit:
  2773 0000146C 59                  <1> 	pop	cx
  2774 0000146D 5A                  <1> 	pop	dx
  2775 0000146E 58                  <1> 	pop	ax
  2776 0000146F C3                  <1> 	ret
  2777                              <1> 
  2778                              <1> .already_on:
  2779 00001470 FB                  <1> 	sti
  2780 00001471 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2781 00001474 D0C8                <1> 	ror	al,1
  2782 00001476 D0C8                <1> 	ror	al,1
  2783 00001478 D0C8                <1> 	ror	al,1
  2784 0000147A D0C8                <1> 	ror	al,1
  2785 0000147C 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2786 0000147E BAF203              <1> 	mov	dx,fdc_dor_reg
  2787 00001481 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2788 00001482 EBE8                <1> 	jmp	.exit
  2789                              <1> 
  2790                              <1> ;=========================================================================
  2791                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2792                              <1> ; Input:
  2793                              <1> ;	CH = cylinder
  2794                              <1> ;	DH = head
  2795                              <1> ; Output:
  2796                              <1> ;	BL = next sector to be transferred
  2797                              <1> ;-------------------------------------------------------------------------	
  2798                              <1> 
  2799                              <1> fdc_end_io:
  2800 00001484 50                  <1> 	push	ax
  2801 00001485 1E                  <1> 	push	ds
  2802 00001486 31DB                <1> 	xor	bx,bx
  2803 00001488 8EDB                <1> 	mov	ds,bx
  2804 0000148A C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2805 0000148E 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2806 00001491 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2807 00001494 FEC0                <1> 	inc	al
  2808 00001496 1F                  <1> 	pop	ds
  2809 00001497 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2810 0000149A 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2811 0000149D 7508                <1> 	jne	.exit
  2812 0000149F 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2813 000014A2 7503                <1> 	jne	.exit
  2814 000014A4 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2815                              <1> .exit:
  2816 000014A7 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2817 000014AB 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2818 000014AD 58                  <1> 	pop	ax
  2819 000014AE C3                  <1> 	ret
  2820                              <1> 
  2821                              <1> ;========================================================================
  2822                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2823                              <1> ; Input:
  2824                              <1> ;	AL = CMOS drive type
  2825                              <1> ;	DS:SI -> drive media type
  2826                              <1> ; Output:
  2827                              <1> ;	CF clear if disk not changed
  2828                              <1> ;		AH = 00h - disk not changed
  2829                              <1> ;	CF set if disk changed or on error
  2830                              <1> ;		AH = 06h - disk changed
  2831                              <1> ;		AH = error code
  2832                              <1> ; Note:
  2833                              <1> ;	Motor needs to be turned on before calling this function
  2834                              <1> ;------------------------------------------------------------------------
  2835                              <1> fdc_disk_change:
  2836 000014AF 51                  <1> 	push	cx
  2837 000014B0 B400                <1> 	mov	ah,0
  2838 000014B2 3C01                <1> 	cmp	al,cmos_360
  2839 000014B4 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2840 000014B6 3C03                <1> 	cmp	al,cmos_720
  2841 000014B8 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2842                              <1> .cmos_invalid:
  2843 000014BA 8A04                <1> 	mov	al,[si]			; media type
  2844 000014BC 2407                <1> 	and	al,fdc_m_state_bits
  2845 000014BE 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2846 000014C0 3C03                <1> 	cmp	al,3
  2847 000014C2 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2848 000014C4 BAF703              <1> 	mov	dx,fdc_dir_reg
  2849 000014C7 EC                  <1> 	in	al,dx			; read disk change line
  2850 000014C8 D0E0                <1> 	shl	al,1
  2851 000014CA 7326                <1> 	jnc	.exit			; no disk change
  2852 000014CC 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2853 000014CF E86CFB              <1> 	call	fdc_init		; full initialization
  2854 000014D2 721E                <1> 	jc	.exit
  2855 000014D4 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2856 000014D7 B501                <1> 	mov	ch,1
  2857 000014D9 E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2858 000014DC 7214                <1> 	jc	.exit
  2859 000014DE B500                <1> 	mov	ch,0
  2860 000014E0 E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2861 000014E3 720D                <1> 	jc	.exit
  2862 000014E5 B406                <1> 	mov	ah,fdc_e_changed
  2863 000014E7 BAF703              <1> 	mov	dx,fdc_dir_reg
  2864 000014EA EC                  <1> 	in	al,dx			; read disk change line
  2865 000014EB D0E0                <1> 	shl	al,1
  2866 000014ED 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2867 000014EF B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2868                              <1> 
  2869                              <1> .changed_or_error:
  2870 000014F1 F9                  <1> 	stc
  2871                              <1> 
  2872                              <1> .exit:
  2873 000014F2 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2874 000014F5 59                  <1> 	pop	cx
  2875 000014F6 C3                  <1> 	ret
  2876                              <1> 
  2877                              <1> ;=========================================================================
  2878                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2879                              <1> ; Input:
  2880                              <1> ;	AL = DMA mode byte
  2881                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2882                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2883                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2884                              <1> ;	CX = byte count (minus 1)
  2885                              <1> ;	ES:BX -> buffer address for DMA operation
  2886                              <1> ; Output:
  2887                              <1> ;	CF clear on success
  2888                              <1> ;	CF set if error
  2889                              <1> ;		AH = 08h - DMA overrun
  2890                              <1> ;	AX,BX trashed
  2891                              <1> ; Note:
  2892                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2893                              <1> ;-------------------------------------------------------------------------
  2894                              <1> fdc_configure_dma:
  2895 000014F7 52                  <1> 	push	dx
  2896 000014F8 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2897 000014FA D1C2                <1> 	rol	dx,1
  2898 000014FC D1C2                <1> 	rol	dx,1
  2899 000014FE D1C2                <1> 	rol	dx,1
  2900 00001500 D1C2                <1> 	rol	dx,1
  2901 00001502 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2902 00001504 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2903 00001507 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2904 0000150A 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2905 0000150C 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2906                              <1> 
  2907 0000150F 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2908 00001511 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2909 00001513 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2910                              <1> 
  2911 00001515 FA                  <1> 	cli
  2912 00001516 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2913 00001518 EB00                <1> 	jmp	$+2
  2914 0000151A EB00                <1> 	jmp	$+2
  2915 0000151C E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2916 0000151E EB00                <1> 	jmp	$+2
  2917 00001520 EB00                <1> 	jmp	$+2
  2918 00001522 88C8                <1> 	mov	al,cl
  2919 00001524 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2920 00001526 EB00                <1> 	jmp	$+2
  2921 00001528 EB00                <1> 	jmp	$+2
  2922 0000152A 88E8                <1> 	mov	al,ch
  2923 0000152C E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2924 0000152E EB00                <1> 	jmp	$+2
  2925 00001530 EB00                <1> 	jmp	$+2
  2926 00001532 88D0                <1> 	mov	al,dl
  2927 00001534 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2928 00001536 EB00                <1> 	jmp	$+2
  2929 00001538 EB00                <1> 	jmp	$+2
  2930 0000153A 88F0                <1> 	mov	al,dh
  2931 0000153C E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2932 0000153E EB00                <1> 	jmp	$+2
  2933 00001540 EB00                <1> 	jmp	$+2
  2934 00001542 88E0                <1> 	mov	al,ah
  2935 00001544 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2936 00001546 EB00                <1> 	jmp	$+2
  2937 00001548 EB00                <1> 	jmp	$+2
  2938 0000154A B002                <1> 	mov	al,2
  2939 0000154C E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2940 0000154E FB                  <1> 	sti
  2941                              <1> 
  2942                              <1> .exit:
  2943 0000154F 5A                  <1> 	pop	dx
  2944 00001550 C3                  <1> 	ret
  2945                              <1> 
  2946                              <1> .dma_boundary:				; Note: CF is already set
  2947 00001551 B409                <1> 	mov	ah,fdc_e_boundary
  2948 00001553 EBFA                <1> 	jmp	.exit
  2949                              <1> 
  2950                              <1> ;=========================================================================
  2951                              <1> ; fdc_send_cmd - Send a command to FDC
  2952                              <1> ; Input:
  2953                              <1> ;	AL = 1st byte of the command
  2954                              <1> ;	AH = 2nd byte of the command
  2955                              <1> ;	SI = 3rd and 4th bytes of the command
  2956                              <1> ;	DI = 5th and 6th bytes of the command
  2957                              <1> ;	BL = 7th byte of the command
  2958                              <1> ;	BH = 8th byte of the command
  2959                              <1> ;	CH = 9th byte of the command
  2960                              <1> ;	CL = command length (number of bytes)
  2961                              <1> ; Output:
  2962                              <1> ;	CF clear if successful
  2963                              <1> ;		AH = 00h - successful completion
  2964                              <1> ;	CF set on error
  2965                              <1> ;		AH = 20h - controller failure
  2966                              <1> ;		AH = 80h - timeout / device not ready
  2967                              <1> ;	AX trashed
  2968                              <1> ;-------------------------------------------------------------------------
  2969                              <1> fdc_send_cmd:
  2970 00001555 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2971 00001558 FEC9                <1> 	dec	cl
  2972 0000155A 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2973 0000155C 88E0                <1> 	mov	al,ah
  2974 0000155E E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2975 00001561 FEC9                <1> 	dec	cl
  2976 00001563 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2977 00001565 89F0                <1> 	mov	ax,si
  2978 00001567 E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2979 0000156A FEC9                <1> 	dec	cl
  2980 0000156C 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2981 0000156E 88E0                <1> 	mov	al,ah
  2982 00001570 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2983 00001573 FEC9                <1> 	dec	cl
  2984 00001575 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2985 00001577 89F8                <1> 	mov	ax,di
  2986 00001579 E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2987 0000157C FEC9                <1> 	dec	cl
  2988 0000157E 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2989 00001580 88E0                <1> 	mov	al,ah
  2990 00001582 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2991 00001585 FEC9                <1> 	dec	cl
  2992 00001587 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2993 00001589 88D8                <1> 	mov	al,bl
  2994 0000158B E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2995 0000158E FEC9                <1> 	dec	cl
  2996 00001590 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2997 00001592 88F8                <1> 	mov	al,bh
  2998 00001594 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2999 00001597 FEC9                <1> 	dec	cl
  3000 00001599 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  3001 0000159B 88E8                <1> 	mov	al,ch
  3002 0000159D E80100              <1> 	call	fdc_write		; send CH (9th byte)
  3003                              <1> 
  3004                              <1> .send_cmd_exit:
  3005 000015A0 C3                  <1> 	ret
  3006                              <1> 
  3007                              <1> ;=========================================================================
  3008                              <1> ; fdc_write - Send byte to FDC
  3009                              <1> ; Input:
  3010                              <1> ;	AL = byte to send
  3011                              <1> ; Output:
  3012                              <1> ;	CF clear if successful
  3013                              <1> ;	CF set if timeout
  3014                              <1> ;		AH = 80h - timeout / device not ready
  3015                              <1> ;-------------------------------------------------------------------------
  3016                              <1> fdc_write:
  3017 000015A1 52                  <1> 	push	dx
  3018 000015A2 50                  <1> 	push	ax
  3019 000015A3 E83502              <1> 	call	fdc_wait_ready
  3020 000015A6 720D                <1> 	jc	.timeout
  3021 000015A8 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  3022 000015AA 3C80                <1> 	cmp	al,fdc_stat_ready
  3023 000015AC 7507                <1> 	jne	.timeout
  3024 000015AE 58                  <1> 	pop	ax
  3025 000015AF BAF503              <1> 	mov	dx,fdc_data_reg
  3026 000015B2 EE                  <1> 	out	dx,al			; write byte
  3027                              <1> 
  3028                              <1> .exit:
  3029 000015B3 5A                  <1> 	pop	dx
  3030 000015B4 C3                  <1> 	ret
  3031                              <1> 
  3032                              <1> .timeout:
  3033 000015B5 58                  <1> 	pop	ax
  3034 000015B6 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3035 000015B8 EBF9                <1> 	jmp	.exit
  3036                              <1> 
  3037                              <1> ;=========================================================================
  3038                              <1> ; fdc_get_result - Read FDC result
  3039                              <1> ; Input:
  3040                              <1> ;	CL = number of result bytes
  3041                              <1> ; Output:
  3042                              <1> ;	CF clear if successful
  3043                              <1> ;		AH = 00h - operation successful
  3044                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  3045                              <1> ;	CF set on error
  3046                              <1> ;		AH = 20h - controller failure
  3047                              <1> ;		AH = 80h - timeout / device not ready
  3048                              <1> ;	AL,BX - trashed
  3049                              <1> ;-------------------------------------------------------------------------
  3050                              <1> fdc_get_result:
  3051 000015BA 52                  <1> 	push	dx
  3052 000015BB BB4200              <1> 	mov	bx,fdc_ctrl_status
  3053                              <1> 
  3054                              <1> .next_byte:
  3055 000015BE E81A02              <1> 	call	fdc_wait_ready
  3056 000015C1 7222                <1> 	jc	.timeout
  3057 000015C3 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  3058 000015C5 88C4                <1> 	mov	ah,al
  3059 000015C7 80E4EF              <1> 	and	ah,~fdc_stat_busy
  3060 000015CA 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  3061 000015CD 7412                <1> 	je	.done			; jump if finished
  3062 000015CF 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  3063 000015D1 7516                <1> 	jne	.failure		; jump on invalid controller status
  3064 000015D3 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  3065 000015D6 7311                <1> 	jnb	.failure		; controller error if so
  3066 000015D8 BAF503              <1> 	mov	dx,fdc_data_reg
  3067 000015DB EC                  <1> 	in	al,dx
  3068 000015DC 8807                <1> 	mov	byte [bx],al
  3069 000015DE 43                  <1> 	inc	bx
  3070 000015DF EBDD                <1> 	jmp	.next_byte
  3071                              <1> 
  3072                              <1> .done:
  3073 000015E1 30E4                <1> 	xor	ah,ah			; operation successful
  3074                              <1> 
  3075                              <1> .exit:
  3076 000015E3 5A                  <1> 	pop	dx
  3077 000015E4 C3                  <1> 	ret
  3078                              <1> 
  3079                              <1> .timeout:
  3080 000015E5 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3081 000015E7 EBFA                <1> 	jmp	.exit
  3082                              <1> 
  3083                              <1> .failure:
  3084 000015E9 B420                <1> 	mov	ah,fdc_e_failure
  3085 000015EB F9                  <1> 	stc
  3086 000015EC EBF5                <1> 	jmp	.exit
  3087                              <1> 
  3088                              <1> ;=========================================================================
  3089                              <1> ; fdc_read - Read byte from FDC
  3090                              <1> ; Input:
  3091                              <1> ;	none
  3092                              <1> ; Output:
  3093                              <1> ;	CF clear if successful
  3094                              <1> ;		AL = byte read from FDC
  3095                              <1> ;		AH - unchanged
  3096                              <1> ;	CF set on error
  3097                              <1> ;		AH = 20h - controller failure
  3098                              <1> ;		AH = 80h - timeout / device not ready
  3099                              <1> ;	CX trashed
  3100                              <1> ;-------------------------------------------------------------------------
  3101                              <1> fdc_read:
  3102 000015EE 52                  <1> 	push	dx
  3103 000015EF BAF403              <1> 	mov	dx,fdc_status_reg
  3104 000015F2 E8E601              <1> 	call	fdc_wait_ready
  3105 000015F5 720F                <1> 	jc	.timeout
  3106 000015F7 EC                  <1> 	in	al,dx
  3107 000015F8 A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  3108 000015FA 740E                <1> 	jz	.failure		; jump if not ready
  3109 000015FC EB00                <1> 	jmp	short $+2		; I/O delay
  3110 000015FE EB00                <1> 	jmp	short $+2
  3111 00001600 BAF503              <1> 	mov	dx,fdc_data_reg
  3112 00001603 EC                  <1> 	in	al,dx			; read the byte
  3113                              <1> 
  3114                              <1> .exit:
  3115 00001604 5A                  <1> 	pop	dx
  3116 00001605 C3                  <1> 	ret
  3117                              <1> 
  3118                              <1> .timeout:
  3119 00001606 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3120 00001608 EBFA                <1> 	jmp	.exit
  3121                              <1> 
  3122                              <1> .failure:
  3123 0000160A B420                <1> 	mov	ah,fdc_e_failure
  3124 0000160C F9                  <1> 	stc
  3125 0000160D EBF5                <1> 	jmp	.exit
  3126                              <1> 
  3127                              <1> ;=========================================================================
  3128                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  3129                              <1> ; Input:
  3130                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  3131                              <1> ; Output:
  3132                              <1> ;	AH = error code
  3133                              <1> ;-------------------------------------------------------------------------
  3134                              <1> 
  3135                              <1> fdc_get_error:
  3136 0000160F BB4200              <1> 	mov	bx,fdc_ctrl_status
  3137 00001612 8B1F                <1> 	mov	bx,[bx]
  3138 00001614 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  3139 00001617 B400                <1> 	mov	ah,fdc_e_success
  3140 00001619 7433                <1> 	jz	.exit			; jump if successful completion
  3141 0000161B F6C340              <1> 	test	bl,40h			; abnormal termination?
  3142 0000161E B420                <1> 	mov	ah,fdc_e_failure
  3143 00001620 742C                <1> 	jz	.exit
  3144 00001622 F6C701              <1> 	test	bh,1			; address mark not found?
  3145 00001625 B402                <1> 	mov	ah,fdc_e_address
  3146 00001627 7525                <1> 	jnz	.exit
  3147 00001629 F6C702              <1> 	test	bh,2			; disk write protected?
  3148 0000162C B403                <1> 	mov	ah,fdc_e_wprotect
  3149 0000162E 751E                <1> 	jnz	.exit
  3150 00001630 F6C704              <1> 	test	bh,4			; sector not found?
  3151 00001633 B404                <1> 	mov	ah,fdc_e_notfound
  3152 00001635 7517                <1> 	jnz	.exit
  3153 00001637 F6C710              <1> 	test	bh,10H			; DMA overrun?
  3154 0000163A B408                <1> 	mov	ah,fdc_e_dma
  3155 0000163C 7510                <1> 	jnz	.exit
  3156 0000163E F6C720              <1> 	test	bh,20H			; CRC error?
  3157 00001641 B410                <1> 	mov	ah,fdc_e_crc
  3158 00001643 7509                <1> 	jnz	.exit
  3159 00001645 F6C780              <1> 	test	bh,80h			; access after last sector?
  3160 00001648 B404                <1> 	mov	ah,fdc_e_notfound
  3161 0000164A 7502                <1> 	jnz	.exit
  3162 0000164C B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  3163                              <1> 
  3164                              <1> .exit:
  3165 0000164E C3                  <1> 	ret
  3166                              <1> 
  3167                              <1> ;=========================================================================
  3168                              <1> ; fdc_reset - Reset FDC
  3169                              <1> ; Input:
  3170                              <1> ;	none
  3171                              <1> ; Output:
  3172                              <1> ;	Resets FDC flags in BIOS area
  3173                              <1> ;	AX,CX,DX - trashed 
  3174                              <1> ;-------------------------------------------------------------------------
  3175                              <1> 
  3176                              <1> fdc_reset:
  3177 0000164F FA                  <1> 	cli
  3178 00001650 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  3179 00001655 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3180 0000165A A03F00              <1> 	mov	al,byte [fdc_motor_state]
  3181 0000165D D0C0                <1> 	rol	al,1			; after rol:
  3182 0000165F D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  3183 00001661 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  3184 00001663 D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  3185 00001665 24FB                <1> 	and	al,0FBh			; clear reserved bit
  3186 00001667 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  3187 00001669 BAF203              <1> 	mov	dx,fdc_dor_reg
  3188 0000166C EE                  <1> 	out	dx,al			; send it to FDC
  3189 0000166D B90300              <1> 	mov	cx,3
  3190 00001670 E829F8              <1> 	call	delay_15us		; 30-45 us delay
  3191 00001673 0C0C                <1> 	or	al,0Ch
  3192 00001675 EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  3193 00001676 FB                  <1> 	sti
  3194 00001677 E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3195 0000167A 7207                <1> 	jc	.exit
  3196 0000167C 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  3197 00001681 30E4                <1> 	xor	ah,ah			; no errors
  3198                              <1> .exit:
  3199 00001683 C3                  <1> 	ret
  3200                              <1> 
  3201                              <1> ;=========================================================================
  3202                              <1> ; read_cmos_type - Read drive type from CMOS
  3203                              <1> ; Input:
  3204                              <1> ;	DL = drive number (0 or 1)
  3205                              <1> ; Output:
  3206                              <1> ;	CF clear if successful
  3207                              <1> ;		AL = drive type
  3208                              <1> ;	CF set on error (invalid drive type)
  3209                              <1> ;=========================================================================
  3210                              <1> 
  3211                              <1> read_cmos_type:
  3212 00001684 B010                <1> 	mov	al,cmos_floppy
  3213 00001686 E80EF4              <1> 	call	rtc_read		; read drive type
  3214 00001689 08D2                <1> 	or	dl,dl			; drive 0?
  3215 0000168B 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  3216 0000168D D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  3217 0000168F D0E8                <1> 	shr	al,1
  3218 00001691 D0E8                <1> 	shr	al,1
  3219 00001693 D0E8                <1> 	shr	al,1
  3220                              <1> .drive_1:
  3221 00001695 240F                <1> 	and	al,0Fh			; mask drive bits
  3222 00001697 3C00                <1> 	cmp	al,cmos_no_floppy
  3223 00001699 740A                <1> 	je	.error
  3224 0000169B 3C05                <1> 	cmp	al,5			; invalid value
  3225 0000169D 7406                <1> 	je	.error
  3226 0000169F 3C06                <1> 	cmp	al,cmos_2880
  3227 000016A1 7702                <1> 	ja	.error
  3228 000016A3 F8                  <1> 	clc
  3229 000016A4 C3                  <1> 	ret
  3230                              <1> 
  3231                              <1> .error:
  3232 000016A5 F9                  <1> 	stc
  3233 000016A6 C3                  <1> 	ret
  3234                              <1> 
  3235                              <1> ;=========================================================================
  3236                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  3237                              <1> ; Input:
  3238                              <1> ;	none, expects drive number in [bp+int_13_dl]
  3239                              <1> ; Output:
  3240                              <1> ;	CF clear if successful
  3241                              <1> ;		AH = 00h
  3242                              <1> ;	CF set on error
  3243                              <1> ;		AH = 20h - invalid CMOS
  3244                              <1> ;-------------------------------------------------------------------------
  3245                              <1> fdc_detect_media:
  3246 000016A7 52                  <1> 	push	dx
  3247 000016A8 51                  <1> 	push	cx
  3248 000016A9 53                  <1> 	push	bx
  3249 000016AA 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  3250 000016AD BB9000              <1> 	mov	bx,fdc_media_state
  3251 000016B0 00D3                <1> 	add	bl,dl
  3252 000016B2 E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  3253 000016B5 B400                <1> 	mov	ah,0
  3254 000016B7 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  3255                              <1> 
  3256 000016B9 3C03                <1> 	cmp	al,cmos_720
  3257 000016BB 7410                <1> 	je	.set_720
  3258 000016BD 3C02                <1> 	cmp	al,cmos_1200
  3259 000016BF 7415                <1> 	je	.detect_1200
  3260 000016C1 3C04                <1> 	cmp	al,cmos_1440
  3261 000016C3 7427                <1> 	je	.detect_1440
  3262 000016C5 3C06                <1> 	cmp	al,cmos_2880
  3263 000016C7 7439                <1> 	je	.detect_2880
  3264                              <1> 	
  3265 000016C9 B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  3266 000016CB EB02                <1> 	jmp	.set_rate
  3267                              <1> 
  3268                              <1> .set_720:
  3269 000016CD B097                <1> 	mov	al,fdc_m_720
  3270                              <1> 
  3271                              <1> .set_rate:
  3272 000016CF 50                  <1> 	push	ax
  3273 000016D0 E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  3274 000016D3 58                  <1> 	pop	ax
  3275 000016D4 EB49                <1> 	jmp	.exit_set_media
  3276                              <1> 
  3277                              <1> .detect_1200:
  3278 000016D6 B000                <1> 	mov	al,0			; try 500 Kbps
  3279 000016D8 E85300              <1> 	call	fdc_read_id
  3280 000016DB B015                <1> 	mov	al,fdc_m_1200in1200
  3281 000016DD 7340                <1> 	jnc	.exit_set_media		; jump if successful
  3282 000016DF B040                <1> 	mov	al,40h			; try 300 Kbps
  3283 000016E1 E84A00              <1> 	call	fdc_read_id
  3284 000016E4 B074                <1> 	mov	al,fdc_m_360in1200
  3285 000016E6 7337                <1> 	jnc	.exit_set_media		; jump if successful
  3286 000016E8 B002                <1> 	mov	al,fdc_m_try_1200in1200
  3287 000016EA EB33                <1> 	jmp	.exit_set_media
  3288                              <1> 
  3289                              <1> .detect_1440:
  3290 000016EC B000                <1> 	mov	al,0			; try 500 Kbps
  3291 000016EE E83D00              <1> 	call	fdc_read_id
  3292 000016F1 B017                <1> 	mov	al,fdc_m_1440
  3293 000016F3 732A                <1> 	jnc	.exit_set_media		; jump if successful
  3294 000016F5 B080                <1> 	mov	al,80h			; try 250 Kbps
  3295 000016F7 E83400              <1> 	call	fdc_read_id
  3296 000016FA B097                <1> 	mov	al,fdc_m_720
  3297 000016FC 7321                <1> 	jnc	.exit_set_media		; jump if successful
  3298 000016FE B007                <1> 	mov	al,fdc_m_try_1440
  3299 00001700 EB1D                <1> 	jmp	.exit_set_media
  3300                              <1> 
  3301                              <1> .detect_2880:
  3302 00001702 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  3303 00001704 E82700              <1> 	call	fdc_read_id
  3304 00001707 B0D7                <1> 	mov	al,fdc_m_2880
  3305 00001709 7314                <1> 	jnc	.exit_set_media		; jump if successful
  3306 0000170B B000                <1> 	mov	al,0			; try 500 Kbps
  3307 0000170D E81E00              <1> 	call	fdc_read_id
  3308 00001710 B017                <1> 	mov	al,fdc_m_1440
  3309 00001712 730B                <1> 	jnc	.exit_set_media		; jump if successful
  3310 00001714 B080                <1> 	mov	al,80h			; try 250 Kbps
  3311 00001716 E81500              <1> 	call	fdc_read_id
  3312 00001719 B097                <1> 	mov	al,fdc_m_720
  3313 0000171B 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  3314 0000171D B0C7                <1> 	mov	al,fdc_m_try_2880
  3315                              <1> 
  3316                              <1> .exit_set_media:
  3317 0000171F 8807                <1> 	mov	byte [bx],al		; set media type
  3318                              <1> 
  3319                              <1> .exit:
  3320 00001721 88264100            <1> 	mov	byte [fdc_last_error],ah
  3321 00001725 5B                  <1> 	pop	bx
  3322 00001726 59                  <1> 	pop	cx
  3323 00001727 5A                  <1> 	pop	dx
  3324 00001728 C3                  <1> 	ret
  3325                              <1> 
  3326                              <1> .invalid_cmos:
  3327 00001729 B420                <1> 	mov	ah,fdc_e_failure
  3328 0000172B F9                  <1> 	stc
  3329 0000172C EBF3                <1> 	jmp	.exit
  3330                              <1> 
  3331                              <1> ;=========================================================================
  3332                              <1> ; fdc_read_id - Read ID
  3333                              <1> ; Input:
  3334                              <1> ;	AL = data transfer rate (bits 7-6)
  3335                              <1> ; Output:
  3336                              <1> ;	CF clear if successful
  3337                              <1> ;		AH = 0 - successful completion
  3338                              <1> ;		AL = ID (bits 7-6)
  3339                              <1> ;	CF set on error
  3340                              <1> ;		AH = error code
  3341                              <1> ;-------------------------------------------------------------------------
  3342                              <1> fdc_read_id:
  3343 0000172E 53                  <1> 	push	bx
  3344 0000172F C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  3345 00001734 E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  3346 00001737 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  3347 0000173A E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  3348 0000173D 7305                <1> 	jnc	.do_read_id
  3349 0000173F E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  3350 00001742 722D                <1> 	jc	.error
  3351                              <1> 
  3352                              <1> .do_read_id:
  3353 00001744 B90300              <1> 	mov	cx,3			; 3 attempts
  3354                              <1> 
  3355                              <1> .read_id_loop:
  3356 00001747 51                  <1> 	push	cx
  3357 00001748 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  3358 0000174A 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  3359 0000174C B102                <1> 	mov	cl,2			; 2 byte commands
  3360 0000174E 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3361 00001753 E8FFFD              <1> 	call	fdc_send_cmd
  3362 00001756 7218                <1> 	jc	.error_cmd
  3363 00001758 E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3364 0000175B 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  3365 0000175D B107                <1> 	mov	cl,7
  3366 0000175F E858FE              <1> 	call	fdc_get_result		; read result bytes
  3367 00001762 720C                <1> 	jc	.error_cmd
  3368 00001764 E8A8FE              <1> 	call	fdc_get_error		; get error code
  3369 00001767 59                  <1> 	pop	cx
  3370 00001768 08E4                <1> 	or	ah,ah
  3371 0000176A 7406                <1> 	jz	.exit			; if no errors
  3372 0000176C E2D9                <1> 	loop	.read_id_loop		; retry
  3373 0000176E EB01                <1> 	jmp	.error
  3374                              <1> 
  3375                              <1> .error_cmd:
  3376 00001770 59                  <1> 	pop	cx
  3377                              <1> 
  3378                              <1> .error:
  3379 00001771 F9                  <1> 	stc
  3380                              <1> 
  3381                              <1> .exit:
  3382 00001772 5B                  <1> 	pop	bx
  3383 00001773 C3                  <1> 	ret
  3384                              <1> 
  3385                              <1> ;=========================================================================
  3386                              <1> ; fdc_select_rate - Select FDC transfer rate
  3387                              <1> ; Input:
  3388                              <1> ;	none
  3389                              <1> ; Output:
  3390                              <1> ;	AL = data transfer rate (bits 7-6)
  3391                              <1> ;-------------------------------------------------------------------------
  3392                              <1> fdc_select_rate:
  3393 00001774 53                  <1> 	push	bx
  3394 00001775 BB9000              <1> 	mov	bx,fdc_media_state
  3395 00001778 00D3                <1> 	add	bl,dl			; SI -> drive media state
  3396 0000177A 8A37                <1> 	mov	dh,byte [bx]		; new media status
  3397 0000177C 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  3398 00001780 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  3399 00001784 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  3400 00001786 740E                <1> 	je	.exit			; exit if rate is already selected
  3401 00001788 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  3402 0000178D 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  3403 00001791 88F0                <1> 	mov	al,dh
  3404 00001793 E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  3405                              <1> 
  3406                              <1> .exit:
  3407 00001796 5B                  <1> 	pop	bx
  3408 00001797 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  3409 0000179A C3                  <1> 	ret
  3410                              <1> 
  3411                              <1> ;=========================================================================
  3412                              <1> ; fdc_set_rate - Set transfer rate
  3413                              <1> ; Input:
  3414                              <1> ;	AL = transfer rate (bits 7 and 6)
  3415                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  3416                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  3417                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  3418                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  3419                              <1> ; Output:
  3420                              <1> ;	AL = transfer rate (bits 1 and 0)
  3421                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  3422                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  3423                              <1> ;	DX = 3F7h - FDC CCR
  3424                              <1> ;-------------------------------------------------------------------------
  3425                              <1> fdc_set_rate:
  3426 0000179B 24C0                <1> 	and	al,fdc_m_rate_bits
  3427 0000179D D0C0                <1> 	rol	al,1
  3428 0000179F D0C0                <1> 	rol	al,1
  3429 000017A1 BAF703              <1> 	mov	dx,fdc_ccr_reg
  3430 000017A4 EE                  <1> 	out	dx,al
  3431 000017A5 C3                  <1> 	ret
  3432                              <1> 
  3433                              <1> ;=========================================================================
  3434                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  3435                              <1> ; Input:
  3436                              <1> ;	none
  3437                              <1> ; Output:
  3438                              <1> ;	CF clear if interrupt had occurred
  3439                              <1> ;		AH = 00h - successful completion
  3440                              <1> ;	CF set if no interrupt
  3441                              <1> ;		AH = 80h - timeout
  3442                              <1> ;	BX = fdc_calib_state
  3443                              <1> ;	AL,CX - trashed
  3444                              <1> ;-------------------------------------------------------------------------
  3445                              <1> fdc_wait_irq:
  3446 000017A6 FB                  <1> 	sti
  3447 000017A7 F8                  <1> 	clc
  3448 000017A8 B80190              <1> 	mov	ax,9001h
  3449 000017AB CD15                <1> 	int	15h			; call OS hook
  3450 000017AD 7221                <1> 	jc	.timeout
  3451 000017AF BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  3452 000017B2 31C9                <1> 	xor	cx,cx
  3453                              <1> 
  3454                              <1> .zero:
  3455 000017B4 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3456 000017B7 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3457                              <1> 
  3458                              <1> .zero_loop:
  3459 000017B9 E461                <1> 	in	al,port_b_reg
  3460 000017BB A810                <1> 	test	al,refresh_flag
  3461 000017BD 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3462 000017BF E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3463 000017C1 EB0D                <1> 	jmp	.timeout
  3464                              <1> 
  3465                              <1> .one:
  3466 000017C3 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3467 000017C6 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3468                              <1> 
  3469                              <1> .one_loop:
  3470 000017C8 E461                <1> 	in	al,port_b_reg
  3471 000017CA A810                <1> 	test	al,refresh_flag
  3472 000017CC 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3473 000017CE E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3474                              <1> 
  3475                              <1> .timeout:
  3476 000017D0 B480                <1> 	mov	ah,fdc_e_timeout
  3477 000017D2 F9                  <1> 	stc
  3478 000017D3 C3                  <1> 	ret
  3479                              <1> 
  3480                              <1> .exit:
  3481 000017D4 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3482 000017D7 B400                <1> 	mov	ah,fdc_e_success
  3483 000017D9 F8                  <1> 	clc				; DEBUG - remove after debug
  3484 000017DA C3                  <1> 	ret
  3485                              <1> 
  3486                              <1> ;=========================================================================
  3487                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3488                              <1> ;		   but no more than one second
  3489                              <1> ; Input:
  3490                              <1> ; Output:
  3491                              <1> ;	CF clear if FDC is ready
  3492                              <1> ;		AL = FDC main status register
  3493                              <1> ;	CF set on timeout
  3494                              <1> ;		AL trashed
  3495                              <1> ;	DX - trashed
  3496                              <1> ;-------------------------------------------------------------------------
  3497                              <1> 
  3498                              <1> fdc_wait_ready:
  3499 000017DB 51                  <1> 	push	cx
  3500 000017DC BAF403              <1> 	mov	dx,fdc_status_reg
  3501 000017DF 31C9                <1> 	xor	cx,cx
  3502                              <1> 
  3503                              <1> .zero:
  3504 000017E1 EC                  <1> 	in	al,dx			; read I/O port
  3505 000017E2 A880                <1> 	test	al,fdc_stat_ready
  3506 000017E4 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3507                              <1> 
  3508                              <1> .zero_loop:
  3509 000017E6 E461                <1> 	in	al,port_b_reg
  3510 000017E8 A810                <1> 	test	al,refresh_flag
  3511 000017EA 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3512 000017EC 49                  <1> 	dec	cx
  3513 000017ED 740D                <1> 	jz	.timeout
  3514 000017EF EC                  <1> 	in	al,dx			; read I/O port again
  3515 000017F0 A880                <1> 	test	al,fdc_stat_ready
  3516 000017F2 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3517                              <1> 
  3518                              <1> .one_loop:
  3519 000017F4 E461                <1> 	in	al,port_b_reg
  3520 000017F6 A810                <1> 	test	al,refresh_flag
  3521 000017F8 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3522 000017FA E2E5                <1> 	loop	.zero
  3523                              <1> 
  3524                              <1> .timeout:
  3525 000017FC F9                  <1> 	stc
  3526                              <1> 
  3527                              <1> .exit:
  3528 000017FD 59                  <1> 	pop	cx
  3529 000017FE C3                  <1> 	ret
  3530                              <1> 
  3531                              <1> ;=========================================================================
  3532                              <1> ; print_floppy - Print floppy configuration
  3533                              <1> ; Input:
  3534                              <1> ;	AL = NVRAM floppy configuration byte
  3535                              <1> ; Ouput:
  3536                              <1> ;	none
  3537                              <1> ;-------------------------------------------------------------------------
  3538                              <1> print_floppy:
  3539 000017FF 50                  <1> 	push	ax
  3540 00001800 56                  <1> 	push	si
  3541 00001801 BE[9701]            <1> 	mov	si,msg_floppy
  3542 00001804 E8890D              <1> 	call	print
  3543 00001807 D0C8                <1> 	ror	al,1
  3544 00001809 D0C8                <1> 	ror	al,1
  3545 0000180B D0C8                <1> 	ror	al,1
  3546 0000180D D0C8                <1> 	ror	al,1
  3547 0000180F 89C6                <1> 	mov	si,ax
  3548 00001811 83E607              <1> 	and	si,0007h
  3549 00001814 D1E6                <1> 	shl	si,1
  3550 00001816 2E8BB4[8706]        <1>     cs	mov	si,word [tbl_floppy+si]
  3551 0000181B E8720D              <1> 	call	print
  3552 0000181E BE[BD01]            <1> 	mov	si,msg_floppy_2
  3553 00001821 E86C0D              <1> 	call	print
  3554 00001824 D0C8                <1> 	ror	al,1
  3555 00001826 D0C8                <1> 	ror	al,1
  3556 00001828 D0C8                <1> 	ror	al,1
  3557 0000182A D0C8                <1> 	ror	al,1
  3558 0000182C 89C6                <1> 	mov	si,ax
  3559 0000182E 83E607              <1> 	and	si,0007h
  3560 00001831 D1E6                <1> 	shl	si,1
  3561 00001833 2E8BB4[8706]        <1>     cs	mov	si,word [tbl_floppy+si]
  3562 00001838 E8550D              <1> 	call	print
  3563 0000183B BE[8800]            <1> 	mov	si,msg_crlf
  3564 0000183E E84F0D              <1> 	call	print
  3565 00001841 5E                  <1> 	pop	si
  3566 00001842 58                  <1> 	pop	ax
  3567 00001843 C3                  <1> 	ret
  3568                                  %include	"kbc.inc"		; keyboard controller functions
  3569                              <1> ;=========================================================================
  3570                              <1> ; kbc.inc - Keyboard controller support
  3571                              <1> ;-------------------------------------------------------------------------
  3572                              <1> ;
  3573                              <1> ; Compiles with NASM 2.07, might work with other versions
  3574                              <1> ;
  3575                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  3576                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3577                              <1> ;
  3578                              <1> ; This program is free software: you can redistribute it and/or modify
  3579                              <1> ; it under the terms of the GNU General Public License as published by
  3580                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3581                              <1> ; (at your option) any later version.
  3582                              <1> ;
  3583                              <1> ; This program is distributed in the hope that it will be useful,
  3584                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3585                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3586                              <1> ; GNU General Public License for more details.
  3587                              <1> ;
  3588                              <1> ; You should have received a copy of the GNU General Public License
  3589                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3590                              <1> ;
  3591                              <1> ;=========================================================================
  3592                              <1> 
  3593                              <1> ;=========================================================================
  3594                              <1> ; Keyboard controller defines - ports, commands, and flags
  3595                              <1> ;-------------------------------------------------------------------------
  3596                              <1> kbc_data_reg	equ	60h
  3597                              <1> kbc_input_reg	equ	60h
  3598                              <1> kbc_output_reg	equ	60h
  3599                              <1> ; keyboard controller return codes
  3600                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3601                              <1> ; keyboard controller status register and its bits
  3602                              <1> kbc_status_reg	equ	64h
  3603                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3604                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3605                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3606                              <1> ; keyboard contoller command register and commands
  3607                              <1> kbc_command_reg	equ	64h
  3608                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3609                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3610                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3611                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3612                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3613                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3614                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3615                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3616                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3617                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3618                              <1> ; keyboard controller control register bits
  3619                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3620                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3621                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3622                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3623                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3624                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3625                              <1> ; keyboard controller input port bits
  3626                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3627                              <1> 
  3628                              <1> ;=========================================================================
  3629                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3630                              <1> ; Input:
  3631                              <1> ;	AL = command
  3632                              <1> ; Output:
  3633                              <1> ;	none
  3634                              <1> ;-------------------------------------------------------------------------
  3635                              <1> kbc_kb_send:
  3636 00001844 50                  <1> 	push	ax
  3637 00001845 51                  <1> 	push	cx
  3638 00001846 88C4                <1> 	mov	ah,al			; save command to AH
  3639 00001848 B90300              <1> 	mov	cx,3			; try 3 times
  3640                              <1> 
  3641                              <1> .1:
  3642 0000184B 51                  <1> 	push	cx
  3643 0000184C FA                  <1> 	cli
  3644                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3645 0000184D 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3646 00001852 31C9                <1> 	xor	cx,cx
  3647                              <1> 
  3648                              <1> .2:					; wait for KBC to empty input buffer
  3649 00001854 E464                <1> 	in	al,kbc_status_reg
  3650 00001856 A802                <1> 	test	al,kbc_stat_ibf
  3651 00001858 E0FA                <1> 	loopnz	.2
  3652                              <1> 
  3653 0000185A 88E0                <1> 	mov	al,ah
  3654 0000185C E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3655 0000185E FB                  <1> 	sti
  3656 0000185F 31C9                <1> 	xor	cx,cx
  3657                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3658 00001861 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3659 00001866 E1F9                <1> 	loopz	.3
  3660 00001868 59                  <1> 	pop	cx
  3661 00001869 7507                <1> 	jnz	.4
  3662 0000186B E2DE                <1> 	loop	.1			; try again
  3663                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3664 0000186D 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3665                              <1> .4:
  3666 00001872 59                  <1> 	pop	cx
  3667 00001873 58                  <1> 	pop	ax
  3668 00001874 C3                  <1> 	ret
  3669                              <1> 
  3670                              <1> ;=========================================================================
  3671                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3672                              <1> ; Input:
  3673                              <1> ;	AL - command byte
  3674                              <1> ;	AH = argument
  3675                              <1> ; Output:
  3676                              <1> ;	ZF == 0 - success
  3677                              <1> ;	ZF == 1 - error
  3678                              <1> ;-------------------------------------------------------------------------
  3679                              <1> kbc_send_cmd:
  3680 00001875 51                  <1> 	push	cx
  3681 00001876 88C5                <1> 	mov	ch,al			; save command byte to CH
  3682 00001878 B11E                <1> 	mov	cl,30			; 30 retries
  3683                              <1> .1:
  3684 0000187A FA                  <1> 	cli
  3685 0000187B 88E8                <1> 	mov	al,ch
  3686 0000187D E82800              <1> 	call	kbc_send_cmd_byte
  3687 00001880 7522                <1> 	jnz	.exit			; time out
  3688 00001882 E464                <1> 	in	al,kbc_status_reg
  3689 00001884 A801                <1> 	test	al,kbc_stat_obf
  3690 00001886 7414                <1> 	jz	.3			; output buffer is empty
  3691 00001888 A820                <1> 	test	al,kbc_stat_aobf
  3692 0000188A 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3693 0000188C E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3694                              <1> %ifdef PS2_MOUSE
  3695 0000188E 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3696                              <1> %endif ; PS2_MOUSE
  3697 00001893 EB07                <1> 	jmp	.3
  3698                              <1> .2:
  3699 00001895 FB                  <1> 	sti
  3700 00001896 FEC9                <1> 	dec	cl
  3701 00001898 75E0                <1> 	jnz	.1
  3702 0000189A EB08                <1> 	jmp	.exit			; note: ZF=1
  3703                              <1> .3:
  3704 0000189C 88E0                <1> 	mov	al,ah
  3705 0000189E E660                <1> 	out	kbc_input_reg,al
  3706 000018A0 FB                  <1> 	sti
  3707 000018A1 80C901              <1> 	or	cl,1			; set ZF=0
  3708                              <1> .exit:
  3709 000018A4 88E8                <1> 	mov	al,ch			; restore AL
  3710 000018A6 59                  <1> 	pop	cx
  3711 000018A7 C3                  <1> 	ret
  3712                              <1> 
  3713                              <1> ;=========================================================================
  3714                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3715                              <1> ; Input:
  3716                              <1> ;	AL - command byte
  3717                              <1> ; Output:
  3718                              <1> ;	ZF == 1 - success
  3719                              <1> ;	ZF == 0 - time out
  3720                              <1> ; Note:
  3721                              <1> ;	XXX - function should be reused in keyboard code
  3722                              <1> ;-------------------------------------------------------------------------
  3723                              <1> kbc_send_cmd_byte:
  3724 000018A8 51                  <1> 	push	cx
  3725 000018A9 50                  <1> 	push	ax
  3726 000018AA 31C9                <1> 	xor	cx,cx
  3727                              <1> 				; wait for KBC to empty input buffer
  3728                              <1> .1:
  3729 000018AC E464                <1> 	in	al,kbc_status_reg
  3730 000018AE A802                <1> 	test	al,kbc_stat_ibf
  3731 000018B0 E0FA                <1> 	loopnz	.1
  3732 000018B2 750C                <1> 	jnz	.exit		; time out
  3733                              <1> 
  3734 000018B4 58                  <1> 	pop	ax
  3735 000018B5 E664                <1> 	out	kbc_command_reg,al
  3736                              <1> 
  3737 000018B7 50                  <1> 	push	ax
  3738 000018B8 31C9                <1> 	xor	cx,cx
  3739                              <1> 				; wait for KBC to empty input buffer
  3740                              <1> .2:
  3741 000018BA E464                <1> 	in	al,kbc_status_reg
  3742 000018BC A802                <1> 	test	al,kbc_stat_ibf
  3743 000018BE E0FA                <1> 	loopnz	.2
  3744                              <1> .exit:
  3745 000018C0 58                  <1> 	pop	ax
  3746 000018C1 59                  <1> 	pop	cx
  3747 000018C2 C3                  <1> 	ret
  3748                              <1> 
  3749                              <1> ;=========================================================================
  3750                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3751                              <1> ; Input:
  3752                              <1> ;	none
  3753                              <1> ; Output:
  3754                              <1> ;	AL = keyboard status register
  3755                              <1> ;	ZF == 0 - data is available
  3756                              <1> ;	ZF == 1 - timed out
  3757                              <1> ; Note:
  3758                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3759                              <1> ;	      be merged with kbc_wait_aux_full
  3760                              <1> ;-------------------------------------------------------------------------
  3761                              <1> kbc_wait_output_full:
  3762 000018C3 51                  <1> 	push	cx
  3763 000018C4 31C9                <1> 	xor	cx,cx
  3764                              <1> .1:
  3765 000018C6 E464                <1> 	in	al,kbc_status_reg
  3766 000018C8 A801                <1> 	test	al,kbc_stat_obf
  3767 000018CA E1FA                <1> 	loopz	.1
  3768 000018CC 09C9                <1> 	or	cx,cx
  3769 000018CE 59                  <1> 	pop	cx
  3770 000018CF C3                  <1> 	ret
  3771                              <1> 
  3772                              <1> %ifdef PS2_MOUSE
  3773                              <1> ;=========================================================================
  3774                              <1> ; kbc_aux_read - read data from auxiliary device
  3775                              <1> ; Input:
  3776                              <1> ;	none
  3777                              <1> ; Output:
  3778                              <1> ;	AL = data
  3779                              <1> ;	CF == 0 - data is available
  3780                              <1> ;	CF == 1 - time out
  3781                              <1> ;-------------------------------------------------------------------------
  3782                              <1> kbc_aux_read:
  3783 000018D0 51                  <1> 	push	cx
  3784                              <1> ;	xor	cx,cx			; XXX too much?!
  3785 000018D1 B91400              <1> 	mov	cx,20			; retry 20 times
  3786                              <1> .1:
  3787 000018D4 E86000              <1> 	call	kbc_wait_aux_full
  3788 000018D7 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3789 000018D9 E1F9                <1> 	loopz	.1
  3790 000018DB EB0B                <1> 	jmp	.error			; time out
  3791                              <1> .2:
  3792 000018DD B90100              <1> 	mov	cx,1
  3793 000018E0 E8B9F5              <1> 	call	delay_15us
  3794 000018E3 E460                <1> 	in	al,kbc_output_reg
  3795 000018E5 F8                  <1> 	clc
  3796 000018E6 EB01                <1> 	jmp	.exit
  3797                              <1> .error:
  3798 000018E8 F9                  <1> 	stc
  3799                              <1> .exit:
  3800 000018E9 59                  <1> 	pop	cx
  3801 000018EA C3                  <1> 	ret
  3802                              <1> 
  3803                              <1> ;=========================================================================
  3804                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3805                              <1> ; Input:
  3806                              <1> ;	AL = command
  3807                              <1> ; Output:
  3808                              <1> ;	AH - status:
  3809                              <1> ;		00h - success
  3810                              <1> ;		03h - interface error (time out)
  3811                              <1> ;		04h - resend requested
  3812                              <1> ;	CF == 0 - no error
  3813                              <1> ;	CF == 1 - error
  3814                              <1> ;-------------------------------------------------------------------------
  3815                              <1> kbc_aux_send:
  3816 000018EB 51                  <1> 	push	cx
  3817 000018EC 88C4                <1> 	mov	ah,al			; store command to AH
  3818 000018EE B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3819 000018F0 E882FF              <1> 	call	kbc_send_cmd
  3820 000018F3 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3821                              <1> 
  3822                              <1> 					; wait for acknowledge
  3823 000018F5 B90A00              <1> 	mov	cx,10			; retry 10 times
  3824                              <1> .1:
  3825 000018F8 E83C00              <1> 	call	kbc_wait_aux_full
  3826 000018FB 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3827 000018FD E2F9                <1> 	loop	.1
  3828 000018FF EB17                <1> 	jmp	.timeout		; no reply - timeout
  3829                              <1> .2:
  3830 00001901 E460                <1> 	in	al,kbc_output_reg
  3831 00001903 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3832 00001905 740C                <1> 	je	.ok
  3833 00001907 3CFE                <1> 	cmp	al,0FEh			; resend?
  3834 00001909 7411                <1> 	je	.resend
  3835 0000190B 3CFC                <1> 	cmp	al,0FCh			; error?
  3836 0000190D 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3837 0000190F E2E7                <1> 	loop	.1
  3838 00001911 EB05                <1> 	jmp	.timeout
  3839                              <1> 
  3840                              <1> .ok:
  3841 00001913 30C0                <1> 	xor	al,al			; success - ACK received
  3842 00001915 F8                  <1> 	clc
  3843 00001916 EB07                <1> 	jmp	.exit
  3844                              <1> 
  3845                              <1> .timeout:
  3846 00001918 B003                <1> 	mov	al,03h			; interface error
  3847 0000191A EB02                <1> 	jmp	.error
  3848                              <1> 
  3849                              <1> .resend:
  3850 0000191C B004                <1> 	mov	al,04h			; resend
  3851                              <1> 
  3852                              <1> .error:
  3853 0000191E F9                  <1> 	stc
  3854                              <1> 
  3855                              <1> .exit:
  3856 0000191F 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3857 00001921 59                  <1> 	pop	cx
  3858 00001922 C3                  <1> 	ret
  3859                              <1> 
  3860                              <1> ;=========================================================================
  3861                              <1> ; kbc_aux_enable - enable auxiliary device
  3862                              <1> ; Input:
  3863                              <1> ;	none
  3864                              <1> ; Output:
  3865                              <1> ;	ZF = 0 - no error
  3866                              <1> ;	ZF = 1 - error
  3867                              <1> ;-------------------------------------------------------------------------
  3868                              <1> kbc_aux_enable:
  3869 00001923 50                  <1> 	push	ax
  3870 00001924 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3871 00001926 B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3872                              <1> 					; enable keyboard, enable aux obf
  3873                              <1> 					; interrupt, enable obf interrupt
  3874 00001928 E84AFF              <1> 	call	kbc_send_cmd
  3875 0000192B 58                  <1> 	pop	ax
  3876 0000192C C3                  <1> 	ret
  3877                              <1> 
  3878                              <1> ;=========================================================================
  3879                              <1> ; kbc_aux_disable - disable auxiliary device
  3880                              <1> ; Input:
  3881                              <1> ;	none
  3882                              <1> ; Output:
  3883                              <1> ;	ZF = 0 - no error
  3884                              <1> ;	ZF = 1 - error
  3885                              <1> ;-------------------------------------------------------------------------
  3886                              <1> kbc_aux_disable:
  3887 0000192D 50                  <1> 	push	ax
  3888 0000192E B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3889 00001930 B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3890                              <1> 					; enable keyboard, disable aux obf
  3891                              <1> 					; interrupt, enable obf interrupt
  3892 00001932 E840FF              <1> 	call	kbc_send_cmd
  3893 00001935 58                  <1> 	pop	ax
  3894 00001936 C3                  <1> 	ret
  3895                              <1> 
  3896                              <1> ;=========================================================================
  3897                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3898                              <1> ; Input:
  3899                              <1> ;	none
  3900                              <1> ; Output:
  3901                              <1> ;	AL = keyboard status register
  3902                              <1> ;	ZF == 0 - data is available
  3903                              <1> ;	ZF == 1 - timed out
  3904                              <1> ;-------------------------------------------------------------------------
  3905                              <1> kbc_wait_aux_full:
  3906 00001937 E889FF              <1> 	call	kbc_wait_output_full
  3907 0000193A 7402                <1> 	jz	.error
  3908 0000193C A820                <1> 	test	al,kbc_stat_aobf
  3909                              <1> .error:
  3910 0000193E C3                  <1> 	ret
  3911                              <1> 
  3912                              <1> %endif ; PS2_MOUSE
  3913                              <1> 
  3914                              <1> ;=========================================================================
  3915                              <1> ; kbc_flush - flush all data from i8042 buffers
  3916                              <1> ; Input:
  3917                              <1> ;	none
  3918                              <1> ; Output:
  3919                              <1> ;	CF = 0 - flushed successfully
  3920                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3921                              <1> ;-------------------------------------------------------------------------
  3922                              <1> kbc_flush:
  3923 0000193F 50                  <1> 	push	ax
  3924 00001940 51                  <1> 	push	cx
  3925 00001941 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3926                              <1> .flush_next_byte:
  3927 00001944 E464                <1> 	in	al,kbc_status_reg
  3928 00001946 A801                <1> 	test	al,kbc_stat_obf
  3929 00001948 740F                <1> 	jz	.flushed
  3930 0000194A 51                  <1> 	push	cx
  3931 0000194B B90400              <1> 	mov	cx,4
  3932 0000194E E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3933 00001951 59                  <1> 	pop	cx
  3934 00001952 E460                <1> 	in	al,kbc_data_reg
  3935 00001954 E2EE                <1> 	loop	.flush_next_byte
  3936 00001956 F9                  <1> 	stc				; unable to flush it
  3937 00001957 EB01                <1> 	jmp	.exit
  3938                              <1> .flushed:
  3939 00001959 F8                  <1> 	clc
  3940                              <1> .exit:
  3941 0000195A 59                  <1> 	pop	cx
  3942 0000195B 58                  <1> 	pop	ax
  3943 0000195C C3                  <1> 	ret
  3944                              <1> 
  3945                              <1> ;=========================================================================
  3946                              <1> ; kbc_init - Initialize keyboard controller
  3947                              <1> ;-------------------------------------------------------------------------
  3948                              <1> kbc_init:
  3949 0000195D 50                  <1> 	push	ax
  3950 0000195E 51                  <1> 	push	cx
  3951 0000195F 52                  <1> 	push	dx
  3952                              <1> 
  3953                              <1> ;-------------------------------------------------------------------------
  3954                              <1> ; test keyboard controller
  3955                              <1> 
  3956 00001960 E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3957                              <1> 
  3958 00001963 B90A00              <1> 	mov	cx,10			; try 10 times
  3959                              <1> 
  3960                              <1> .kbc_reset_retry:
  3961 00001966 B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3962 00001968 E83DFF              <1> 	call 	kbc_send_cmd_byte
  3963 0000196B E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3964                              <1> 
  3965 0000196E E460                <1> 	in	al,kbc_output_reg
  3966 00001970 3C55                <1> 	cmp	al,55h			; check for success
  3967 00001972 E0F2                <1> 	loopne	.kbc_reset_retry
  3968 00001974 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3969                              <1> 
  3970 00001979 B90A00              <1> 	mov	cx,10			; try 10 times
  3971                              <1> 
  3972                              <1> .kbc_test_retry:
  3973 0000197C B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3974 0000197E E827FF              <1> 	call	kbc_send_cmd_byte
  3975 00001981 E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3976                              <1> 
  3977 00001984 E460                <1> 	in	al,kbc_output_reg
  3978 00001986 3C00                <1> 	cmp	al,0			; check for success
  3979 00001988 E0F2                <1> 	loopne	.kbc_test_retry
  3980 0000198A 7403E98E00          <1> 	jne	kbd_int_fail
  3981                              <1> 
  3982                              <1> ;-------------------------------------------------------------------------
  3983                              <1> ; read display type and set equipment bits accordingly
  3984                              <1> 
  3985 0000198F B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3986 00001991 E814FF              <1> 	call	kbc_send_cmd_byte
  3987 00001994 E82CFF              <1> 	call	kbc_wait_output_full
  3988                              <1> 
  3989 00001997 E460                <1> 	in	al,kbc_output_reg
  3990 00001999 A840                <1> 	test	al,kbc_in_display
  3991 0000199B 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3992 0000199D 830E100030          <1> 	or	word [equipment_list],equip_mono
  3993 000019A2 EB05                <1> 	jmp	.get_disp_done
  3994                              <1> .get_disp_color:
  3995 000019A4 830E100020          <1> 	or	word [equipment_list],equip_color
  3996                              <1> .get_disp_done:
  3997                              <1> 
  3998                              <1> ;-------------------------------------------------------------------------
  3999                              <1> ; initialize keyboard controller
  4000                              <1> 
  4001 000019A9 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  4002 000019AB E8FAFE              <1> 	call	kbc_send_cmd_byte
  4003                              <1> 
  4004 000019AE B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  4005 000019B0 E8F5FE              <1> 	call	kbc_send_cmd_byte
  4006                              <1> 
  4007 000019B3 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  4008 000019B5 B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  4009                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  4010                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  4011                              <1> 					; Bit 4 = 0 - Enable keyboard
  4012                              <1> 					; Bit 3 = 1 - Disable inhibit
  4013                              <1> 					; Bit 2 = 0 - system flag = 0
  4014                              <1> 					; Bit 1 = 0 - reserved
  4015                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  4016 000019B7 E8BBFE              <1> 	call	kbc_send_cmd
  4017                              <1> 
  4018 000019BA B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  4019 000019BC E8E9FE              <1> 	call	kbc_send_cmd_byte
  4020                              <1> 
  4021 000019BF B90010              <1> 	mov	cx,1000h
  4022 000019C2 E8D7F4              <1> 	call	delay_15us
  4023                              <1> 
  4024 000019C5 E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  4025 000019C8 E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  4026                              <1> 
  4027                              <1> 
  4028                              <1> %ifdef PS2_MOUSE
  4029                              <1> ;-------------------------------------------------------------------------
  4030                              <1> ; check for PS/2 mouse presence
  4031                              <1> 
  4032 000019CA B90A00              <1> 	mov	cx,10			; try 10 times
  4033                              <1> .mouse_reset_retry:
  4034 000019CD B0FF                <1> 	mov	al,0FFh
  4035 000019CF E819FF              <1> 	call	kbc_aux_send
  4036 000019D2 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  4037 000019D4 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4038 000019D7 E1F4                <1> 	loopz	.mouse_reset_retry
  4039 000019D9 EB13                <1> 	jmp	.no_mouse
  4040                              <1> .mouse_reset_ok:
  4041 000019DB E8F2FE              <1> 	call	kbc_aux_read
  4042 000019DE 720E                <1> 	jc	.no_mouse
  4043 000019E0 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  4044 000019E2 750A                <1> 	jne	.no_mouse
  4045 000019E4 E8E9FE              <1> 	call	kbc_aux_read
  4046 000019E7 7205                <1> 	jc	.no_mouse
  4047                              <1> ; mouse reset successful, update equipment word accordingly
  4048 000019E9 830E100004          <1> 	or      word [equipment_list],equip_mouse
  4049                              <1> .no_mouse:
  4050                              <1> %endif ; PS2_MOUSE
  4051                              <1> 
  4052                              <1> ;-------------------------------------------------------------------------
  4053                              <1> ; setup keyboard buffer
  4054                              <1> 
  4055 000019EE B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  4056 000019F1 A38000              <1>         mov     word [kbd_buffer_start],ax
  4057 000019F4 A31A00              <1>         mov     word [kbd_buffer_head],ax
  4058 000019F7 A31C00              <1>         mov     word [kbd_buffer_tail],ax
  4059 000019FA 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  4060 000019FD A38200              <1>         mov     word [kbd_buffer_end],ax
  4061 00001A00 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  4062 00001A02 A31700              <1>         mov     word [kbd_flags_1],ax
  4063 00001A05 A31800              <1>         mov     word [kbd_flags_2],ax
  4064 00001A08 A39600              <1>         mov     word [kbd_flags_3],ax
  4065 00001A0B A39700              <1>         mov     word [kbd_flags_4],ax
  4066 00001A0E B010                <1> 	mov	al,e_kbd_ok
  4067 00001A10 E680                <1> 	out	post_reg,al
  4068 00001A12 5A                  <1> 	pop	dx
  4069 00001A13 59                  <1> 	pop	cx
  4070 00001A14 58                  <1> 	pop	ax
  4071 00001A15 C3                  <1> 	ret
  4072                              <1> 
  4073                              <1> kbd_ctrl_fail:
  4074 00001A16 B060                <1> 	mov	al,e_kbd_ctrl_fail
  4075 00001A18 E680                <1> 	out	post_reg,al
  4076                              <1> .1:
  4077 00001A1A F4                  <1> 	hlt
  4078 00001A1B EBFD                <1> 	jmp	.1
  4079                              <1> 
  4080                              <1> kbd_int_fail:
  4081 00001A1D 240F                <1> 	and	al,0Fh
  4082 00001A1F 0463                <1> 	add	al,e_kbd_int_fail
  4083 00001A21 E680                <1> 	out	post_reg,al
  4084                              <1> .1:
  4085 00001A23 F4                  <1> 	hlt
  4086 00001A24 EBFD                <1> 	jmp	.1
  4087                              <1> 
  4088                              <1> kbd_key_fail:
  4089 00001A26 B061                <1> 	mov	al,e_kbd_key_fail
  4090 00001A28 E680                <1> 	out	post_reg,al
  4091                              <1> .1:
  4092 00001A2A F4                  <1> 	hlt
  4093 00001A2B EBFD                <1> 	jmp	.1
  4094                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  4095                              <1> ;=========================================================================
  4096                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  4097                              <1> ;		 and related INT 16h functions:
  4098                              <1> ;	INT 16h - BIOS Keyboard Services
  4099                              <1> ;		- function AH=00h
  4100                              <1> ;		- function AH=01h
  4101                              <1> ;		- function AH=10h
  4102                              <1> ;		- function AH=11h
  4103                              <1> ;-------------------------------------------------------------------------
  4104                              <1> ;
  4105                              <1> ; Compiles with NASM 2.07, might work with other versions
  4106                              <1> ;
  4107                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4108                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4109                              <1> ;
  4110                              <1> ; This program is free software: you can redistribute it and/or modify
  4111                              <1> ; it under the terms of the GNU General Public License as published by
  4112                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4113                              <1> ; (at your option) any later version.
  4114                              <1> ;
  4115                              <1> ; This program is distributed in the hope that it will be useful,
  4116                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4117                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4118                              <1> ; GNU General Public License for more details.
  4119                              <1> ;
  4120                              <1> ; You should have received a copy of the GNU General Public License
  4121                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4122                              <1> ;
  4123                              <1> ;=========================================================================
  4124                              <1> 
  4125                              <1> ;=========================================================================
  4126                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  4127                              <1> ;                   BIOS scan code translation table
  4128                              <1> ; Note 1: Table starts with scancode == 1
  4129                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  4130                              <1> ;	00 - no flags
  4131                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  4132                              <1> ;	     x in this case equals digit value
  4133                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  4134                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  4135                              <1> ;	8x - F11, F12 BIOS scan codes
  4136                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  4137                              <1> ;-------------------------------------------------------------------------
  4138                              <1> 
  4139                              <1> scan_xlat_table:
  4140                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4141 00001A2D 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  4142 00001A35 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  4143 00001A3D 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  4144 00001A45 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  4145 00001A4D 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  4146 00001A55 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  4147 00001A5D 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  4148 00001A65 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  4149 00001A6D 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  4150 00001A75 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  4151 00001A7D 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  4152 00001A85 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  4153 00001A8D 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  4154 00001A95 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  4155 00001A9D 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  4156 00001AA5 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  4157                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4158 00001AAD 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  4159 00001AB5 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  4160 00001ABD 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  4161 00001AC5 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  4162 00001ACD 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  4163 00001AD5 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  4164 00001ADD 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  4165 00001AE5 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  4166 00001AED 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  4167 00001AF5 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  4168 00001AFD 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  4169 00001B05 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  4170 00001B0D 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  4171 00001B15 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  4172 00001B1D 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  4173 00001B25 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  4174                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4175 00001B2D 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  4176 00001B35 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  4177 00001B3D 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  4178 00001B45 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  4179 00001B4D 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  4180 00001B55 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  4181 00001B5D 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  4182 00001B65 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  4183 00001B6D 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  4184 00001B75 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  4185 00001B7D 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  4186 00001B85 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  4187 00001B8D 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  4188 00001B95 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  4189 00001B9D 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  4190 00001BA5 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  4191                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4192 00001BAD 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  4193 00001BB5 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  4194 00001BBD 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  4195 00001BC5 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  4196 00001BCD 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  4197 00001BD5 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  4198 00001BDD 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  4199 00001BE5 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  4200 00001BED 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  4201 00001BF5 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  4202 00001BFD 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  4203 00001C05 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  4204 00001C0D 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  4205 00001C15 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  4206 00001C1D 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  4207 00001C25 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  4208                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4209 00001C2D 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  4210 00001C35 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  4211 00001C3D 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  4212 00001C45 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  4213 00001C4D 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  4214 00001C55 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  4215 00001C5D 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  4216 00001C65 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  4217 00001C6D 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  4218 00001C75 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  4219 00001C7D 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  4220 00001C85 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  4221 00001C8D 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  4222 00001C95 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  4223 00001C9D 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  4224 00001CA5 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  4225                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  4226 00001CAD 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  4227 00001CB5 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  4228 00001CBD 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  4229 00001CC5 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  4230 00001CCD 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  4231 00001CD5 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  4232 00001CDD 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  4233 00001CE5 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  4234                              <1> .end:
  4235                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  4236                              <1> 
  4237                              <1> ;=========================================================================
  4238                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  4239                              <1> ; Input:
  4240                              <1> ;	AL - scan code
  4241                              <1> ; Output:
  4242                              <1> ;	AX - ASCII character / scan code pair
  4243                              <1> ;-------------------------------------------------------------------------
  4244                              <1> scan_xlat:
  4245 00001CED 53                  <1> 	push	bx
  4246 00001CEE FEC8                <1> 	dec	al
  4247 00001CF0 3C58                <1> 	cmp	al,scan_xlat_table_size
  4248 00001CF2 7205                <1> 	jb	.1
  4249 00001CF4 31C0                <1> 	xor	ax,ax
  4250 00001CF6 E9AB00              <1> 	jmp	.exit
  4251                              <1> 
  4252                              <1> .1:
  4253 00001CF9 B700                <1> 	mov	bh,00h				; calculate offset of the key
  4254 00001CFB 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  4255 00001CFD D1E3                <1> 	shl	bx,1				; BX = AL * 8
  4256 00001CFF D1E3                <1> 	shl	bx,1
  4257 00001D01 D1E3                <1> 	shl	bx,1
  4258                              <1> 
  4259 00001D03 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  4260 00001D08 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  4261 00001D0A 2E8B87[331A]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  4262                              <1> 	; check for numeric Keypad keys
  4263 00001D0F 2EF687[2E1A]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  4264 00001D15 7474                <1> 	jz	.check_extended
  4265 00001D17 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4266 00001D1C 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  4267                              <1> 						; and so it is not a keypad key
  4268                              <1> 
  4269 00001D1E 2E8A87[2E1A]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  4270 00001D23 240F                <1> 	and	al,0Fh				; get the numeric value
  4271 00001D25 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  4272 00001D29 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  4273 00001D2B A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  4274                              <1> 
  4275 00001D2E 31C0                <1> 	xor	ax,ax				; return nothing
  4276 00001D30 EB72                <1> 	jmp	.exit
  4277                              <1> 
  4278                              <1> .check_ctrl:
  4279 00001D32 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  4280 00001D37 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  4281 00001D39 2E8B87[311A]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  4282 00001D3E EB4B                <1> 	jmp	.check_extended
  4283                              <1> 
  4284                              <1> .check_locks:
  4285 00001D40 2EF687[2E1A]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  4286 00001D46 741D                <1> 	jz	.check_shift			; not affected by Locks
  4287                              <1> 
  4288 00001D48 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  4289 00001D4A 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  4290                              <1> 
  4291 00001D4C F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  4292 00001D51 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  4293 00001D53 EB07                <1> 	jmp	.lock_active
  4294                              <1> 
  4295                              <1> .check_num_lock:
  4296 00001D55 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  4297 00001D5A 7409                <1> 	jz	.check_shift			; Num Lock is not active
  4298                              <1> .lock_active:
  4299                              <1> 	; are any of Shift keys active?
  4300 00001D5C F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4301 00001D61 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  4302 00001D63 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  4303                              <1> 
  4304                              <1> .check_shift:
  4305                              <1> 	; are any of Shift keys active?
  4306 00001D65 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4307 00001D6A 7407                <1> 	jz	.no_shift
  4308                              <1> .shift:
  4309 00001D6C 2E8B87[2F1A]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  4310 00001D71 EB18                <1> 	jmp	.check_extended
  4311                              <1> 
  4312                              <1> .no_shift:
  4313 00001D73 88C4                <1> 	mov	ah,al				; Move scan code to AH
  4314 00001D75 FEC4                <1> 	inc	ah
  4315 00001D77 2E8A87[2D1A]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  4316 00001D7C 2EF687[2E1A]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  4317 00001D82 7407                <1> 	jz	.check_extended			; not F11 or F12
  4318 00001D84 2E8AA7[2E1A]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  4319 00001D89 EB19                <1> 	jmp	.exit
  4320                              <1> 
  4321                              <1> .check_extended:
  4322 00001D8B 2EF687[2E1A]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  4323 00001D91 7411                <1> 	jz	.exit				; no extended key
  4324 00001D93 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4325 00001D98 740A                <1> 	jz	.exit				; ... not a 0E0h
  4326 00001D9A 3C00                <1> 	cmp	al,00h
  4327 00001D9C 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  4328 00001D9E B0E0                <1> 	mov	al,0E0h				; indicate extended key
  4329 00001DA0 EB02                <1> 	jmp	.exit
  4330                              <1> 
  4331                              <1> .ascii_code:
  4332 00001DA2 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  4333                              <1> 						; key with valid ASCII code
  4334                              <1> 						; (Keypad Enter, *, and /)
  4335                              <1> 
  4336                              <1> .exit:
  4337 00001DA4 5B                  <1> 	pop	bx
  4338 00001DA5 C3                  <1> 	ret
  4339                              <1> 
  4340                              <1> ;=========================================================================
  4341                              <1> ; int_16_fn00 - get keystroke
  4342                              <1> ; Input:
  4343                              <1> ;	AH = 00h
  4344                              <1> ; Output:
  4345                              <1> ;	AH = BIOS scan code
  4346                              <1> ;	AL = ASCII character
  4347                              <1> ; Notes:
  4348                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4349                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4350                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4351                              <1> ;	- Use function AH=10h for extended keystrokes handling
  4352                              <1> ;-------------------------------------------------------------------------
  4353                              <1> int_16_fn00:
  4354 00001DA6 FB                  <1> 	sti
  4355                              <1> .1:
  4356 00001DA7 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4357 00001DAB 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4358 00001DAF 74F6                <1> 	jz	.1			; wait or keystroke
  4359 00001DB1 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4360 00001DB3 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4361                              <1> 					;   location
  4362 00001DB6 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4363 00001DBA 7504                <1> 	jne	.2
  4364 00001DBC 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4365                              <1> .2:
  4366 00001DC0 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4367 00001DC4 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4368                              <1> 					;   extended key?
  4369 00001DC6 7504                <1> 	jne	.3			; not a convertible key
  4370 00001DC8 B000                <1> 	mov	al,00h			; convert to a standard key
  4371 00001DCA EB2C                <1> 	jmp	.exit
  4372                              <1> .3:
  4373 00001DCC 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4374 00001DCE 74D7                <1> 	je	.1			; an ignored extended key, get next key
  4375 00001DD0 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4376                              <1> 					;   (scancode above 84h)
  4377 00001DD3 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  4378 00001DD5 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4379 00001DD8 751E                <1> 	jne	.exit
  4380 00001DDA 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4381 00001DDC 7504                <1> 	jne	.4
  4382 00001DDE B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4383 00001DE0 EB16                <1> 	jmp	.exit
  4384                              <1> .4:
  4385 00001DE2 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4386 00001DE4 7504                <1> 	jne	.5
  4387 00001DE6 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4388 00001DE8 EB0E                <1> 	jmp	.exit
  4389                              <1> .5:
  4390 00001DEA 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4391 00001DEC 7504                <1> 	jne	.6
  4392 00001DEE B435                <1> 	mov	ah,35h			; standard / scancode
  4393 00001DF0 EB06                <1> 	jmp	.exit
  4394                              <1> .6:
  4395 00001DF2 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4396 00001DF4 7502                <1> 	jne	.exit
  4397 00001DF6 B437                <1> 	mov	ah,37h			; standard * scancode
  4398                              <1> .exit:
  4399 00001DF8 E9704A              <1> 	jmp	int_16_exit
  4400                              <1> 
  4401                              <1> ;=========================================================================
  4402                              <1> ; int_16_fn01 - check for keystroke
  4403                              <1> ; Input:
  4404                              <1> ;	AH = 01h
  4405                              <1> ; Output:
  4406                              <1> ;	ZF = 1 - no keystroke available
  4407                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4408                              <1> ;		AH = BIOS scan code
  4409                              <1> ;		AL = ASCII character
  4410                              <1> ; Notes:
  4411                              <1> ;	- Does not remove keystroke from keyboard buffer
  4412                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4413                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4414                              <1> ;	- Use function AH=11h for extended keystrokes handling
  4415                              <1> ;-------------------------------------------------------------------------
  4416                              <1> int_16_fn01:
  4417 00001DFB 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4418 00001DFF 8B07                <1> 	mov	ax,word [bx]
  4419 00001E01 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4420 00001E05 7436                <1> 	jz	.exit			; no keystroke, exit
  4421 00001E07 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4422                              <1> 					;   extended key?
  4423 00001E09 7504                <1> 	jne	.1			; not a convertible key
  4424 00001E0B B000                <1> 	mov	al,00h			; convert to a standard key
  4425 00001E0D EB2C                <1> 	jmp	.clear_zf
  4426                              <1> .1:
  4427 00001E0F 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4428 00001E11 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  4429 00001E13 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4430                              <1> 					;   (scancode above 84h)
  4431 00001E16 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  4432 00001E18 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4433 00001E1B 751E                <1> 	jne	.clear_zf
  4434 00001E1D 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4435 00001E1F 7504                <1> 	jne	.2
  4436 00001E21 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4437 00001E23 EB16                <1> 	jmp	.clear_zf
  4438                              <1> .2:
  4439 00001E25 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4440 00001E27 7504                <1> 	jne	.3
  4441 00001E29 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4442 00001E2B EB0E                <1> 	jmp	.clear_zf
  4443                              <1> .3:
  4444 00001E2D 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4445 00001E2F 7504                <1> 	jne	.4
  4446 00001E31 B435                <1> 	mov	ah,35h			; standard / scancode
  4447 00001E33 EB06                <1> 	jmp	.clear_zf
  4448                              <1> .4:
  4449 00001E35 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4450 00001E37 7502                <1> 	jne	.clear_zf
  4451 00001E39 B437                <1> 	mov	ah,37h			; standard * scancode
  4452                              <1> 
  4453                              <1> .clear_zf:
  4454 00001E3B 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4455                              <1> .exit:
  4456 00001E3D E92E4A              <1> 	jmp	int_16_exitf
  4457                              <1> 
  4458                              <1> .discard_key:
  4459 00001E40 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4460                              <1> 					;   location
  4461 00001E43 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4462 00001E47 7504                <1> 	jne	.5
  4463 00001E49 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4464                              <1> .5:
  4465 00001E4D 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4466 00001E51 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4467                              <1> 	
  4468                              <1> 
  4469                              <1> ;=========================================================================
  4470                              <1> ; int_16_fn10 - get extended keystroke
  4471                              <1> ; Input:
  4472                              <1> ;	AH = 10h
  4473                              <1> ; Output:
  4474                              <1> ;	AH = BIOS scan code
  4475                              <1> ;	AL = ASCII character
  4476                              <1> ; Note:
  4477                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4478                              <1> ;-------------------------------------------------------------------------
  4479                              <1> int_16_fn10:
  4480 00001E53 FB                  <1> 	sti
  4481                              <1> .1:
  4482 00001E54 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4483 00001E58 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4484 00001E5C 74F6                <1> 	jz	.1			; wait or keystroke
  4485 00001E5E 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4486 00001E60 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4487                              <1> 					;   location
  4488 00001E63 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4489 00001E67 7504                <1> 	jne	.2
  4490 00001E69 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4491                              <1> .2:
  4492 00001E6D 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4493 00001E71 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4494 00001E73 7502                <1> 	jne	.exit			; not a extended key
  4495 00001E75 B000                <1> 	mov	al,00h			; set scancode to zero
  4496                              <1> 
  4497                              <1> .exit:
  4498 00001E77 E9F149              <1> 	jmp	int_16_exit
  4499                              <1> 
  4500                              <1> ;=========================================================================
  4501                              <1> ; int_16_fn11 - check for extended keystroke
  4502                              <1> ; Input:
  4503                              <1> ;	AH = 01h
  4504                              <1> ; Output:
  4505                              <1> ;	ZF = 1 - no keystroke available
  4506                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4507                              <1> ;		AH = BIOS scan code
  4508                              <1> ;		AL = ASCII character
  4509                              <1> ; Note:
  4510                              <1> ;	- Does not remove keystroke from keyboard buffer
  4511                              <1> ;-------------------------------------------------------------------------
  4512                              <1> int_16_fn11:
  4513 00001E7A 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4514 00001E7E 8B07                <1> 	mov	ax,word [bx]
  4515 00001E80 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4516 00001E84 7408                <1> 	jz	.exit			; no keystroke, exit
  4517 00001E86 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4518 00001E88 7502                <1> 	jne	.clear_zf		; not a extended key
  4519 00001E8A B000                <1> 	mov	al,00h			; set scancode to zero
  4520                              <1> .clear_zf:
  4521 00001E8C 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4522                              <1> .exit:
  4523 00001E8E E9DD49              <1> 	jmp	int_16_exitf
  4524                                  %include	"serial1.inc"		; serial port services & detection
  4525                              <1> ;========================================================================
  4526                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
  4527                              <1> ;       INT 14h, function AH=01h
  4528                              <1> ;	INT 14h, function AH=02h
  4529                              <1> ;	detect_serial
  4530                              <1> ;	serial port related definitions and tables
  4531                              <1> ;	- see serial2.inc for other INT 14h functions
  4532                              <1> ;-------------------------------------------------------------------------
  4533                              <1> ;
  4534                              <1> ; Compiles with NASM 2.07, might work with other versions
  4535                              <1> ;
  4536                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4537                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4538                              <1> ;
  4539                              <1> ; This program is free software: you can redistribute it and/or modify
  4540                              <1> ; it under the terms of the GNU General Public License as published by
  4541                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4542                              <1> ; (at your option) any later version.
  4543                              <1> ;
  4544                              <1> ; This program is distributed in the hope that it will be useful,
  4545                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4546                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4547                              <1> ; GNU General Public License for more details.
  4548                              <1> ;
  4549                              <1> ; You should have received a copy of the GNU General Public License
  4550                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4551                              <1> ;
  4552                              <1> ;=========================================================================
  4553                              <1> 
  4554                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
  4555                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
  4556                              <1> 
  4557                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
  4558                              <1> 
  4559                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
  4560                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
  4561                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
  4562                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
  4563                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
  4564                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
  4565                              <1> 
  4566                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
  4567                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
  4568                              <1> uart_mcr_rts	equ	3		; MCR - request to send (RTS)
  4569                              <1> 
  4570                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
  4571                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
  4572                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
  4573                              <1> 
  4574                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
  4575                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
  4576                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
  4577                              <1> 
  4578                              <1> uart_err_timeout equ	80h		; timeout error
  4579                              <1> 
  4580                              <1> num_serial	equ	4		; number of serial ports
  4581                              <1> 
  4582                              <1> ;=========================================================================
  4583                              <1> ; int_14_fn01 - Send character
  4584                              <1> ; Input:
  4585                              <1> ;	AH = 01h - function 01h - send character
  4586                              <1> ;	AL = character to send
  4587                              <1> ;	DX = serial port number (0-3)
  4588                              <1> ; Output:
  4589                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4590                              <1> ;-------------------------------------------------------------------------
  4591                              <1> int_14_fn01:
  4592 00001E91 50                  <1> 	push	ax
  4593 00001E92 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4594 00001E94 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR
  4595 00001E96 B320                <1> 	mov	bl,uart_lsr_thre	; and for THR empty in LSR
  4596 00001E98 E82200              <1> 	call	uart_wait_status
  4597 00001E9B 59                  <1> 	pop	cx
  4598 00001E9C 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
  4599 00001E9E 88C8                <1> 	mov	al,cl
  4600 00001EA0 EE                  <1> 	out	dx,al			; sent the character
  4601 00001EA1 E9C248              <1> 	jmp	int_14_exit
  4602                              <1> 
  4603                              <1> int_14_timeout:
  4604 00001EA4 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
  4605 00001EA6 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
  4606 00001EA9 E9BA48              <1> 	jmp	int_14_exit
  4607                              <1> 
  4608                              <1> ;=========================================================================
  4609                              <1> ; int_14_fn02 - Receive character
  4610                              <1> ; Input:
  4611                              <1> ;	AH = 02h - function 02h - receive character
  4612                              <1> ;	DX = serial port number (0-3)
  4613                              <1> ; Output:
  4614                              <1> ;	AL = character received
  4615                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4616                              <1> ;-------------------------------------------------------------------------
  4617                              <1> int_14_fn02:
  4618 00001EAC 50                  <1> 	push	ax
  4619 00001EAD B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4620 00001EAF B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR
  4621 00001EB1 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR
  4622 00001EB3 E80700              <1> 	call	uart_wait_status
  4623 00001EB6 59                  <1> 	pop	cx
  4624 00001EB7 75EB                <1> 	jnz	int_14_timeout
  4625 00001EB9 EC                  <1> 	in	al,dx			; receive the character
  4626 00001EBA E9A948              <1> 	jmp	int_14_exit
  4627                              <1> 
  4628                              <1> ;=========================================================================
  4629                              <1> ; uart_wait_status - wait for modem and line status
  4630                              <1> ; Input:
  4631                              <1> ;	AL = value to write to MCR (Modem Control Register)
  4632                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
  4633                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
  4634                              <1> ;	DX = UART base address
  4635                              <1> ;	SI = serial port number
  4636                              <1> ; Output:
  4637                              <1> ;	AH = line status
  4638                              <1> ;	ZF = 0 - timeout
  4639                              <1> ;	CX,BX - destroyed
  4640                              <1> ;-------------------------------------------------------------------------
  4641                              <1> uart_wait_status:
  4642 00001EBD 52                  <1> 	push	dx
  4643 00001EBE 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
  4644 00001EC1 EE                  <1> 	out	dx,al			; output MCR value
  4645 00001EC2 42                  <1> 	inc	dx
  4646 00001EC3 42                  <1> 	inc	dx			; DX = UART MSR address
  4647                              <1> 					; OPTIMIZATION:
  4648                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
  4649 00001EC4 E80A00              <1> 	call	wait_for_port		; wait for MSR status
  4650 00001EC7 7506                <1> 	jnz	.wait_exit
  4651 00001EC9 4A                  <1> 	dec	dx			; DX = UART LSR address
  4652                              <1> 					; OPTIMIZATION:
  4653                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
  4654 00001ECA 88DF                <1> 	mov	bh,bl			; BH = LSR mask
  4655 00001ECC E80200              <1> 	call	wait_for_port		; wait for LSR status
  4656                              <1> .wait_exit:
  4657 00001ECF 5A                  <1> 	pop	dx
  4658 00001ED0 C3                  <1> 	ret
  4659                              <1> 
  4660                              <1> ;=========================================================================
  4661                              <1> ; wait_for_port - wait for set bits in a register
  4662                              <1> ;
  4663                              <1> ; Input:
  4664                              <1> ;	BH = mask to wait for (bits that need to be 1)
  4665                              <1> ;	DX = register address
  4666                              <1> ;	SI = address of the timeout value (in seconds)
  4667                              <1> ; Output:
  4668                              <1> ;	AH = last port reading
  4669                              <1> ;	ZF clear on timeout
  4670                              <1> ;	ZF set on success
  4671                              <1> ;	AL - trashed
  4672                              <1> ;	CX - trashed
  4673                              <1> ;-------------------------------------------------------------------------
  4674                              <1> wait_for_port:
  4675 00001ED1 53                  <1> 	push	bx
  4676 00001ED2 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
  4677                              <1> 
  4678                              <1> .loop_outer:
  4679 00001ED4 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
  4680                              <1> 
  4681                              <1> .loop_inner:
  4682 00001ED7 EC                  <1> 	in	al,dx			; read the register
  4683 00001ED8 88C4                <1> 	mov	ah,al			; save register in AH
  4684 00001EDA 20F8                <1> 	and	al,bh
  4685 00001EDC 38F8                <1> 	cmp	al,bh			; required bits are set?
  4686 00001EDE 7414                <1> 	je	.exit
  4687                              <1> 
  4688                              <1> .zero_loop:
  4689 00001EE0 E461                <1> 	in	al,port_b_reg
  4690 00001EE2 A810                <1> 	test	al,refresh_flag
  4691 00001EE4 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  4692                              <1> 
  4693                              <1> .one_loop:
  4694 00001EE6 E461                <1> 	in	al,port_b_reg
  4695 00001EE8 A810                <1> 	test	al,refresh_flag
  4696 00001EEA 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  4697 00001EEC E2E9                <1> 	loop	.loop_inner
  4698                              <1> 
  4699 00001EEE FECB                <1> 	dec	bl
  4700 00001EF0 75E2                <1> 	jnz	.loop_outer
  4701 00001EF2 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
  4702                              <1> 
  4703                              <1> .exit:
  4704 00001EF4 5B                  <1> 	pop	bx
  4705 00001EF5 C3                  <1> 	ret
  4706                              <1> 
  4707                              <1> ;=========================================================================
  4708                              <1> ; detect_serial - detect and print serial ports
  4709                              <1> ; Input:
  4710                              <1> ;	none
  4711                              <1> ; Output:
  4712                              <1> ;	none (updates BIOS data area)
  4713                              <1> ;-------------------------------------------------------------------------
  4714                              <1> detect_serial:
  4715 00001EF6 50                  <1> 	push	ax
  4716 00001EF7 53                  <1> 	push	bx
  4717 00001EF8 52                  <1> 	push	dx
  4718 00001EF9 56                  <1> 	push	si
  4719 00001EFA BE[3E02]            <1> 	mov	si,msg_serial
  4720 00001EFD E89006              <1> 	call	print
  4721 00001F00 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
  4722 00001F03 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
  4723 00001F07 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
  4724 00001F0B 31DB                <1> 	xor	bx,bx			; BX = 0
  4725                              <1> .detect_loop:
  4726 00001F0D BE[5B02]            <1> 	mov	si,msg_serial_com
  4727 00001F10 E87D06              <1> 	call	print
  4728 00001F13 88D8                <1> 	mov	al,bl
  4729 00001F15 D0E8                <1> 	shr	al,1
  4730 00001F17 FEC0                <1> 	inc	al			; AL = COM port number (1..4)
  4731 00001F19 E8D206              <1> 	call	print_digit
  4732 00001F1C BE[9000]            <1> 	mov	si,msg_colon
  4733 00001F1F E86E06              <1> 	call	print
  4734 00001F22 2E8B97[8C1F]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
  4735 00001F27 EC                  <1> 	in	al,dx
  4736 00001F28 B00F                <1> 	mov	al,0Fh
  4737 00001F2A EE                  <1> 	out	dx,al			; enable interrupts
  4738 00001F2B B000                <1> 	mov	al,00h
  4739 00001F2D E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
  4740 00001F2F EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4741 00001F30 3C0F                <1> 	cmp	al,0Fh
  4742 00001F32 7530                <1> 	jne	.no_port		; no port at this address
  4743 00001F34 B000                <1> 	mov	al,00h
  4744 00001F36 EE                  <1> 	out	dx,al			; disable interrupts
  4745 00001F37 B0FF                <1> 	mov	al,0FFh
  4746 00001F39 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4747 00001F3B EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4748 00001F3C 3C00                <1> 	cmp	al,00h
  4749 00001F3E 7524                <1> 	jne	.no_port		; no port at this address
  4750 00001F40 4A                  <1> 	dec	dx			; DX = UART base address
  4751                              <1> 					; OPTIMIZATION:
  4752                              <1> 					; uart_base = uart_ier_reg - 1
  4753 00001F41 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
  4754                              <1> 					; data area
  4755                              <1> 					
  4756                              <1> 	;; SGEO serial port fix
  4757 00001F43 50                  <1> 	push ax
  4758 00001F44 51                  <1> 	push cx
  4759                              <1> 	
  4760 00001F45 A11000              <1> 	mov ax,[equipment_list]
  4761 00001F48 B109                <1> 	mov cl,9
  4762 00001F4A D3E8                <1> 	shr ax,cl
  4763 00001F4C 2407                <1> 	and al,0x7
  4764 00001F4E 40                  <1> 	inc ax
  4765 00001F4F D3E0                <1> 	shl ax,cl	
  4766 00001F51 81261000FFF1        <1> 	and word [equipment_list],0xF1FF
  4767 00001F57 09061000            <1> 	or [equipment_list],ax
  4768                              <1> 	
  4769 00001F5B 59                  <1> 	pop cx
  4770 00001F5C 58                  <1> 	pop ax
  4771                              <1> 					
  4772 00001F5D 89D0                <1> 	mov	ax,dx
  4773 00001F5F E84906              <1> 	call	print_hex
  4774 00001F62 EB0A                <1> 	jmp	.next
  4775                              <1> 
  4776                              <1> .no_port:
  4777 00001F64 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
  4778 00001F68 BE[8B00]            <1> 	mov	si,msg_none
  4779 00001F6B E82206              <1> 	call	print
  4780                              <1> 	
  4781                              <1> .next:
  4782 00001F6E 43                  <1> 	inc	bx
  4783 00001F6F 43                  <1> 	inc	bx
  4784 00001F70 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
  4785 00001F73 7408                <1> 	je	.done
  4786 00001F75 BE[9300]            <1> 	mov	si,msg_semicolon
  4787 00001F78 E81506              <1> 	call	print
  4788 00001F7B EB90                <1> 	jmp	.detect_loop
  4789                              <1> 
  4790                              <1> .done:
  4791 00001F7D BE[8800]            <1> 	mov	si,msg_crlf
  4792 00001F80 E80D06              <1> 	call	print
  4793                              <1> 
  4794 00001F83 B024                <1> 	mov	al,e_serial_ok		; serial port detection complete
  4795 00001F85 E680                <1> 	out	post_reg,al
  4796                              <1> 
  4797 00001F87 5E                  <1> 	pop	si
  4798 00001F88 5A                  <1> 	pop	dx
  4799 00001F89 5B                  <1> 	pop	bx
  4800 00001F8A 58                  <1> 	pop	ax
  4801 00001F8B C3                  <1> 	ret
  4802                              <1> 
  4803                              <1> ;-------------------------------------------------------------------------
  4804                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
  4805 00001F8C F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
  4806 00001F90 E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
  4807                              <1> 
  4808                              <1> ;-------------------------------------------------------------------------
  4809                              <1> ; UART divisor values table
  4810 00001F94 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
  4811 00001F96 0003                <1> 		dw	uart_osc/16/150		; 150 bps
  4812 00001F98 8001                <1> 		dw	uart_osc/16/300		; 300 bps
  4813 00001F9A C000                <1> 		dw	uart_osc/16/600		; 600 bps
  4814 00001F9C 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
  4815 00001F9E 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
  4816 00001FA0 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
  4817 00001FA2 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
  4818 00001FA4 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
  4819 00001FA6 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
  4820 00001FA8 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
  4821 00001FAA 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
  4822                              <1> num_divisors	equ ($-uart_divisors)/2
  4823                                  %include	"printer1.inc"		; parallel printer services & detection
  4824                              <1> ;========================================================================
  4825                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
  4826                              <1> ;	INT 17h, function AH=01h 
  4827                              <1> ;	detect_parallel
  4828                              <1> ;	- see printer2.inc for other INT 17h functions
  4829                              <1> ;-------------------------------------------------------------------------
  4830                              <1> ;
  4831                              <1> ; Compiles with NASM 2.07, might work with other versions
  4832                              <1> ;
  4833                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4834                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4835                              <1> ;
  4836                              <1> ; This program is free software: you can redistribute it and/or modify
  4837                              <1> ; it under the terms of the GNU General Public License as published by
  4838                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4839                              <1> ; (at your option) any later version.
  4840                              <1> ;
  4841                              <1> ; This program is distributed in the hope that it will be useful,
  4842                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4843                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4844                              <1> ; GNU General Public License for more details.
  4845                              <1> ;
  4846                              <1> ; You should have received a copy of the GNU General Public License
  4847                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4848                              <1> ;
  4849                              <1> ;=========================================================================
  4850                              <1> 
  4851                              <1> num_parallel	equ	3		; number of parallel ports
  4852                              <1> 
  4853                              <1> prn_data_reg	equ	0		; printer data register (out)
  4854                              <1> 
  4855                              <1> prn_stat_reg	equ	1		; printer status register (in)
  4856                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
  4857                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
  4858                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
  4859                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
  4860                              <1> 
  4861                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
  4862                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
  4863                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
  4864                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
  4865                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
  4866                              <1> 
  4867                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
  4868                              <1> 
  4869                              <1> ;=========================================================================
  4870                              <1> ; int_17_fn01 - Initialize printer port
  4871                              <1> ; Input:
  4872                              <1> ;	AH = 1 - function 01h - initialize printer port
  4873                              <1> ;	DX = printer port number (0-2)
  4874                              <1> ; Output:
  4875                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  4876                              <1> ;-------------------------------------------------------------------------
  4877                              <1> int_17_fn01:
  4878 00001FAC 42                  <1> 	inc	dx
  4879 00001FAD 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  4880                              <1> 					; OPTIMIZATION:
  4881                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
  4882 00001FAE B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
  4883 00001FB0 EE                  <1> 	out	dx,al
  4884 00001FB1 51                  <1> 	push	cx
  4885 00001FB2 B9B509              <1> 	mov	cx,prn_init_delay
  4886 00001FB5 E8E4EE              <1> 	call	delay_15us
  4887 00001FB8 59                  <1> 	pop	cx
  4888 00001FB9 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  4889 00001FBB EE                  <1> 	out	dx,al			; deactivate init bit
  4890 00001FBC 4A                  <1> 	dec	dx			; OPTIMIZATION:
  4891                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
  4892 00001FBD E97950              <1> 	jmp	int_17_status		; exit returning status
  4893                              <1> 
  4894                              <1> ;=========================================================================
  4895                              <1> ; detect_parallel - detect and print parallel ports
  4896                              <1> ; Input:
  4897                              <1> ;	none
  4898                              <1> ; Output:
  4899                              <1> ;	none (updates BIOS data area)
  4900                              <1> ; Notes:
  4901                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
  4902                              <1> ;	  enumeration is used:
  4903                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
  4904                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
  4905                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
  4906                              <1> ;-------------------------------------------------------------------------
  4907                              <1> detect_parallel:
  4908 00001FC0 50                  <1> 	push	ax
  4909 00001FC1 53                  <1> 	push	bx
  4910 00001FC2 52                  <1> 	push	dx
  4911 00001FC3 56                  <1> 	push	si
  4912 00001FC4 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
  4913 00001FC7 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
  4914 00001FCB 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
  4915 00001FCF 31DB                <1> 	xor	bx,bx			; BX = 0
  4916 00001FD1 31FF                <1> 	xor	di,di			; DI = 0
  4917                              <1> .detect_loop:
  4918 00001FD3 2E8B95[6420]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
  4919 00001FD8 B05A                <1> 	mov	al,05Ah			; just some test value
  4920 00001FDA EE                  <1> 	out	dx,al			; write it to the printer data register
  4921 00001FDB B0FF                <1> 	mov	al,0FFh
  4922 00001FDD E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4923 00001FDF EC                  <1> 	in	al,dx
  4924 00001FE0 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
  4925 00001FE2 751F                <1> 	jne	.no_port		; no port at this address
  4926 00001FE4 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
  4927                              <1> 					; data area
  4928                              <1> 					
  4929                              <1> 	;; SGEO parallel port fix
  4930 00001FE7 50                  <1> 	push ax
  4931 00001FE8 51                  <1> 	push cx
  4932 00001FE9 A11000              <1> 	mov ax,[equipment_list]
  4933 00001FEC B10E                <1> 	mov cl,14
  4934 00001FEE D3E8                <1> 	shr ax,cl
  4935 00001FF0 2403                <1> 	and al,0x3
  4936 00001FF2 40                  <1> 	inc ax
  4937 00001FF3 D3E0                <1> 	shl ax,cl
  4938 00001FF5 81261000FF3F        <1> 	and word [equipment_list],0x3FFF
  4939 00001FFB 09061000            <1> 	or [equipment_list],ax
  4940 00001FFF 59                  <1> 	pop cx
  4941 00002000 58                  <1> 	pop ax
  4942 00002001 EB09                <1> 	jmp	.next
  4943                              <1> 
  4944                              <1> .no_port:
  4945 00002003 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
  4946 00002008 09FF                <1> 	or	di,di			; no printer port at 3BCh?
  4947 0000200A 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
  4948                              <1> .next:
  4949 0000200C 43                  <1> 	inc	bx
  4950 0000200D 43                  <1> 	inc	bx
  4951                              <1> 
  4952                              <1> .next_skip_3BC:
  4953 0000200E 47                  <1> 	inc	di
  4954 0000200F 47                  <1> 	inc	di
  4955 00002010 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
  4956 00002013 7402                <1> 	je	.print			; done with detection, print findings
  4957 00002015 EBBC                <1> 	jmp	.detect_loop
  4958                              <1> 
  4959                              <1> .print:
  4960 00002017 BE[5F02]            <1> 	mov	si,msg_parallel
  4961 0000201A E87305              <1> 	call	print
  4962 0000201D 31DB                <1> 	xor	bx,bx
  4963                              <1> 
  4964                              <1> .print_loop:
  4965 0000201F BE[7C02]            <1> 	mov	si,msg_parallel_lpt
  4966 00002022 E86B05              <1> 	call	print
  4967 00002025 88D8                <1> 	mov	al,bl
  4968 00002027 D0E8                <1> 	shr	al,1
  4969 00002029 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
  4970 0000202B E8C005              <1> 	call	print_digit
  4971 0000202E BE[9000]            <1> 	mov	si,msg_colon
  4972 00002031 E85C05              <1> 	call	print
  4973 00002034 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
  4974 00002037 09C0                <1> 	or	ax,ax			; parallel interface installed?
  4975 00002039 7405                <1> 	jz	.print_no_port
  4976 0000203B E86D05              <1> 	call	print_hex
  4977 0000203E EB06                <1> 	jmp	.print_next
  4978                              <1> 
  4979                              <1> .print_no_port:
  4980 00002040 BE[8B00]            <1> 	mov	si,msg_none
  4981 00002043 E84A05              <1> 	call	print
  4982                              <1> 
  4983                              <1> .print_next:
  4984 00002046 43                  <1> 	inc	bx
  4985 00002047 43                  <1> 	inc	bx
  4986 00002048 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
  4987 0000204B 7408                <1> 	je	.done
  4988 0000204D BE[9300]            <1> 	mov	si,msg_semicolon
  4989 00002050 E83D05              <1> 	call	print
  4990 00002053 EBCA                <1> 	jmp	.print_loop
  4991                              <1> 
  4992                              <1> .done:
  4993 00002055 BE[8800]            <1> 	mov	si,msg_crlf
  4994 00002058 E83505              <1> 	call	print
  4995                              <1> 
  4996 0000205B B025                <1> 	mov	al,e_parallel_ok	; parallel port detection complete
  4997 0000205D E680                <1> 	out	post_reg,al
  4998                              <1> 
  4999 0000205F 5E                  <1> 	pop	si
  5000 00002060 5A                  <1> 	pop	dx
  5001 00002061 5B                  <1> 	pop	bx
  5002 00002062 58                  <1> 	pop	ax
  5003 00002063 C3                  <1> 	ret
  5004                              <1> 
  5005                              <1> ;-------------------------------------------------------------------------
  5006                              <1> ; parallel port base addresses - used for port detection
  5007 00002064 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
  5008                                  %ifdef PS2_MOUSE
  5009                                  %ifndef AT_COMPAT
  5010                                  %error "PS2_MOUSE depends on AT_COMPAT. Please fix config.inc."
  5011                                  %endif ; AT_COMPAT
  5012                                  %include	"ps2aux.inc"
  5013                              <1> ;=========================================================================
  5014                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  5015                              <1> ;	INT 15h, function AH=0C2h
  5016                              <1> ;	INT 74h - IRQ12 interrupt handler
  5017                              <1> ;-------------------------------------------------------------------------
  5018                              <1> ;
  5019                              <1> ; Compiles with NASM 2.07, might work with other versions
  5020                              <1> ;
  5021                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5022                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5023                              <1> ;
  5024                              <1> ; This program is free software: you can redistribute it and/or modify
  5025                              <1> ; it under the terms of the GNU General Public License as published by
  5026                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5027                              <1> ; (at your option) any later version.
  5028                              <1> ;
  5029                              <1> ; This program is distributed in the hope that it will be useful,
  5030                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5031                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5032                              <1> ; GNU General Public License for more details.
  5033                              <1> ;
  5034                              <1> ; You should have received a copy of the GNU General Public License
  5035                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5036                              <1> ;
  5037                              <1> ;=========================================================================
  5038                              <1> 
  5039                              <1> ;-------------------------------------------------------------------------
  5040                              <1> ; offsets for registers on stack
  5041                              <1> int_15_fnC2_bp	equ	0
  5042                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  5043                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  5044                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  5045                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  5046                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  5047                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  5048                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  5049                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  5050                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  5051                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  5052                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  5053                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  5054                              <1> 
  5055                              <1> ;=========================================================================
  5056                              <1> ; int_15_fnC2 - mouse functions
  5057                              <1> ; Input:
  5058                              <1> ;	AH = 0C2h - mouse functions
  5059                              <1> ;	AL - function:
  5060                              <1> ;		00h - enable / disable PS/2 mouse
  5061                              <1> ;		01h - reset PS/2 mouse
  5062                              <1> ;		02h - set sample rate
  5063                              <1> ;		03h - set resolution
  5064                              <1> ;		04h - read device type
  5065                              <1> ;		05h - initialize PS/2 mouse
  5066                              <1> ;		06h - set scaling or get status
  5067                              <1> ;		07h - set PS/2 mouse driver address
  5068                              <1> ; Output:
  5069                              <1> ;	AH - exit status:
  5070                              <1> ;		00h - no error
  5071                              <1> ;		01h - invalid function call
  5072                              <1> ;		02h - invalid input value
  5073                              <1> ;		03h - interface error
  5074                              <1> ;		04h - request for resend received from 8042
  5075                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  5076                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  5077                              <1> ;-------------------------------------------------------------------------
  5078                              <1> int_15_fnC2:
  5079 0000206A 50                  <1> 	push	ax
  5080 0000206B 53                  <1> 	push	bx
  5081 0000206C 51                  <1> 	push	cx
  5082 0000206D 52                  <1> 	push	dx
  5083 0000206E 1E                  <1> 	push	ds
  5084 0000206F 55                  <1> 	push	bp
  5085 00002070 89E5                <1> 	mov	bp,sp			; establish stack addressing
  5086 00002072 BB4000              <1> 	mov	bx,biosdseg
  5087 00002075 8EDB                <1> 	mov	ds,bx
  5088 00002077 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  5089 0000207B 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  5090 0000207D 3C08                <1> 	cmp	al,.num_func
  5091 0000207F 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  5092 00002081 E8A9F8              <1> 	call	kbc_aux_disable		; disable auxiliary device
  5093 00002084 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  5094 00002086 B700                <1> 	mov	bh,0
  5095 00002088 D1E3                <1> 	shl	bx,1			; address words
  5096 0000208A 2EFFA7[8F20]        <1>     cs	jmp	near [.dispatch+bx]
  5097                              <1> 
  5098                              <1> .dispatch:
  5099 0000208F [C820]              <1> 	dw	int_15_fnC200
  5100 00002091 [E920]              <1> 	dw	int_15_fnC201
  5101 00002093 [0C21]              <1> 	dw	int_15_fnC202
  5102 00002095 [3321]              <1> 	dw	int_15_fnC203
  5103 00002097 [5521]              <1> 	dw	int_15_fnC204
  5104 00002099 [6D21]              <1> 	dw	int_15_fnC205
  5105 0000209B [B121]              <1> 	dw	int_15_fnC206
  5106 0000209D [0222]              <1> 	dw	int_15_fnC207
  5107                              <1> .num_func	equ ($-.dispatch)/2
  5108                              <1> 
  5109                              <1> int_15_fnC2_ok:
  5110 0000209F B400                <1> 	mov	ah,00h			; no error
  5111 000020A1 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  5112 000020A5 EB14                <1> 	jmp	int_15_fnC2_exit
  5113                              <1> 
  5114                              <1> int_15_fnC2_err1:
  5115 000020A7 B401                <1> 	mov	ah,01h			; invalid function call
  5116 000020A9 EB0C                <1> 	jmp	int_15_fnC2_err
  5117                              <1> 
  5118                              <1> int_15_fnC2_err2:
  5119 000020AB B402                <1> 	mov	ah,02h			; invalid input value
  5120 000020AD EB08                <1> 	jmp	int_15_fnC2_err
  5121                              <1> 
  5122                              <1> int_15_fnC2_err3:
  5123 000020AF B403                <1> 	mov	ah,03h			; interface error
  5124 000020B1 EB04                <1> 	jmp	int_15_fnC2_err
  5125                              <1> 
  5126                              <1> int_15_fnC2_err5:
  5127 000020B3 B405                <1> 	mov	ah,05h			; no driver installed
  5128 000020B5 EB00                <1> 	jmp	int_15_fnC2_err
  5129                              <1> 
  5130                              <1> int_15_fnC2_err:
  5131 000020B7 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  5132                              <1> 
  5133                              <1> int_15_fnC2_exit:
  5134 000020BB 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  5135 000020BE E862F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
  5136 000020C1 5D                  <1> 	pop	bp
  5137 000020C2 1F                  <1> 	pop	ds
  5138 000020C3 5A                  <1> 	pop	dx
  5139 000020C4 59                  <1> 	pop	cx
  5140 000020C5 5B                  <1> 	pop	bx
  5141 000020C6 58                  <1> 	pop	ax
  5142 000020C7 CF                  <1> 	iret
  5143                              <1> 
  5144                              <1> ;=========================================================================
  5145                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  5146                              <1> ; Input:
  5147                              <1> ;	AX = 0C200h
  5148                              <1> ;	BH - sub-function:
  5149                              <1> ;		00h - disable
  5150                              <1> ;		01h - enable
  5151                              <1> ;-------------------------------------------------------------------------
  5152                              <1> int_15_fnC200:
  5153 000020C8 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5154 000020CB 80FF01              <1> 	cmp	bh,01h
  5155 000020CE 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5156                              <1> 
  5157 000020D0 F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  5158 000020D5 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  5159                              <1> 
  5160 000020D7 80FF00              <1> 	cmp	bh,00h
  5161 000020DA 7404                <1> 	je	.disable
  5162 000020DC B0F4                <1> 	mov	al,0F4h			; device enable command
  5163 000020DE EB02                <1> 	jmp	.send_it
  5164                              <1> .disable:
  5165 000020E0 B0F5                <1> 	mov	al,0F5h			; device disable command
  5166                              <1> 
  5167                              <1> .send_it:
  5168 000020E2 E806F8              <1> 	call	kbc_aux_send
  5169 000020E5 72D0                <1> 	jc	int_15_fnC2_err		; error
  5170 000020E7 EBB6                <1> 	jmp	int_15_fnC2_ok
  5171                              <1> 
  5172                              <1> ;=========================================================================
  5173                              <1> ; int_15_fnC201 - reset PS/2 mouse
  5174                              <1> ; Input:
  5175                              <1> ;	AX = 0C201h
  5176                              <1> ; Output:
  5177                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  5178                              <1> ;	     0AAh - BAT successful XXX test!!!
  5179                              <1> ;	     0FCh - BAT error
  5180                              <1> ;	BH = device ID
  5181                              <1> ;-------------------------------------------------------------------------
  5182                              <1> int_15_fnC201:
  5183 000020E9 B90A00              <1> 	mov	cx,10			; try the reset 10 times
  5184                              <1> .1:
  5185 000020EC B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5186 000020EE E8FAF7              <1> 	call	kbc_aux_send
  5187 000020F1 7307                <1> 	jnc	.2			; no error - continue
  5188 000020F3 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5189 000020F6 E1F4                <1> 	loopz	.1			; try again
  5190 000020F8 EBBD                <1> 	jmp	int_15_fnC2_err		; error
  5191                              <1> .2:
  5192 000020FA E8D3F7              <1> 	call	kbc_aux_read
  5193 000020FD 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  5194 000020FF 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5195 00002102 E8CBF7              <1> 	call	kbc_aux_read
  5196 00002105 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  5197 00002107 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5198 0000210A EB93                <1> 	jmp	int_15_fnC2_ok
  5199                              <1> 
  5200                              <1> ;=========================================================================
  5201                              <1> ; int_15_fnC202 - set sample rate
  5202                              <1> ; Input:
  5203                              <1> ;	AX = 0C202h
  5204                              <1> ;	BH - sample rate:
  5205                              <1> ;		00h - 10 samples per second
  5206                              <1> ;		01h - 20 samples per second
  5207                              <1> ;		02h - 40 samples per second
  5208                              <1> ;		03h - 60 samples per second
  5209                              <1> ;		04h - 80 samples per second
  5210                              <1> ;		05h - 100 samples per second
  5211                              <1> ;		06h - 200 samples per second
  5212                              <1> ;-------------------------------------------------------------------------
  5213                              <1> int_15_fnC202:
  5214 0000210C 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5215 0000210F 80FF06              <1> 	cmp	bh,06h
  5216 00002112 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  5217 00002114 88FB                <1> 	mov	bl,bh
  5218 00002116 B700                <1> 	mov	bh,00h			; rate index in BX
  5219                              <1> 
  5220 00002118 B0F3                <1> 	mov	al,0F3h			; set sample rate
  5221 0000211A E8CEF7              <1> 	call	kbc_aux_send
  5222 0000211D 7298                <1> 	jc	int_15_fnC2_err		; error
  5223                              <1> 
  5224 0000211F 2E8A87[2C21]        <1>     cs	mov	al,byte [.rate_table+bx]
  5225 00002124 E8C4F7              <1> 	call	kbc_aux_send
  5226 00002127 728E                <1> 	jc	int_15_fnC2_err		; error
  5227 00002129 E973FF              <1> 	jmp	int_15_fnC2_ok
  5228                              <1> 
  5229 0000212C 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  5230                              <1> 	
  5231                              <1> ;=========================================================================
  5232                              <1> ; int_15_fnC203 - set resolution
  5233                              <1> ; Input:
  5234                              <1> ;	AX = 0C203h
  5235                              <1> ;	BH - resolution value:
  5236                              <1> ;		00h - 1 count per millimeter
  5237                              <1> ;		01h - 2 counts per millimeter
  5238                              <1> ;		02h - 4 counts per millimeter
  5239                              <1> ;		03h - 8 counts per millimeter
  5240                              <1> ;-------------------------------------------------------------------------
  5241                              <1> int_15_fnC203:
  5242 00002133 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5243 00002136 80FF03              <1> 	cmp	bh,03h
  5244 00002139 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5245                              <1> 
  5246 0000213E B0E8                <1> 	mov	al,0E8h			; set resolution
  5247 00002140 E8A8F7              <1> 	call	kbc_aux_send
  5248 00002143 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  5249                              <1> 
  5250 00002148 88F8                <1> 	mov	al,bh
  5251 0000214A E89EF7              <1> 	call	kbc_aux_send
  5252 0000214D 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  5253 00002152 E94AFF              <1> 	jmp	int_15_fnC2_ok
  5254                              <1> 
  5255                              <1> ;=========================================================================
  5256                              <1> ; int_15_fnC204 - read device type
  5257                              <1> ; Input:
  5258                              <1> ;	AX = 0C204h
  5259                              <1> ; Output:
  5260                              <1> ;	BH = device type
  5261                              <1> ;-------------------------------------------------------------------------
  5262                              <1> int_15_fnC204:
  5263 00002155 B0F2                <1> 	mov	al,0F2h			; read device type
  5264 00002157 E891F7              <1> 	call	kbc_aux_send
  5265 0000215A 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  5266 0000215F E86EF7              <1> 	call	kbc_aux_read
  5267 00002162 7303E948FF          <1> 	jc	int_15_fnC2_err3
  5268 00002167 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5269 0000216A E932FF              <1> 	jmp	int_15_fnC2_ok
  5270                              <1> 
  5271                              <1> ;=========================================================================
  5272                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  5273                              <1> ; Input:
  5274                              <1> ;	AX = 0C205h
  5275                              <1> ;	BH = data package size in bytes (03h or 04h)
  5276                              <1> ; Output:
  5277                              <1> ;	none
  5278                              <1> ;-------------------------------------------------------------------------
  5279                              <1> int_15_fnC205:
  5280 0000216D 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5281 00002170 80FF03              <1> 	cmp	bh,03h
  5282 00002173 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  5283 00002178 80FF04              <1> 	cmp	bh,04h
  5284 0000217B 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5285 00002180 FECF                <1> 	dec	bh
  5286                              <1> 
  5287 00002182 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5288 00002185 24F8                <1> 	and	al,0F8h			; mask out package size bits
  5289 00002187 08F8                <1> 	or	al,bh			; add the new package size
  5290 00002189 A22700              <1> 	mov	byte [mouse_flags_2],al
  5291                              <1> 
  5292 0000218C B90500              <1> 	mov	cx,5			; try the reset 5 times
  5293                              <1> .1:
  5294 0000218F B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5295 00002191 E857F7              <1> 	call	kbc_aux_send
  5296 00002194 7308                <1> 	jnc	.2			; no error - continue
  5297 00002196 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5298 00002199 E1F4                <1> 	loopz	.1			; try again
  5299 0000219B E919FF              <1> 	jmp	int_15_fnC2_err		; error
  5300                              <1> .2:
  5301 0000219E E82FF7              <1> 	call	kbc_aux_read
  5302 000021A1 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5303 000021A6 E827F7              <1> 	call	kbc_aux_read
  5304 000021A9 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5305 000021AE E9EEFE              <1> 	jmp	int_15_fnC2_ok
  5306                              <1> 
  5307                              <1> ;=========================================================================
  5308                              <1> ; int_15_fnC206 - set scaling or get status
  5309                              <1> ; Input:
  5310                              <1> ;	AX = 0C206h
  5311                              <1> ;	BH - sub-function:
  5312                              <1> ;		00h - return status
  5313                              <1> ;		01h - set scaling factor to 1:1
  5314                              <1> ;		02h - set scaling factor to 2:1
  5315                              <1> ; Output:
  5316                              <1> ;	if BH = 00h on entry:
  5317                              <1> ;		BL - status byte 1:
  5318                              <1> ;			bit 0 = 1 - right button pressed
  5319                              <1> ;			bit 1 = 0 - reserved
  5320                              <1> ;			bit 2 = 1 - left button pressed
  5321                              <1> ;			bit 3 = 0 - reserved
  5322                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  5323                              <1> ;			bit 5 = 0 - disable, 1 - enable
  5324                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  5325                              <1> ;			bit 7 = 0 - reserved
  5326                              <1> ;		CL - status byte 2:
  5327                              <1> ;			00h - 1 count per millimeter
  5328                              <1> ;			01h - 2 counts per millimeter
  5329                              <1> ;			02h - 4 counts per millimeter
  5330                              <1> ;			03h - 8 counts per millimeter
  5331                              <1> ;		DL - status byte 3:
  5332                              <1> ;			0Ah - 10 samples per second
  5333                              <1> ;			14h - 20 samples per second
  5334                              <1> ;			3Ch - 40 samples per second
  5335                              <1> ;			3Ch - 60 samples per second
  5336                              <1> ;			50h - 80 samples per second
  5337                              <1> ;			64h - 100 samples per second
  5338                              <1> ;			0C8h - 200 samples per second
  5339                              <1> ;-------------------------------------------------------------------------
  5340                              <1> int_15_fnC206:
  5341 000021B1 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5342 000021B4 80FF02              <1> 	cmp	bh,02h
  5343 000021B7 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5344 000021BC 7433                <1> 	je	.scale_2x1
  5345 000021BE 80FF01              <1> 	cmp	bh,01h
  5346 000021C1 7432                <1> 	je	.scale_1x1
  5347                              <1> 					; BH == 0, return status
  5348 000021C3 B0E9                <1> 	mov	al,0E9h			; request status command
  5349 000021C5 E823F7              <1> 	call	kbc_aux_send
  5350 000021C8 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  5351 000021CD E800F7              <1> 	call	kbc_aux_read
  5352 000021D0 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5353 000021D5 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5354 000021D8 E8F5F6              <1> 	call	kbc_aux_read
  5355 000021DB 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5356 000021E0 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  5357 000021E3 E8EAF6              <1> 	call	kbc_aux_read
  5358 000021E6 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  5359 000021EB 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  5360 000021EE E9AEFE              <1> 	jmp	int_15_fnC2_ok
  5361                              <1> 
  5362                              <1> .scale_2x1:
  5363 000021F1 B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  5364 000021F3 EB02                <1> 	jmp	.send_it
  5365                              <1> .scale_1x1:
  5366 000021F5 B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  5367                              <1> .send_it:
  5368 000021F7 E8F1F6              <1> 	call	kbc_aux_send
  5369 000021FA 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  5370 000021FF E99DFE              <1> 	jmp	int_15_fnC2_ok
  5371                              <1> 
  5372                              <1> ;=========================================================================
  5373                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  5374                              <1> ; Input:
  5375                              <1> ;	AX = 0C207h
  5376                              <1> ;	ES:BX - pointer to mouse driver
  5377                              <1> ;-------------------------------------------------------------------------
  5378                              <1> int_15_fnC207:
  5379 00002202 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  5380 00002205 891E2200            <1> 	mov	word [mouse_driver],bx
  5381 00002209 8CC0                <1> 	mov	ax,es
  5382 0000220B A32400              <1> 	mov	word [mouse_driver+2],ax
  5383 0000220E 09C0                <1> 	or	ax,ax
  5384 00002210 750C                <1> 	jnz	.set_handler
  5385 00002212 09DB                <1> 	or	bx,bx
  5386 00002214 7508                <1> 	jnz	.set_handler
  5387                              <1> ; remove handler
  5388 00002216 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  5389 0000221B E981FE              <1> 	jmp	int_15_fnC2_ok
  5390                              <1> 
  5391                              <1> .set_handler:
  5392 0000221E 800E270080          <1> 	or	byte [mouse_flags_2],80h
  5393 00002223 E979FE              <1> 	jmp	int_15_fnC2_ok
  5394                              <1> 
  5395                              <1> ;=========================================================================
  5396                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  5397                              <1> ;-------------------------------------------------------------------------
  5398                              <1> int_74:
  5399 00002226 FB                  <1> 	sti
  5400 00002227 50                  <1> 	push	ax
  5401 00002228 53                  <1> 	push	bx
  5402 00002229 1E                  <1> 	push	ds
  5403 0000222A B84000              <1> 	mov	ax,biosdseg
  5404 0000222D 8ED8                <1> 	mov	ds,ax
  5405 0000222F A10E00              <1> 	mov	ax,word [ebda_segment]
  5406 00002232 8ED8                <1> 	mov	ds,ax
  5407                              <1> 
  5408 00002234 E464                <1> 	in	al,kbc_status_reg
  5409 00002236 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  5410 00002238 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  5411 0000223A 7561                <1> 	jne	.exit			; no mouse data in the buffer
  5412                              <1> 
  5413 0000223C E460                <1> 	in	al,kbc_data_reg
  5414 0000223E 88C4                <1> 	mov	ah,al			; save to AH
  5415                              <1> 
  5416 00002240 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5417 00002243 A880                <1> 	test	al,80h
  5418 00002245 7456                <1> 	jz	.exit			; no mouse driver installed
  5419                              <1> 
  5420 00002247 A02600              <1> 	mov	al,byte [mouse_flags_1]
  5421 0000224A 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  5422 0000224C BB2800              <1> 	mov	bx,mouse_data
  5423 0000224F 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  5424 00002251 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  5425                              <1> 
  5426 00002253 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  5427 00002257 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  5428                              <1> 
  5429 0000225A 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  5430 0000225C 7306                <1> 	jae	.call_driver
  5431                              <1> 
  5432 0000225E FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  5433 00002262 EB39                <1> 	jmp	.exit
  5434                              <1> 
  5435                              <1> .call_driver:
  5436                              <1> 
  5437                              <1> ;-------------------------------------------------------------------------
  5438                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  5439                              <1> ; package sizes.
  5440                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  5441                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  5442                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  5443                              <1> ;-------------------------------------------------------------------------
  5444                              <1> 
  5445 00002264 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  5446 00002267 7413                <1> 	jz	.four_bytes
  5447                              <1> 					; put data in stack for 3 bytes format
  5448 00002269 31C0                <1> 	xor	ax,ax
  5449 0000226B A02800              <1> 	mov	al,byte [mouse_data]
  5450 0000226E 50                  <1> 	push	ax
  5451 0000226F A02900              <1> 	mov	al,byte [mouse_data+1]
  5452 00002272 50                  <1> 	push	ax
  5453 00002273 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5454 00002276 50                  <1> 	push	ax
  5455 00002277 B000                <1> 	mov	al,00h
  5456 00002279 50                  <1> 	push	ax
  5457 0000227A EB15                <1> 	jmp	.do_call
  5458                              <1> 
  5459                              <1> .four_bytes:				; put data in stack for 4 bytes format
  5460 0000227C 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  5461 00002280 A02800              <1> 	mov	al,byte [mouse_data]
  5462 00002283 50                  <1> 	push	ax
  5463 00002284 B400                <1> 	mov	ah,00h
  5464 00002286 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5465 00002289 50                  <1> 	push	ax
  5466 0000228A A02B00              <1> 	mov	al,byte [mouse_data+3]
  5467 0000228D 50                  <1> 	push	ax
  5468 0000228E B000                <1> 	mov	al,00h
  5469 00002290 50                  <1> 	push	ax
  5470                              <1> 
  5471                              <1> .do_call:
  5472 00002291 FF1E2200            <1> 	call	far [mouse_driver]
  5473 00002295 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  5474 00002298 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  5475                              <1> 
  5476                              <1> .exit:
  5477 0000229D B020                <1> 	mov	al,20h
  5478 0000229F E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  5479 000022A1 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  5480 000022A3 1F                  <1> 	pop	ds
  5481 000022A4 5B                  <1> 	pop	bx
  5482 000022A5 58                  <1> 	pop	ax
  5483 000022A6 CF                  <1> 	iret
  5484                                  %endif
  5485                                  %include	"sound.inc"		; sound test
  5486                              <1> ;=========================================================================
  5487                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  5488                              <1> ;-------------------------------------------------------------------------
  5489                              <1> ;
  5490                              <1> ; Compiles with NASM 2.07, might work with other versions
  5491                              <1> ;
  5492                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5493                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5494                              <1> ;
  5495                              <1> ; This program is free software: you can redistribute it and/or modify
  5496                              <1> ; it under the terms of the GNU General Public License as published by
  5497                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5498                              <1> ; (at your option) any later version.
  5499                              <1> ;
  5500                              <1> ; This program is distributed in the hope that it will be useful,
  5501                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5502                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5503                              <1> ; GNU General Public License for more details.
  5504                              <1> ;
  5505                              <1> ; You should have received a copy of the GNU General Public License
  5506                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5507                              <1> ;
  5508                              <1> ;=========================================================================
  5509                              <1> 
  5510 000022A7 6908                <1> notes	dw	pic_freq/554		; D flat
  5511 000022A9 FFFF                <1> 	dw	-1			; silent
  5512 000022AB 8814                <1> 	dw	pic_freq/227		; D flat
  5513 000022AD 980C                <1> 	dw	pic_freq/370		; G flat
  5514 000022AF 8814                <1> 	dw	pic_freq/227		; D flat
  5515 000022B1 3B0B                <1> 	dw	pic_freq/415		; A flat
  5516 000022B3 0000                <1> 	dw	0
  5517                              <1> 
  5518                              <1> ;=========================================================================
  5519                              <1> ; sound - Play power-on sound.
  5520                              <1> ; Input:
  5521                              <1> ;	none
  5522                              <1> ; Output:
  5523                              <1> ;	none, destroys some registers
  5524                              <1> ;-------------------------------------------------------------------------
  5525                              <1> sound:
  5526 000022B5 FC                  <1> 	cld
  5527 000022B6 BE[A722]            <1> 	mov	si,notes		; set SI to notes table
  5528                              <1> 
  5529 000022B9 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5530 000022BB E643                <1> 	out	pit_ctl_reg,al
  5531                              <1> 
  5532                              <1> .loop:
  5533 000022BD 2EAD                <1>     cs	lodsw				; load next note to AX
  5534 000022BF 83F800              <1> 	cmp	ax,0
  5535 000022C2 7422                <1> 	jz	.exit
  5536 000022C4 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  5537 000022C6 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5538 000022C8 88E0                <1> 	mov	al,ah
  5539 000022CA E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5540                              <1> 
  5541 000022CC E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5542 000022CE 0C03                <1>         or      al,03h			; turn on the speaker
  5543 000022D0 E661                <1>         out     port_b_reg,al		; write the new value
  5544                              <1> 
  5545                              <1> .silent:
  5546 000022D2 B90030              <1> 	mov	cx,3000h
  5547 000022D5 E8C4EB              <1> 	call	delay_15us		; delay while note is playing
  5548                              <1> 
  5549 000022D8 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5550 000022DA 24FC                <1> 	and	al,0FCh			; turn off the speaker
  5551 000022DC E661                <1>         out     port_b_reg,al		; write the new value
  5552                              <1> 
  5553 000022DE B90001              <1>         mov     cx,0100h
  5554 000022E1 E8B8EB              <1> 	call	delay_15us		; delay after the note
  5555                              <1>         
  5556 000022E4 EBD7                <1>         jmp     .loop			; play the next note
  5557                              <1> .exit:
  5558 000022E6 C3                  <1> 	ret
  5559                              <1> 
  5560                              <1> ;=========================================================================
  5561                              <1> ; beep - Play a beep sound
  5562                              <1> ; Input:
  5563                              <1> ;	BL - duration in 0.1 second
  5564                              <1> ; Output:
  5565                              <1> ;	BL = 0
  5566                              <1> ;-------------------------------------------------------------------------
  5567                              <1> beep:
  5568 000022E7 50                  <1> 	push	ax
  5569 000022E8 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5570 000022EA E643                <1> 	out	pit_ctl_reg,al
  5571 000022EC B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  5572 000022EF E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5573 000022F1 88E0                <1> 	mov	al,ah
  5574 000022F3 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5575 000022F5 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5576 000022F7 0C03                <1> 	or	al,03h			; turn on the speaker
  5577 000022F9 E661                <1> 	out	port_b_reg,al		; write the new value
  5578                              <1> .loop:
  5579 000022FB B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  5580 000022FE E89BEB              <1> 	call	delay_15us
  5581 00002301 FECB                <1> 	dec	bl
  5582 00002303 75F6                <1> 	jnz	.loop
  5583 00002305 3403                <1> 	xor	al,03h			; turn off the speaker
  5584 00002307 E661                <1> 	out	port_b_reg,al		; write the new value
  5585 00002309 58                  <1> 	pop	ax
  5586 0000230A C3                  <1> 	ret
  5587                                  %include	"cpu.inc"		; CPU and FPU detection
  5588                              <1> ;=========================================================================
  5589                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  5590                              <1> ;-------------------------------------------------------------------------
  5591                              <1> ;
  5592                              <1> ; Compiles with NASM 2.07, might work with other versions
  5593                              <1> ;
  5594                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5595                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5596                              <1> ;
  5597                              <1> ; This program is free software: you can redistribute it and/or modify
  5598                              <1> ; it under the terms of the GNU General Public License as published by
  5599                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5600                              <1> ; (at your option) any later version.
  5601                              <1> ;
  5602                              <1> ; This program is distributed in the hope that it will be useful,
  5603                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5604                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5605                              <1> ; GNU General Public License for more details.
  5606                              <1> ;
  5607                              <1> ; You should have received a copy of the GNU General Public License
  5608                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5609                              <1> ;
  5610                              <1> ;=========================================================================
  5611                              <1> 
  5612                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  5613                              <1> 
  5614                              <1> ;=========================================================================
  5615                              <1> ; detect_cpu - detect and print CPU type
  5616                              <1> ; Note:
  5617                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  5618                              <1> ;	  incorrect results if used on other CPU types.
  5619                              <1> ;-------------------------------------------------------------------------
  5620                              <1> detect_cpu:
  5621 0000230B 50                  <1> 	push	ax
  5622 0000230C 56                  <1> 	push	si
  5623 0000230D BE[9600]            <1> 	mov	si,msg_cpu
  5624 00002310 E87D02              <1> 	call	print
  5625                              <1> 
  5626                              <1> ; test for NEC V20
  5627 00002313 B80101              <1> 	mov	ax,0101h
  5628 00002316 D510                <1> 	aad	10h			; NEC V20 ignores the argument
  5629 00002318 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  5630 0000231A 7452                <1> 	je	.nec_v20
  5631                              <1> 
  5632                              <1> ; not NEC V20, test for various 8088 versions
  5633                              <1> .i8088:					; 8088 - NMOS version of 8088
  5634 0000231C FA                  <1> 	cli				; disable interrupts
  5635 0000231D 1E                  <1> 	push	ds
  5636 0000231E 31C0                <1> 	xor	ax,ax
  5637 00002320 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  5638 00002322 B8[9023]            <1> 	mov	ax,.int_01		; new int 01h offset
  5639 00002325 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  5640 00002329 50                  <1> 	push	ax			; save to stack
  5641 0000232A 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  5642 0000232C 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  5643 00002330 50                  <1> 	push	ax			; save to stack
  5644 00002331 9C                  <1> 	pushf				; push flags to stack (save)
  5645 00002332 9C                  <1> 	pushf				; push flags to stack (modify)
  5646 00002333 58                  <1> 	pop	ax			; and move them to AX
  5647 00002334 0D0001              <1> 	or	ax,flags_tf		; set TF
  5648 00002337 50                  <1> 	push	ax
  5649 00002338 31C0                <1> 	xor	ax,ax			; AX = 0
  5650 0000233A 9D                  <1> 	popf				; load modified value to FLAGS register
  5651                              <1> 					; enable single-step
  5652 0000233B 90                  <1> 	nop
  5653 0000233C 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  5654                              <1> 					; after PUSH SREG instructions
  5655                              <1> .push_sreg:				; and will not single-step to here
  5656 0000233D 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  5657                              <1> 					; after modifying segment registers
  5658                              <1> .pop_sreg:				; and will not single-step to here
  5659 0000233E 90                  <1> 	nop
  5660 0000233F 9D                  <1> 	popf				; restore original FLAGS, disable
  5661                              <1> 					; single-step
  5662                              <1> 
  5663 00002340 5E                  <1> 	pop	si			; get original int 01h segment
  5664 00002341 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  5665 00002345 5E                  <1> 	pop	si			; get original int 01h offset
  5666 00002346 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  5667 0000234A 1F                  <1> 	pop	ds
  5668 0000234B FB                  <1> 	sti				; enable interrupts
  5669 0000234C 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  5670 0000234F 740D                <1> 	jz	.i8088_78
  5671                              <1> 
  5672 00002351 83F802              <1> 	cmp	ax,0002h
  5673 00002354 7410                <1> 	jz	.i8088_81
  5674                              <1> 
  5675                              <1> .harris:				; Harris / Intersil 80C88
  5676 00002356 BE[E800]            <1> 	mov	si,msg_cpu_harris
  5677 00002359 E83402              <1> 	call	print
  5678 0000235C EB16                <1> 	jmp	.exit
  5679                              <1> 
  5680                              <1> .i8088_78:
  5681 0000235E BE[B300]            <1> 	mov	si,msg_cpu_8088_78
  5682 00002361 E82C02              <1> 	call	print
  5683 00002364 EB0E                <1> 	jmp	.exit
  5684                              <1> 
  5685                              <1> .i8088_81:
  5686 00002366 BE[CA00]            <1> 	mov	si,msg_cpu_8088_81
  5687 00002369 E82402              <1> 	call	print
  5688 0000236C EB06                <1> 	jmp	.exit
  5689                              <1> 
  5690                              <1> .nec_v20:
  5691 0000236E BE[F500]            <1> 	mov	si,msg_cpu_nec_v20
  5692 00002371 E81C02              <1> 	call	print
  5693                              <1> 
  5694                              <1> .exit:
  5695                              <1> 	;; SGEO do turbo test.
  5696 00002374 BE[1501]            <1> 	mov si, msg_turbo
  5697 00002377 E81602              <1> 	call print
  5698                              <1> 	
  5699 0000237A BE[1F01]            <1> 	mov si, msg_turbo_on
  5700                              <1> 	
  5701 0000237D E461                <1> 	in al, 0x61
  5702 0000237F A804                <1> 	test al,0x4
  5703 00002381 7503                <1> 	jnz .exit1
  5704 00002383 BE[2201]            <1> 	mov si, msg_turbo_off
  5705                              <1> .exit1:
  5706 00002386 E80702              <1> 	call print
  5707                              <1> 	
  5708 00002389 B021                <1> 	mov	al,e_cpu_detect_ok	; CPU detection finished
  5709 0000238B E680                <1> 	out	post_reg,al
  5710                              <1> 
  5711 0000238D 5E                  <1> 	pop	si
  5712 0000238E 58                  <1> 	pop	ax
  5713 0000238F C3                  <1> 	ret
  5714                              <1> 
  5715                              <1> ; stack frame after "push bp"
  5716                              <1> ; BP - word [BP]
  5717                              <1> ; IP - word [BP+2]
  5718                              <1> ; CS - word [BP+4]
  5719                              <1> ; FLAGS - word [BP+6]
  5720                              <1> .int_01:
  5721 00002390 55                  <1> 	push	bp
  5722 00002391 89E5                <1> 	mov	bp,sp
  5723 00002393 817E02[3E23]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  5724 00002398 7504                <1> 	jne	.1
  5725 0000239A B001                <1> 	mov	al,01h			; (C) INTEL '79
  5726 0000239C EB09                <1> 	jmp	.int_01_exit
  5727                              <1> .1:
  5728 0000239E 817E02[3D23]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  5729 000023A3 7502                <1> 	jne	.int_01_exit
  5730 000023A5 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  5731                              <1> .int_01_exit:
  5732 000023A7 5D                  <1> 	pop	bp
  5733 000023A8 CF                  <1> 	iret
  5734                              <1> 
  5735                              <1> ;=========================================================================
  5736                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  5737                              <1> ;-------------------------------------------------------------------------
  5738                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  5739                              <1> detect_fpu:
  5740 000023A9 50                  <1> 	push	ax
  5741 000023AA 51                  <1> 	push	cx
  5742 000023AB 56                  <1> 	push	si
  5743                              <1> 		
  5744 000023AC DBE3                <1> 	fninit				; initialize coprocessor
  5745 000023AE B90300              <1> 	mov	cx,3
  5746                              <1> .wait:
  5747 000023B1 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  5748                              <1> 					;   (can't use fwait, since it could
  5749                              <1> 					;   be no coprocessor at all)
  5750 000023B3 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  5751 000023B7 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  5752 000023BD D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  5753 000023C1 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  5754 000023C7 750D                <1> 	jne	.no_fpu			;   after finit
  5755                              <1> 
  5756                              <1> .fpu:
  5757 000023C9 BE[FD00]            <1> 	mov	si, msg_fpu_present
  5758 000023CC E8C101              <1> 	call	print
  5759 000023CF 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  5760 000023D4 EB06                <1> 	jmp	.exit
  5761                              <1> 
  5762                              <1> .no_fpu:
  5763 000023D6 BE[0A01]            <1> 	mov si, msg_no_fpu
  5764 000023D9 E8B401              <1> 	call	print
  5765                              <1> 
  5766                              <1> .exit:
  5767 000023DC 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  5768                              <1> 
  5769 000023E0 B022                <1> 	mov	al,e_fpu_detect_ok	; FPU detection finished
  5770 000023E2 E680                <1> 	out	post_reg,al
  5771                              <1> 
  5772 000023E4 5E                  <1> 	pop	si
  5773 000023E5 59                  <1> 	pop	cx
  5774 000023E6 58                  <1> 	pop	ax
  5775 000023E7 C3                  <1> 	ret
  5776                                  
  5777                                  %ifdef AT_COMPAT
  5778                                  
  5779                                  ;=========================================================================
  5780                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  5781                                  ;-------------------------------------------------------------------------
  5782                                  int_ignore2:
  5783 000023E8 50                      	push	ax
  5784 000023E9 B020                    	mov	al,20h
  5785 000023EB E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5786 000023ED E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5787 000023EF 58                      	pop	ax
  5788 000023F0 CF                      	iret
  5789                                  
  5790                                  ;=========================================================================
  5791                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  5792                                  ;-------------------------------------------------------------------------
  5793                                  int_71:
  5794 000023F1 50                      	push	ax
  5795 000023F2 B020                    	mov	al,20h
  5796 000023F4 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5797 000023F6 58                      	pop	ax
  5798 000023F7 CD0A                    	int	0Ah		; call IRQ2 ISR
  5799 000023F9 CF                      	iret
  5800                                  
  5801                                  ;=========================================================================
  5802                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  5803                                  ;-------------------------------------------------------------------------
  5804                                  int_75:
  5805 000023FA 50                      	push	ax
  5806 000023FB B020                    	mov	al,20h
  5807 000023FD E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5808 000023FF E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5809 00002401 58                      	pop	ax
  5810 00002402 CD02                    	int	02h		; call NMI ISR
  5811 00002404 CF                      	iret
  5812                                  
  5813                                  %endif ; AT_COMPAT
  5814                                  
  5815                                  ;=========================================================================
  5816                                  ; extension_scan - scan for BIOS extensions
  5817                                  ; Input:
  5818                                  ;	DX - start segment
  5819                                  ;	BX - end segment
  5820                                  ; Returns:
  5821                                  ;	DX - address for the continuation of the scan
  5822                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  5823                                  ;-------------------------------------------------------------------------
  5824                                  extension_scan:
  5825 00002405 C70667000000            	mov	word [67h],0
  5826 0000240B C70669000000            	mov	word [69h],0
  5827                                  .scan:
  5828 00002411 8EC2                    	mov	es,dx
  5829 00002413 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  5830 0000241A 7532                    	jnz	.next			; no signature, check next 2 KiB
  5831 0000241C 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  5832 00002420 B400                    	mov	ah,0
  5833 00002422 B105                    	mov	cl,5
  5834 00002424 D3E0                    	shl	ax,cl			; convert size to paragraphs
  5835 00002426 01C2                    	add	dx,ax
  5836 00002428 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  5837 0000242B 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  5838 0000242E B104                    	mov	cl,4
  5839 00002430 D3E0                    	shl	ax,cl			; convert size to bytes
  5840 00002432 89C1                    	mov	cx,ax
  5841 00002434 B000                    	mov	al,0
  5842 00002436 31F6                    	xor	si,si
  5843                                  .checksum:
  5844 00002438 260204                      es	add	al,byte [si]
  5845 0000243B 46                      	inc	si
  5846 0000243C E2FA                    	loop	.checksum
  5847 0000243E 08C0                    	or	al,al			; AL == 0?
  5848 00002440 750C                    	jnz	.next			; AL not zero - bad checksum
  5849 00002442 C70667000300            	mov	word [67h],3		; extension initialization offset
  5850 00002448 8C066900                	mov	word [69h],es		; extension segment
  5851 0000244C EB08                    	jmp	.exit
  5852                                  .next:
  5853 0000244E 81C28000                	add	dx,80h			; add 2 KiB
  5854 00002452 39DA                    	cmp	dx,bx
  5855 00002454 72BB                    	jb	.scan
  5856                                  .exit:
  5857 00002456 C3                      	ret
  5858                                  
  5859                                  ;=========================================================================
  5860                                  ; ipl - Initial Program Load - try to read and execute boot sector
  5861                                  ;-------------------------------------------------------------------------
  5862                                  ipl:
  5863 00002457 FB                      	sti
  5864 00002458 31C0                    	xor	ax,ax
  5865 0000245A 8ED8                    	mov	ds,ax
  5866 0000245C C7067800[C76F]          	mov	word [78h],int_1E
  5867 00002462 8C0E7A00                	mov	word [7Ah],cs
  5868                                  
  5869                                  .retry:
  5870 00002466 B004                    	mov	al,4			; try booting from floppy 4 times
  5871                                  
  5872                                  .fd_loop:
  5873 00002468 50                      	push	ax
  5874 00002469 B400                    	mov	ah,00h			; reset disk system
  5875 0000246B B200                    	mov	dl,00h			; drive 0
  5876 0000246D CD13                    	int	13h
  5877 0000246F 722C                    	jb	.fd_failed
  5878 00002471 B408                    	mov	ah,08h			; get drive parameters
  5879 00002473 B200                    	mov	dl,00h			; drive 0
  5880 00002475 CD13                    	int	13h
  5881 00002477 7224                    	jc	.fd_failed
  5882 00002479 80FA00                  	cmp	dl,00h
  5883 0000247C 741F                    	jz	.fd_failed		; jump if zero drives
  5884 0000247E B80102                  	mov	ax,0201h		; read one sector
  5885 00002481 31D2                    	xor	dx,dx			; head 0, drive 0
  5886 00002483 8EC2                    	mov	es,dx			; to 0000:7C00
  5887 00002485 BB007C                  	mov	bx,7C00h
  5888 00002488 B90100                  	mov	cx,0001h		; track 0, sector 1
  5889 0000248B CD13                    	int	13h
  5890 0000248D 720E                    	jc	.fd_failed
  5891 0000248F 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5892 00002496 7505                    	jnz	.fd_failed
  5893 00002498 EA007C0000              	jmp	0000h:7C00h
  5894                                  
  5895                                  .fd_failed:
  5896 0000249D 58                      	pop	ax
  5897 0000249E FEC8                    	dec	al
  5898 000024A0 75C6                    	jnz	.fd_loop
  5899                                  
  5900                                  ; try booting from HDD
  5901                                  
  5902 000024A2 B40D                    	mov	ah,0Dh			; reset hard disks
  5903 000024A4 B280                    	mov	dl,80h			; drive 80h
  5904 000024A6 CD13                    	int	13h
  5905 000024A8 7222                    	jc	.hd_failed
  5906 000024AA B80102                  	mov	ax,0201h		; read one sector
  5907 000024AD BA8000                  	mov	dx,0080h		; head 0, drive 80h
  5908 000024B0 31DB                    	xor	bx,bx
  5909 000024B2 8EC3                    	mov	es,bx			; to 0000:7C00
  5910 000024B4 BB007C                  	mov	bx,7C00h
  5911 000024B7 B90100                  	mov	cx,0001h		; track 0, sector 1
  5912 000024BA CD13                    	int	13h
  5913 000024BC 720E                    	jc	.hd_failed
  5914 000024BE 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5915 000024C5 7505                    	jnz	.hd_failed
  5916 000024C7 EA007C0000              	jmp	0000h:7C00h
  5917                                  
  5918                                  .hd_failed:
  5919 000024CC BE[0003]                	mov	si,msg_boot_failed
  5920 000024CF E8BE00                  	call	print
  5921 000024D2 B400                    	mov	ah,00h
  5922 000024D4 CD16                    	int	16h
  5923 000024D6 EB8E                    	jmp	.retry
  5924                                  
  5925                                  ;=========================================================================
  5926                                  ; get_line - read an ASCIIZ string from the console
  5927                                  ; Input:
  5928                                  ;	ES:DI - pointer to the buffer
  5929                                  ;	AX - max string length
  5930                                  ; Output:
  5931                                  ;	AX - string length
  5932                                  ; Notes:
  5933                                  ;	Buffer must have size of max string length + 1 to accomodate 00h
  5934                                  ;-------------------------------------------------------------------------
  5935                                  get_line:
  5936 000024D8 53                      	push	bx
  5937 000024D9 52                      	push	dx
  5938 000024DA 56                      	push	si
  5939 000024DB 57                      	push	di
  5940                                  
  5941 000024DC FC                      	cld
  5942 000024DD 89FE                    	mov	si,di
  5943 000024DF 01C6                    	add	si,ax			; SI = last character position
  5944 000024E1 31D2                    	xor	dx,dx			; DX = 0 - string length
  5945                                  
  5946                                  .read_char_loop:
  5947 000024E3 B400                    	mov	ah,00h			; read character from keyboard
  5948 000024E5 CD16                    	int	16h
  5949                                  
  5950 000024E7 3C08                    	cmp	al,08h			; <Backspace> key
  5951 000024E9 741B                    	jz	.backspace
  5952                                  
  5953 000024EB 3C0D                    	cmp	al,0Dh			; <Enter> key
  5954 000024ED 7441                    	jz	.enter
  5955                                  
  5956 000024EF 3C20                    	cmp	al,20h			; below printable ASCII code?
  5957 000024F1 7233                    	jb	.error_input
  5958                                  
  5959 000024F3 3C7E                    	cmp	al,7Eh			; above printable ASCII code?
  5960 000024F5 772F                    	ja	.error_input
  5961                                  
  5962 000024F7 39F7                    	cmp	di,si			; end of buffer reached?
  5963 000024F9 732B                    	jae	.error_input
  5964                                  
  5965 000024FB AA                      	stosb				; store character in the buffer
  5966 000024FC 42                      	inc	dx			; increment strng length
  5967                                  
  5968 000024FD B40E                    	mov	ah,0Eh			; teletype output (echo)
  5969 000024FF BB0700                  	mov	bx,0007h
  5970 00002502 CD10                    	int	10h
  5971                                  
  5972 00002504 EBDD                    	jmp	.read_char_loop
  5973                                  
  5974                                  .backspace:
  5975 00002506 09D2                    	or	dx,dx			; empty string?
  5976 00002508 741C                    	jz	.error_input
  5977                                  
  5978 0000250A 4F                      	dec	di			; move pointer back
  5979 0000250B 4A                      	dec	dx			; decrement string size
  5980                                  
  5981 0000250C B8080E                  	mov	ax,0E08h		; move the cursor back
  5982 0000250F BB0700                  	mov	bx,0007h
  5983 00002512 CD10                    	int	10h
  5984                                  
  5985 00002514 B8200E                  	mov	ax,0E20h		; erase the character under the cursor
  5986 00002517 BB0700                  	mov	bx,0007h
  5987 0000251A CD10                    	int	10h
  5988                                  
  5989 0000251C B8080E                  	mov	ax,0E08h		; move the cursor back again
  5990 0000251F BB0700                  	mov	bx,0007h
  5991 00002522 CD10                    	int	10h
  5992                                  
  5993 00002524 EBBD                    	jmp	.read_char_loop
  5994                                  
  5995                                  .error_input:
  5996 00002526 B8070E                  	mov	ax,0E07h		; beep
  5997 00002529 BB0700                  	mov	bx,0007h
  5998 0000252C CD10                    	int	10h
  5999                                  
  6000 0000252E EBB3                    	jmp	.read_char_loop
  6001                                  
  6002                                  .enter:
  6003 00002530 B000                    	mov	al,00h			; store 00h at the end of the string
  6004 00002532 AA                      	stosb
  6005                                  
  6006 00002533 B80D0E                  	mov	ax,0E0Dh		; CR
  6007 00002536 BB0700                  	mov	bx,0007h
  6008 00002539 CD10                    	int	10h
  6009                                  
  6010 0000253B B80A0E                  	mov	ax,0E0Ah		; LF
  6011 0000253E BB0700                  	mov	bx,0007h
  6012 00002541 CD10                    	int	10h
  6013                                  
  6014 00002543 89D0                    	mov	ax,dx			; string length to AX
  6015                                  
  6016 00002545 5F                      	pop	di
  6017 00002546 5E                      	pop	si
  6018 00002547 5A                      	pop	dx
  6019 00002548 5B                      	pop	bx
  6020 00002549 C3                      	ret
  6021                                  
  6022                                  ;=========================================================================
  6023                                  ; atoi - convert ASCIIZ string to an 16-bit integer number
  6024                                  ; Input:
  6025                                  ;	ES:DI - pointer to string
  6026                                  ; Output:
  6027                                  ;	AX - number
  6028                                  ; 	ES:DI - pointer moved to the position following the number
  6029                                  ;-------------------------------------------------------------------------
  6030                                  atoi:
  6031 0000254A 53                      	push	bx
  6032 0000254B 51                      	push	cx
  6033 0000254C 52                      	push	dx
  6034                                  
  6035 0000254D 31C0                    	xor	ax,ax			; zero the result
  6036 0000254F BB0A00                  	mov	bx,10			; multiplier
  6037                                  
  6038                                  .atoi_loop:
  6039 00002552 268A0D                      es	mov	cl,byte [di]
  6040                                  
  6041 00002555 80F930                  	cmp	cl,'0'			; ASCII code below '0'
  6042 00002558 7211                    	jb	.exit
  6043                                  
  6044 0000255A 80F939                  	cmp	cl,'9'			; ASCII code above '9'
  6045 0000255D 770C                    	ja	.exit
  6046                                  
  6047 0000255F 47                      	inc	di			; move to the next character
  6048                                  
  6049 00002560 80E930                  	sub	cl,'0'			; convert to ASCII to binary
  6050                                  
  6051 00002563 F7E3                    	mul	bx			; DX:AX = AX * 10
  6052 00002565 B500                    	mov	ch,0
  6053 00002567 01C8                    	add	ax,cx			; AX = AX + CX
  6054                                  
  6055 00002569 EBE7                    	jmp	.atoi_loop
  6056                                  
  6057                                  .exit:
  6058 0000256B 5A                      	pop	dx
  6059 0000256C 59                      	pop	cx
  6060 0000256D 5B                      	pop	bx
  6061 0000256E C3                      	ret
  6062                                  
  6063                                  ;=========================================================================
  6064                                  ; bin_to_bcd - convert binary number to a packed BCD
  6065                                  ; Input:
  6066                                  ;	AX - binary number
  6067                                  ; Output:
  6068                                  ;	AX - packed BCD number
  6069                                  ;-------------------------------------------------------------------------
  6070                                  bin_to_bcd:
  6071 0000256F 53                      	push	bx
  6072 00002570 51                      	push	cx
  6073 00002571 52                      	push	dx
  6074 00002572 56                      	push	si
  6075                                  
  6076 00002573 B100                    	mov	cl,0			; shift amount
  6077 00002575 31F6                    	xor	si,si			; zero result
  6078 00002577 BB0A00                  	mov	bx,10			; BX - divisor
  6079                                  
  6080                                  .bin_to_bcd_loop:
  6081 0000257A 31D2                    	xor	dx,dx			; DX - zero for 32-bit div operand
  6082 0000257C F7F3                    	div	bx
  6083                                  
  6084 0000257E D3E2                    	shl	dx,cl			; shift digit to the required position
  6085 00002580 80C104                  	add	cl,4			; calculate next position
  6086                                  
  6087 00002583 01D6                    	add	si,dx			; add reminder to the result
  6088 00002585 09C0                    	or	ax,ax			; quotient is zero?
  6089 00002587 75F1                    	jnz	.bin_to_bcd_loop
  6090                                  
  6091 00002589 89F0                    	mov	ax,si			; result to AX
  6092                                  
  6093 0000258B 5E                      	pop	si
  6094 0000258C 5A                      	pop	dx
  6095 0000258D 59                      	pop	cx
  6096 0000258E 5B                      	pop	bx
  6097 0000258F C3                      	ret
  6098                                  
  6099                                  
  6100                                  ;=========================================================================
  6101                                  ; print - print ASCIIZ string to the console
  6102                                  ; Input:
  6103                                  ;	CS:SI - pointer to string to print
  6104                                  ; Output:
  6105                                  ;	none
  6106                                  ;-------------------------------------------------------------------------
  6107                                  print:
  6108 00002590 9C                      	pushf
  6109 00002591 50                      	push	ax
  6110 00002592 53                      	push	bx
  6111 00002593 56                      	push	si
  6112 00002594 1E                      	push	ds
  6113 00002595 0E                      	push	cs
  6114 00002596 1F                      	pop	ds
  6115 00002597 FC                      	cld
  6116                                  .1:
  6117 00002598 AC                      	lodsb
  6118 00002599 08C0                    	or	al,al
  6119 0000259B 7408                    	jz	.exit
  6120 0000259D B40E                    	mov	ah,0Eh
  6121 0000259F B30F                    	mov	bl,0Fh
  6122 000025A1 CD10                    	int	10h
  6123 000025A3 EBF3                    	jmp	.1
  6124                                  .exit:
  6125 000025A5 1F                      	pop	ds
  6126 000025A6 5E                      	pop	si
  6127 000025A7 5B                      	pop	bx
  6128 000025A8 58                      	pop	ax
  6129 000025A9 9D                      	popf
  6130 000025AA C3                      	ret
  6131                                  
  6132                                  ;=========================================================================
  6133                                  ; print_hex - print 16-bit number in hexadecimal
  6134                                  ; Input:
  6135                                  ;	AX - number to print
  6136                                  ; Output:
  6137                                  ;	none
  6138                                  ;-------------------------------------------------------------------------
  6139                                  print_hex:
  6140 000025AB 86C4                    	xchg	al,ah
  6141 000025AD E80600                  	call	print_byte		; print the upper byte
  6142 000025B0 86C4                    	xchg	al,ah
  6143 000025B2 E80100                  	call	print_byte		; print the lower byte
  6144 000025B5 C3                      	ret
  6145                                  
  6146                                  ;=========================================================================
  6147                                  ; print_byte - print a byte in hexadecimal
  6148                                  ; Input:
  6149                                  ;	AL - byte to print
  6150                                  ; Output:
  6151                                  ;	none
  6152                                  ;-------------------------------------------------------------------------
  6153                                  print_byte:
  6154 000025B6 D0C0                    	rol	al,1
  6155 000025B8 D0C0                    	rol	al,1
  6156 000025BA D0C0                    	rol	al,1
  6157 000025BC D0C0                    	rol	al,1
  6158 000025BE E82D00                  	call	print_digit
  6159 000025C1 D0C0                    	rol	al,1
  6160 000025C3 D0C0                    	rol	al,1
  6161 000025C5 D0C0                    	rol	al,1
  6162 000025C7 D0C0                    	rol	al,1
  6163 000025C9 E82200                  	call	print_digit
  6164 000025CC C3                      	ret
  6165                                  
  6166                                  ;=========================================================================
  6167                                  ; print_dec - print 16-bit number in decimal
  6168                                  ; Input:
  6169                                  ;	AX - number to print
  6170                                  ; Output:
  6171                                  ;	none
  6172                                  ;-------------------------------------------------------------------------
  6173                                  print_dec:
  6174 000025CD 50                      	push	ax
  6175 000025CE 51                      	push	cx
  6176 000025CF 52                      	push	dx
  6177 000025D0 B90A00                  	mov	cx,10		; base = 10
  6178 000025D3 E80400                  	call	.print_rec
  6179 000025D6 5A                      	pop	dx
  6180 000025D7 59                      	pop	cx
  6181 000025D8 58                      	pop	ax
  6182 000025D9 C3                      	ret
  6183                                  
  6184                                  .print_rec:			; print all digits recursively
  6185 000025DA 52                      	push	dx
  6186 000025DB 31D2                    	xor	dx,dx		; DX = 0
  6187 000025DD F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  6188 000025DF 83F800                  	cmp	ax,0
  6189 000025E2 7403                    	je	.below10
  6190 000025E4 E8F3FF                  	call	.print_rec	; print number / 10 recursively
  6191                                  .below10:
  6192 000025E7 89D0                    	mov	ax,dx		; reminder is in DX
  6193 000025E9 E80200                  	call	print_digit	; print reminder
  6194 000025EC 5A                      	pop	dx
  6195 000025ED C3                      	ret
  6196                                  
  6197                                  ;=========================================================================
  6198                                  ; print_digit - print hexadecimal digit
  6199                                  ; Input:
  6200                                  ;	AL - bits 3...0 - digit to print (0...F)
  6201                                  ; Output:
  6202                                  ;	none
  6203                                  ;-------------------------------------------------------------------------
  6204                                  print_digit:
  6205 000025EE 50                      	push	ax
  6206 000025EF 53                      	push	bx
  6207 000025F0 240F                    	and	al,0Fh
  6208 000025F2 0430                    	add	al,'0'			; convert to ASCII
  6209 000025F4 3C39                    	cmp	al,'9'			; less or equal 9?
  6210 000025F6 7602                    	jna	.1
  6211 000025F8 0407                    	add	al,'A'-'9'-1		; a hex digit
  6212                                  .1:
  6213 000025FA B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  6214 000025FC B307                    	mov	bl,07h			; just in case we're in graphic mode
  6215 000025FE CD10                    	int	10h
  6216 00002600 5B                      	pop	bx
  6217 00002601 58                      	pop	ax
  6218 00002602 C3                      	ret
  6219                                  
  6220                                  ;=========================================================================
  6221                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  6222                                  ; Input:
  6223                                  ;	AX = memory size in KiB
  6224                                  ; Notes:
  6225                                  ;	- Assumes that EBDA memory was cleaned
  6226                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  6227                                  ;-------------------------------------------------------------------------
  6228                                  reserve_ebda:
  6229                                  %ifdef PS2_MOUSE
  6230 00002603 50                      	push	ax
  6231 00002604 51                      	push	cx
  6232 00002605 F70610000400            	test	word [equipment_list],equip_mouse
  6233 0000260B 742B                    	jz	.no_mouse
  6234 0000260D A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  6235 00002610 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  6236 00002613 A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  6237 00002616 B106                    	mov	cl,6
  6238 00002618 D3E0                    	shl	ax,cl			; convert to segment
  6239 0000261A A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  6240 0000261D 1E                      	push	ds
  6241 0000261E 8ED8                    	mov	ds,ax
  6242 00002620 B80100                  	mov	ax,EBDA_SIZE
  6243 00002623 A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  6244 00002626 1F                      	pop	ds
  6245 00002627 56                      	push	si
  6246 00002628 BE[DF02]                	mov	si,msg_ebda
  6247 0000262B E862FF                  	call	print
  6248 0000262E E89CFF                  	call	print_dec
  6249 00002631 BE[F602]                	mov	si,msg_kibx
  6250 00002634 E859FF                  	call	print
  6251 00002637 5E                      	pop	si
  6252                                  .no_mouse:
  6253 00002638 59                      	pop	cx
  6254 00002639 58                      	pop	ax
  6255                                  %endif ; PS2_MOUSE
  6256 0000263A C3                      	ret
  6257                                  
  6258                                  ;=========================================================================
  6259                                  ; detect_ram - Determine the size of installed RAM and test it
  6260                                  ; Input:
  6261                                  ;	none
  6262                                  ; Output:
  6263                                  ;	AX = RAM size
  6264                                  ;	CX, SI - trashed
  6265                                  ;-------------------------------------------------------------------------
  6266                                  detect_ram:
  6267 0000263B B030                    	mov	al,e_ram_start		; RAM scan start
  6268 0000263D E680                    	out	post_reg,al
  6269                                  
  6270 0000263F 1E                      	push	ds
  6271 00002640 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  6272 00002642 B82000                  	mov	ax,MIN_RAM_SIZE
  6273                                  
  6274                                  .fill_loop:
  6275 00002645 50                      	push	ax
  6276 00002646 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6277 00002648 8ED8                    	mov	ds,ax
  6278 0000264A A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  6279 0000264D 58                      	pop	ax
  6280 0000264E 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6281 00002651 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6282 00002654 75EF                    	jne	.fill_loop
  6283 00002656 B82000                  	mov	ax,MIN_RAM_SIZE
  6284                                  
  6285                                  .size_loop:
  6286 00002659 50                      	push	ax
  6287 0000265A D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6288 0000265C 8ED8                    	mov	ds,ax
  6289 0000265E 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  6290 00002662 750B                    	jne	.size_done
  6291 00002664 58                      	pop	ax
  6292 00002665 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6293 00002668 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6294 0000266B 7303                    	jnb	.size_exit
  6295 0000266D EBEA                    	jmp	.size_loop
  6296                                  
  6297                                  .size_done:
  6298 0000266F 58                      	pop	ax
  6299                                  
  6300                                  .size_exit:
  6301 00002670 1F                      	pop	ds
  6302 00002671 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  6303                                  
  6304                                  ; AX = detected memory size, now test the RAM
  6305                                  
  6306 00002674 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  6307 0000267A 7474                    	je	.test_done
  6308                                  
  6309 0000267C BE[8002]                	mov	si,msg_ram_testing
  6310 0000267F E80EFF                  	call	print
  6311 00002682 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  6312                                  
  6313                                  .test_loop:
  6314 00002685 50                      	push	ax
  6315 00002686 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  6316 00002688 B700                    	mov	bh,00h			; page 0
  6317 0000268A CD10                    	int	10h			; position returned in DX
  6318 0000268C 58                      	pop	ax
  6319 0000268D E83DFF                  	call	print_dec
  6320 00002690 50                      	push	ax
  6321 00002691 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  6322 00002693 B700                    	mov	bh,00h			; page 0
  6323 00002695 CD10                    	int	10h
  6324 00002697 B401                    	mov	ah,01h
  6325 00002699 CD16                    	int	16h
  6326 0000269B 7412                    	jz	.test_no_key
  6327 0000269D B400                    	mov	ah,00h
  6328 0000269F CD16                    	int	16h			; read the keystroke
  6329 000026A1 3C1B                    	cmp	al,1Bh			; ESC?
  6330 000026A3 7421                    	je	.test_esc
  6331 000026A5 3D003B                  	cmp	ax,3B00h		; F1?
  6332 000026A8 7505                    	jne	.test_no_key
  6333 000026AA 800E120001              	or	byte [post_flags],post_setup
  6334                                  
  6335                                  .test_no_key:
  6336 000026AF 58                      	pop	ax
  6337 000026B0 E83E00                  	call	ram_test_block
  6338 000026B3 721D                    	jc	.test_error		; error in last test
  6339 000026B5 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  6340 000026B8 3B061300                	cmp	ax,word [memory_size]
  6341 000026BC 72C7                    	jb	.test_loop
  6342                                  
  6343 000026BE 50                      	push	ax
  6344 000026BF B031                    	mov	al,e_ram_complete	; RAM scan complete
  6345 000026C1 E680                    	out	post_reg,al
  6346 000026C3 58                      	pop	ax
  6347                                  
  6348 000026C4 EB2A                    	jmp	.test_done
  6349                                  
  6350                                  .test_esc:
  6351 000026C6 58                      	pop	ax
  6352 000026C7 A11300                  	mov	ax,word [memory_size]
  6353                                  
  6354 000026CA 50                      	push	ax
  6355 000026CB B032                    	mov	al,e_ram_esc		; RAM scan canceled
  6356 000026CD E680                    	out	post_reg,al
  6357 000026CF 58                      	pop	ax
  6358                                  
  6359 000026D0 EB1E                    	jmp	.test_done
  6360                                  
  6361                                  .test_error:
  6362 000026D2 A31300                  	mov	word [memory_size],ax	; store size of good memory
  6363 000026D5 BE[9D02]                	mov	si,msg_ram_error
  6364 000026D8 E8B5FE                  	call	print
  6365 000026DB E8EFFE                  	call	print_dec
  6366 000026DE BE[FA02]                	mov	si,msg_kib
  6367 000026E1 E8ACFE                  	call	print
  6368 000026E4 BE[8800]                	mov	si,msg_crlf
  6369 000026E7 E8A6FE                  	call	print
  6370                                  
  6371 000026EA 50                      	push	ax
  6372 000026EB B080                    	mov	al,e_ram_fail		; RAM scan failed
  6373 000026ED E680                    	out	post_reg,al
  6374 000026EF 58                      	pop	ax
  6375                                  
  6376                                  .test_done:
  6377 000026F0 C3                      	ret
  6378                                  
  6379                                  ;=========================================================================
  6380                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  6381                                  ; Input:
  6382                                  ;	AX = address of the memory to test (in KiB)
  6383                                  ; Output:
  6384                                  ;	CF = status
  6385                                  ;		0 = passed
  6386                                  ;		1 = failed
  6387                                  ;-------------------------------------------------------------------------
  6388                                  ram_test_block:
  6389 000026F1 50                      	push	ax
  6390 000026F2 53                      	push	bx
  6391 000026F3 51                      	push	cx
  6392 000026F4 56                      	push	si
  6393 000026F5 57                      	push	di
  6394 000026F6 1E                      	push	ds
  6395 000026F7 06                      	push	es
  6396 000026F8 B106                    	mov	cl,6			; convert KiB to segment address
  6397 000026FA D3E0                    	shl	ax,cl			; (multiply by 64)
  6398 000026FC 8ED8                    	mov	ds,ax
  6399 000026FE 8EC0                    	mov	es,ax
  6400 00002700 31F6                    	xor	si,si
  6401 00002702 31FF                    	xor	di,di
  6402 00002704 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  6403 00002707 B8AA55                  	mov	ax,55AAh		; first test pattern
  6404 0000270A 89D9                    	mov	cx,bx
  6405 0000270C F3AB                        rep	stosw				; store test pattern
  6406 0000270E 89D9                    	mov	cx,bx			; RAM test block size
  6407                                  .1:
  6408 00002710 AD                      	lodsw
  6409 00002711 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6410 00002714 7522                    	jne	.fail
  6411 00002716 E2F8                    	loop	.1
  6412 00002718 31F6                    	xor	si,si
  6413 0000271A 31FF                    	xor	di,di
  6414 0000271C B855AA                  	mov	ax,0AA55h		; second test pattern
  6415 0000271F 89D9                    	mov	cx,bx			; RAM test block size
  6416 00002721 F3AB                        rep stosw				; store test pattern
  6417 00002723 89D9                    	mov	cx,bx			; RAM test block size
  6418                                  .2:
  6419 00002725 AD                      	lodsw
  6420 00002726 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6421 00002729 750D                    	jne	.fail
  6422 0000272B E2F8                    	loop	.2
  6423 0000272D 31FF                    	xor	di,di
  6424 0000272F 31C0                    	xor	ax,ax			; zero
  6425 00002731 89D9                    	mov	cx,bx			; RAM test block size
  6426 00002733 F3AB                        rep stosw				; zero the memory
  6427 00002735 F8                      	clc				; test passed, clear CF
  6428 00002736 EB01                    	jmp	.exit
  6429                                  
  6430                                  .fail:
  6431 00002738 F9                      	stc				; test failed, set CF
  6432                                  
  6433                                  .exit:
  6434 00002739 07                      	pop	es
  6435 0000273A 1F                      	pop	ds
  6436 0000273B 5F                      	pop	di
  6437 0000273C 5E                      	pop	si
  6438 0000273D 59                      	pop	cx
  6439 0000273E 5B                      	pop	bx
  6440 0000273F 58                      	pop	ax
  6441 00002740 C3                      	ret
  6442                                  
  6443                                  ;=========================================================================
  6444                                  ; print display type
  6445                                  ;-------------------------------------------------------------------------
  6446                                  print_display:
  6447 00002741 BE[2601]                	mov	si,msg_disp
  6448 00002744 E849FE                  	call	print
  6449 00002747 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  6450 0000274A 2430                    	and	al,equip_video		; get video adapter type
  6451 0000274C BE[6801]                	mov	si,msg_disp_mda
  6452 0000274F 3C30                    	cmp	al,equip_mono		; monochrome?
  6453 00002751 740A                    	jz	.print_disp
  6454 00002753 BE[6201]                	mov	si,msg_disp_cga
  6455 00002756 3C20                    	cmp	al,equip_color		; CGA?
  6456 00002758 7403                    	jz	.print_disp
  6457 0000275A BE[4301]                	mov	si,msg_disp_ega		; otherwise EGA or later
  6458                                  .print_disp:
  6459 0000275D E830FE                  	call	print
  6460 00002760 C3                      	ret
  6461                                  
  6462                                  ;=========================================================================
  6463                                  ; print PS/2 mouse presence
  6464                                  ;-------------------------------------------------------------------------
  6465                                  
  6466                                  print_mouse:
  6467 00002761 BE[0E02]                	mov	si,msg_mouse
  6468 00002764 E829FE                  	call	print
  6469 00002767 BE[3502]                	mov	si,msg_absent
  6470 0000276A F606100004              	test	byte [equipment_list],equip_mouse
  6471 0000276F 7403                    	jz	.print_mouse
  6472 00002771 BE[2B02]                	mov	si,msg_present
  6473                                  .print_mouse:
  6474 00002774 E819FE                  	call	print
  6475 00002777 C3                      	ret
  6476                                  
  6477                                  ;=========================================================================
  6478                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  6479                                  ;-------------------------------------------------------------------------
  6480                                  
  6481                                  detect_rom_ext:
  6482 00002778 B040                    	mov	al,e_ext_start		; ROM extension scan start
  6483 0000277A E680                    	out	post_reg,al
  6484                                  
  6485 0000277C BA00C8                  	mov	dx,0C800h
  6486 0000277F BB00F8                  	mov	bx,0F800h
  6487                                  
  6488                                  .ext_scan_loop:
  6489 00002782 E880FC                  	call	extension_scan
  6490 00002785 833E670000              	cmp	word [67h],0
  6491 0000278A 7429                    	jz	.ext_scan_done		; No ROM extension found
  6492 0000278C B041                    	mov	al,e_ext_detect		; ROM extension found
  6493 0000278E E680                    	out	post_reg,al
  6494 00002790 BE[3C03]                	mov	si,msg_rom_found
  6495 00002793 E8FAFD                  	call	print
  6496 00002796 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  6497 00002799 E80FFE                  	call	print_hex
  6498 0000279C BE[5903]                	mov	si,msg_rom_init
  6499 0000279F E8EEFD                  	call	print
  6500 000027A2 53                      	push	bx
  6501 000027A3 52                      	push	dx
  6502 000027A4 FF1E6700                	call	far [67h]
  6503 000027A8 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6504 000027AB 8ED8                    	mov	ds,ax
  6505 000027AD B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  6506 000027AF E680                    	out	post_reg,al
  6507 000027B1 5A                      	pop	dx
  6508 000027B2 5B                      	pop	bx
  6509 000027B3 EBCD                    	jmp	.ext_scan_loop
  6510                                  
  6511                                  .ext_scan_done:
  6512 000027B5 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  6513 000027B7 E680                    	out	post_reg,al
  6514                                  
  6515 000027B9 C3                      	ret
  6516                                  
  6517                                  ;=========================================================================
  6518                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  6519                                  ;-------------------------------------------------------------------------
  6520                                  interrupt_table:
  6521 000027BA [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
  6522 000027BC [537F]                  	dw	int_dummy		; INT 01 - Single step
  6523 000027BE [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  6524 000027C0 [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  6525 000027C2 [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  6526 000027C4 [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
  6527 000027C6 [537F]                  	dw	int_dummy		; INT 06
  6528 000027C8 [537F]                  	dw	int_dummy		; INT 07
  6529 000027CA [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  6530 000027CC [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  6531 000027CE [237F]                  	dw	int_ignore		; INT 0A - IRQ2
  6532 000027D0 [237F]                  	dw	int_ignore		; INT 0B - IRQ3
  6533 000027D2 [237F]                  	dw	int_ignore		; INT 0C - IRQ4
  6534 000027D4 [237F]                  	dw	int_ignore		; INT 0D - IRQ5
  6535 000027D6 [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  6536 000027D8 [237F]                  	dw	int_ignore		; INT 0F - IRQ7
  6537 000027DA [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
  6538 000027DC [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  6539 000027DE [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  6540 000027E0 [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  6541 000027E2 [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  6542 000027E4 [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  6543 000027E6 [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  6544 000027E8 [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  6545 000027EA [4D63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  6546 000027EC [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  6547 000027EE [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
  6548 000027F0 [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  6549 000027F2 [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
  6550 000027F4 [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
  6551 000027F6 [C76F]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  6552 000027F8 [9706]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  6553                                  
  6554                                  %ifdef AT_COMPAT
  6555                                  interrupt_table2:
  6556 000027FA [2010]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  6557 000027FC [F123]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  6558 000027FE [E823]                  	dw	int_ignore2		; INT 72 - IRQ10
  6559 00002800 [E823]                  	dw	int_ignore2		; INT 73 - IRQ11
  6560                                  %ifndef PS2_MOUSE
  6561                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  6562                                  %else
  6563 00002802 [2622]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  6564                                  %endif
  6565 00002804 [FA23]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  6566 00002806 [E823]                  	dw	int_ignore2		; INT 76 - IRQ14
  6567 00002808 [E823]                  	dw	int_ignore2		; INT 77 - IRQ15
  6568                                  %endif ; AT_COMPAT
  6569                                  
  6570                                  
  6571                                  %include	"tandy.inc"
  6572                              <1> ; Tandy.inc - Tandy byte id
  6573                              <1> ;
  6574                              <1> ; Compiles with NASM 2.07, might work with other versions
  6575                              <1> ;
  6576                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  6577                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  6578                              <1> ;
  6579                              <1> ; This program is free software: you can redistribute it and/or modify
  6580                              <1> ; it under the terms of the GNU General Public License as published by
  6581                              <1> ; the Free Software Foundation, either version 3 of the License, or
  6582                              <1> ; (at your option) any later version.
  6583                              <1> ;
  6584                              <1> ; This program is distributed in the hope that it will be useful,
  6585                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6586                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6587                              <1> ; GNU General Public License for more details.
  6588                              <1> ;
  6589                              <1> ; You should have received a copy of the GNU General Public License
  6590                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  6591                              <1> ;
  6592                              <1> ;=========================================================================
  6593                              <1> 
  6594                              <1> %ifdef TANDY_ID
  6595                              <1> 	setloc	0xC000
  6596                              <1> 	db '!BIOS ROM version 01.03.00',0x0D, 0x0A, 0x00
  6597                              <1> 	db 'Compatibility Software',0x0D, 0x0A, 0x00
  6598                              <1> 	db 'Copyright (C) 1984,1985,1986,1987',0x0D, 0x0A, 0x00
  6599                              <1> 	db 'Phoenix Software Associates Ltd.',0x0D, 0x0A, 0x00
  6600                              <1> 	db 'and Tandy Corporation.',0x0D, 0x0A, 0x00
  6601                              <1> 	db 'All rights reserved.',0x0D, 0x0A, 0x00
  6602                              <1> 	db '$'
  6603                              <1> %endif
  6604                              <1> 
  6605                                  
  6606                                  ;=========================================================================
  6607                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  6608                                  ;-------------------------------------------------------------------------
  6609 0000280A FF<rept>                	setloc	0E05Bh		; POST Entry Point
  6610          ******************       warning: (setloc:7) Inserting 14417 bytes
  6611                                  cold_start:
  6612 0000605B B84000                  	mov	ax,biosdseg
  6613 0000605E 8ED8                    	mov	ds,ax
  6614 00006060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  6615                                  
  6616                                  warm_start:
  6617 00006066 FA                      	cli				; disable interrupts
  6618 00006067 FC                      	cld				; clear direction flag
  6619 00006068 B001                    	mov	al,e_start
  6620 0000606A E680                    	out	post_reg,al		; POST start code
  6621                                  
  6622                                  ;-------------------------------------------------------------------------
  6623                                  ; test CPU's FLAG register
  6624                                  
  6625 0000606C 31C0                    	xor	ax,ax			; AX = 0
  6626 0000606E 724A                    	jb	cpu_fail
  6627 00006070 7048                    	jo	cpu_fail
  6628 00006072 7846                    	js	cpu_fail
  6629 00006074 7544                    	jnz	cpu_fail
  6630 00006076 7B42                    	jpo	cpu_fail
  6631 00006078 83C001                  	add	ax,1			; AX = 1
  6632 0000607B 743D                    	jz	cpu_fail
  6633 0000607D 7A3B                    	jpe	cpu_fail
  6634 0000607F 2D0280                  	sub	ax,8002h
  6635 00006082 7836                    	js	cpu_fail
  6636 00006084 40                      	inc	ax
  6637 00006085 7133                    	jno	cpu_fail
  6638 00006087 D1E0                    	shl	ax,1
  6639 00006089 732F                    	jnb	cpu_fail
  6640 0000608B 752D                    	jnz	cpu_fail
  6641 0000608D D1E0                    	shl	ax,1
  6642 0000608F 7229                    	jb	cpu_fail
  6643                                  
  6644                                  ;-------------------------------------------------------------------------
  6645                                  ; Test CPU registers
  6646                                  
  6647 00006091 B8AAAA                  	mov	ax,0AAAAh
  6648                                  .1:
  6649 00006094 8ED8                    	mov	ds,ax
  6650 00006096 8CDB                    	mov	bx,ds
  6651 00006098 8EC3                    	mov	es,bx
  6652 0000609A 8CC1                    	mov	cx,es
  6653 0000609C 8ED1                    	mov	ss,cx
  6654 0000609E 8CD2                    	mov	dx,ss
  6655 000060A0 89D5                    	mov	bp,dx
  6656 000060A2 89EC                    	mov	sp,bp
  6657 000060A4 89E6                    	mov	si,sp
  6658 000060A6 89F7                    	mov	di,si
  6659 000060A8 81FFAAAA                	cmp	di,0AAAAh
  6660 000060AC 7506                    	jnz	.2
  6661 000060AE 89F8                    	mov	ax,di
  6662 000060B0 F7D0                    	not	ax
  6663 000060B2 EBE0                    	jmp	.1
  6664                                  .2:
  6665 000060B4 81FF5555                	cmp	di,5555h
  6666 000060B8 741A                    	jz	cpu_ok
  6667                                  
  6668                                  cpu_fail:
  6669 000060BA B052                    	mov	al,e_cpu_fail
  6670 000060BC E680                    	out	post_reg,al
  6671                                  
  6672                                  ;-------------------------------------------------------------------------
  6673                                  ; CPU error: continious beep - 400 Hz
  6674                                  
  6675 000060BE B0B6                    	mov	al,0B6h
  6676 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6677 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6678 000060C5 E642                    	out	pit_ch2_reg,al
  6679 000060C7 88E0                    	mov	al,ah
  6680 000060C9 E642                    	out	pit_ch2_reg,al
  6681 000060CB E461                    	in	al,port_b_reg
  6682 000060CD 0C03                    	or	al,3			; turn speaker on and enable
  6683 000060CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6684                                  
  6685                                  .1:
  6686 000060D1 F4                      	hlt
  6687 000060D2 EBFD                    	jmp	.1
  6688                                  
  6689                                  ;-------------------------------------------------------------------------
  6690                                  ; CPU test passed
  6691                                  
  6692                                  cpu_ok:
  6693 000060D4 B002                    	mov	al,e_cpu_ok
  6694 000060D6 E680                    	out	post_reg,al
  6695                                  
  6696                                  ;-------------------------------------------------------------------------
  6697                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  6698                                  
  6699 000060D8 B00D                    	mov	al,0Dh & nmi_disable
  6700 000060DA E670                    	out	rtc_addr_reg,al		; disable NMI
  6701 000060DC EB00                    	jmp	$+2
  6702 000060DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  6703                                  
  6704 000060E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  6705 000060E2 E661                    	out	port_b_reg,al
  6706 000060E4 B000                    	mov	al,00h			; clear turbo bit
  6707 000060E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  6708                                  
  6709 000060E8 BAD803                  	mov	dx,cga_mode_reg
  6710 000060EB EE                      	out	dx,al			; disable video output on CGA
  6711 000060EC FEC0                    	inc	al
  6712 000060EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  6713 000060F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  6714                                  
  6715                                  ;-------------------------------------------------------------------------
  6716                                  ; Initialize DMAC (8237)
  6717                                  
  6718 000060F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  6719 000060F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  6720 000060F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6721 000060F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  6722 000060FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6723 000060FC B042                     	mov	al,42h			; single mode, verify, channel 2
  6724 000060FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6725 00006100 B043                     	mov	al,43h			; single mode, verify, channel 3
  6726 00006102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6727 00006104 B000                     	mov	al,0			; DMA Command register bits:
  6728                                   					; DACK active low, DREQ active high,
  6729                                   					; late write, fixed priority,
  6730                                   					; normal timing, controller enable
  6731                                   					; channel 0 addr hold disable
  6732                                   					; memory to memory disable
  6733 00006106 E608                     	out	08h,al			; DMA Command register
  6734 00006108 E681                     	out	81h,al			; DMA Page, channel 2
  6735 0000610A E682                     	out	82h,al			; DMA Page, channel 3
  6736 0000610C E683                     	out	83h,al			; DMA Page, channels 0,1
  6737 0000610E B003                    	mov	al,e_dmac_ok
  6738 00006110 E680                    	out	post_reg,al
  6739                                  
  6740                                  ;-------------------------------------------------------------------------
  6741                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  6742                                  
  6743                                  low_ram_test:
  6744 00006112 31F6                    	xor	si,si
  6745 00006114 31FF                    	xor	di,di
  6746 00006116 8EDF                    	mov	ds,di
  6747 00006118 8EC7                    	mov	es,di
  6748 0000611A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  6749 0000611E B8AA55                  	mov	ax,55AAh		; first test pattern
  6750 00006121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6751 00006124 F3AB                        rep	stosw				; store test pattern
  6752 00006126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6753                                  .1:
  6754 00006129 AD                      	lodsw
  6755 0000612A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6756 0000612D 7524                    	jne	low_ram_fail
  6757 0000612F E2F8                    	loop	.1
  6758 00006131 31F6                    	xor	si,si
  6759 00006133 31FF                    	xor	di,di
  6760 00006135 B855AA                  	mov	ax,0AA55h		; second test pattern
  6761 00006138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6762 0000613B F3AB                        rep stosw				; store test pattern
  6763 0000613D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6764                                  .2:
  6765 00006140 AD                      	lodsw
  6766 00006141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6767 00006144 750D                    	jne	low_ram_fail
  6768 00006146 E2F8                    	loop	.2
  6769 00006148 31FF                    	xor	di,di
  6770 0000614A 31C0                    	xor	ax,ax			; zero
  6771 0000614C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6772 0000614F F3AB                        rep stosw				; zero the memory
  6773 00006151 EB29                    	jmp	low_ram_ok		; test passed
  6774                                  
  6775                                  low_ram_fail:
  6776 00006153 B054                    	mov	al,e_low_ram_fail	; test failed
  6777 00006155 E680                    	out	post_reg,al
  6778                                  
  6779                                  ;-------------------------------------------------------------------------
  6780                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  6781                                  
  6782 00006157 B0B6                    	mov	al,0B6h
  6783 00006159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6784 0000615B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6785 0000615E E642                    	out	pit_ch2_reg,al
  6786 00006160 88E0                    	mov	al,ah
  6787 00006162 E642                    	out	pit_ch2_reg,al
  6788 00006164 E461                    	in	al,port_b_reg
  6789                                  .1:
  6790 00006166 0C03                    	or	al,3			; turn speaker on and enable
  6791 00006168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6792 0000616A B90000                  	mov	cx,0
  6793                                  .2:
  6794 0000616D 90                      	nop
  6795 0000616E E2FD                    	loop	.2
  6796 00006170 24FC                    	and	al,0FCh			; turn of speaker
  6797 00006172 E661                    	out	port_b_reg,al
  6798 00006174 B90000                  	mov	cx,0
  6799                                  .3:
  6800 00006177 90                      	nop
  6801 00006178 E2FD                    	loop	.3
  6802 0000617A EBEA                    	jmp	.1
  6803                                  
  6804                                  ;-------------------------------------------------------------------------
  6805                                  ; Low memory test passed
  6806                                  
  6807                                  low_ram_ok:
  6808 0000617C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  6809 00006180 B004                    	mov	al,e_low_ram_ok
  6810 00006182 E680                    	out	post_reg,al
  6811                                  
  6812                                  ;-------------------------------------------------------------------------
  6813                                  ; Set up stack - using upper 256 bytes of interrupt table
  6814                                  
  6815 00006184 B83000                  	mov	ax,0030h
  6816 00006187 8ED0                    	mov	ss,ax
  6817 00006189 BC0001                  	mov	sp,0100h
  6818                                  
  6819                                  ;-------------------------------------------------------------------------
  6820                                  ; Initialize interrupt table
  6821                                  
  6822 0000618C 0E                      	push	cs
  6823 0000618D 1F                      	pop	ds
  6824 0000618E 31FF                    	xor	di,di
  6825 00006190 8EC7                    	mov	es,di
  6826 00006192 BE[BA27]                	mov	si,interrupt_table
  6827 00006195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  6828 00006198 B800F0                  	mov	ax,bioscseg
  6829                                  .1:
  6830 0000619B A5                      	movsw				; copy ISR address (offset part)
  6831 0000619C AB                      	stosw				; store segment part
  6832 0000619D E2FC                    	loop	.1
  6833                                  %ifdef AT_COMPAT
  6834 0000619F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  6835 000061A2 BE[FA27]                	mov	si,interrupt_table2
  6836 000061A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  6837                                  .2:
  6838 000061A8 A5                      	movsw				; copy ISR address (offset part)
  6839 000061A9 AB                      	stosw				; store segment part
  6840 000061AA E2FC                    	loop	.2
  6841                                  %endif ; AT_COMPAT
  6842 000061AC B005                    	mov     al,e_int_ok
  6843 000061AE E680                    	out	post_reg,al
  6844                                  
  6845                                  ;-------------------------------------------------------------------------
  6846                                  ; set DS to BIOS data area
  6847                                  
  6848 000061B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6849 000061B3 8ED8                    	mov	ds,ax
  6850                                  
  6851                                  ;-------------------------------------------------------------------------
  6852                                  ; Initialize PIT (8254 timer)
  6853                                  
  6854 000061B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  6855 000061B7 E643                    	out	pit_ctl_reg,al
  6856 000061B9 B000                    	mov	al,0
  6857 000061BB E640                    	out	pit_ch0_reg,al
  6858 000061BD E640                    	out	pit_ch0_reg,al
  6859 000061BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  6860 000061C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  6861 000061C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  6862 000061C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  6863 000061C7 B040                    	mov	al,40h			; XXX timer latch
  6864 000061C9 E643                    	out	pit_ctl_reg,al
  6865                                  
  6866                                  ;-------------------------------------------------------------------------
  6867                                  ; Play "power on" sound - also tests PIT functionality
  6868 000061CB E8E7C0                  	call	sound
  6869                                  
  6870 000061CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  6871 000061D0 E680                    	out	post_reg,al
  6872                                  
  6873                                  ;-------------------------------------------------------------------------
  6874                                  ; Initialize PIC (8259)
  6875                                  
  6876                                  %ifdef AT_COMPAT
  6877 000061D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  6878 000061D4 E620                    	out	pic1_reg0,al
  6879 000061D6 E6A0                    	out	pic2_reg0,al
  6880 000061D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  6881 000061DA E621                    	out	pic1_reg1,al
  6882 000061DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  6883 000061DE E6A1                    	out	pic2_reg1,al
  6884 000061E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  6885 000061E2 E621                    	out	pic1_reg1,al
  6886 000061E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  6887 000061E6 E6A1                    	out	pic2_reg1,al
  6888 000061E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  6889 000061EA E621                    	out	pic1_reg1,al
  6890 000061EC E6A1                    	out	pic2_reg1,al
  6891                                  %else
  6892                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  6893                                  	out	pic1_reg0,al
  6894                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  6895                                  	out	pic1_reg1,al
  6896                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  6897                                  	out	pic1_reg1,al
  6898                                  	mov	al,e_pic_ok
  6899                                  	out	post_reg,al
  6900                                  %endif ; AT_COMPAT
  6901                                  
  6902                                  ;-------------------------------------------------------------------------
  6903                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  6904                                  
  6905 000061EE E86CB7                  	call	kbc_init
  6906                                  
  6907                                  ;-------------------------------------------------------------------------
  6908                                  ; enable interrupts
  6909                                  
  6910                                  %ifdef AT_COMPAT
  6911 000061F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  6912 000061F3 E621                    	out	pic1_reg1,al
  6913                                  %ifndef PS2_MOUSE
  6914                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  6915                                  %else
  6916 000061F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  6917                                  %endif ; PS2_MOUSE
  6918 000061F7 E6A1                    	out	pic2_reg1,al
  6919                                  %else
  6920                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  6921                                  	out	pic1_reg1,al
  6922                                  %endif ; AT_COMPAT
  6923 000061F9 FB                      	sti
  6924                                  
  6925                                  ;-------------------------------------------------------------------------
  6926                                  ; look for video BIOS, initialize it if present
  6927                                  
  6928 000061FA BA00C0                  	mov	dx,0C000h
  6929 000061FD BB00C8                  	mov	bx,0C800h
  6930 00006200 E802C2                  	call	extension_scan
  6931 00006203 833E670000              	cmp	word [67h],0
  6932 00006208 7418                    	jz	.no_video_bios
  6933 0000620A B011                    	mov	al,e_video_bios_ok
  6934 0000620C E680                    	out	post_reg,al
  6935 0000620E FF1E6700                	call	far [67h]
  6936 00006212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6937 00006215 8ED8                    	mov	ds,ax
  6938 00006217 B012                    	mov	al,e_video_init_ok
  6939 00006219 E680                    	out	post_reg,al
  6940                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)
  6941 0000621B 83261000CF              	and	word [equipment_list],~equip_video
  6942 00006220 EB1E                    	jmp	.video_initialized
  6943                                  
  6944                                  .no_video_bios:
  6945 00006222 8A261000                	mov	ah,byte [equipment_list] 	; get equipment - low byte
  6946 00006226 80E430                  	and	ah,equip_video				; get video adapter type
  6947                                  
  6948 00006229 B007                    	mov	al,07h						; monochrome 80x25 mode
  6949 0000622B 80FC30                  	cmp	ah,equip_mono				; monochrome?
  6950 0000622E 7402                    	jz	.set_mode
  6951                                  
  6952 00006230 B003                    	mov	al,03h						; color 80x25 mode
  6953                                  
  6954                                  .set_mode:
  6955 00006232 B400                    	mov	ah,00h						; INT 10, AH=00 - Set video mode
  6956                                  
  6957                                  	;; SGEO - try and do a video fix..
  6958 00006234 50                      	push ax
  6959 00006235 CD10                    	int	10h
  6960                                  	;; 100ms
  6961 00006237 B92C1A                  	mov cx, 0x43 * 100
  6962 0000623A E85FAC                  	call delay_15us
  6963 0000623D 58                      	pop ax
  6964 0000623E CD10                    	int 0x10
  6965                                  
  6966                                  .video_initialized:
  6967                                  
  6968                                  ;-------------------------------------------------------------------------
  6969                                  ; print the copyright message
  6970                                  
  6971 00006240 BE[0000]                	mov	si,msg_copyright
  6972 00006243 E84AC3                  	call	print
  6973                                  
  6974                                  ;-------------------------------------------------------------------------
  6975                                  ; Initialize RTC / NVRAM
  6976                                  
  6977 00006246 E86CA8                  	call	rtc_init
  6978                                  
  6979                                  ; read equipment byte from CMOS and set it in BIOS data area
  6980                                  
  6981 00006249 BE[DE03]                	mov	si,msg_setup
  6982 0000624C E841C3                  	call	print
  6983                                  
  6984                                  ;-------------------------------------------------------------------------
  6985                                  ; detect and print availability of various equipment
  6986                                  
  6987 0000624F E8B9C0                  	call	detect_cpu		; detect and print CPU type
  6988 00006252 E854C1                  	call	detect_fpu		; detect and print FPU presence
  6989                                  
  6990 00006255 E8DFAB                  	call	print_rtc		; print current RTC time
  6991                                  
  6992 00006258 E8E6C4                  	call	print_display		; print display type
  6993 0000625B E803C5                  	call	print_mouse		; print mouse presence
  6994                                  
  6995 0000625E E895BC                  	call	detect_serial		; detect serial ports and print findings
  6996 00006261 E85CBD                  	call	detect_parallel		; detect parallel ports and print
  6997                                  					; findings
  6998                                  
  6999 00006264 B010                    	mov	al,cmos_floppy
  7000 00006266 E82EA8                  	call	rtc_read		; floppies type to AL
  7001 00006269 E893B5                  	call	print_floppy		; print floppy drive types
  7002                                  
  7003 0000626C E8CCC3                  	call	detect_ram		; test RAM, get RAM size in AX
  7004                                  
  7005 0000626F BE[C102]                	mov	si,msg_ram_total
  7006 00006272 E81BC3                  	call	print
  7007 00006275 E855C3                  	call	print_dec		; print RAM size
  7008 00006278 BE[F602]                	mov	si,msg_kibx
  7009 0000627B E812C3                  	call	print
  7010                                  
  7011 0000627E E882C3                  	call	reserve_ebda		; reserve EBDA if needed
  7012                                  
  7013 00006281 BE[E802]                	mov	si,msg_ram_avail
  7014 00006284 E809C3                  	call	print
  7015 00006287 A11300                  	mov	ax,word [memory_size]
  7016 0000628A E840C3                  	call	print_dec		; print remaining RAM size
  7017 0000628D BE[FA02]                	mov	si,msg_kib
  7018 00006290 E8FDC2                  	call	print
  7019                                  
  7020 00006293 E8E2C4                  	call	detect_rom_ext		; detect and initialize extension ROMs
  7021                                  
  7022                                  ;-------------------------------------------------------------------------
  7023                                  ; Check for F1 (setup key), run setup utility if pressed
  7024                                  
  7025 00006296 B401                    	mov	ah,01h
  7026 00006298 CD16                    	int	16h
  7027 0000629A 740E                    	jz	.no_key
  7028 0000629C B400                    	mov	ah,00h
  7029 0000629E CD16                    	int	16h			; read the keystroke
  7030 000062A0 3D003B                  	cmp	ax,3B00h		; F1?
  7031 000062A3 7505                    	jne	.no_key
  7032 000062A5 800E120001              	or	byte [post_flags],post_setup
  7033                                  .no_key:
  7034                                  
  7035 000062AA F606120001              	test	byte [post_flags],post_setup
  7036 000062AF 7403                    	jz	.no_setup
  7037 000062B1 E81CA9                  	call	rtc_setup
  7038                                  
  7039                                  .no_setup:
  7040                                  
  7041                                  ;-------------------------------------------------------------------------
  7042                                  ; boot the OS
  7043                                  
  7044 000062B4 B000                    	mov	al,e_boot		; boot the OS POST code
  7045 000062B6 E680                    	out	post_reg,al
  7046                                  
  7047 000062B8 BE[6E03]                	mov	si,msg_boot
  7048 000062BB E8D2C2                  	call	print
  7049 000062BE CD19                    	int	19h			; boot the OS
  7050                                  
  7051                                  ;=========================================================================
  7052                                  ; int_02 - NMI
  7053                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  7054                                  ;	implemented
  7055                                  ;-------------------------------------------------------------------------
  7056 000062C0 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  7057          ******************       warning: (setloc:7) Inserting 3 bytes
  7058                                  int_02:
  7059 000062C3 50                      	push	ax
  7060 000062C4 B00D                    	mov	al,0Dh & nmi_disable
  7061 000062C6 E8CEA7                  	call	rtc_read		; disable NMI
  7062 000062C9 E461                    	in	al,port_b_reg		; read Port B
  7063 000062CB 88C4                    	mov	ah,al
  7064 000062CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  7065 000062CF E661                    	out	port_b_reg,al
  7066 000062D1 A840                    	test	al,iochk_status
  7067 000062D3 7506                    	jnz	.iochk_nmi
  7068 000062D5 88E0                    	mov	al,ah
  7069 000062D7 E661                    	out	port_b_reg,al		; restore original bits
  7070 000062D9 EB24                    	jmp	.exit
  7071                                  
  7072                                  .iochk_nmi:
  7073 000062DB 56                      	push	si
  7074 000062DC BE[0663]                	mov	si,msg_iochk_nmi
  7075 000062DF E8AEC2                  	call	print
  7076 000062E2 5E                      	pop	si
  7077                                  .1:
  7078 000062E3 B400                    	mov	ah,0h
  7079 000062E5 CD16                    	int	16h
  7080 000062E7 3C69                    	cmp	al,'i'			; exit from NMI
  7081 000062E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  7082 000062EB 3C49                    	cmp	al,'I'
  7083 000062ED 7410                    	je	.exit
  7084 000062EF 3C72                    	cmp	al,'r'
  7085 000062F1 7503E965FD              	je	cold_start
  7086 000062F6 3C52                    	cmp	al,'R'
  7087 000062F8 7503E95EFD              	je	cold_start
  7088 000062FD EBE4                    	jmp	.1
  7089                                  .exit:
  7090 000062FF B08D                    	mov	al,0Dh | nmi_enable
  7091 00006301 E893A7                  	call	rtc_read		; enable NMI
  7092 00006304 58                      	pop	ax
  7093 00006305 CF                      	iret
  7094                                  
  7095                                  msg_iochk_nmi:
  7096 00006306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  7097 0000630F 206465746563746564-
  7098 00006318 2E2054797065202769-
  7099 00006321 2720746F2069676E6F-
  7100 0000632A 726520494F43484B20-
  7101 00006333 4E4D49732C206F7220-
  7102 0000633C 27722720746F207265-
  7103 00006345 626F6F742E         
  7104 0000634A 0D0A00                  	db	0Dh, 0Ah, 00h
  7105                                  
  7106                                  ;=========================================================================
  7107                                  ; int_18 - execute ROM BASIC
  7108                                  ; Note:
  7109                                  ;	Prints an error message since we don't have ROM BASIC
  7110                                  ;-------------------------------------------------------------------------
  7111                                  int_18:
  7112 0000634D BE[2D03]                	mov	si,msg_no_basic
  7113 00006350 E83DC2                  	call	print
  7114                                  .1:
  7115 00006353 F4                      	hlt
  7116 00006354 EBFD                    	jmp	.1
  7117                                  
  7118                                  ;=========================================================================
  7119                                  ; int_19 - load and execute the boot sector
  7120                                  ;-------------------------------------------------------------------------
  7121 00006356 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  7122          ******************       warning: (setloc:7) Inserting 924 bytes
  7123                                  int_19:
  7124 000066F2 E962BD                  	jmp	ipl
  7125                                  
  7126                                  ;=========================================================================
  7127                                  ; configuration data table
  7128                                  ;-------------------------------------------------------------------------
  7129                                  	setloc	0E6F5h
  7130                                  config_table:
  7131 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  7132                                  .bytes:
  7133                                  %ifdef AT_COMPAT
  7134 000066F7 FC                      	db	0FCh			; byte 2: model = AT
  7135 000066F8 00                      	db	00h			; byte 3: submodel = 0
  7136 000066F9 00                      	db	00h			; byte 4: release = 0
  7137 000066FA 70                      	db	01110000b		; byte 5: feature byte 1
  7138                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7139                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7140                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7141                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7142                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7143                                  ;		||`-- real time clock installed
  7144                                  ;		|`-- 2nd interrupt controller installed
  7145                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7146 000066FB 00                      	db	00h			; byte 6: feature byte 2
  7147 000066FC 00                      	db	00h			; byte 7: feature byte 3
  7148 000066FD 00                      	db	00h			; byte 8: feature byte 4
  7149 000066FE 00                      	db	00h			; byte 9: feature byte 5
  7150                                  %else
  7151                                  	db	0FEh			; byte 2: model = XT
  7152                                  	db	00h			; byte 3: submodel = 0
  7153                                  	db	00h			; byte 4: release = 0
  7154                                  	db	00000000b		; byte 5: feature byte 1
  7155                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7156                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7157                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7158                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7159                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7160                                  ;		||`-- real time clock installed
  7161                                  ;		|`-- 2nd interrupt controller installed
  7162                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7163                                  	db	00h			; byte 6: feature byte 2
  7164                                  	db	00h			; byte 7: feature byte 3
  7165                                  	db	00h			; byte 8: feature byte 4
  7166                                  	db	00h			; byte 9: feature byte 5
  7167                                  %endif ; AT_COMPAT
  7168                                  .size	equ	$-.bytes
  7169                                  
  7170                                  ;=========================================================================
  7171                                  ; Includes with fixed entry points (for IBM compatibility)
  7172                                  ;-------------------------------------------------------------------------
  7173                                  
  7174                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  7175                              <1> ;========================================================================
  7176                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  7177                              <1> ;       INT 14h, function AH=00h
  7178                              <1> ;       INT 14h, function AH=03h
  7179                              <1> ;       INT 14h, function AH=04h
  7180                              <1> ;       INT 14h, function AH=05h
  7181                              <1> ;	- see serial1.inc for other INT 14h functions
  7182                              <1> ;-------------------------------------------------------------------------
  7183                              <1> ;
  7184                              <1> ; Compiles with NASM 2.07, might work with other versions
  7185                              <1> ;
  7186                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7187                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7188                              <1> ;
  7189                              <1> ; This program is free software: you can redistribute it and/or modify
  7190                              <1> ; it under the terms of the GNU General Public License as published by
  7191                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7192                              <1> ; (at your option) any later version.
  7193                              <1> ;
  7194                              <1> ; This program is distributed in the hope that it will be useful,
  7195                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7196                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7197                              <1> ; GNU General Public License for more details.
  7198                              <1> ;
  7199                              <1> ; You should have received a copy of the GNU General Public License
  7200                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7201                              <1> ;
  7202                              <1> ;=========================================================================
  7203                              <1> 
  7204                              <1> ;=========================================================================
  7205                              <1> ; int_14 - BIOS Serial Port Communication Services
  7206                              <1> ;-------------------------------------------------------------------------
  7207 000066FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  7208          ******************  <1>  warning: (setloc:7) Inserting 42 bytes
  7209                              <1> int_14:
  7210 00006729 FB                  <1> 	sti
  7211 0000672A 51                  <1> 	push	cx
  7212 0000672B 52                  <1> 	push	dx
  7213 0000672C 56                  <1> 	push	si
  7214 0000672D 1E                  <1> 	push	ds
  7215 0000672E 53                  <1> 	push	bx
  7216 0000672F BB4000              <1> 	mov	bx,biosdseg
  7217 00006732 8EDB                <1> 	mov	ds,bx
  7218 00006734 80FC06              <1> 	cmp	ah,.max/2
  7219 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
  7220 00006739 83FA04              <1> 	cmp	dx,num_serial
  7221 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
  7222 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  7223 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  7224 00006743 89D3                <1> 	mov	bx,dx
  7225 00006745 D1E3                <1> 	shl	bx,1
  7226 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  7227 00006749 09D2                <1> 	or	dx,dx
  7228 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
  7229 0000674D B700                <1> 	mov	bh,0
  7230 0000674F 88E3                <1> 	mov	bl,ah
  7231 00006751 D1E3                <1> 	shl	bx,1
  7232 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
  7233                              <1> .dispatch:
  7234 00006758 [6C67]              <1> 	dw	int_14_fn00
  7235 0000675A [911E]              <1> 	dw	int_14_fn01
  7236 0000675C [AC1E]              <1> 	dw	int_14_fn02
  7237 0000675E [A167]              <1> 	dw	int_14_fn03
  7238 00006760 [AB67]              <1> 	dw	int_14_fn04
  7239 00006762 [0568]              <1> 	dw	int_14_fn05
  7240                              <1> .max	equ	$-.dispatch
  7241                              <1> 
  7242                              <1> int_14_error:
  7243 00006764 31C0                <1> 	xor	ax,ax
  7244                              <1> 
  7245                              <1> int_14_exit:
  7246 00006766 5B                  <1> 	pop	bx
  7247 00006767 1F                  <1> 	pop	ds
  7248 00006768 5E                  <1> 	pop	si
  7249 00006769 5A                  <1> 	pop	dx
  7250 0000676A 59                  <1> 	pop	cx
  7251 0000676B CF                  <1> 	iret
  7252                              <1> 
  7253                              <1> ;=========================================================================
  7254                              <1> ; int_14_fn00 - Initialize serial port
  7255                              <1> ; Input:
  7256                              <1> ;	AH = 0 - function 00h - initialize serial port
  7257                              <1> ;	AL - initialization parameters
  7258                              <1> ;		bit 1,0	= 10	- 7 data bits
  7259                              <1> ;			= 11	- 8 data bits
  7260                              <1> ;		bit 2	= 0	- 1 stop bit
  7261                              <1> ;			= 1	- 2 stop bits
  7262                              <1> ;		bit 3	= 0	- parity disable
  7263                              <1> ;			= 1	- parity enable
  7264                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  7265                              <1> ;			= 1	- even parity (if parity enabled)
  7266                              <1> ;		bit 7-5 = 000	- 110 bps
  7267                              <1> ;			= 001	- 150 bps
  7268                              <1> ;			= 010	- 300 bps
  7269                              <1> ;			= 011	- 600 bps
  7270                              <1> ;			= 100	- 1200 bps
  7271                              <1> ;			= 101	- 2400 bps
  7272                              <1> ;			= 110	- 4800 bps
  7273                              <1> ;			= 111	- 9600 bps
  7274                              <1> ;	DX = serial port number (0-3)
  7275                              <1> ; Output:
  7276                              <1> ;	AL = modem status
  7277                              <1> ;		bit 0	= 1	- delta clear to send
  7278                              <1> ;		bit 1	= 1	- delta data set ready
  7279                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  7280                              <1> ;		bit 3	= 1	- delta data carrier detect
  7281                              <1> ;		bit 4	= 1	- clear to send
  7282                              <1> ;		bit 5	= 1	- data set ready
  7283                              <1> ;		bit 6	= 1	- ring indicator
  7284                              <1> ;		bit 7	= 1	- data carrier detect
  7285                              <1> ;	AH = line status
  7286                              <1> ;		bit 0	= 1	- data ready
  7287                              <1> ;		bit 1	= 1	- overrun error
  7288                              <1> ;		bit 2	= 1	- parity error
  7289                              <1> ;		bit 3	= 1	- framing error
  7290                              <1> ;		bit 4	= 1	- break interrupt
  7291                              <1> ;		bit 5	= 1	- transmitter holding register
  7292                              <1> ;		bit 6	= 1	- transmitter empty
  7293                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  7294                              <1> ;-------------------------------------------------------------------------
  7295                              <1> int_14_fn00:
  7296 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  7297 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7298 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7299 00006773 EE                  <1> 	out	dx,al
  7300 00006774 31DB                <1> 	xor	bx,bx
  7301 00006776 88E3                <1> 	mov	bl,ah
  7302 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  7303 0000677B D0EB                <1> 	shr	bl,1
  7304 0000677D D0EB                <1> 	shr	bl,1
  7305 0000677F D0EB                <1> 	shr	bl,1
  7306 00006781 D0EB                <1> 	shr	bl,1
  7307 00006783 2E8B9F[941F]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7308 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7309 0000678B 88D8                <1> 	mov	al,bl
  7310 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  7311 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  7312 0000678F 88F8                <1> 	mov	al,bh
  7313 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  7314 00006792 42                  <1> 	inc	dx
  7315 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  7316 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  7317 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  7318                              <1> 					; get control bits
  7319 00006798 EE                  <1> 	out	dx,al			; set LCR
  7320 00006799 4A                  <1> 	dec	dx
  7321 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  7322                              <1> 					; OPTIMIZATION:
  7323                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7324 0000679B B000                <1> 	mov	al,0
  7325 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  7326 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  7327                              <1> 					; OPTIMIZATION:
  7328                              <1> 					; uart_base = uart_ier_reg - 1
  7329 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7330                              <1> 
  7331                              <1> ;=========================================================================
  7332                              <1> ; int_14_fn03 - Return serial port status
  7333                              <1> ; Input:
  7334                              <1> ;	AH = 03h - function 03h - return serial port status
  7335                              <1> ;	DX = serial port number (0-3)
  7336                              <1> ; Output:
  7337                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7338                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7339                              <1> ;-------------------------------------------------------------------------
  7340                              <1> int_14_fn03:
  7341 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  7342 000067A4 EC                  <1> 	in	al,dx
  7343 000067A5 88C4                <1> 	mov	ah,al
  7344 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  7345 000067A8 EC                  <1> 	in	al,dx
  7346 000067A9 EBBB                <1> 	jmp	int_14_exit
  7347                              <1> 
  7348                              <1> ;=========================================================================
  7349                              <1> ; int_14_fn04 - Extended initialize serial port
  7350                              <1> ; Input:
  7351                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  7352                              <1> ;	AL - break status:
  7353                              <1> ;		00h = no break
  7354                              <1> ;		01h = break
  7355                              <1> ;	BH - parity:
  7356                              <1> ;		00h = no parity
  7357                              <1> ;		01h = odd parity
  7358                              <1> ;		02h = even parity
  7359                              <1> ;		03h = stick parity odd
  7360                              <1> ;		04h = stick parity even
  7361                              <1> ;	BL - stop bits:
  7362                              <1> ;		00h = 1 stop bit
  7363                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  7364                              <1> ;	CH - word length:
  7365                              <1> ;		00h = 5 bits
  7366                              <1> ;		01h = 6 bits
  7367                              <1> ;		02h = 7 bits
  7368                              <1> ;		03h = 8 bits
  7369                              <1> ;	CL - bps rate:
  7370                              <1> ;		00h = 110 bps
  7371                              <1> ;		01h = 150 bps
  7372                              <1> ;		02h = 300 bps
  7373                              <1> ;		03h = 600 bps
  7374                              <1> ;		04h = 1200 bps
  7375                              <1> ;		05h = 2400 bps
  7376                              <1> ;		06h = 6000 bps
  7377                              <1> ;		07h = 9600 bps
  7378                              <1> ;		08h = 19200 bps
  7379                              <1> ;		09h = 38400 bps
  7380                              <1> ;		0Ah = 57600 bps
  7381                              <1> ;		0Bh = 115200 bps
  7382                              <1> ;	DX = serial port number (0-3)
  7383                              <1> ; Output:
  7384                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7385                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7386                              <1> ;-------------------------------------------------------------------------
  7387                              <1> int_14_fn04:
  7388 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  7389 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  7390 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  7391                              <1> 					; exit returning modem and line status
  7392 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7393 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7394 000067B7 EE                  <1> 	out	dx,al
  7395 000067B8 31DB                <1> 	xor	bx,bx
  7396 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  7397 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  7398 000067BE 2E8B9F[941F]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7399 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7400 000067C6 88D8                <1> 	mov	al,bl
  7401 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  7402 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  7403 000067CA 88F8                <1> 	mov	al,bh
  7404 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  7405 000067CD 42                  <1> 	inc	dx
  7406 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  7407                              <1> 
  7408 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  7409 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  7410                              <1> 
  7411 000067D4 D0E0                <1> 	shl	al,1
  7412 000067D6 D0E0                <1> 	shl	al,1
  7413 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  7414                              <1> 	
  7415 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  7416 000067DB 53                  <1> 	push	bx			; push it back to the stack
  7417                              <1> 
  7418 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  7419 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  7420 000067E1 FECF                <1> 	dec	bh
  7421 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  7422 000067E6 D0E7                <1> 	shl	bh,1
  7423 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  7424                              <1> 
  7425                              <1> .set_parity:
  7426 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  7427                              <1> 
  7428 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  7429                              <1> 	
  7430 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  7431 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  7432                              <1> 
  7433 000067F3 D0E0                <1> 	shl	al,1
  7434 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  7435                              <1> 
  7436 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  7437 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  7438                              <1> 
  7439 000067FC EE                  <1> 	out	dx,al			; set LCR
  7440 000067FD 4A                  <1> 	dec	dx
  7441 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  7442                              <1> 					; OPTIMIZATION:
  7443                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7444 000067FF B000                <1> 	mov	al,0
  7445 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  7446 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  7447                              <1> 					; OPTIMIZATION:
  7448                              <1> 					; uart_base = uart_ier_reg - 1
  7449 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7450                              <1> 
  7451                              <1> ;=========================================================================
  7452                              <1> ; int_14_fn05 - Extended serial port control
  7453                              <1> ; Input:
  7454                              <1> ;	AH = 05h - function 05h - extended serial port control
  7455                              <1> ;	AL - sub-function:
  7456                              <1> ;		00h = read modem control register
  7457                              <1> ;		01h = write modem control register
  7458                              <1> ;			BL = modem control register
  7459                              <1> ;	DX = serial port number (0-3)
  7460                              <1> ; Output:
  7461                              <1> ;	AX = status	
  7462                              <1> ;	sub-function AL = 00h:
  7463                              <1> ;		BL = modem control register
  7464                              <1> ;-------------------------------------------------------------------------
  7465                              <1> int_14_fn05:
  7466 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  7467 00006807 750D                <1> 	jnz	int_14_fn05_01
  7468                              <1> 
  7469                              <1> ;-------------------------------------------------------------------------
  7470                              <1> ; sub-function 00h - read modem control register
  7471                              <1> ; int_14_fn05_00:
  7472 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7473 0000680C EC                  <1> 	in	al,dx
  7474 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  7475 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  7476 00006810 53                  <1> 	push	bx			; put BX back to the stack
  7477 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7478 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7479                              <1> 
  7480                              <1> ;-------------------------------------------------------------------------
  7481                              <1> ; sub-function 01h - write modem control register
  7482                              <1> int_14_fn05_01:
  7483 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7484 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  7485 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  7486 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  7487 0000681D EE                  <1> 	out	dx,al
  7488 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7489 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7490                                  %include	"atkbd.inc"		; INT 16, INT 09
  7491                              <1> ;=========================================================================
  7492                              <1> ; atkbd.inc - AT keyboard support
  7493                              <1> ;       INT 16h - BIOS Keyboard Services
  7494                              <1> ;		- function AH=02h
  7495                              <1> ;		- function AH=03h
  7496                              <1> ;		- function AH=05h
  7497                              <1> ;		- function AH=12h
  7498                              <1> ;		- see scancode.inc for other (scancode related)
  7499                              <1> ;                 INT 16h functions
  7500                              <1> ;       INT 09h - IRQ1 interrupt handler
  7501                              <1> ;-------------------------------------------------------------------------
  7502                              <1> ;
  7503                              <1> ; Compiles with NASM 2.07, might work with other versions
  7504                              <1> ;
  7505                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  7506                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7507                              <1> ;
  7508                              <1> ; This program is free software: you can redistribute it and/or modify
  7509                              <1> ; it under the terms of the GNU General Public License as published by
  7510                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7511                              <1> ; (at your option) any later version.
  7512                              <1> ;
  7513                              <1> ; This program is distributed in the hope that it will be useful,
  7514                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7515                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7516                              <1> ; GNU General Public License for more details.
  7517                              <1> ;
  7518                              <1> ; You should have received a copy of the GNU General Public License
  7519                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7520                              <1> ;
  7521                              <1> ;=========================================================================
  7522                              <1> 
  7523                              <1> ;=========================================================================
  7524                              <1> ; Scan codes and keyboard flags
  7525                              <1> ;-------------------------------------------------------------------------
  7526                              <1> 
  7527                              <1> ; scancodes for special keys
  7528                              <1> 
  7529                              <1> kbd_num_code	equ	45h
  7530                              <1> kbd_scroll_code	equ	46h
  7531                              <1> kbd_caps_code	equ	3ah
  7532                              <1> kbd_ctrl_code	equ	1dh
  7533                              <1> kbd_alt_code	equ	38h
  7534                              <1> kbd_rshift_code	equ	36h
  7535                              <1> kbd_prtsc_code	equ	37h
  7536                              <1> kbd_lshift_code	equ	2ah
  7537                              <1> kbd_ins_code	equ	52h
  7538                              <1> kbd_del_code	equ	53h
  7539                              <1> 
  7540                              <1> ; Bits for the various modifier keys
  7541                              <1> 
  7542                              <1> kbd_rshft_bit	equ	1
  7543                              <1> kbd_lshft_bit	equ	2
  7544                              <1> kbd_ctrl_bit	equ	4
  7545                              <1> kbd_alt_bit	equ	8
  7546                              <1> kbd_scroll_bit	equ	10h
  7547                              <1> kbd_num_bit	equ	20h
  7548                              <1> kbd_caps_bit	equ	40h
  7549                              <1> kbd_ins_bit	equ	80h
  7550                              <1> 
  7551                              <1> ;=========================================================================
  7552                              <1> ; int_16 - BIOS keyboard functions
  7553                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  7554                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  7555                              <1> ;	conditions
  7556                              <1> ;-------------------------------------------------------------------------
  7557 00006824 FF<rept>            <1> 	setloc	0E82Eh
  7558          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  7559                              <1> int_16:
  7560 0000682E 53                  <1> 	push	bx
  7561 0000682F 1E                  <1> 	push	ds
  7562 00006830 BB4000              <1> 	mov	bx,biosdseg
  7563 00006833 8EDB                <1> 	mov	ds,bx
  7564 00006835 80FC13              <1> 	cmp	ah,.num_func
  7565 00006838 7331                <1> 	jae	int_16_exit
  7566 0000683A B700                <1> 	mov	bh,0
  7567 0000683C 88E3                <1> 	mov	bl,ah
  7568 0000683E D1E3                <1> 	shl	bx,1
  7569 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
  7570                              <1> 
  7571                              <1> .dispatch:
  7572 00006845 [A61D]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  7573 00006847 [FB1D]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  7574 00006849 [7468]              <1> 	dw	int_16_fn02		; get shift status
  7575 0000684B [7968]              <1> 	dw	int_16_fn03		; set delays
  7576 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
  7577 0000684F [A668]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  7578 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
  7579 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
  7580 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
  7581 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
  7582 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
  7583 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  7584 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  7585 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  7586 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  7587 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  7588 00006865 [531E]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  7589 00006867 [7A1E]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  7590 00006869 [CF68]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  7591                              <1> .num_func	equ	($-.dispatch)/2
  7592                              <1> 
  7593                              <1> int_16_exit:
  7594 0000686B 1F                  <1> 	pop	ds
  7595 0000686C 5B                  <1> 	pop	bx
  7596 0000686D CF                  <1> 	iret
  7597                              <1> 
  7598                              <1> int_16_exitf:
  7599 0000686E 1F                  <1> 	pop	ds
  7600 0000686F 5B                  <1> 	pop	bx
  7601 00006870 FB                  <1> 	sti
  7602 00006871 CA0200              <1> 	retf	2
  7603                              <1> 
  7604                              <1> ;=========================================================================
  7605                              <1> ; int_16_fn02 - get shift flags
  7606                              <1> ; Input:
  7607                              <1> ;	AH = 02h
  7608                              <1> ; Output:
  7609                              <1> ;	AL - shift flags
  7610                              <1> ;            AL bits:
  7611                              <1> ;		7 - Insert active
  7612                              <1> ;		6 - Caps Lock active
  7613                              <1> ;		5 - Num Lock active
  7614                              <1> ;		4 - Scroll Lock active
  7615                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  7616                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  7617                              <1> ;		1 - left shift key pressed
  7618                              <1> ;		0 - right shift key pressed
  7619                              <1> ;-------------------------------------------------------------------------
  7620                              <1> int_16_fn02:
  7621 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7622 00006877 EBF2                <1> 	jmp	int_16_exit
  7623                              <1> 
  7624                              <1> ;=========================================================================
  7625                              <1> ; int_16_fn03 - set keyboard typematic rate
  7626                              <1> ; Input:
  7627                              <1> ;	AH = 03
  7628                              <1> ;	AL - subfunction
  7629                              <1> ;	     00 - set typematic rate to default
  7630                              <1> ;	     01 - increase initial delay
  7631                              <1> ;	     02 - slow typematic rate by 1/2
  7632                              <1> ;	     04 - turn off typematic chars
  7633                              <1> ;	     05 - set typematic rate/delay
  7634                              <1> ;	BH - repeat delay (AL=5)
  7635                              <1> ;		0 - 250ms	2 - 750ms
  7636                              <1> ;		1 - 500ms	3 - 1000ms
  7637                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  7638                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  7639                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  7640                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  7641                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  7642                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  7643                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  7644                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  7645                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  7646                              <1> ; Output:
  7647                              <1> ;	none
  7648                              <1> ;-------------------------------------------------------------------------
  7649                              <1> int_16_fn03:
  7650 00006879 3C05                <1> 	cmp	al,05
  7651 0000687B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  7652 0000687D 53                  <1> 	push	bx
  7653 0000687E 51                  <1> 	push	cx
  7654 0000687F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7655 00006881 E824B0              <1> 	call	kbc_send_cmd_byte
  7656 00006884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  7657 00006887 B105                <1> 	mov	cl,5
  7658 00006889 D2E7                <1> 	shl	bh,cl
  7659 0000688B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  7660 0000688E B0F3                <1> 	mov	al,0F3h
  7661 00006890 E8B1AF              <1> 	call	kbc_kb_send
  7662 00006893 88F8                <1> 	mov	al,bh
  7663 00006895 E8ACAF              <1> 	call	kbc_kb_send
  7664 00006898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7665 0000689A E80BB0              <1> 	call	kbc_send_cmd_byte
  7666 0000689D B004                <1> 	mov	al,04h
  7667 0000689F E8A2AF              <1> 	call	kbc_kb_send
  7668 000068A2 59                  <1> 	pop	cx
  7669 000068A3 5B                  <1> 	pop	bx
  7670                              <1> .exit:
  7671 000068A4 EBC5                <1> 	jmp	int_16_exit
  7672                              <1> 
  7673                              <1> ;=========================================================================
  7674                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  7675                              <1> ; Input:
  7676                              <1> ;	AH = 05h
  7677                              <1> ;	CH = BIOS scan code
  7678                              <1> ;	CL = ACII character
  7679                              <1> ; Output:
  7680                              <1> ;	AL - status
  7681                              <1> ;	     00h - success
  7682                              <1> ;	     01h - keyboard buffer full
  7683                              <1> ;-------------------------------------------------------------------------
  7684                              <1> int_16_fn05:
  7685 000068A6 56                  <1> 	push	si
  7686 000068A7 B001                <1> 	mov	al,1			; assume no space
  7687 000068A9 FA                  <1> 	cli				; critical section
  7688 000068AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7689 000068AE 89DE                <1> 	mov	si,bx
  7690 000068B0 83C302              <1> 	add	bx,2
  7691 000068B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7692 000068B7 7504                <1> 	jne	.1
  7693 000068B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7694                              <1> .1:
  7695 000068BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7696 000068C1 7408                <1> 	je	.no_space		; no space in buffer
  7697 000068C3 890C                <1> 	mov	word [si],cx
  7698 000068C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7699 000068C9 B000                <1> 	mov	al,0			; stored successfully
  7700                              <1> .no_space:
  7701 000068CB FB                  <1> 	sti
  7702 000068CC 5E                  <1> 	pop	si
  7703 000068CD EB9C                <1> 	jmp	int_16_exit
  7704                              <1> 
  7705                              <1> ;=========================================================================
  7706                              <1> ; int_16_fn12 - get extended shift flags
  7707                              <1> ; Input:
  7708                              <1> ;	AH = 12h
  7709                              <1> ; Output:
  7710                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  7711                              <1> ;	AH - shift flags 2
  7712                              <1> ;            AH bits:
  7713                              <1> ;		7 - SysRq key pressed
  7714                              <1> ;		6 - Caps Lock pressed
  7715                              <1> ;		5 - Num Lock pressed
  7716                              <1> ;		4 - Scroll Lock pressed
  7717                              <1> ;		3 - right Alt key pressed
  7718                              <1> ;		2 - right Ctrl key pressed
  7719                              <1> ;		1 - left Alt key pressed
  7720                              <1> ;		0 - left Ctrl key pressed
  7721                              <1> ;-------------------------------------------------------------------------
  7722                              <1> int_16_fn12:
  7723 000068CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  7724 000068D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  7725 000068D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  7726 000068D9 7403                <1> 	je	.1
  7727 000068DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  7728                              <1> .1:
  7729 000068DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  7730 000068E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  7731 000068E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  7732 000068E6 08C4                <1> 	or	ah,al			; copy to AH
  7733 000068E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7734 000068EB E97DFF              <1> 	jmp	int_16_exit
  7735                              <1> 
  7736                              <1> ;=========================================================================
  7737                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  7738                              <1> ;-------------------------------------------------------------------------
  7739 000068EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  7740          ******************  <1>  warning: (setloc:7) Inserting 153 bytes
  7741                              <1> int_09:
  7742 00006987 50                  <1> 	push	ax
  7743 00006988 53                  <1> 	push	bx
  7744 00006989 1E                  <1> 	push	ds
  7745                              <1> 
  7746 0000698A B84000              <1> 	mov	ax,biosdseg
  7747 0000698D 8ED8                <1> 	mov	ds,ax
  7748                              <1> 
  7749                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7750                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7751                              <1> 	call    kbc_send_cmd_byte
  7752                              <1> %endif
  7753 0000698F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  7754 00006991 FB                  <1> 	sti
  7755 00006992 B44F                <1> 	mov	ah,4Fh
  7756 00006994 F9                  <1> 	stc
  7757 00006995 CD15                <1> 	int	15h			; keyboard intercept
  7758 00006997 7203E9CB01          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  7759                              <1> 
  7760                              <1> ; check for KBC response codes
  7761                              <1> 
  7762 0000699C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  7763 0000699E 7503E9C401          <1> 	je      keyboard_int_exit
  7764 000069A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  7765 000069A5 7508                <1> 	jne     .2
  7766 000069A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  7767 000069AC E9B801              <1> 	jmp	keyboard_int_exit
  7768                              <1> .2:
  7769 000069AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  7770 000069B1 7508                <1> 	jne	.3
  7771 000069B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  7772 000069B8 E9AC01              <1> 	jmp	keyboard_int_exit
  7773                              <1> 
  7774                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  7775                              <1> 
  7776                              <1> .3:
  7777                              <1> 
  7778                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  7779                              <1> 
  7780 000069BB 3CE0                <1> 	cmp	al,0E0h
  7781 000069BD 750D                <1> 	jne	.4
  7782 000069BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  7783 000069C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  7784 000069C9 E99B01              <1> 	jmp	keyboard_int_exit
  7785                              <1> .4:
  7786 000069CC 3CE1                <1> 	cmp	al,0E1h
  7787 000069CE 750D                <1> 	jne	.5
  7788 000069D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  7789 000069D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  7790 000069DA E98A01              <1> 	jmp	keyboard_int_exit
  7791                              <1> 
  7792                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  7793                              <1> 
  7794                              <1> .5:
  7795 000069DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  7796 000069E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  7797 000069E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  7798 000069E7 7529                <1> 	jne	.6
  7799 000069E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  7800 000069EB 750B                <1> 	jne	.check_minus
  7801 000069ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  7802 000069F3 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  7803                              <1> 
  7804                              <1> .check_minus:
  7805 000069F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  7806 000069FA 7509                <1> 	jne	.check_plus
  7807                              <1> 
  7808                              <1> .turbo_off:
  7809 000069FC E461                <1> 	in	al,port_b_reg
  7810 000069FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  7811 00006A00 E661                <1> 	out	port_b_reg,al
  7812 00006A02 E96201              <1> 	jmp	keyboard_int_exit
  7813                              <1> 
  7814                              <1> .check_plus:
  7815 00006A05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  7816 00006A07 7509                <1> 	jne	.6
  7817                              <1> 
  7818                              <1> .turbo_on:
  7819 00006A09 E461                <1> 	in	al,port_b_reg
  7820 00006A0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  7821 00006A0D E661                <1> 	out	port_b_reg,al
  7822 00006A0F E95501              <1> 	jmp	keyboard_int_exit
  7823                              <1> 
  7824                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  7825                              <1> ; in the keyboard flags variables.
  7826                              <1> 
  7827                              <1> .6:
  7828 00006A12 3C52                <1> 	cmp	al,kbd_ins_code
  7829 00006A14 7508                <1> 	jne	.7
  7830 00006A16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  7831 00006A1B E90A01              <1> 	jmp	.translate	   	; pass on INS key
  7832                              <1> 
  7833                              <1> .7:
  7834 00006A1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  7835 00006A20 750D                <1> 	jne     .8
  7836 00006A22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  7837 00006A27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  7838 00006A2C E93301              <1> 	jmp     .no_buffer
  7839                              <1> 
  7840                              <1> ; handle the left and right Shift keys
  7841                              <1> 
  7842                              <1> .8:
  7843 00006A2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  7844 00006A31 7508                <1> 	jne	.9
  7845 00006A33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  7846 00006A38 E92701              <1> 	jmp	.no_buffer
  7847                              <1> .9:
  7848 00006A3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  7849 00006A3D 7508                <1> 	jne     .10
  7850 00006A3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  7851 00006A44 E91B01              <1> 	jmp     .no_buffer
  7852                              <1> .10:
  7853 00006A47 3C36                <1> 	cmp	al,kbd_rshift_code
  7854 00006A49 7508                <1> 	jne	.11
  7855 00006A4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  7856 00006A50 E90F01              <1> 	jmp	.no_buffer
  7857                              <1> .11:
  7858 00006A53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  7859 00006A55 7508                <1> 	jne     .12
  7860 00006A57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  7861 00006A5C E90301              <1> 	jmp	.no_buffer
  7862                              <1> 
  7863                              <1> ; handle the Alt key
  7864                              <1> 
  7865                              <1> .12:
  7866 00006A5F 3C38                <1> 	cmp	al,kbd_alt_code
  7867 00006A61 7508                <1> 	jne	.13
  7868 00006A63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  7869 00006A68 E9F700              <1> 	jmp	.no_buffer
  7870                              <1> .13:
  7871 00006A6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  7872 00006A6D 751C                <1> 	jne	.14
  7873 00006A6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  7874 00006A74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  7875 00006A79 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  7876 00006A7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  7877 00006A81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  7878 00006A86 B400                <1> 	mov	ah,0
  7879 00006A88 E9B600              <1> 	jmp	.put_in_buffer
  7880                              <1> 
  7881                              <1> ; handle the Ctrl key
  7882                              <1> 
  7883                              <1> .14:
  7884 00006A8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  7885 00006A8D 7508                <1> 	jne	.15
  7886 00006A8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  7887 00006A94 E9CB00              <1> 	jmp	.no_buffer
  7888                              <1> .15:
  7889 00006A97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  7890 00006A99 7508                <1> 	jne	.16
  7891 00006A9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  7892 00006AA0 E9BF00              <1> 	jmp	.no_buffer
  7893                              <1> 
  7894                              <1> ; handle the Caps Lock key
  7895                              <1> 
  7896                              <1> .16:
  7897 00006AA3 3C3A                <1> 	cmp	al,kbd_caps_code
  7898 00006AA5 750D                <1> 	jne	.17
  7899 00006AA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  7900 00006AAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  7901 00006AB1 E9AE00              <1> 	jmp	.no_buffer
  7902                              <1> .17:
  7903 00006AB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  7904 00006AB6 7508                <1> 	jne	.18
  7905 00006AB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  7906 00006ABD E9D000              <1> 	jmp	set_LEDs
  7907                              <1> 
  7908                              <1> ; check if print screen key was pressed
  7909                              <1> 
  7910                              <1> .18:
  7911 00006AC0 3C37                <1> 	cmp	al,kbd_prtsc_code
  7912 00006AC2 750A                <1> 	jne	.test_scroll_loc
  7913 00006AC4 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7914 00006AC9 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  7915 00006ACB E9B500              <1> 	jmp	print_screen
  7916                              <1> 
  7917                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  7918                              <1> 
  7919                              <1> .test_scroll_loc:
  7920 00006ACE 3C46                <1> 	cmp	al,kbd_scroll_code
  7921 00006AD0 7528                <1> 	jne	.19
  7922 00006AD2 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7923 00006AD7 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  7924                              <1> 
  7925                              <1> ; handle Ctrl-Break
  7926                              <1> 
  7927 00006AD9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  7928 00006ADD 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  7929 00006AE1 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7930 00006AE5 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  7931 00006AEA CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  7932 00006AEC EB74                <1> 	jmp	.no_buffer
  7933                              <1> 
  7934                              <1> ; handle Scroll Lock
  7935                              <1> 
  7936                              <1> .scroll_lock:
  7937 00006AEE 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  7938 00006AF3 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  7939 00006AF8 EB68                <1> 	jmp	.no_buffer
  7940                              <1> .19:
  7941 00006AFA 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  7942 00006AFC 7508                <1> 	jne	.20
  7943 00006AFE 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  7944 00006B03 E98A00              <1> 	jmp	set_LEDs
  7945                              <1> 
  7946                              <1> ; handle the Num Lock
  7947                              <1> 
  7948                              <1> .20:
  7949 00006B06 3C45                <1> 	cmp	al,kbd_num_code
  7950 00006B08 7513                <1> 	jne	.21
  7951 00006B0A F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  7952 00006B0F 755E                <1> 	jnz	pause			; jump if pause
  7953 00006B11 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  7954 00006B16 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  7955 00006B1B EB45                <1> 	jmp	.no_buffer
  7956                              <1> .21:
  7957 00006B1D 3CC5                <1> 	cmp	al,kbd_num_code+80h
  7958 00006B1F 7507                <1> 	jne	.translate
  7959 00006B21 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  7960 00006B26 EB68                <1> 	jmp	set_LEDs
  7961                              <1> 
  7962                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  7963                              <1> 
  7964                              <1> .translate:
  7965 00006B28 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  7966 00006B2D 7407                <1> 	jz	.check_release
  7967 00006B2F 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  7968 00006B34 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  7969                              <1> .check_release:
  7970 00006B36 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  7971 00006B38 7528                <1> 	jnz	.no_buffer
  7972                              <1> 
  7973 00006B3A E8B0B1              <1> 	call	scan_xlat
  7974 00006B3D 85C0                <1> 	test	ax,ax		 	; check for bad code
  7975 00006B3F 7421                <1> 	je	.no_buffer
  7976                              <1> 
  7977                              <1> .put_in_buffer:
  7978 00006B41 56                  <1> 	push	si			; XXX - use Int 16h/05?
  7979 00006B42 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7980 00006B46 89DE                <1> 	mov	si,bx
  7981 00006B48 83C302              <1> 	add	bx,2
  7982 00006B4B 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7983 00006B4F 7504                <1> 	jne	.1
  7984 00006B51 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7985                              <1> .1:
  7986 00006B55 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7987 00006B59 7406                <1> 	je	.no_space		; no space in buffer
  7988 00006B5B 8904                <1> 	mov	word [si],ax
  7989 00006B5D 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7990                              <1> 
  7991                              <1> .no_space:
  7992 00006B61 5E                  <1> 	pop	si
  7993                              <1> 
  7994                              <1> .no_buffer:
  7995 00006B62 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  7996                              <1> 
  7997                              <1> keyboard_int_exit:
  7998                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7999                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  8000                              <1> 	call	kbc_send_cmd_byte
  8001                              <1> %endif
  8002 00006B67 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  8003 00006B69 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  8004                              <1> 
  8005                              <1> keyboard_int_exit1:
  8006 00006B6B 1F                  <1> 	pop	ds
  8007 00006B6C 5B                  <1> 	pop	bx
  8008 00006B6D 58                  <1> 	pop	ax
  8009 00006B6E CF                  <1> 	iret
  8010                              <1> 
  8011                              <1> pause:
  8012 00006B6F 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  8013 00006B74 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  8014                              <1> 
  8015 00006B76 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  8016 00006B78 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  8017                              <1> 
  8018                              <1> .pause_loop:
  8019 00006B7A F606180008          <1> 	test	byte [kbd_flags_2],08h
  8020 00006B7F 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  8021 00006B81 EBE8                <1> 	jmp	keyboard_int_exit1
  8022                              <1> 
  8023                              <1> print_screen:
  8024 00006B83 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  8025 00006B85 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  8026 00006B87 CD05                <1> 	int	5h			; INT 5 - print screen
  8027 00006B89 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  8028 00006B8E EBDB                <1> 	jmp	keyboard_int_exit1
  8029                              <1> 
  8030                              <1> ;=========================================================================
  8031                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  8032                              <1> ; 	     variable and update LEDs on the keyboard
  8033                              <1> ;-------------------------------------------------------------------------
  8034                              <1> set_LEDs:
  8035                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  8036                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  8037                              <1> 	call	kbc_send_cmd_byte
  8038                              <1> %endif
  8039                              <1> 
  8040 00006B90 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  8041 00006B92 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  8042                              <1> 
  8043 00006B94 A01700              <1> 	mov	al,byte [kbd_flags_1]
  8044 00006B97 D0E8                <1> 	shr	al,1
  8045 00006B99 D0E8                <1> 	shr	al,1
  8046 00006B9B D0E8                <1> 	shr	al,1
  8047 00006B9D D0E8                <1> 	shr	al,1
  8048 00006B9F 2407                <1> 	and	al,111b
  8049 00006BA1 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  8050 00006BA6 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  8051 00006BAA 88C4                <1> 	mov	ah,al			; save LED bits
  8052                              <1> 
  8053 00006BAC B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  8054 00006BAE E8F7AC              <1> 	call	kbc_send_cmd_byte
  8055                              <1> 
  8056 00006BB1 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  8057 00006BB3 E88EAC              <1> 	call	kbc_kb_send		; send the command to the keyboard
  8058 00006BB6 88E0                <1> 	mov	al,ah			; get parameter byte
  8059 00006BB8 E889AC              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  8060                              <1> 
  8061 00006BBB B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  8062 00006BBD E8E8AC              <1> 	call	kbc_send_cmd_byte
  8063 00006BC0 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  8064 00006BC2 E87FAC              <1> 	call	kbc_kb_send
  8065 00006BC5 EBA4                <1> 	jmp	keyboard_int_exit1
  8066                              <1> 
  8067                                  %include	"floppy2.inc"		; INT 13
  8068                              <1> ;=========================================================================
  8069                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  8070                              <1> ;       INT 13h, function AH=02h
  8071                              <1> ;       INT 13h, function AH=03h
  8072                              <1> ;       INT 13h, function AH=04h
  8073                              <1> ;       INT 13h, function AH=05h
  8074                              <1> ;	- see floppy1.inc for other INT 13h functions
  8075                              <1> ;-------------------------------------------------------------------------
  8076                              <1> ;
  8077                              <1> ; Compiles with NASM 2.07, might work with other versions
  8078                              <1> ;
  8079                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8080                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8081                              <1> ;
  8082                              <1> ; This program is free software: you can redistribute it and/or modify
  8083                              <1> ; it under the terms of the GNU General Public License as published by
  8084                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8085                              <1> ; (at your option) any later version.
  8086                              <1> ;
  8087                              <1> ; This program is distributed in the hope that it will be useful,
  8088                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8089                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8090                              <1> ; GNU General Public License for more details.
  8091                              <1> ;
  8092                              <1> ; You should have received a copy of the GNU General Public License
  8093                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8094                              <1> ;
  8095                              <1> ;=========================================================================
  8096                              <1> 
  8097                              <1> ;-------------------------------------------------------------------------
  8098                              <1> ; offsets for registers on stack
  8099                              <1> int_13_bp	equ	0
  8100                              <1> int_13_ds	equ	int_13_bp+2
  8101                              <1> int_13_di	equ	int_13_ds+2
  8102                              <1> int_13_si	equ	int_13_di+2
  8103                              <1> int_13_dx	equ	int_13_si+2
  8104                              <1> int_13_dl	equ	int_13_dx
  8105                              <1> int_13_dh	equ	int_13_dx+1
  8106                              <1> int_13_cx	equ	int_13_dx+2
  8107                              <1> int_13_cl	equ	int_13_cx
  8108                              <1> int_13_ch	equ	int_13_cx+1
  8109                              <1> int_13_bx	equ	int_13_cx+2
  8110                              <1> int_13_bl	equ	int_13_bx
  8111                              <1> int_13_bh	equ	int_13_bx+1
  8112                              <1> int_13_ax	equ	int_13_bx+2
  8113                              <1> int_13_al	equ	int_13_ax
  8114                              <1> int_13_ah	equ	int_13_ax+1
  8115                              <1> int_13_ip	equ	int_13_ax+2
  8116                              <1> int_13_cs	equ	int_13_ip+2
  8117                              <1> int_13_flags	equ	int_13_cs+2
  8118                              <1> int_13_flags_l	equ	int_13_flags
  8119                              <1> 
  8120                              <1> ;=========================================================================
  8121                              <1> ; int_13 - BIOS floppy disk services
  8122                              <1> ; Input:
  8123                              <1> ;	AH = function
  8124                              <1> ;		00h - Reset disk system
  8125                              <1> ;		01h - Get status of last operation
  8126                              <1> ;		02h - Read disk sectors
  8127                              <1> ;		03h - Write disk sectors
  8128                              <1> ;		04h - Verify disk sectors
  8129                              <1> ;		05h - Format track
  8130                              <1> ;		08h - Get drive parameters
  8131                              <1> ;		15h - Get disk type
  8132                              <1> ;		16h - Detect disk change
  8133                              <1> ;		17h - Set disk type for format
  8134                              <1> ;		18h - Set media type for format
  8135                              <1> ; Output:
  8136                              <1> ;	- depends on function
  8137                              <1> ;	- for most functions:
  8138                              <1> ;		CF clear if successful
  8139                              <1> ;			AH = 00h - successful completion
  8140                              <1> ;		CF set on error
  8141                              <1> ;			AH = error code
  8142                              <1> ;-------------------------------------------------------------------------
  8143 00006BC7 FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  8144          ******************  <1>  warning: (setloc:7) Inserting 146 bytes
  8145                              <1> int_13:
  8146 00006C59 FB                  <1> 	sti
  8147 00006C5A 50                  <1> 	push	ax
  8148 00006C5B 53                  <1> 	push	bx
  8149 00006C5C 51                  <1> 	push	cx
  8150 00006C5D 52                  <1> 	push	dx
  8151 00006C5E 56                  <1> 	push	si
  8152 00006C5F 57                  <1> 	push	di
  8153 00006C60 1E                  <1> 	push	ds
  8154 00006C61 55                  <1> 	push	bp
  8155 00006C62 89E5                <1> 	mov	bp,sp
  8156 00006C64 80FC19              <1> 	cmp	ah,.num_func
  8157 00006C67 7743                <1> 	ja	.invalid_function
  8158 00006C69 88E0                <1> 	mov	al,ah
  8159 00006C6B 98                  <1> 	cbw
  8160 00006C6C 89C7                <1> 	mov	di,ax
  8161 00006C6E D1E7                <1> 	shl	di,1
  8162 00006C70 B84000              <1> 	mov	ax,biosdseg
  8163 00006C73 8ED8                <1> 	mov	ds,ax
  8164 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  8165                              <1> 
  8166                              <1> .dispatch:
  8167 00006C7A [3410]              <1> 	dw	int_13_fn00		; Reset disk system
  8168 00006C7C [A310]              <1> 	dw	int_13_fn01		; Get status of last operation
  8169 00006C7E [EF6C]              <1> 	dw	int_13_fn02		; Read disk sectors
  8170 00006C80 [EF6C]              <1> 	dw	int_13_fn03		; Write disk sectors
  8171 00006C82 [EF6C]              <1> 	dw	int_13_fn04		; Verify disk sectors
  8172 00006C84 [5D6E]              <1> 	dw	int_13_fn05		; Format track
  8173 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  8174 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  8175 00006C8A [AF10]              <1> 	dw	int_13_fn08		; Get drive parameters
  8176 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  8177 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  8178 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  8179 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  8180 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  8181 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  8182 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  8183 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  8184 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  8185 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  8186 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  8187 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  8188 00006CA4 [5C11]              <1> 	dw	int_13_fn15		; Get disk type
  8189 00006CA6 [7D11]              <1> 	dw	int_13_fn16		; Detect disk change
  8190 00006CA8 [C911]              <1> 	dw	int_13_fn17		; Set disk type for format
  8191 00006CAA [3412]              <1> 	dw	int_13_fn18		; Set media type for format
  8192                              <1> .num_func	equ ($-.dispatch)/2
  8193                              <1> 
  8194                              <1> .invalid_function:
  8195 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  8196 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  8197 00006CB2 F9                  <1> 	stc				; error condition
  8198 00006CB3 EB21                <1> 	jmp	int_13_exit
  8199                              <1> 
  8200                              <1> ;-------------------------------------------------------------------------
  8201                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  8202                              <1> 
  8203                              <1> int_13_upd_exit:
  8204 00006CB5 9C                  <1> 	pushf
  8205 00006CB6 50                  <1> 	push	ax
  8206 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  8207 00006CBA 3C01                <1> 	cmp	al,1
  8208 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  8209 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  8210 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  8211 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  8212 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  8213 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  8214 00006CCA 08C0                <1> 	or	al,al
  8215 00006CCC 7402                <1> 	jz	.drive_0
  8216 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  8217                              <1> 
  8218                              <1> .drive_0:
  8219 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  8220                              <1> 
  8221                              <1> .no_update:
  8222 00006CD4 58                  <1> 	pop	ax
  8223 00006CD5 9D                  <1> 	popf
  8224                              <1> 
  8225                              <1> int_13_exit:
  8226 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  8227 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  8228 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  8229 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  8230 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  8231                              <1> 
  8232                              <1> .set_error:
  8233 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  8234 00006CE6 5D                  <1> 	pop	bp
  8235 00006CE7 1F                  <1> 	pop	ds
  8236 00006CE8 5F                  <1> 	pop	di
  8237 00006CE9 5E                  <1> 	pop	si
  8238 00006CEA 5A                  <1> 	pop	dx
  8239 00006CEB 59                  <1> 	pop	cx
  8240 00006CEC 5B                  <1> 	pop	bx
  8241 00006CED 58                  <1> 	pop	ax
  8242 00006CEE CF                  <1> 	iret
  8243                              <1> 
  8244                              <1> ;=========================================================================
  8245                              <1> ; int_13_fn02 - Read disk sectors
  8246                              <1> ; int_13_fn03 - Write disk sectors
  8247                              <1> ; int_13_fn04 - Verify disk sectors
  8248                              <1> ; Input:
  8249                              <1> ;	AH = function
  8250                              <1> ;		02h - read
  8251                              <1> ;		03h - write
  8252                              <1> ;		04h - verify
  8253                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  8254                              <1> ;	CH = cylinder number
  8255                              <1> ;	CL = sector number
  8256                              <1> ;	DH = head number (0 or 1)
  8257                              <1> ;	DL = drive number (0 or 1)
  8258                              <1> ;	ES:BX -> data buffer
  8259                              <1> ; Output:
  8260                              <1> ;	CF clear if successful
  8261                              <1> ;		AH = 00h - successful completion
  8262                              <1> ;		AL = number of sectors transferred or verified
  8263                              <1> ;	CF set on error
  8264                              <1> ;		AH = error code
  8265                              <1> ;-------------------------------------------------------------------------
  8266                              <1> int_13_fn02:
  8267                              <1> int_13_fn03:
  8268                              <1> int_13_fn04:
  8269 00006CEF 80FA01              <1> 	cmp	dl,1
  8270 00006CF2 7603E94801          <1> 	ja	.invalid_drive
  8271 00006CF7 BE9000              <1> 	mov	si,fdc_media_state
  8272 00006CFA 52                  <1> 	push	dx
  8273 00006CFB B600                <1> 	mov	dh,00h
  8274 00006CFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  8275 00006CFF 5A                  <1> 	pop	dx
  8276                              <1> 
  8277 00006D00 E881A9              <1> 	call	read_cmos_type		; get drive type in AL
  8278 00006D03 7303E93701          <1> 	jc	.invalid_drive
  8279                              <1> 
  8280 00006D08 BF3F00              <1> 	mov	di,fdc_motor_state
  8281 00006D0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  8282 00006D0E 80FC03              <1> 	cmp	ah,03h			; write function
  8283 00006D11 7503                <1> 	jne	.motor_on		; jump if not write function
  8284 00006D13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  8285                              <1> 
  8286                              <1> .motor_on:
  8287 00006D16 E8DCA6              <1> 	call	fdc_motor_on
  8288 00006D19 3C01                <1> 	cmp	al,cmos_360
  8289 00006D1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  8290 00006D20 3C03                <1> 	cmp	al,cmos_720
  8291 00006D22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  8292                              <1> 
  8293 00006D27 E885A7              <1> 	call	fdc_disk_change
  8294 00006D2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  8295                              <1> 
  8296 00006D2F F60410              <1> 	test	byte [si],fdc_m_established
  8297 00006D32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  8298                              <1> 
  8299 00006D37 E83AAA              <1> 	call	fdc_select_rate		; select transfer rate
  8300                              <1> 	
  8301                              <1> .fdc_send_specify:
  8302 00006D3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  8303                              <1> 					; 0BFh - specify byte 0 for 1.44M
  8304 00006D3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  8305 00006D40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  8306 00006D42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  8307 00006D44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  8308 00006D47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  8309 00006D49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  8310                              <1> 
  8311                              <1> .fdc_send_specify_cmd:
  8312 00006D4B BE0200              <1> 	mov	si,2			; specify byte 1
  8313 00006D4E B103                <1> 	mov	cl,3			; 3 bytes command
  8314 00006D50 E802A8              <1> 	call	fdc_send_cmd
  8315 00006D53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  8316 00006D58 1E                  <1> 	push	ds
  8317 00006D59 31F6                <1> 	xor	si,si
  8318 00006D5B 8EDE                <1> 	mov	ds,si
  8319 00006D5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8320 00006D61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  8321 00006D64 B400                <1> 	mov	ah,00h
  8322 00006D66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  8323 00006D68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  8324 00006D6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  8325 00006D6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  8326 00006D70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  8327 00006D72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  8328                              <1> 
  8329                              <1> .calc_dma_count:
  8330 00006D75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  8331 00006D78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  8332 00006D7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  8333 00006D7D 1F                  <1> 	pop	ds
  8334 00006D7E 48                  <1> 	dec	ax			; minus one byte
  8335 00006D7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  8336                              <1> 
  8337 00006D81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  8338 00006D84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  8339 00006D86 80FC02              <1> 	cmp	ah,02h			; read function?
  8340 00006D89 7409                <1> 	je	.configure_dma		; jump if read function
  8341 00006D8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8342 00006D8D 80FC03              <1> 	cmp	ah,03h			; write function?
  8343 00006D90 7402                <1> 	je	.configure_dma		; jump if write function
  8344 00006D92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  8345                              <1> 
  8346                              <1> .configure_dma:
  8347 00006D94 E860A7              <1> 	call	fdc_configure_dma
  8348 00006D97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  8349 00006D9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  8350                              <1> 
  8351 00006D9F E89CA5              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8352 00006DA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8353                              <1> 
  8354 00006DA7 1E                  <1> 	push	ds
  8355 00006DA8 31C0                <1> 	xor	ax,ax
  8356 00006DAA 8ED8                <1> 	mov	ds,ax
  8357 00006DAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8358 00006DB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  8359 00006DB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  8360 00006DB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  8361 00006DB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  8362 00006DBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  8363 00006DBD 1F                  <1> 	pop	ds
  8364                              <1> 
  8365 00006DBE BE9000              <1> 	mov	si,fdc_media_state
  8366 00006DC1 B600                <1> 	mov	dh,00h
  8367 00006DC3 01D6                <1> 	add	si,dx
  8368 00006DC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  8369 00006DC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  8370 00006DC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  8371 00006DCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  8372 00006DCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  8373 00006DD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  8374 00006DD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  8375 00006DD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  8376 00006DD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  8377 00006DDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  8378 00006DDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  8379 00006DDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  8380                              <1> 	
  8381                              <1> .gap_set:
  8382 00006DE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  8383 00006DE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  8384 00006DE7 88F4                <1> 	mov	ah,dh			; head
  8385 00006DE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  8386 00006DEB D0E4                <1> 	shl	ah,1
  8387 00006DED D0E4                <1> 	shl	ah,1
  8388 00006DEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  8389 00006DF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  8390 00006DF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  8391 00006DF7 7502                <1> 	jne	.send_command		; jump if not write 
  8392 00006DF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  8393                              <1> 
  8394                              <1> .send_command:
  8395 00006DFB B109                <1> 	mov	cl,9			; 9 bytes command
  8396 00006DFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8397 00006E02 E850A7              <1> 	call	fdc_send_cmd
  8398 00006E05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  8399 00006E07 E89CA9              <1> 	call	fdc_wait_irq
  8400 00006E0A 7228                <1> 	jc	.error_fdc_get_result
  8401 00006E0C B107                <1> 	mov	cl,7
  8402 00006E0E E8A9A7              <1> 	call	fdc_get_result		; read result bytes
  8403 00006E11 7228                <1> 	jc	.error_end_io
  8404                              <1> 
  8405 00006E13 E8F9A7              <1> 	call	fdc_get_error
  8406                              <1> 
  8407                              <1> .exit_end_io:
  8408 00006E16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  8409                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  8410 00006E19 E868A6              <1> 	call	fdc_end_io		; return number of last sector in BL
  8411 00006E1C 08C0                <1> 	or	al,al
  8412 00006E1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  8413 00006E20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  8414 00006E22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  8415                              <1> 
  8416                              <1> .zero_sectors:
  8417 00006E25 08E4                <1> 	or	ah,ah
  8418 00006E27 7401                <1> 	jz	.exit			; jump if no errors
  8419                              <1> 
  8420                              <1> .error:
  8421 00006E29 F9                  <1> 	stc				; indicate error
  8422                              <1> 
  8423                              <1> .exit:
  8424 00006E2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  8425 00006E2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  8426 00006E31 E981FE              <1> 	jmp	int_13_upd_exit
  8427                              <1> 
  8428                              <1> .error_fdc_get_result:
  8429 00006E34 B107                <1> 	mov	cl,7
  8430 00006E36 50                  <1> 	push	ax
  8431 00006E37 E880A7              <1> 	call	fdc_get_result		; read result bytes
  8432 00006E3A 58                  <1> 	pop	ax
  8433                              <1> 
  8434                              <1> .error_end_io:
  8435 00006E3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  8436 00006E3D EBD7                <1> 	jmp	.exit_end_io
  8437                              <1> 
  8438                              <1> .invalid_drive:
  8439 00006E3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  8440 00006E42 EBE5                <1> 	jmp	.error
  8441                              <1> 
  8442                              <1> ; 360K and 720K drives don't support change line, and only support
  8443                              <1> ; one media type - set it here
  8444                              <1> 
  8445                              <1> .set_media_360:
  8446 00006E44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  8447 00006E46 EB02                <1> 	jmp	.set_media
  8448                              <1> 
  8449                              <1> .set_media_720:
  8450 00006E48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  8451                              <1> 
  8452                              <1> .set_media:
  8453 00006E4A 8804                <1> 	mov	byte [si],al		; save media state
  8454 00006E4C E84CA9              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  8455 00006E4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  8456 00006E52 E9E5FE              <1> 	jmp	.fdc_send_specify
  8457                              <1> 
  8458                              <1> ; establish media type
  8459                              <1> 
  8460                              <1> .establish_media:
  8461 00006E55 E84FA8              <1> 	call	fdc_detect_media
  8462 00006E58 72E1                <1> 	jc	.error_end_io
  8463 00006E5A E9DDFE              <1> 	jmp	.fdc_send_specify
  8464                              <1> 	
  8465                              <1> 
  8466                              <1> ;=========================================================================
  8467                              <1> ; int_13_fn05 - Format track
  8468                              <1> ; Input:
  8469                              <1> ;	AH = 05h
  8470                              <1> ;	CH = track number
  8471                              <1> ;	DH = head number (0 or 1)
  8472                              <1> ;	DL = drive number (0 or 1)
  8473                              <1> ;	ES:BX -> address field buffer
  8474                              <1> ; Output:
  8475                              <1> ;	CF clear if successful
  8476                              <1> ;		AH = 00h - successful completion
  8477                              <1> ;	CF set on error
  8478                              <1> ;		AH = error code 
  8479                              <1> ;-------------------------------------------------------------------------
  8480                              <1> int_13_fn05:
  8481 00006E5D 80FA01              <1> 	cmp	dl,1
  8482 00006E60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  8483 00006E65 E81CA8              <1> 	call	read_cmos_type		; get drive type in AL
  8484 00006E68 7303E99500          <1> 	jc	.invalid_drive
  8485 00006E6D BE9000              <1> 	mov	si,fdc_media_state
  8486 00006E70 52                  <1> 	push	dx
  8487 00006E71 B600                <1> 	mov	dh,00h
  8488 00006E73 01D6                <1> 	add	si,dx			; SI -> drive media state
  8489 00006E75 5A                  <1> 	pop	dx
  8490 00006E76 803C00              <1> 	cmp	byte [si],0
  8491 00006E79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  8492 00006E7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  8493 00006E83 E86FA5              <1> 	call	fdc_motor_on
  8494 00006E86 E826A6              <1> 	call	fdc_disk_change		; read disk change line
  8495 00006E89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  8496 00006E8B E8E6A8              <1> 	call	fdc_select_rate		; select transfer rate
  8497 00006E8E E8F3A1              <1> 	call	fdc_send_specify	; send FDC Specify command
  8498 00006E91 1E                  <1> 	push	ds
  8499 00006E92 31F6                <1> 	xor	si,si
  8500 00006E94 8EDE                <1> 	mov	ds,si
  8501 00006E96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8502 00006E9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  8503 00006E9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  8504 00006EA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  8505 00006EA3 1F                  <1> 	pop	ds
  8506 00006EA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  8507 00006EA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  8508 00006EA8 D1E1                <1> 	shl	cx,1
  8509 00006EAA 49                  <1> 	dec	cx	 		; minus one byte...
  8510 00006EAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8511 00006EAD E847A6              <1> 	call	fdc_configure_dma
  8512 00006EB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  8513 00006EB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  8514 00006EB5 56                  <1> 	push	si
  8515 00006EB6 E885A4              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8516 00006EB9 5E                  <1> 	pop	si
  8517 00006EBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8518                              <1> 
  8519 00006EBC 88F4                <1> 	mov	ah,dh
  8520 00006EBE D0E4                <1> 	shl	ah,1
  8521 00006EC0 D0E4                <1> 	shl	ah,1
  8522 00006EC2 08D4                <1> 	or	ah,dl
  8523 00006EC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  8524                              <1> 
  8525 00006EC6 B106                <1> 	mov	cl,6			; 6 byte command
  8526 00006EC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8527 00006ECD E885A6              <1> 	call	fdc_send_cmd
  8528 00006ED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  8529 00006ED2 E8D1A8              <1> 	call	fdc_wait_irq
  8530 00006ED5 720A                <1> 	jc	.exit_end_io
  8531 00006ED7 B107                <1> 	mov	cl,7
  8532 00006ED9 E8DEA6              <1> 	call	fdc_get_result		; read result bytes
  8533 00006EDC 7203                <1> 	jc	.exit_end_io
  8534 00006EDE E82EA7              <1> 	call	fdc_get_error		; get error code
  8535                              <1> 
  8536                              <1> .exit_end_io:
  8537 00006EE1 E8A0A5              <1> 	call	fdc_end_io
  8538 00006EE4 08E4                <1> 	or	ah,ah
  8539 00006EE6 7401                <1> 	jz	.exit			; jump if no errors
  8540                              <1> 
  8541                              <1> .error:
  8542 00006EE8 F9                  <1> 	stc				; indicate error
  8543                              <1> 
  8544                              <1> .exit:
  8545 00006EE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  8546 00006EED E9C5FD              <1> 	jmp	int_13_upd_exit
  8547                              <1> 
  8548                              <1> .error_fdc_get_result:
  8549 00006EF0 B107                <1> 	mov	cl,7
  8550 00006EF2 50                  <1> 	push	ax
  8551 00006EF3 E8C4A6              <1> 	call	fdc_get_result		; read result bytes
  8552 00006EF6 58                  <1> 	pop	ax
  8553 00006EF7 EBE8                <1> 	jmp	.exit_end_io
  8554                              <1> 
  8555                              <1> .error_end_io:
  8556 00006EF9 E888A5              <1> 	call	fdc_end_io
  8557 00006EFC EBEA                <1> 	jmp	.error
  8558                              <1> 
  8559                              <1> .timeout:
  8560 00006EFE B480                <1> 	mov	ah,fdc_e_timeout
  8561 00006F00 EBE6                <1> 	jmp	.error
  8562                              <1> 
  8563                              <1> .invalid_drive:
  8564 00006F02 B401                <1> 	mov	ah,fdc_e_invalid
  8565 00006F04 EBE2                <1> 	jmp	.error
  8566                              <1> 
  8567                              <1> ;=========================================================================
  8568                              <1> ; int_0E - IRQ6 (FDC) service routine
  8569                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  8570                              <1> ;-------------------------------------------------------------------------
  8571 00006F06 FF<rept>            <1> 	setloc	0EF57h
  8572          ******************  <1>  warning: (setloc:7) Inserting 81 bytes
  8573                              <1> 
  8574                              <1> int_0E:
  8575 00006F57 50                  <1> 	push	ax
  8576 00006F58 1E                  <1> 	push	ds
  8577 00006F59 B84000              <1> 	mov	ax,biosdseg
  8578 00006F5C 8ED8                <1> 	mov	ds,ax
  8579 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  8580 00006F63 1F                  <1> 	pop	ds
  8581 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  8582 00006F66 E620                <1> 	out	pic1_reg0,al
  8583 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  8584 00006F6B CD15                <1> 	int	15h
  8585 00006F6D 58                  <1> 	pop	ax
  8586 00006F6E CF                  <1> 	iret
  8587                              <1> 
  8588                              <1> ;=========================================================================
  8589                              <1> ; Disk parameter tables in INT 1Eh format
  8590                              <1> ; Byte 0: First byte for specify command:
  8591                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  8592                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  8593                              <1> ; Byte 1: Second byte for specify command:
  8594                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  8595                              <1> ;	bit 0: non-DMA mode (always 0)
  8596                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  8597                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  8598                              <1> ; Byte 4: sectors per track
  8599                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  8600                              <1> ; Byte 6: special sector size (0FFh - not used)
  8601                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  8602                              <1> ; Byte 8: format filler byte (default 0F6h)
  8603                              <1> ; Byte 9: head settle time in milliseconds
  8604                              <1> ; Byte A: motor start time, in 1/8 seconds
  8605                              <1> ; Byte B: number of cylinders minus one
  8606                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  8607                              <1> ;-------------------------------------------------------------------------
  8608                              <1> media_360_in_360:
  8609 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8610 00006F78 0F08                <1>
  8611 00006F7A 2780                <1> 	db	27h, 80h
  8612                              <1> media_1200:
  8613 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  8614 00006F85 0F08                <1>
  8615 00006F87 4F00                <1> 	db	4Fh, 00h
  8616                              <1> media_720:
  8617 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8618 00006F92 0F08                <1>
  8619 00006F94 4F80                <1> 	db	4Fh, 80h
  8620                              <1> media_1440:
  8621 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  8622 00006F9F 0F08                <1>
  8623 00006FA1 4F00                <1> 	db	4Fh, 00h
  8624                              <1> media_360_in_1200:
  8625 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  8626 00006FAC 0F08                <1>
  8627 00006FAE 2740                <1> 	db	27h, 40h
  8628                              <1> media_2880:
  8629 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8630 00006FB9 0F08                <1>
  8631 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  8632                              <1> 
  8633                              <1> ;=========================================================================
  8634                              <1> ; Disk parameter table for IBM compatibility
  8635                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  8636                              <1> ;-------------------------------------------------------------------------
  8637 00006FBD FF<rept>            <1> 	setloc	0EFC7h
  8638          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  8639                              <1> int_1E:
  8640 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8641 00006FD0 0F08                <1>
  8642                                  %include	"printer2.inc"		; INT 17
  8643                              <1> ;=========================================================================
  8644                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  8645                              <1> ;       INT 17h, function AH=00h
  8646                              <1> ;	INT 17h, function AH=02h
  8647                              <1> ;	- see printer1.inc for other INT 17h functions
  8648                              <1> ;-------------------------------------------------------------------------
  8649                              <1> ;
  8650                              <1> ; Compiles with NASM 2.07, might work with other versions
  8651                              <1> ;
  8652                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8653                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8654                              <1> ;
  8655                              <1> ; This program is free software: you can redistribute it and/or modify
  8656                              <1> ; it under the terms of the GNU General Public License as published by
  8657                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8658                              <1> ; (at your option) any later version.
  8659                              <1> ;
  8660                              <1> ; This program is distributed in the hope that it will be useful,
  8661                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8662                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8663                              <1> ; GNU General Public License for more details.
  8664                              <1> ;
  8665                              <1> ; You should have received a copy of the GNU General Public License
  8666                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8667                              <1> ;
  8668                              <1> ;=========================================================================
  8669                              <1> 
  8670                              <1> ;=========================================================================
  8671                              <1> ; int_17  - BIOS Printer Services
  8672                              <1> ;-------------------------------------------------------------------------
  8673                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  8674                              <1> int_17:
  8675 00006FD2 FB                  <1> 	sti
  8676 00006FD3 53                  <1> 	push	bx
  8677 00006FD4 52                  <1> 	push	dx
  8678 00006FD5 56                  <1> 	push	si
  8679 00006FD6 1E                  <1> 	push	ds
  8680 00006FD7 BB4000              <1> 	mov	bx,biosdseg
  8681 00006FDA 8EDB                <1> 	mov	ds,bx
  8682 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
  8683 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  8684 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  8685 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  8686 00006FE6 89D3                <1> 	mov	bx,dx
  8687 00006FE8 D1E3                <1> 	shl	bx,1
  8688 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  8689 00006FED 09D2                <1> 	or	dx,dx
  8690 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  8691                              <1> 
  8692 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  8693                              <1> 
  8694 00006FF3 08E4                <1> 	or	ah,ah
  8695 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  8696 00006FF7 FECC                <1> 	dec	ah
  8697 00006FF9 7503E9AEAF          <1> 	jz	int_17_fn01		; AH = 01h
  8698 00006FFE FECC                <1> 	dec	ah
  8699 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  8700                              <1> 
  8701                              <1> int_17_exit:
  8702 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  8703 00007005 88D8                <1> 	mov	al,bl			; restore AL
  8704                              <1> 
  8705                              <1> int_17_error:
  8706 00007007 1F                  <1> 	pop	ds
  8707 00007008 5E                  <1> 	pop	si
  8708 00007009 5A                  <1> 	pop	dx
  8709 0000700A 5B                  <1> 	pop	bx
  8710 0000700B CF                  <1> 	iret
  8711                              <1> 
  8712                              <1> ;=========================================================================
  8713                              <1> ; int_17_fn00 - Print character
  8714                              <1> ; Input:
  8715                              <1> ;	AH = 0 - function 00h - print character
  8716                              <1> ;	AL = character to print
  8717                              <1> ;	DX = printer port number (0-2)
  8718                              <1> ; Output:
  8719                              <1> ;	AH = printer status:
  8720                              <1> ;		bit 0	= 1	- timeout error
  8721                              <1> ;		bit 1,2		- reserved
  8722                              <1> ;		bit 3	= 1	- I/O error
  8723                              <1> ;		bit 4	= 1	- printed selected
  8724                              <1> ;		bit 5	= 1	- out of paper
  8725                              <1> ;		bit 6	= 1	- acknowledge from printer
  8726                              <1> ;		bit 7	= 1	- printer not busy
  8727                              <1> ;-------------------------------------------------------------------------
  8728                              <1> int_17_fn00:
  8729 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  8730 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8731                              <1> 					; OPTIMIZATION:
  8732                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8733 0000700E EC                  <1> 	in	al,dx			; read status
  8734 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  8735 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  8736 00007014 750C                <1>         jnz     .not_busy
  8737                              <1> 
  8738 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  8739 00007019 CD15                <1> 	int	15h			; call OS hook
  8740                              <1> 
  8741 0000701B B780                <1> 	mov	bh,prn_stat_busy
  8742 0000701D E8B1AE              <1> 	call	wait_for_port		; wait for printer to be ready
  8743 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  8744                              <1> 
  8745                              <1> .not_busy:
  8746 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  8747                              <1> 					; OPTIMIZATION:
  8748                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  8749 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  8750 00007025 EE                  <1> 	out	dx,al			; activate strobe
  8751 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  8752 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  8753 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  8754 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  8755 0000702E EBD2                <1> 	jmp	int_17_exit
  8756                              <1> 
  8757                              <1> .timeout:
  8758 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  8759 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  8760 00007036 EBCA                <1> 	jmp	int_17_exit
  8761                              <1> 
  8762                              <1> ;=========================================================================
  8763                              <1> ; int_17_fn02 - Return printer status
  8764                              <1> ; Input:
  8765                              <1> ;	AH = 2 - function 02h - return printer status
  8766                              <1> ;	DX = printer port number (0-2)
  8767                              <1> ; Output:
  8768                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  8769                              <1> ;-------------------------------------------------------------------------
  8770                              <1> int_17_fn02:
  8771 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8772                              <1> 					; OPTIMIZATION:
  8773                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8774                              <1> int_17_status:
  8775 00007039 EC                  <1> 	in	al,dx			; read the status
  8776 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  8777 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  8778 0000703F EBC1                <1> 	jmp	int_17_exit
  8779                                  %include	"video.inc"		; INT 10
  8780                              <1> ;=========================================================================
  8781                              <1> ; video.inc - BIOS video services
  8782                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  8783                              <1> ;-------------------------------------------------------------------------
  8784                              <1> ;
  8785                              <1> ; Compiles with NASM 2.07, might work with other versions
  8786                              <1> ;
  8787                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  8788                              <1> ;
  8789                              <1> ; This program is free software: you can redistribute it and/or modify
  8790                              <1> ; it under the terms of the GNU General Public License as published by
  8791                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8792                              <1> ; (at your option) any later version.
  8793                              <1> ;
  8794                              <1> ; This program is distributed in the hope that it will be useful,
  8795                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8796                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8797                              <1> ; GNU General Public License for more details.
  8798                              <1> ;
  8799                              <1> ; You should have received a copy of the GNU General Public License
  8800                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8801                              <1> ;
  8802                              <1> ;=========================================================================
  8803                              <1> 
  8804                              <1> ;-------------------------------------------------------------------------
  8805                              <1> ; CRTC registers
  8806                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  8807                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  8808                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  8809                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  8810                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  8811                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  8812                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  8813                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  8814                              <1> 
  8815                              <1> ;-------------------------------------------------------------------------
  8816                              <1> ; control characters
  8817                              <1> bel	equ	07h
  8818                              <1> bs	equ	08h
  8819                              <1> lf	equ	0Ah
  8820                              <1> cr	equ	0Dh
  8821                              <1> 
  8822 00007041 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  8823          ******************  <1>  warning: (setloc:7) Inserting 4 bytes
  8824                              <1> 
  8825                              <1> int_10_dispatch:
  8826 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
  8827 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  8828 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
  8829 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  8830 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
  8831 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
  8832 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
  8833 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
  8834 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
  8835 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
  8836 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
  8837 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
  8838 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  8839 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  8840 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
  8841 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
  8842                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  8843                              <1> 
  8844                              <1> 
  8845                              <1> ;-------------------------------------------------------------------------
  8846                              <1> ; offsets for registers on stack
  8847                              <1> 
  8848                              <1> int_10_ax	equ	0
  8849                              <1> int_10_al	equ	int_10_ax
  8850                              <1> int_10_ah	equ	int_10_ax+1
  8851                              <1> int_10_bx	equ	int_10_ax+2
  8852                              <1> int_10_bl	equ	int_10_bx
  8853                              <1> int_10_bh	equ	int_10_bx+1
  8854                              <1> int_10_cx	equ	int_10_bx+2
  8855                              <1> int_10_ch	equ	int_10_cx+1
  8856                              <1> int_10_dx	equ	int_10_cx+2
  8857                              <1> 
  8858                              <1> ;=========================================================================
  8859                              <1> ; int_10 - BIOS video services
  8860                              <1> ; Input:
  8861                              <1> ;	AH - Function
  8862                              <1> ;		00h - Set video mode
  8863                              <1> ;		01h - Set text mode cursor shape
  8864                              <1> ;		02h - Set cursor position
  8865                              <1> ;		03h - Get cursor position and shape
  8866                              <1> ;		04h - Read light pen position
  8867                              <1> ;		05h - Select active display page
  8868                              <1> ;		06h - Scroll up window
  8869                              <1> ;		07h - Scroll down window
  8870                              <1> ;		08h - Read character and attribute at cursor position
  8871                              <1> ;		09h - Write character and attribute at cursor position
  8872                              <1> ;		0Ah - Write character only at cursor position
  8873                              <1> ;		0Bh -
  8874                              <1> ;			BH = 00h - Set background/border color
  8875                              <1> ;			BH = 01h - Set palette
  8876                              <1> ;		0Ch - Write graphics pixel
  8877                              <1> ;		0Dh - Read graphics pixel
  8878                              <1> ;		0Eh - Teletype output
  8879                              <1> ;		0Fh - Get current video mode
  8880                              <1> ;-------------------------------------------------------------------------
  8881                              <1> 	setloc	0F065h			; int 10 Entry Point
  8882                              <1> int_10:
  8883 00007065 FB                  <1> 	sti
  8884 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  8885 00007067 55                  <1> 	push	bp
  8886 00007068 06                  <1> 	push	es
  8887 00007069 1E                  <1> 	push	ds
  8888 0000706A 56                  <1> 	push	si
  8889 0000706B 57                  <1> 	push	di
  8890 0000706C 52                  <1> 	push	dx
  8891 0000706D 51                  <1> 	push	cx
  8892 0000706E 53                  <1> 	push	bx
  8893 0000706F 50                  <1> 	push	ax
  8894 00007070 BB4000              <1> 	mov	bx,biosdseg
  8895 00007073 8EDB                <1> 	mov	ds,bx
  8896 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  8897 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  8898 0000707C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  8899 0000707F 7202                <1> 	jb	.color			; it is CGA
  8900 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  8901                              <1> 
  8902                              <1> .color:
  8903 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  8904 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  8905 00007087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  8906 0000708A 730B                <1> 	jae	.exit			; invalid function
  8907 0000708C B700                <1> 	mov	bh,0
  8908 0000708E 88E3                <1> 	mov	bl,ah
  8909 00007090 D1E3                <1> 	shl	bx,1
  8910 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  8911                              <1> 
  8912                              <1> .exit:
  8913 00007097 58                  <1> 	pop	ax
  8914 00007098 5B                  <1> 	pop	bx
  8915 00007099 59                  <1> 	pop	cx
  8916 0000709A 5A                  <1> 	pop	dx
  8917 0000709B 5F                  <1> 	pop	di
  8918 0000709C 5E                  <1> 	pop	si
  8919 0000709D 1F                  <1> 	pop	ds
  8920 0000709E 07                  <1> 	pop	es
  8921 0000709F 5D                  <1> 	pop	bp
  8922 000070A0 CF                  <1> 	iret
  8923                              <1> 
  8924                              <1> 
  8925                              <1> ;=========================================================================
  8926                              <1> ; int_1D - Video parameters tables
  8927                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  8928                              <1> ; video mode initialization
  8929                              <1> ;-------------------------------------------------------------------------
  8930 000070A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  8931          ******************  <1>  warning: (setloc:7) Inserting 3 bytes
  8932                              <1> int_1D:
  8933                              <1> 	; CGA test 40x25 modes
  8934 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  8935 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8936                              <1> 
  8937                              <1> 	; CGA text 80x25 modes
  8938 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  8939 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8940                              <1> 
  8941                              <1> 	; CGA graphics modes
  8942 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  8943 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  8944                              <1> 
  8945                              <1> 	; MDA text 80x25 mode
  8946 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  8947 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  8948                              <1> 
  8949                              <1> page_size:
  8950 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  8951 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  8952 000070E8 0040                <1> 	dw	4000h			; graphics modes
  8953 000070EA 0040                <1> 	dw	4000h
  8954                              <1> 
  8955                              <1> columns:
  8956 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  8957 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  8958 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  8959 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  8960                              <1> 
  8961 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  8962                              <1> 
  8963 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  8964                              <1> 
  8965                              <1> ;=========================================================================
  8966                              <1> ; int_10_fn00 - Set video mode
  8967                              <1> ; Input:
  8968                              <1> ;	AH = 00h
  8969                              <1> ;	AL = video mode
  8970                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  8971                              <1> ;		01h - CGA - text 40x25, 16 colors
  8972                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  8973                              <1> ;		03h - CGA - text 80x25, 16 colors
  8974                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  8975                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  8976                              <1> ;		06h - CGA - graphics 640x200, monochrome
  8977                              <1> ;		07h - MDA - text 80x25, monochrome
  8978                              <1> ;-------------------------------------------------------------------------
  8979                              <1> int_10_fn00:
  8980 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  8981 00007107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  8982 0000710A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  8983 0000710D B000                <1> 	mov	al,0
  8984 0000710F 80FB07              <1> 	cmp	bl,07h
  8985 00007112 7206                <1> 	jb	.color			; jump if monochrome mode
  8986 00007114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  8987 00007116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  8988 00007118 FEC0                <1> 	inc	al
  8989                              <1> 
  8990                              <1> .color:
  8991 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  8992 0000711C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  8993 00007120 80C204              <1> 	add	dl,4
  8994 00007123 EE                  <1> 	out	dx,al			; Reset the video
  8995 00007124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  8996 00007128 B700                <1> 	mov	bh,0
  8997 0000712A 53                  <1> 	push	bx
  8998 0000712B 06                  <1> 	push	es
  8999 0000712C 31C0                <1> 	xor	ax,ax
  9000 0000712E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  9001 00007130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  9002 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  9003 0000713A 01DE                <1> 	add	si,bx
  9004                              <1> 
  9005 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  9006 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  9007 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  9008                              <1> 
  9009 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  9010                              <1> 
  9011                              <1> .setup_crt_loop:
  9012 00007149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  9013 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  9014 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  9015 00007151 46                  <1> 	inc	si			;  ...point to next
  9016 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  9017 00007154 07                  <1> 	pop	es
  9018 00007155 31FF                <1> 	xor	di,di
  9019 00007157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  9020 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  9021 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  9022 0000715F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  9023 00007161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  9024 00007163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  9025                              <1> 
  9026                              <1> .text_fill:
  9027 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  9028                              <1> 
  9029                              <1> .clear_screen:
  9030 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  9031                              <1> 
  9032 0000716B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  9033 0000716F 80C204              <1> 	add	dl,4
  9034 00007172 5B                  <1> 	pop	bx
  9035 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  9036 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  9037 00007179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  9038 0000717C 42                  <1> 	inc	dx
  9039 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  9040 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  9041 00007182 7502                <1> 	jnz	.set_palette
  9042 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  9043                              <1> 
  9044                              <1> .set_palette:
  9045 00007186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  9046 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  9047                              <1> 
  9048 0000718A 8CD8                <1> 	mov	ax,ds
  9049 0000718C 8EC0                <1> 	mov	es,ax
  9050 0000718E 31C0                <1> 	xor	ax,ax
  9051 00007190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  9052 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  9053 00007196 BF4E00              <1> 	mov	di,video_page_offt
  9054 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  9055                              <1> 
  9056 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  9057 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  9058 000071A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  9059                              <1> 					; but it means that for mode 7
  9060                              <1> 					; we'll get graphics page size?!
  9061 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  9062 000071AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  9063 000071AE C3                  <1> 	ret
  9064                              <1> 
  9065                              <1> ;=========================================================================
  9066                              <1> ; int_10_fn01 - Set text-mode cursor shape
  9067                              <1> ; Input:
  9068                              <1> ;	AH = 01h
  9069                              <1> ;	CH = cursor scan line start
  9070                              <1> ;	CL = cursor scan line end
  9071                              <1> ; Output:
  9072                              <1> ;	none
  9073                              <1> ;-------------------------------------------------------------------------
  9074                              <1> int_10_fn01:
  9075 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  9076 000071B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  9077 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  9078 000071B8 C3                  <1> 	ret
  9079                              <1> 
  9080                              <1> ;=========================================================================
  9081                              <1> ; int_10_fn02 - Set cursor position
  9082                              <1> ; Input:
  9083                              <1> ;	AH = 02h
  9084                              <1> ;	BH = page number
  9085                              <1> ;	DH = cursor row (00h is top)
  9086                              <1> ;	DL = cursor column (00h is left)
  9087                              <1> ; Output:
  9088                              <1> ;	none
  9089                              <1> ;-------------------------------------------------------------------------
  9090                              <1> int_10_fn02:
  9091 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9092 000071BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  9093 000071C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  9094                              <1> 
  9095                              <1> ;=========================================================================
  9096                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  9097                              <1> ;	BL = page
  9098                              <1> ;	DH = cursor row (00h is top)
  9099                              <1> ;	DL = cursor column (00h is left)
  9100                              <1> ;-------------------------------------------------------------------------
  9101                              <1> set_cur_pos:
  9102 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  9103 000071C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  9104 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  9105 000071CB D1E8                <1> 	shr	ax,1
  9106 000071CD 89C1                <1> 	mov	cx,ax
  9107 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9108 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9109                              <1> bios_set_cur_pos:
  9110 000071D4 B700                <1> 	mov	bh,0
  9111 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  9112 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  9113 000071DB C3                  <1> 	ret
  9114                              <1> 
  9115                              <1> ;=========================================================================
  9116                              <1> ; int_10_fn03 - Get cursor position and shape
  9117                              <1> ; Input:
  9118                              <1> ;	AH = 03h
  9119                              <1> ;	BH = page number
  9120                              <1> ; Output:
  9121                              <1> ;	CH = cursor start scan line
  9122                              <1> ;	CL = cursor end scan line
  9123                              <1> ;	DH = cursor row (00h is top)
  9124                              <1> ;	DL = cursor column (00h is left)
  9125                              <1> ;-------------------------------------------------------------------------
  9126                              <1> int_10_fn03:
  9127 000071DC B700                <1> 	mov	bh,0
  9128 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9129 000071E1 D0E3                <1> 	shl	bl,1
  9130 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  9131 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  9132 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  9133 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  9134 000071EF C3                  <1> 	ret
  9135                              <1> 
  9136                              <1> ;=========================================================================
  9137                              <1> ; int_10_fn04 - Read light pen position
  9138                              <1> ; Input:
  9139                              <1> ;	AH = 04h
  9140                              <1> ; Output:
  9141                              <1> ;	AH - light pen trigger flag
  9142                              <1> ;		00h not down/triggered
  9143                              <1> ;		01h down/triggered
  9144                              <1> ;	If light pen is triggered:
  9145                              <1> ;		DH = character row
  9146                              <1> ;		DL = character column
  9147                              <1> ;		CH = pixel row
  9148                              <1> ;		BX = pixel column
  9149                              <1> ;-------------------------------------------------------------------------
  9150                              <1> int_10_fn04:
  9151 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  9152 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  9153 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  9154 000071FB EC                  <1> 	in	al,dx			; read it
  9155 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  9156 000071FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  9157 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  9158 00007202 7501                <1> 	jnz	.read_pen		; continue if triggered
  9159 00007204 C3                  <1> 	ret				; not triggered - return
  9160                              <1> 
  9161                              <1> .read_pen:
  9162 00007205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  9163 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  9164 0000720B EE                  <1> 	out	dx,al			; select it
  9165 0000720C 42                  <1> 	inc	dx			; CRTC data register
  9166 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  9167 0000720E 88C4                <1> 	mov	ah,al
  9168 00007210 4A                  <1> 	dec	dx			; CRTC index register
  9169 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  9170 00007213 EE                  <1> 	out	dx,al			; select it
  9171 00007214 42                  <1> 	inc	dx			; CRTC data register
  9172 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  9173                              <1> 
  9174 00007216 B700                <1> 	mov	bh,0
  9175 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  9176 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  9177 00007221 29D8                <1> 	sub	ax,bx
  9178 00007223 7902                <1> 	jns	.1
  9179 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  9180                              <1> 
  9181                              <1> .1:
  9182 00007227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  9183 0000722A 7325                <1> 	jnb	.text			; calculate character position if text
  9184 0000722C B228                <1> 	mov	dl,40			; divide by 40
  9185 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  9186 00007230 B700                <1> 	mov	bh,0
  9187 00007232 88E3                <1> 	mov	bl,ah
  9188 00007234 B103                <1> 	mov	cl,3
  9189 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  9190 00007238 88C5                <1> 	mov	ch,al
  9191 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  9192 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  9193 0000723E 88C6                <1> 	mov	dh,al
  9194 00007240 D0EE                <1> 	shr	dh,1
  9195 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  9196 00007244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  9197 00007249 751A                <1> 	jnz	.exit
  9198 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  9199 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  9200 0000724F EB14                <1> 	jmp	.exit
  9201                              <1> 
  9202                              <1> .text:
  9203 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  9204 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  9205 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  9206 00007259 B103                <1> 	mov	cl,3
  9207 0000725B D2E4                <1> 	shl	ah,cl
  9208 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  9209 0000725F B700                <1> 	mov	bh,0
  9210 00007261 88C3                <1> 	mov	bl,al
  9211 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  9212                              <1> 
  9213                              <1> .exit:
  9214 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  9215 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  9216 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  9217 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  9218                              <1> 
  9219                              <1> .reset_pen:
  9220 00007272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  9221 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  9222 00007279 EE                  <1> 	out	dx,al			; reset it
  9223 0000727A C3                  <1> 	ret
  9224                              <1> 
  9225                              <1> .correction:
  9226 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  9227                              <1> 
  9228                              <1> ;=========================================================================
  9229                              <1> ; int_10_fn05 - Select active display page
  9230                              <1> ; Input:
  9231                              <1> ;	AH = 05h
  9232                              <1> ;	AL - new page number (00h is the first page)
  9233                              <1> ; Output:
  9234                              <1> ;	none
  9235                              <1> ;-------------------------------------------------------------------------
  9236                              <1> int_10_fn05:
  9237 00007283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  9238 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  9239 00007288 B400                <1> 	mov	ah,0
  9240 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  9241 0000728E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  9242 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  9243 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  9244 00007295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  9245 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  9246                              <1> 
  9247 0000729A B700                <1> 	mov	bh,0
  9248 0000729C D1E3                <1> 	shl	bx,1
  9249 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  9250 000072A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  9251 000072A4 D1E8                <1> 	shr	ax,1
  9252 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  9253 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9254 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9255 000072AD C3                  <1> 	ret
  9256                              <1> 
  9257                              <1> ;=========================================================================
  9258                              <1> ; int_10_fn06 - scroll up window
  9259                              <1> ; int_10_fn07 - scroll down window
  9260                              <1> ; Input:
  9261                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  9262                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  9263                              <1> ;	BH = attribute used to write blank rows at bottom of window
  9264                              <1> ;	CH,CL = row,column of window's upper left corner
  9265                              <1> ;	DH,DL = row,column of window's lower right corner
  9266                              <1> ; Output:
  9267                              <1> ;	none
  9268                              <1> ; TODO:
  9269                              <1> ;	optimize graphics fill
  9270                              <1> ;-------------------------------------------------------------------------
  9271                              <1> int_10_fn06:
  9272                              <1> int_10_fn07:
  9273 000072AE E86604              <1> 	call	vid_check_mode
  9274 000072B1 7303E9D900          <1> 	jb	.graphics_scroll
  9275                              <1> 
  9276 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  9277 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  9278 000072BD 720A                <1> 	jb	.no_snow
  9279 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  9280 000072C4 7703                <1> 	ja	.no_snow
  9281 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  9282                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  9283                              <1> .no_snow:
  9284 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9285 000072CC 50                  <1> 	push	ax
  9286 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  9287 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  9288 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9289                              <1> 
  9290                              <1> .1:
  9291 000072D6 E89804              <1> 	call	vid_position_to_offset
  9292 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  9293 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9294                              <1> 
  9295                              <1> ; calculate scroll window size (DX)
  9296                              <1> 
  9297 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9298 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  9299 000072E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  9300                              <1> 
  9301                              <1> ; calculate offset between the source and the destination (AX)
  9302                              <1> 
  9303 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  9304 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  9305 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  9306 000072F0 52                  <1> 	push    dx
  9307 000072F1 B400                <1>         mov     ah,0
  9308 000072F3 F7E3                <1>         mul     bx
  9309 000072F5 5A                  <1>         pop     dx
  9310                              <1> 
  9311 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  9312 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  9313 000072FA 1E                  <1> 	push	ds
  9314 000072FB 8CC1                <1> 	mov	cx,es
  9315 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9316 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9317 00007303 7405                <1> 	jz	.2			; jump if scroll up
  9318 00007305 F7D8                <1> 	neg	ax			; negate offset
  9319 00007307 F7DB                <1> 	neg	bx			; negate distance
  9320 00007309 FD                  <1> 	std				; copy backwards
  9321                              <1> 
  9322                              <1> .2:
  9323 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  9324 0000730D 08C9                <1> 	or	cl,cl
  9325 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  9326 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  9327 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  9328 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  9329                              <1> 
  9330 00007316 09DB                <1> 	or	bx,bx
  9331 00007318 7434                <1> 	jz	.text_full_row_scroll
  9332                              <1> 
  9333                              <1> .text_scroll_loop:
  9334 0000731A B500                <1> 	mov	ch,0
  9335 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  9336                              <1> 
  9337 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  9338 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  9339 00007322 E85800              <1> 	call	.retrace_wait
  9340                              <1> 
  9341                              <1> .text_scroll_no_retrace:
  9342 00007325 F3A5                <1> 	repz	movsw			; copy one row
  9343                              <1> 
  9344                              <1> ;.text_scroll_next_row:
  9345 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  9346 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  9347 0000732B FECE                <1> 	dec	dh			; decrement row counter
  9348 0000732D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  9349                              <1> 
  9350                              <1> .text_fill:
  9351 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  9352 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  9353                              <1> 
  9354                              <1> .text_fill_only:
  9355 00007334 B500                <1> 	mov	ch,0
  9356 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  9357 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  9358                              <1> 
  9359                              <1> .text_fill_loop:
  9360 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  9361 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  9362 0000733F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  9363 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  9364                              <1> 
  9365                              <1> .text_fill_no_retrace:
  9366 00007344 F3AB                <1> 	repz	stosw			; fill one row
  9367 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  9368 00007348 FECE                <1> 	dec	dh			; decrement row counter
  9369 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  9370                              <1> 
  9371 0000734C 1F                  <1> 	pop	ds
  9372 0000734D C3                  <1> 	ret
  9373                              <1> 
  9374                              <1> .text_full_row_scroll:
  9375 0000734E 09C0                <1> 	or	ax,ax
  9376 00007350 741F                <1> 	jz	.text_full_row_no_snow
  9377 00007352 50                  <1> 	push	ax
  9378 00007353 88D0                <1> 	mov	al,dl
  9379 00007355 F6E6                <1> 	mul	dh
  9380                              <1> 
  9381                              <1> .text_full_row_loop:
  9382 00007357 B9F000              <1> 	mov	cx,240
  9383 0000735A 39C8                <1> 	cmp	ax,cx
  9384 0000735C 7705                <1> 	ja	.copy_chunk
  9385 0000735E 91                  <1> 	xchg	ax,cx
  9386 0000735F 31C0                <1> 	xor	ax,ax
  9387 00007361 EB02                <1> 	jmp	.do_copy
  9388                              <1> 
  9389                              <1> .copy_chunk:
  9390 00007363 29C8                <1> 	sub	ax,cx
  9391                              <1> 
  9392                              <1> .do_copy:
  9393 00007365 E81500              <1> 	call	.retrace_wait
  9394 00007368 F3A5                <1> 	rep	movsw
  9395 0000736A 09C0                <1> 	or	ax,ax
  9396 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  9397 0000736E 58                  <1> 	pop	ax
  9398 0000736F EBBE                <1> 	jmp	.text_fill
  9399                              <1> 
  9400                              <1> .text_full_row_no_snow:
  9401 00007371 50                  <1> 	push	ax
  9402 00007372 88D0                <1> 	mov	al,dl
  9403 00007374 F6E6                <1> 	mul	dh
  9404 00007376 89C1                <1> 	mov	cx,ax
  9405 00007378 F3A5                <1> 	rep	movsw
  9406 0000737A 58                  <1> 	pop	ax
  9407 0000737B EBB2                <1> 	jmp	.text_fill
  9408                              <1> 
  9409                              <1> ;-------------------------------------------------------------------------
  9410                              <1> ; .retrace_wait - next till the next vertical retrace
  9411                              <1> 
  9412                              <1> .retrace_wait:
  9413 0000737D 50                  <1> 	push	ax
  9414 0000737E 52                  <1> 	push	dx
  9415 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  9416                              <1> 
  9417                              <1> .retrace_wait_not_set:
  9418 00007382 EC                  <1> 	in	al,dx
  9419 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9420 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  9421                              <1> 
  9422                              <1> .retrace_wait_set:
  9423 00007387 EC                  <1> 	in	al,dx
  9424 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9425 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  9426 0000738C 5A                  <1> 	pop	dx
  9427 0000738D 58                  <1> 	pop	ax
  9428                              <1> 
  9429                              <1> .retrace_exit:
  9430 0000738E C3                  <1> 	ret
  9431                              <1> 
  9432                              <1> ;-------------------------------------------------------------------------
  9433                              <1> ; .graphics_scroll - scroll for graphics modes
  9434                              <1> 
  9435                              <1> .graphics_scroll:
  9436 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9437 00007392 50                  <1> 	push	ax
  9438 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  9439 00007397 7403                <1> 	jz	.3			; jump if scroll down
  9440 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9441                              <1> 
  9442                              <1> .3:
  9443 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  9444 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9445                              <1> 
  9446                              <1> ; calculate scroll windows size (DX)
  9447                              <1> 
  9448 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9449 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  9450 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  9451 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  9452 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  9453 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9454 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  9455 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  9456 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  9457 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  9458 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9459 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  9460 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  9461                              <1> 
  9462                              <1> .4:
  9463 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9464 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  9465 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  9466                              <1> 					;   for copying backwards
  9467                              <1> 
  9468                              <1> .5:
  9469 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  9470 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  9471 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  9472 000073CF 53                  <1> 	push	bx
  9473 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  9474 000073D2 B050                <1> 	mov	al,50h
  9475 000073D4 F6E3                <1> 	mul	bl
  9476 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  9477 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9478 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  9479 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  9480 000073E1 BB5020              <1> 	mov	bx,2050h
  9481 000073E4 FD                  <1> 	std				; copy backwards
  9482                              <1> 
  9483                              <1> .6:
  9484 000073E5 89FE                <1> 	mov	si,di
  9485 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  9486 000073E9 58                  <1> 	pop	ax
  9487 000073EA 8CC1                <1> 	mov	cx,es
  9488 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9489 000073EE 08C0                <1> 	or	al,al
  9490 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  9491 000073F2 50                  <1> 	push	ax
  9492                              <1> 
  9493                              <1> .graphics_scroll_loop:
  9494 000073F3 B500                <1> 	mov	ch,0
  9495 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9496 000073F7 56                  <1> 	push	si
  9497 000073F8 57                  <1> 	push	di
  9498 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  9499 000073FB 5F                  <1> 	pop	di
  9500 000073FC 5E                  <1> 	pop	si
  9501 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  9502 00007401 81C70020            <1> 	add	di,2000h
  9503 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9504 00007407 56                  <1> 	push	si
  9505 00007408 57                  <1> 	push	di
  9506 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  9507 0000740B 5F                  <1> 	pop	di
  9508 0000740C 5E                  <1> 	pop	si
  9509 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  9510 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  9511 00007411 FECE                <1> 	dec	dh			; decrement row counter
  9512 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  9513                              <1> 
  9514 00007415 58                  <1> 	pop	ax
  9515 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  9516                              <1> 
  9517                              <1> .graphics_fill:
  9518 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  9519 0000741B B500                <1> 	mov	ch,0
  9520                              <1> 
  9521                              <1> .graphics_fill_loop:
  9522 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9523 0000741F 57                  <1> 	push	di
  9524 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  9525 00007422 5F                  <1> 	pop	di
  9526 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  9527 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9528 00007429 57                  <1> 	push	di
  9529 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  9530 0000742C 5F                  <1> 	pop	di
  9531 0000742D 29DF                <1> 	sub	di,bx
  9532 0000742F FECE                <1> 	dec	dh			; decrement row counter
  9533 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  9534 00007433 C3                  <1> 	ret
  9535                              <1> 
  9536                              <1> ;=========================================================================
  9537                              <1> ; int_10_fn08 - Read character and attribute
  9538                              <1> ; Input:
  9539                              <1> ;	AH = 08h
  9540                              <1> ; Output:
  9541                              <1> ;	AL - character read
  9542                              <1> ;	BH - video attribute (text modes only)
  9543                              <1> ; int_10_fn09 - Write character and attribute
  9544                              <1> ; Input:
  9545                              <1> ;	AH = 09h
  9546                              <1> ;	AL - character to write
  9547                              <1> ;	BH - page number
  9548                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  9549                              <1> ;	CX - number of times to write character
  9550                              <1> ; Output:
  9551                              <1> ;	none
  9552                              <1> ; int_10_fn0A - Write character only
  9553                              <1> ; Input:
  9554                              <1> ;	AH = 0Ah
  9555                              <1> ;	AL - character to write
  9556                              <1> ;	BH - page number
  9557                              <1> ;	CX - repeat count
  9558                              <1> ; Output:
  9559                              <1> ;	none
  9560                              <1> ;-------------------------------------------------------------------------
  9561                              <1> int_10_fn08:
  9562                              <1> int_10_fn09:
  9563                              <1> int_10_fn0A:
  9564 00007434 E8E002              <1> 	call	vid_check_mode
  9565 00007437 7277                <1> 	jb	.graphics		; jump if graphics mode
  9566 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9567 0000743C B700                <1> 	mov	bh,0
  9568 0000743E 53                  <1> 	push	bx
  9569 0000743F E82803              <1> 	call	vid_current_offset
  9570 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  9571 00007444 58                  <1> 	pop	ax			; AX = page number
  9572 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  9573 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  9574 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  9575 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  9576 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  9577 00007454 1E                  <1> 	push	ds
  9578 00007455 8CC3                <1> 	mov	bx,es
  9579 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  9580 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9581 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  9582 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  9583                              <1> 
  9584                              <1> .read_retrace_wait:
  9585 00007460 EC                  <1> 	in	al,dx
  9586 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9587 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  9588 00007465 FA                  <1> 	cli
  9589                              <1> 
  9590                              <1> .read_no_retrace_wait:
  9591 00007466 EC                  <1> 	in	al,dx
  9592 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9593 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  9594                              <1> 
  9595 0000746B AD                  <1> 	lodsw				; read character and attribute
  9596 0000746C FB                  <1> 	sti
  9597 0000746D 1F                  <1> 	pop	ds
  9598 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  9599 00007471 C3                  <1> 	ret
  9600                              <1> 
  9601                              <1> .text_write:
  9602 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  9603 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  9604 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  9605 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  9606 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  9607                              <1> 
  9608                              <1> .write_char_retrace:
  9609 0000747F EC                  <1> 	in	al,dx
  9610 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9611 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  9612                              <1> 
  9613                              <1> .write_retrace_wait1:
  9614 00007484 EC                  <1> 	in	al,dx
  9615 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9616 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  9617 00007489 FA                  <1> 	cli
  9618                              <1> 
  9619                              <1> .write_no_retrace_wait1:
  9620 0000748A EC                  <1> 	in	al,dx
  9621 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9622 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  9623                              <1> 
  9624                              <1> .do_write_char_attr:
  9625 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  9626 00007491 AB                  <1> 	stosw				; write it to video memory
  9627 00007492 FB                  <1> 	sti
  9628 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  9629 00007495 1F                  <1> 	pop	ds
  9630 00007496 C3                  <1> 	ret
  9631                              <1> 
  9632                              <1> .text_write_char_only:
  9633 00007497 EC                  <1> 	in	al,dx
  9634 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9635 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  9636                              <1> 
  9637                              <1> .write_retrace_wait2:
  9638 0000749C EC                  <1> 	in	al,dx
  9639 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9640 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  9641 000074A1 FA                  <1> 	cli
  9642                              <1> 
  9643                              <1> .write_no_retrace_wait2:
  9644 000074A2 EC                  <1> 	in	al,dx
  9645 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9646 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  9647                              <1> 
  9648                              <1> .do_write_char_only:
  9649 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  9650 000074A9 AA                  <1> 	stosb				; write it to video memory
  9651 000074AA FB                  <1> 	sti
  9652 000074AB 47                  <1> 	inc	di			; skip attribute
  9653 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  9654 000074AE 1F                  <1> 	pop	ds
  9655 000074AF C3                  <1> 	ret
  9656                              <1> 
  9657                              <1> .graphics:
  9658 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  9659 000074B4 7503E9B300          <1> 	jz	.graphics_read
  9660                              <1> 
  9661 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  9662 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  9663 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  9664 000074C1 1E                  <1> 	push	ds
  9665 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  9666 000074C5 B400                <1> 	mov	ah,0
  9667 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  9668 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  9669 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  9670 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  9671 000074D0 EB0C                <1> 	jmp	.CG9_03
  9672                              <1> 
  9673                              <1> .CG9_02:
  9674 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  9675 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  9676 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  9677 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  9678 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  9679                              <1> 
  9680                              <1> .CG9_03:
  9681 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  9682 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  9683 000074E1 D3E0                <1> 	shl	ax,cl
  9684 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  9685 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  9686 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  9687 000074ED 1E                  <1> 	push	ds
  9688 000074EE 8EDA                <1> 	mov	ds,dx
  9689 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  9690 000074F2 D1E7                <1> 	shl	di,1
  9691 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  9692 000074F7 83E003              <1> 	and	ax,3
  9693 000074FA BB5555              <1> 	mov	bx,5555h
  9694 000074FD F7E3                <1> 	mul	bx
  9695 000074FF 89C2                <1> 	mov	dx,ax
  9696 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  9697                              <1> 
  9698                              <1> .CG9_04:
  9699 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  9700 00007506 57                  <1> 	push	di
  9701 00007507 56                  <1> 	push	si
  9702                              <1> 
  9703                              <1> .CG9_05:
  9704 00007508 AC                  <1> 	lodsb				; Read the screen
  9705 00007509 51                  <1> 	push	cx
  9706 0000750A 53                  <1> 	push	bx
  9707 0000750B 31DB                <1> 	xor	bx,bx
  9708 0000750D B90800              <1> 	mov	cx,8
  9709                              <1> 
  9710                              <1> .CG9_06:
  9711 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  9712 00007512 D1DB                <1> 	rcr	bx,1
  9713 00007514 D1FB                <1> 	sar	bx,1
  9714 00007516 E2F8                <1> 	loop	.CG9_06
  9715                              <1> 
  9716 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  9717 0000751A 5B                  <1> 	pop	bx
  9718 0000751B 59                  <1> 	pop	cx
  9719 0000751C 21D0                <1> 	and	ax,dx
  9720 0000751E 86E0                <1> 	xchg	ah,al
  9721 00007520 08DB                <1> 	or	bl,bl
  9722 00007522 7903                <1> 	jns	.CG9_07
  9723 00007524 263305              <1>     es	xor	ax,word [di]
  9724                              <1> 
  9725                              <1> .CG9_07:
  9726 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  9727 0000752A 81F70020            <1> 	xor	di,2000h
  9728 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  9729 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  9730 00007534 83C750              <1> 	add	di,50h			; Else advance character
  9731                              <1> 
  9732                              <1> .CG9_08:
  9733 00007537 FECF                <1> 	dec	bh			; Show another char written
  9734 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  9735 0000753B 5E                  <1> 	pop	si
  9736 0000753C 5F                  <1> 	pop	di
  9737 0000753D 47                  <1> 	inc	di
  9738 0000753E 47                  <1> 	inc	di
  9739 0000753F E2C3                <1> 	loop	.CG9_04
  9740 00007541 1F                  <1> 	pop	ds
  9741 00007542 C3                  <1> 	ret
  9742                              <1> 
  9743                              <1> .CG8_02:
  9744 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  9745 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  9746                              <1> 
  9747                              <1> .CG8_03:
  9748 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  9749 0000754B 57                  <1> 	push	di
  9750 0000754C 56                  <1> 	push	si
  9751                              <1> 
  9752                              <1> .CG8_04:
  9753 0000754D AC                  <1> 	lodsb				; Read from one plane
  9754 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  9755 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  9756 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  9757                              <1> 
  9758                              <1> .CG8_05:
  9759 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  9760 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  9761 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  9762 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  9763 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  9764                              <1> 
  9765                              <1> .CG8_06:
  9766 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  9767 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  9768 00007565 5E                  <1> 	pop	si
  9769 00007566 5F                  <1> 	pop	di
  9770 00007567 47                  <1> 	inc	di
  9771 00007568 E2DF                <1> 	loop	.CG8_03
  9772 0000756A 1F                  <1> 	pop	ds
  9773 0000756B C3                  <1> 	ret
  9774                              <1> 
  9775                              <1> .graphics_read:
  9776 0000756C FC                  <1> 	cld				; Increment upwards
  9777 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  9778 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  9779 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  9780 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  9781 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  9782 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  9783 0000757F 8CC0                <1> 	mov	ax,es
  9784 00007581 1E                  <1> 	push	ds
  9785 00007582 57                  <1> 	push	di
  9786 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  9787 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  9788 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  9789 00007589 D1E6                <1> 	shl	si,1
  9790 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  9791                              <1> 
  9792                              <1> CGR_02:
  9793 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  9794 00007590 86E0                <1> 	xchg	ah,al
  9795 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  9796 00007595 B200                <1> 	mov	dl,0
  9797                              <1> 
  9798                              <1> CGR_03:
  9799 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  9800 00007599 F8                  <1> 	clc
  9801 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  9802 0000759C F9                  <1> 	stc				; Else show not set
  9803                              <1> 
  9804                              <1> CGR_04:
  9805 0000759D D0D2                <1> 	rcl	dl,1
  9806 0000759F D1E9                <1> 	shr	cx,1
  9807 000075A1 D1E9                <1> 	shr	cx,1
  9808 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  9809 000075A5 368815              <1>     ss	mov	byte [di],dl
  9810 000075A8 47                  <1> 	inc	di
  9811 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  9812 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  9813 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  9814 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  9815                              <1> 
  9816                              <1> CGR_05:
  9817 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  9818 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  9819 000075B6 EB17                <1> 	jmp	short	CGR_08
  9820                              <1> 
  9821                              <1> CGR_06:
  9822 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  9823                              <1> 
  9824                              <1> CGR_07:
  9825 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  9826 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  9827 000075BF 47                  <1> 	inc	di			;  ...advance
  9828 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  9829 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  9830 000075C7 47                  <1> 	inc	di			;  ...advance
  9831 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  9832 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  9833 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  9834                              <1> 
  9835                              <1> CGR_08:
  9836 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  9837 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  9838 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  9839 000075D6 8CD2                <1> 	mov	dx,ss
  9840 000075D8 8EDA                <1> 	mov	ds,dx
  9841 000075DA 5E                  <1> 	pop	si
  9842 000075DB B000                <1> 	mov	al,0
  9843                              <1> 
  9844                              <1> CGR_09:
  9845 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  9846                              <1> 
  9847                              <1> CGR_10:
  9848 000075E0 56                  <1> 	push	si
  9849 000075E1 57                  <1> 	push	di
  9850 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  9851 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  9852 000075E7 5F                  <1> 	pop	di
  9853 000075E8 5E                  <1> 	pop	si
  9854 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  9855 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  9856 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  9857 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  9858 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  9859                              <1> 
  9860 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  9861 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  9862 000075F7 31DB                <1> 	xor	bx,bx
  9863 000075F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  9864 000075FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  9865 000075FF 8CC3                <1> 	mov	bx,es
  9866 00007601 09FB                <1> 	or	bx,di
  9867 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  9868 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  9869                              <1> 
  9870                              <1> CGR_11:
  9871 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  9872 0000760A 1F                  <1> 	pop	ds
  9873 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  9874 0000760E C3                  <1> 	ret
  9875                              <1> 
  9876                              <1> ;=========================================================================
  9877                              <1> ; int_10_fn0B - Set background color or palette
  9878                              <1> ; Input:
  9879                              <1> ; 	AH - 0Bh
  9880                              <1> ;	BH = 00h - set background / border color
  9881                              <1> ;		BL - background (graphics modes) or border (text modes)
  9882                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  9883                              <1> ;		BL - palette ID:
  9884                              <1> ;			00h - background, green, red, and yellow (brown)
  9885                              <1> ;			01h - background, cyan, magenta, and white
  9886                              <1> ; Output:
  9887                              <1> ;	none
  9888                              <1> ;-------------------------------------------------------------------------
  9889                              <1> int_10_fn0B:
  9890 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  9891 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  9892 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  9893 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  9894                              <1> 
  9895 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  9896 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  9897 00007620 08E0                <1> 	or	al,ah			; apply new color
  9898 00007622 EB09                <1> 	jmp	.write_palet_reg
  9899                              <1> 
  9900                              <1> .set_palette:
  9901 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  9902 00007626 F6C401              <1> 	test	ah,01h
  9903 00007629 7402                <1> 	jz	.write_palet_reg
  9904 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  9905                              <1> 
  9906                              <1> .write_palet_reg:
  9907 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  9908 00007630 8B166300            <1> 	mov	dx,word [video_port]
  9909 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  9910 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  9911 00007638 C3                  <1> 	ret
  9912                              <1> 
  9913                              <1> ;=========================================================================
  9914                              <1> ; int_10_fn0C - Write graphics pixel
  9915                              <1> ; Input:
  9916                              <1> ;	AH = 0Ch
  9917                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  9918                              <1> ;	CX = column
  9919                              <1> ;	DX = row
  9920                              <1> ; Output:
  9921                              <1> ;	none
  9922                              <1> ;-------------------------------------------------------------------------
  9923                              <1> int_10_fn0C:
  9924 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  9925 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9926 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9927 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  9928 00007643 2401                <1> 	and	al,1			; one bit per pixel
  9929 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9930 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  9931 00007649 EB0F                <1> 	jmp	.prepare_mask
  9932                              <1> 
  9933                              <1> .mode_320x200:
  9934 0000764B D0E1                <1> 	shl	cl,1
  9935 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9936 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  9937 00007652 2403                <1> 	and	al,3			; two bit per pixel
  9938 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9939 00007656 D0C8                <1> 	ror	al,1
  9940 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  9941                              <1> 
  9942                              <1> .prepare_mask:
  9943 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  9944 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  9945 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  9946 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  9947 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  9948 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  9949 00007667 EB04                <1> 	jmp	.write_pixel
  9950                              <1> 
  9951                              <1> .set_color:
  9952 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  9953 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  9954                              <1> 
  9955                              <1> .write_pixel:
  9956 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  9957 00007670 C3                  <1> 	ret
  9958                              <1> 
  9959                              <1> ;=========================================================================
  9960                              <1> ; int_10_fn0D - Read graphics pixel
  9961                              <1> ; Input:
  9962                              <1> ;	AH = 0Dh
  9963                              <1> ;	CX = column
  9964                              <1> ;	DX = row
  9965                              <1> ; Output:
  9966                              <1> ;	AL = pixel color 
  9967                              <1> ;-------------------------------------------------------------------------
  9968                              <1> int_10_fn0D:
  9969 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  9970 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  9971 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9972 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  9973 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  9974 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  9975 0000767F EB0A                <1> 	jmp	.exit
  9976                              <1> 
  9977                              <1> .mode_320x200:
  9978 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  9979 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  9980 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  9981 00007687 D0C0                <1> 	rol	al,1
  9982 00007689 2403                <1> 	and	al,3			; two bits per pixel
  9983                              <1> 
  9984                              <1> .exit:
  9985 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  9986 0000768E C3                  <1> 	ret
  9987                              <1> 
  9988                              <1> ;=========================================================================
  9989                              <1> ; int_10_fn0E - Teletype output
  9990                              <1> ; Input:
  9991                              <1> ;	AH = 0Eh
  9992                              <1> ;	AL = character to write
  9993                              <1> ;	BL = foreground color (graphics modes only)
  9994                              <1> ; Output:
  9995                              <1> ;	none
  9996                              <1> ; Notes:
  9997                              <1> ;	- writes character to the active video page
  9998                              <1> ;	- support following control characters: BEL, BS, LF, CR
  9999                              <1> ;-------------------------------------------------------------------------
 10000                              <1> int_10_fn0E:
 10001 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
 10002 00007693 B700                <1> 	mov	bh,0
 10003 00007695 D0E3                <1> 	shl	bl,1			; word index
 10004 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
 10005                              <1> 
 10006 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
 10007 0000769D 3C08                <1> 	cmp	al,bs
 10008 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
 10009 000076A1 3C0A                <1> 	cmp	al,lf
 10010 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
 10011 000076A5 3C07                <1> 	cmp	al,bel
 10012 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
 10013 000076A9 3C0D                <1> 	cmp	al,cr
 10014 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
 10015 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
 10016 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
 10017 000076B2 B90100              <1> 	mov	cx,1			; one character
 10018 000076B5 CD10                <1> 	int	10h			; write character
 10019 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
 10020 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
 10021 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
 10022 000076BF B200                <1> 	mov	dl,0			; move to the first position
 10023                              <1> 
 10024                              <1> .lf:
 10025 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
 10026 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
 10027 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
 10028 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
 10029                              <1> 
 10030                              <1> .bs:
 10031 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
 10032 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
 10033 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
 10034 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
 10035                              <1> 
 10036                              <1> .cr:
 10037 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
 10038                              <1> 
 10039                              <1> .set_cursor_pos:
 10040 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
 10041 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
 10042                              <1> 
 10043                              <1> .bel:
 10044 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
 10045 000076DE E806AC              <1> 	call	beep
 10046 000076E1 C3                  <1> 	ret
 10047                              <1> 
 10048                              <1> .scroll:
 10049 000076E2 B402                <1> 	mov	ah,02h
 10050 000076E4 CD10                <1> 	int	10h			; set new cursor position
 10051 000076E6 E82E00              <1> 	call	vid_check_mode
 10052 000076E9 B700                <1> 	mov	bh,0
 10053 000076EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
 10054 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
 10055 000076EF CD10                <1> 	int	10h			; read attirbute at current position
 10056 000076F1 88E7                <1> 	mov	bh,ah
 10057                              <1> 
 10058                              <1> .do_scroll:
 10059 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
 10060 000076F5 B001                <1> 	mov	al,1			; scroll one line
 10061 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
 10062 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
 10063 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
 10064 000076FF FECA                <1> 	dec	dl
 10065 00007701 CD10                <1> 	int	10h			; scroll page up
 10066 00007703 C3                  <1> 	ret
 10067                              <1> 
 10068                              <1> ;=========================================================================
 10069                              <1> ; int_10_fn0F - Get current video mode
 10070                              <1> ; Input:
 10071                              <1> ;	AH = 0Fh
 10072                              <1> ; Output:
 10073                              <1> ;	AL = video mode
 10074                              <1> ;	AH = characters per column
 10075                              <1> ;	BH = active video page
 10076                              <1> ;-------------------------------------------------------------------------
 10077                              <1> int_10_fn0F:
 10078 00007704 A04A00              <1> 	mov	al,byte [video_columns]
 10079 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
 10080 0000770A A04900              <1> 	mov	al,byte [video_mode]
 10081 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
 10082 00007710 A06200              <1> 	mov	al,byte [video_page]
 10083 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
 10084 00007716 C3                  <1> 	ret
 10085                              <1> 
 10086                              <1> ;=========================================================================
 10087                              <1> ; vid_check_mode - Check current video mode
 10088                              <1> ; Input:
 10089                              <1> ;	none
 10090                              <1> ; Output:
 10091                              <1> ;	ZF set if monochrome mode (mode 07h)
 10092                              <1> ;	CF set if graphics modes (modes 04h - 06h)
 10093                              <1> ;-------------------------------------------------------------------------
 10094                              <1> vid_check_mode:
 10095 00007717 50                  <1> 	push	ax
 10096 00007718 A04900              <1> 	mov	al,byte [video_mode]
 10097 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
 10098 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
 10099 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
 10100 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
 10101 00007722 7303                <1> 	jnb	.exit			; jump if not graphics
 10102 00007724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
 10103 00007726 F9                  <1> 	stc				; XXX
 10104                              <1> 
 10105                              <1> .exit:
 10106 00007727 58                  <1> 	pop	ax
 10107 00007728 C3                  <1> 	ret
 10108                              <1> 
 10109                              <1> ;=========================================================================
 10110                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10111                              <1> ; Input:
 10112                              <1> ;	AH = register number
 10113                              <1> ;	CX = word to write
 10114                              <1> ; Output:
 10115                              <1> ;	AX trashed
 10116                              <1> ; Note:
 10117                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
 10118                              <1> ;-------------------------------------------------------------------------
 10119                              <1> vid_crtc_writew:
 10120 00007729 88E8                <1> 	mov	al,ch
 10121 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
 10122 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
 10123 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
 10124                              <1> 
 10125                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
 10126                              <1> 
 10127                              <1> ;=========================================================================
 10128                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10129                              <1> ; Input:
 10130                              <1> ;	AH = register number
 10131                              <1> ;	AL = byte to write
 10132                              <1> ; Output:
 10133                              <1> ;	none
 10134                              <1> ;-------------------------------------------------------------------------
 10135                              <1> vid_crtc_writeb:
 10136 00007732 52                  <1> 	push	dx
 10137 00007733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
 10138 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
 10139 00007739 EE                  <1> 	out	dx,al			; write register number
 10140 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
 10141 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
 10142 0000773E EE                  <1> 	out	dx,al			; write byte
 10143 0000773F 5A                  <1> 	pop	dx
 10144 00007740 C3                  <1> 	ret
 10145                              <1> 
 10146                              <1> ;=========================================================================
 10147                              <1> ; vid_pixel_address - calculate pixel address and mask
 10148                              <1> ; Input:
 10149                              <1> ;	CX - column
 10150                              <1> ;	DX - row
 10151                              <1> ; Output:
 10152                              <1> ;	SI - pixel address
 10153                              <1> ;	CH - pixel mask
 10154                              <1> ;	CL - pixel position in the byte
 10155                              <1> ;	ZF - mode
 10156                              <1> ;		0 = 320x200
 10157                              <1> ;		1 = 640x200
 10158                              <1> ;-------------------------------------------------------------------------
 10159                              <1> vid_pixel_address:
 10160 00007741 31F6                <1> 	xor	si,si			; SI = 0
 10161 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
 10162 00007745 7303                <1> 	jnb	.even			; jump if on even row 
 10163 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
 10164                              <1> 
 10165                              <1> .even:
 10166 0000774A B050                <1> 	mov	al,50h			; bytes in each row
 10167 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
 10168                              <1> 
 10169 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
 10170 00007750 89CA                <1> 	mov	dx,cx			; DX - column
 10171 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
 10172 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
 10173 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
 10174 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
 10175 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
 10176                              <1> 
 10177                              <1> .1:
 10178 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
 10179 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
 10180 00007764 01D6                <1> 	add	si,dx			; add column address to SI
 10181 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
 10182 00007768 9D                  <1> 	popf
 10183 00007769 C3                  <1> 	ret
 10184                              <1> 
 10185                              <1> ;=========================================================================
 10186                              <1> ; vid_current_offset - convert current cursor position to offset
 10187                              <1> ;		       relative to page starting address
 10188                              <1> ; Input:
 10189                              <1> ;	BL = page
 10190                              <1> ; Output:
 10191                              <1> ;	AX = offset
 10192                              <1> ;-------------------------------------------------------------------------
 10193                              <1> vid_current_offset:
 10194 0000776A B700                <1> 	mov	bh,0
 10195 0000776C D1E3                <1> 	shl	bx,1				; word index
 10196 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
 10197                              <1> 
 10198                              <1> ; fall through to vid_position_to_offset
 10199                              <1> 
 10200                              <1> ;=========================================================================
 10201                              <1> ; vid_position_to_offset - convert position (row and column) to offset
 10202                              <1> ;			   relative to page starting address
 10203                              <1> ; Input:
 10204                              <1> ;	AH = row
 10205                              <1> ;	AL = column
 10206                              <1> ; Output:
 10207                              <1> ;	AX = offset
 10208                              <1> ;-------------------------------------------------------------------------
 10209                              <1> vid_position_to_offset:
 10210 00007771 53                  <1> 	push	bx
 10211 00007772 88C3                <1> 	mov	bl,al			; BL = column
 10212 00007774 88E0                <1> 	mov	al,ah			; AL = row
 10213 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10214 0000777A B700                <1> 	mov	bh,0			;
 10215 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
 10216 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
 10217 00007780 5B                  <1> 	pop	bx
 10218 00007781 C3                  <1> 	ret
 10219                              <1> 
 10220                              <1> ;=========================================================================
 10221                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
 10222                              <1> ; Input:
 10223                              <1> ;	AH = row
 10224                              <1> ;	AL = column
 10225                              <1> ; Output:
 10226                              <1> ;	AX = offset
 10227                              <1> ;-------------------------------------------------------------------------
 10228                              <1> vid_gfx_pos_to_offset:
 10229 00007782 53                  <1> 	push	bx
 10230 00007783 88C3                <1> 	mov	bl,al			; BL = column
 10231 00007785 88E0                <1> 	mov	al,ah			; AL = row
 10232 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10233 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
 10234 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
 10235 0000778F B700                <1> 	mov	bh,0
 10236 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
 10237 00007793 5B                  <1> 	pop	bx
 10238 00007794 C3                  <1> 	ret
 10239                                  
 10240                                  ;=========================================================================
 10241                                  ; int_12 - Get memory size
 10242                                  ; Input:
 10243                                  ;	none
 10244                                  ; Output:
 10245                                  ;	AX = memory size
 10246                                  ;-------------------------------------------------------------------------
 10247 00007795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
 10248          ******************       warning: (setloc:7) Inserting 172 bytes
 10249                                  int_12:
 10250 00007841 FB                      	sti
 10251 00007842 1E                      	push	ds
 10252 00007843 B84000                  	mov	ax,biosdseg
 10253 00007846 8ED8                    	mov	ds,ax
 10254 00007848 A11300                  	mov	ax,word [memory_size]
 10255 0000784B 1F                      	pop	ds
 10256 0000784C CF                      	iret
 10257                                  
 10258                                  ;=========================================================================
 10259                                  ; int_11 - Get equipment list
 10260                                  ; Input:
 10261                                  ;	none
 10262                                  ; Output:
 10263                                  ;	AX = equipment list
 10264                                  ;-------------------------------------------------------------------------
 10265                                  	setloc	0F84Dh			; INT 11 Entry Point
 10266                                  int_11:
 10267 0000784D FB                      	sti
 10268 0000784E 1E                      	push	ds
 10269 0000784F B84000                  	mov	ax,biosdseg
 10270 00007852 8ED8                    	mov	ds,ax
 10271 00007854 A11000                  	mov	ax,word [equipment_list]
 10272 00007857 1F                      	pop	ds
 10273 00007858 CF                      	iret
 10274                                  
 10275                                  ;=========================================================================
 10276                                  ; Includes with fixed entry points (for IBM compatibility)
 10277                                  ;-------------------------------------------------------------------------
 10278                                  
 10279                                  %include	"misc.inc"
 10280                              <1> ;=========================================================================
 10281                              <1> ; misc.inc - Miscellaneous BIOS Services
 10282                              <1> ;       INT 15h, functions:
 10283                              <1> ;       	4Fh	- OS hook keyboard intercept
 10284                              <1> ;		90h	- Device busy loop
 10285                              <1> ;		91h	- Interrupt completed
 10286                              <1> ;		0C0h	- Get system configruation
 10287                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
 10288                              <1> ;		
 10289                              <1> ;-------------------------------------------------------------------------
 10290                              <1> ;
 10291                              <1> ; Compiles with NASM 2.07, might work with other versions
 10292                              <1> ;
 10293                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10294                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10295                              <1> ;
 10296                              <1> ; This program is free software: you can redistribute it and/or modify
 10297                              <1> ; it under the terms of the GNU General Public License as published by
 10298                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10299                              <1> ; (at your option) any later version.
 10300                              <1> ;
 10301                              <1> ; This program is distributed in the hope that it will be useful,
 10302                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10303                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10304                              <1> ; GNU General Public License for more details.
 10305                              <1> ;
 10306                              <1> ; You should have received a copy of the GNU General Public License
 10307                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10308                              <1> ;
 10309                              <1> ;=========================================================================
 10310                              <1> 
 10311                              <1> ;-------------------------------------------------------------------------
 10312                              <1> ; offsets for registers on stack
 10313                              <1> int_15_bp	equ	0
 10314                              <1> int_15_ip	equ	int_15_bp+2
 10315                              <1> int_15_cs	equ	int_15_ip+2
 10316                              <1> int_15_flags	equ	int_15_cs+2
 10317                              <1> 
 10318                              <1> ;=========================================================================
 10319                              <1> ; int_15 - Miscellaneous BIOS services
 10320                              <1> ; Input:
 10321                              <1> ;	AH = 4Fh - OS hook keyboard intercept
 10322                              <1> ;		- Does nothing
 10323                              <1> ;	AH = 0C2h - PS/2 mouse services
 10324                              <1> ;		- Implemented in ps2aux.inc
 10325                              <1> ;-------------------------------------------------------------------------
 10326                              <1> 	setloc	0F859h			; INT 15 Entry Point
 10327                              <1> int_15:
 10328 00007859 FB                  <1> 	sti
 10329 0000785A 80FC4F              <1> 	cmp	ah,4Fh
 10330 0000785D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
 10331 0000785F 80FCC0              <1> 	cmp	ah,0C0h
 10332 00007862 742E                <1> 	je	int_15_fnC0
 10333 00007864 3D0190              <1> 	cmp	ax,9001h
 10334 00007867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
 10335 00007869 3DFD90              <1> 	cmp	ax,90FDh
 10336 0000786C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
 10337 0000786E 3D0191              <1> 	cmp	ax,9101h
 10338 00007871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
 10339                              <1> 
 10340                              <1> %ifdef PS2_MOUSE
 10341 00007873 80FCC2              <1> 	cmp	ah,0C2h
 10342 00007876 7503                <1> 	jne	.1
 10343 00007878 E9EFA7              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
 10344                              <1> .1:
 10345                              <1> %endif
 10346                              <1> 
 10347 0000787B B486                <1> 	mov	ah,86h			; no cassete present
 10348                              <1> 
 10349                              <1> int_15_err:
 10350 0000787D 55                  <1> 	push	bp
 10351 0000787E 89E5                <1> 	mov	bp,sp
 10352 00007880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
 10353 00007884 5D                  <1> 	pop	bp
 10354 00007885 CF                  <1> 	iret
 10355                              <1> 
 10356                              <1> int_15_ok:
 10357 00007886 55                  <1> 	push	bp
 10358 00007887 89E5                <1> 	mov	bp,sp
 10359 00007889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
 10360 0000788D 5D                  <1> 	pop	bp
 10361 0000788E CF                  <1> 	iret
 10362                              <1> 
 10363                              <1> int_15_os_hook:
 10364 0000788F B400                <1> 	mov	ah,00h
 10365                              <1> 
 10366                              <1> int_15_exit:
 10367 00007891 CF                  <1> 	iret
 10368                              <1> 
 10369                              <1> ;=========================================================================
 10370                              <1> ; int_15_fnC0 - Get configuration
 10371                              <1> ; Input:
 10372                              <1> ;	AH = 0C0h - get configuration
 10373                              <1> ; Output:
 10374                              <1> ;	AH = 00h - function supported
 10375                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
 10376                              <1> ;	CF = 0 (success)
 10377                              <1> ;-------------------------------------------------------------------------
 10378                              <1> int_15_fnC0:
 10379 00007892 B400                <1> 	mov	ah,00h
 10380 00007894 BB00F0              <1> 	mov	bx,bioscseg
 10381 00007897 8EC3                <1> 	mov	es,bx
 10382 00007899 BB[F566]            <1> 	mov	bx,config_table
 10383 0000789C EBE8                <1> 	jmp	int_15_ok
 10384                                  %include	"fnt00-7F.inc"
 10385                              <1> ;=========================================================================
 10386                              <1> ; fnt00-7F.inc - Font for graphics modes
 10387                              <1> ;       Characters from 00h to 7Fh
 10388                              <1> ;-------------------------------------------------------------------------
 10389                              <1> ;
 10390                              <1> ; Compiles with NASM 2.07, might work with other versions
 10391                              <1> ;
 10392                              <1> ; This font is borrowed from kbd package (alt-8x8)
 10393                              <1> ;
 10394                              <1> ; This program is free software: you can redistribute it and/or modify
 10395                              <1> ; it under the terms of the GNU General Public License as published by
 10396                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10397                              <1> ; (at your option) any later version.
 10398                              <1> ;
 10399                              <1> ; This program is distributed in the hope that it will be useful,
 10400                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10401                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10402                              <1> ; GNU General Public License for more details.
 10403                              <1> ;
 10404                              <1> ; You should have received a copy of the GNU General Public License
 10405                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10406                              <1> ;
 10407                              <1> ;=========================================================================
 10408 0000789E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
 10409          ******************  <1>  warning: (setloc:7) Inserting 464 bytes
 10410                              <1> gfx_font:
 10411 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
 10412 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
 10413 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
 10414 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
 10415 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
 10416 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
 10417 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
 10418 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
 10419 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
 10420 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
 10421 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
 10422 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
 10423 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
 10424 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
 10425 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
 10426 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
 10427 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
 10428 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
 10429 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
 10430 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
 10431 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
 10432 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
 10433 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
 10434 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
 10435 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
 10436 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
 10437 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
 10438 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
 10439 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
 10440 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
 10441 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
 10442 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
 10443 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
 10444 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
 10445 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
 10446 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
 10447 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
 10448 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
 10449 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
 10450 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
 10451 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
 10452 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
 10453 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
 10454 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
 10455 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
 10456 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
 10457 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
 10458 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
 10459 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
 10460 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
 10461 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
 10462 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
 10463 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
 10464 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
 10465 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
 10466 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
 10467 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
 10468 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
 10469 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
 10470 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
 10471 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
 10472 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
 10473 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
 10474 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
 10475 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
 10476 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
 10477 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
 10478 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
 10479 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
 10480 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
 10481 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
 10482 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
 10483 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
 10484 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10485 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
 10486 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
 10487 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
 10488 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
 10489 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
 10490 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
 10491 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
 10492 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
 10493 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
 10494 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
 10495 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
 10496 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
 10497 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10498 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
 10499 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
 10500 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
 10501 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
 10502 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
 10503 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
 10504 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
 10505 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
 10506 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
 10507 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
 10508 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
 10509 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
 10510 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
 10511 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
 10512 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
 10513 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
 10514 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10515 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
 10516 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
 10517 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
 10518 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
 10519 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10520 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
 10521 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
 10522 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
 10523 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
 10524 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
 10525 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
 10526 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
 10527 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
 10528 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
 10529 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10530 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
 10531 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
 10532 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10533 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
 10534 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
 10535 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
 10536 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
 10537 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
 10538 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
 10539                                  %include	"time2.inc"
 10540                              <1> ;=========================================================================
 10541                              <1> ; time2.int - BIOS Time Services
 10542                              <1> ;       INT 1Ah - BIOS Time Serivces
 10543                              <1> ;		dispatcher
 10544                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
 10545                              <1> ;-------------------------------------------------------------------------
 10546                              <1> ;
 10547                              <1> ; Compiles with NASM 2.07, might work with other versions
 10548                              <1> ;
 10549                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10550                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10551                              <1> ;
 10552                              <1> ; This program is free software: you can redistribute it and/or modify
 10553                              <1> ; it under the terms of the GNU General Public License as published by
 10554                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10555                              <1> ; (at your option) any later version.
 10556                              <1> ;
 10557                              <1> ; This program is distributed in the hope that it will be useful,
 10558                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10559                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10560                              <1> ; GNU General Public License for more details.
 10561                              <1> ;
 10562                              <1> ; You should have received a copy of the GNU General Public License
 10563                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10564                              <1> ;
 10565                              <1> ;=========================================================================
 10566                              <1> 
 10567                              <1> ;=========================================================================
 10568                              <1> ; int_1A - BIOS Time Services
 10569                              <1> ; Note: see time1.inc for functions implementation
 10570                              <1> ;-------------------------------------------------------------------------
 10571                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
 10572                              <1> int_1A:
 10573 00007E6E 53                  <1> 	push	bx
 10574 00007E6F 1E                  <1> 	push	ds
 10575 00007E70 BB4000              <1> 	mov	bx,biosdseg
 10576 00007E73 8EDB                <1> 	mov	ds,bx
 10577 00007E75 80FC08              <1> 	cmp	ah,.max/2
 10578 00007E78 731B                <1> 	jae	int_1A_exit
 10579 00007E7A B700                <1> 	mov	bh,0
 10580 00007E7C 88E3                <1> 	mov	bl,ah
 10581 00007E7E D1E3                <1> 	shl	bx,1
 10582 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
 10583                              <1> .dispatch:
 10584 00007E85 [B30E]              <1> 	dw	int_1A_fn00
 10585 00007E87 [C50E]              <1> 	dw	int_1A_fn01
 10586 00007E89 [D50E]              <1> 	dw	int_1A_fn02
 10587 00007E8B [070F]              <1> 	dw	int_1A_fn03
 10588 00007E8D [4C0F]              <1> 	dw	int_1A_fn04
 10589 00007E8F [7C0F]              <1> 	dw	int_1A_fn05
 10590 00007E91 [BB0F]              <1> 	dw	int_1A_fn06
 10591 00007E93 [0C10]              <1> 	dw	int_1A_fn07
 10592                              <1> .max	equ	$-.dispatch
 10593                              <1> int_1A_exit:
 10594 00007E95 1F                  <1> 	pop	ds
 10595 00007E96 5B                  <1> 	pop	bx
 10596 00007E97 CF                  <1> 	iret
 10597                              <1> int_1A_exitf:
 10598 00007E98 1F                  <1> 	pop	ds
 10599 00007E99 5B                  <1> 	pop	bx
 10600 00007E9A CA0200              <1> 	retf	2
 10601                              <1> 
 10602                              <1> ;=========================================================================
 10603                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
 10604                              <1> ;-------------------------------------------------------------------------
 10605 00007E9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
 10606          ******************  <1>  warning: (setloc:7) Inserting 8 bytes
 10607                              <1> int_08:
 10608 00007EA5 50                  <1> 	push	ax
 10609 00007EA6 1E                  <1> 	push	ds
 10610 00007EA7 B84000              <1> 	mov	ax,biosdseg
 10611 00007EAA 8ED8                <1> 	mov	ds,ax
 10612 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
 10613 00007EB1 7413                <1> 	jz	.1
 10614 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
 10615 00007EB7 750D                <1> 	jnz	.1
 10616 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
 10617 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
 10618 00007EC0 52                  <1> 	push	dx
 10619 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
 10620 00007EC4 EE                  <1> 	out	dx,al
 10621 00007EC5 5A                  <1> 	pop	dx
 10622                              <1> .1:
 10623 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
 10624 00007ECA 7504                <1> 	jnz	.2
 10625 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
 10626                              <1> .2:
 10627 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
 10628 00007ED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
 10629 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
 10630 00007EDD 7512                <1> 	jnz	.3
 10631 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
 10632 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
 10633 00007EEB C70670000100        <1> 	mov	word [new_day],1
 10634                              <1> .3:
 10635 00007EF1 CD1C                <1> 	int	1Ch			; User timer interrupt
 10636 00007EF3 B020                <1> 	mov	al,20h
 10637 00007EF5 E620                <1> 	out	pic1_reg0,al
 10638 00007EF7 1F                  <1> 	pop	ds
 10639 00007EF8 58                  <1> 	pop	ax
 10640 00007EF9 CF                  <1> 	iret
 10641                                  
 10642                                  ;=========================================================================
 10643                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
 10644                                  ;-------------------------------------------------------------------------
 10645 00007EFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
 10646          ******************       warning: (setloc:7) Inserting 41 bytes
 10647                                  int_ignore:
 10648 00007F23 50                      	push	ax
 10649 00007F24 1E                      	push	ds
 10650 00007F25 B84000                  	mov	ax,biosdseg
 10651 00007F28 8ED8                    	mov	ds,ax
 10652 00007F2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
 10653 00007F2C E620                    	out	pic1_reg0,al
 10654 00007F2E 90                      	nop
 10655 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
 10656 00007F31 88C4                    	mov	ah,al
 10657 00007F33 08C0                    	or	al,al
 10658 00007F35 7504                    	jnz	.1
 10659 00007F37 B4FF                    	mov	ah,0FFh
 10660 00007F39 EB0A                    	jmp	.2
 10661                                  .1:
 10662 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
 10663 00007F3D 08E0                    	or	al,ah
 10664 00007F3F E621                    	out	pic1_reg1,al
 10665 00007F41 B020                    	mov	al,20h			; end of interrupt
 10666 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
 10667                                  .2:
 10668 00007F45 88266B00                	mov	byte [last_irq],ah
 10669 00007F49 1F                      	pop	ds
 10670 00007F4A 58                      	pop	ax
 10671 00007F4B CF                      	iret
 10672                                  
 10673                                  ;=========================================================================
 10674                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
 10675                                  ;-------------------------------------------------------------------------
 10676 00007F4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
 10677          ******************       warning: (setloc:7) Inserting 7 bytes
 10678                                  int_dummy:
 10679 00007F53 CF                      	iret
 10680                                  
 10681                                  ;=========================================================================
 10682                                  ; int_05 - BIOS Print Screen
 10683                                  ;-------------------------------------------------------------------------
 10684                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
 10685                                  int_05:
 10686 00007F54 FB                      	sti
 10687 00007F55 50                      	push	ax
 10688 00007F56 53                      	push	bx
 10689 00007F57 51                      	push	cx
 10690 00007F58 52                      	push	dx
 10691 00007F59 1E                      	push	ds
 10692 00007F5A B84000                  	mov	ax,biosdseg
 10693 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
 10694 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
 10695 00007F64 746A                    	je	.exit			; print screen is already in progress
 10696 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
 10697                                  					; signal that print screen is running
 10698                                  
 10699 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
 10700 00007F6D CD10                    	int	10h			; returns number of columns in AH
 10701                                  					; and active display page in BH
 10702 00007F6F 88E1                    	mov	cl,ah			; store number columns
 10703                                  
 10704 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
 10705 00007F75 08ED                    	or	ch,ch
 10706 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
 10707                                  
 10708 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
 10709 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
 10710 00007F7E 7602                    	jbe	.get_cursor_pos
 10711                                  
 10712                                  .wrong_num_rows:
 10713 00007F80 B519                    	mov	ch,25			; assume 25 rows
 10714                                  
 10715                                  .get_cursor_pos:
 10716 00007F82 B403                    	mov	ah,03h			; get cursor position and size
 10717 00007F84 CD10                    	int	10h			; returns cursor position in DX
 10718 00007F86 52                      	push	dx			; save original position / DX in stack
 10719                                  
 10720                                  
 10721 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
 10722 00007F89 E85100                  	call	.print_char
 10723 00007F8C 7548                    	jnz	.error
 10724 00007F8E B40A                    	mov	ah,0Ah
 10725 00007F90 E84A00                  	call	.print_char
 10726 00007F93 7541                    	jnz	.error
 10727                                  
 10728 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
 10729                                  
 10730                                  .row_loop:
 10731 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
 10732                                  
 10733                                  .column_loop:
 10734 00007F99 B402                    	mov	ah,02h
 10735 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
 10736                                  
 10737 00007F9D B408                    	mov	ah,08h
 10738 00007F9F CD10                    	int	10h			; read character at cursor position
 10739                                  
 10740 00007FA1 3C20                    	cmp	al,20h			; control character?
 10741 00007FA3 7302                    	jae	.continue		; no, print it
 10742 00007FA5 B020                    	mov	al,20h			; print space instead
 10743                                  
 10744                                  .continue:
 10745 00007FA7 E83300                  	call	.print_char
 10746 00007FAA 752A                    	jnz	.error
 10747 00007FAC FEC2                    	inc	dl
 10748 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
 10749 00007FB0 72E7                    	jb	.column_loop		; print next column
 10750                                  
 10751 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
 10752 00007FB4 E82600                  	call	.print_char
 10753 00007FB7 751D                    	jnz	.error
 10754 00007FB9 B40A                    	mov	ah,0Ah
 10755 00007FBB E81F00                  	call	.print_char
 10756 00007FBE 7516                    	jnz	.error
 10757                                  
 10758 00007FC0 FEC6                    	inc	dh
 10759 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
 10760 00007FC4 72D1                    	jb	.row_loop		; print next row
 10761                                  
 10762 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
 10763                                  					; ready for the next call
 10764                                  
 10765                                  .restore_cursor:
 10766 00007FCB 5A                      	pop	dx			; DX = original cursor position
 10767 00007FCC B402                    	mov	ah,02h
 10768 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
 10769                                  
 10770                                  .exit:
 10771 00007FD0 1F                      	pop	ds
 10772 00007FD1 5A                      	pop	dx
 10773 00007FD2 59                      	pop	cx
 10774 00007FD3 5B                      	pop	bx
 10775 00007FD4 58                      	pop	ax
 10776 00007FD5 CF                      	iret
 10777                                  
 10778                                  .error:
 10779 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
 10780                                  					; signal failure
 10781 00007FDB EBEE                    	jmp	.restore_cursor
 10782                                  
 10783                                  
 10784                                  .print_char:
 10785 00007FDD 52                      	push	dx
 10786 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
 10787 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
 10788 00007FE2 CD17                    	int	17h
 10789 00007FE4 5A                      	pop	dx
 10790 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
 10791 00007FE8 C3                      	ret
 10792                                  
 10793                                  ;=========================================================================
 10794                                  ; start - at power up or reset execution starts here (F000:FFF0)
 10795                                  ;-------------------------------------------------------------------------
 10796 00007FE9 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
 10797          ******************       warning: (setloc:7) Inserting 7 bytes
 10798                                  start:
 10799 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
 10800                                  
 10801                                  	setloc	0FFF5h			; ROM Date in ASCII
 10802 00007FF5 31322F31322F3136        	db	DATE			; BIOS release date MM/DD/YY
 10803 00007FFD 20                      	db	20h
 10804                                  
 10805                                  	setloc	0FFFEh			; System Model
 10806                                  %ifdef TANDY_ID
 10807                                  	db 0xFF					;; for tandy id
 10808                                  %else
 10809                                  %ifdef AT_COMPAT
 10810 00007FFE FC                      	db	0fch			; system is an IBM AT compatible
 10811                                  %else
 10812                                  	db	0feh			; system is an IBM PC/XT compatible
 10813                                  %endif ; AT_COMPAT
 10814                                  %endif
 10815 00007FFF FF                      	db	0ffh
 10816                                  
