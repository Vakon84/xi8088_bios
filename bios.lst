     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.07, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
   108                                  %include "config.inc"
   109                              <1> ;=========================================================================
   110                              <1> ; config.inc - Compilation time settings and settings
   111                              <1> ;-------------------------------------------------------------------------
   112                              <1> ;
   113                              <1> ; Compiles with NASM 2.07, might work with other versions
   114                              <1> ;
   115                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   116                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   117                              <1> ;
   118                              <1> ; This program is free software: you can redistribute it and/or modify
   119                              <1> ; it under the terms of the GNU General Public License as published by
   120                              <1> ; the Free Software Foundation, either version 3 of the License, or
   121                              <1> ; (at your option) any later version.
   122                              <1> ;
   123                              <1> ; This program is distributed in the hope that it will be useful,
   124                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   125                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   126                              <1> ; GNU General Public License for more details.
   127                              <1> ;
   128                              <1> ; You should have received a copy of the GNU General Public License
   129                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   130                              <1> ;
   131                              <1> ;=========================================================================
   132                              <1> 
   133                              <1> %define DATE		'12/31/12'	; BIOS release date MM/DD/YY
   134                              <1> %define VERSION		'0.8.1'		; BIOS version
   135                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   136                              <1> 
   137                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
   138                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   139                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   140                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   141                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   142                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   143                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   144                              <1> 					; EBDA is required for PS/2 aux support
   145                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   146                                  %include "errno.inc"
   147                              <1> ;=========================================================================
   148                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> ;
   151                              <1> ; Compiles with NASM 2.07, might work with other versions
   152                              <1> ;
   153                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   154                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   155                              <1> ;
   156                              <1> ; This program is free software: you can redistribute it and/or modify
   157                              <1> ; it under the terms of the GNU General Public License as published by
   158                              <1> ; the Free Software Foundation, either version 3 of the License, or
   159                              <1> ; (at your option) any later version.
   160                              <1> ;
   161                              <1> ; This program is distributed in the hope that it will be useful,
   162                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   163                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   164                              <1> ; GNU General Public License for more details.
   165                              <1> ;
   166                              <1> ; You should have received a copy of the GNU General Public License
   167                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   168                              <1> ;
   169                              <1> ;=========================================================================
   170                              <1> 
   171                              <1> e_start		equ	01h		; BIOS POST started
   172                              <1> e_cpu_ok	equ	02h		; CPU test passed
   173                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   174                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   175                              <1> e_int_ok	equ	05h		; interrupt table initialized
   176                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   177                              <1> e_pic_ok	equ	08h		; PIC initialized
   178                              <1> e_kbd_ok	equ	10h		; KBD test passed
   179                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   180                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   181                              <1> e_rtc_init_ok	equ	20h		; RTC initialized
   182                              <1> e_cpu_detect_ok	equ	21h		; CPU type detected
   183                              <1> e_fpu_detect_ok	equ	22h		; FPU type detected
   184                              <1> e_serial_ok	equ	24h		; Serial port scan finished
   185                              <1> e_parallel_ok	equ	25h		; Parallel port scan finished
   186                              <1> e_ram_start	equ	30h		; RAM test start
   187                              <1> e_ram_complete	equ	31h		; RAM test completed
   188                              <1> e_ram_esc	equ	32h		; RAM test canceled
   189                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   190                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found
   191                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   192                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   193                              <1> e_boot		equ	49h		; Boot the OS
   194                              <1> e_cpu_fail	equ	52h		; CPU test failed
   195                              <1> e_low_ram_fail	equ	54h		; low RAM test failed
   196                              <1> e_kbd_ctrl_fail	equ	60h		; KBD test - controller selftest failed
   197                              <1> e_kbd_key_fail	equ	61h		; KBD test - echo test failed
   198                              <1> e_kbd_timeout	equ	62h		; KBD timeout
   199                              <1> e_kbd_int_fail	equ	63h		; KBD test - interface test failed
   200                              <1> e_ram_fail	equ	80h		; RAM test failed
   201                                  
   202                                  bioscseg	equ	0F000h
   203                                  biosdseg	equ	0040h
   204                                  
   205                                  pic1_reg0	equ	20h
   206                                  pic1_reg1	equ	21h
   207                                  pit_ch0_reg	equ	40h
   208                                  pit_ch1_reg	equ	41h
   209                                  pit_ch2_reg	equ	42h
   210                                  pit_ctl_reg	equ	43h
   211                                  port_b_reg	equ	61h
   212                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   213                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   214                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   215                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   216                                  post_reg	equ	80h	; POST status output port
   217                                  pic2_reg0	equ	0A0h
   218                                  pic2_reg1	equ	0A1h
   219                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   220                                  cga_mode_reg	equ	3D8h
   221                                  mda_mode_reg	equ	3B8h
   222                                  
   223                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   224                                  
   225                                  ;========================================================================
   226                                  ; BIOS data area variables
   227                                  ;------------------------------------------------------------------------
   228                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   229                                  				; or 0 if port doesn't exist
   230                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   231                                  				; or 0 if port doesn't exist
   232                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   233                                  equipment_list	equ	10h	; word - equpment list
   234                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   235                                  equip_fpu	equ	0000000000000010b	; FPU installed
   236                                  equip_mouse	equ	0000000000000100b
   237                                  equip_video	equ	0000000000110000b	; video type bit mask
   238                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   239                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   240                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   241                                  ;			|||||||||||||||`-- floppy drives installed
   242                                  ;			||||||||||||||`-- FPU installed
   243                                  ;			|||||||||||||`-- PS/2 mouse installed
   244                                  ;			||||||||||||`-- reserved
   245                                  ;			||||||||||`--- initial video mode
   246                                  ;			||||||||`---- number of floppy drives - 1
   247                                  ;			|||||||`---- O = DMA installed
   248                                  ;			||||`------ number of serial ports
   249                                  ;			|||`------ game adapter installed
   250                                  ;			||`------ internal modem?!
   251                                  ;			`------- number of parallel ports
   252                                  
   253                                  post_flags	equ	12h	; byte - post flags
   254                                  post_setup	equ	01h	; run NVRAM setup
   255                                  memory_size	equ	13h	; word - memory size in KiB
   256                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   257                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   258                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   259                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   260                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   261                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   262                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   263                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   264                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   265                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   266                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   267                                  video_mode	equ	49h	; byte - active video mode number
   268                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   269                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   270                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   271                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   272                                  video_cur_shape	equ	60h	; word - cursor shape
   273                                  video_page	equ	62h	; byte - active video page
   274                                  video_port	equ	63h	; word - I/O port for the display adapter
   275                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   276                                  video_palet_reg	equ	66h	; byte - color palette
   277                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   278                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   279                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   280                                  new_day		equ	70h	; byte - 1 = new day flag
   281                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   282                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   283                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   284                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   285                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   286                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   287                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   288                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   289                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   290                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   291                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   292                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   293                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   294                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   295                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   296                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   297                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   298                                  
   299                                  ;=========================================================================
   300                                  ; Extended BIOS data area variables
   301                                  ;-------------------------------------------------------------------------
   302                                  ebda_size	equ	0h
   303                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   304                                  mouse_flags_1	equ	26h
   305                                  mouse_flags_2	equ	27h
   306                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   307                                  
   308                                  	org	START		; Use only upper 32 KiB of ROM
   309                                  
   310                                  ;=========================================================================
   311                                  ; Includes
   312                                  ;-------------------------------------------------------------------------
   313                                  %include	"messages.inc"		; POST messages
   314                              <1> ;=========================================================================
   315                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> ;
   318                              <1> ; Compiles with NASM 2.07, might work with other versions
   319                              <1> ;
   320                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   321                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   322                              <1> ;
   323                              <1> ; This program is free software: you can redistribute it and/or modify
   324                              <1> ; it under the terms of the GNU General Public License as published by
   325                              <1> ; the Free Software Foundation, either version 3 of the License, or
   326                              <1> ; (at your option) any later version.
   327                              <1> ;
   328                              <1> ; This program is distributed in the hope that it will be useful,
   329                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   330                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   331                              <1> ; GNU General Public License for more details.
   332                              <1> ;
   333                              <1> ; You should have received a copy of the GNU General Public License
   334                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   335                              <1> ;
   336                              <1> ;=========================================================================
   337                              <1> 
   338 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   339 00000002 586920383038382042- <1> 		db	"Xi 8088 BIOS, Version "
   340 0000000B 494F532C2056657273- <1>
   341 00000014 696F6E20            <1>
   342 00000018 302E382E31          <1> 		db	VERSION
   343 0000001D 2E20                <1> 		db	". "
   344 0000001F 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2012 Sergey Kiselev", 0Dh, 0Ah
   345 00000028 202843292032303130- <1>
   346 00000031 202D20323031322053- <1>
   347 0000003A 6572676579204B6973- <1>
   348 00000043 656C65760D0A        <1>
   349 00000049 446973747269627574- <1> 		db	"Distributed under the terms of "
   350 00000052 656420756E64657220- <1>
   351 0000005B 746865207465726D73- <1>
   352 00000064 206F6620            <1>
   353 00000068 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   354 00000071 656E6572616C205075- <1>
   355 0000007A 626C6963204C696365- <1>
   356 00000083 6E73650D0A          <1>
   357 00000088 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   358 0000008B 6E6F6E6500          <1> msg_none	db	'none', 00h
   359 00000090 3A2000              <1> msg_colon	db	': ', 00h
   360 00000093 3B2000              <1> msg_semicolon	db	'; ', 00h
   361 00000096 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   362 0000009F 6573736F723A202020- <1>
   363 000000A8 202020202020202020- <1>
   364 000000B1 2000                <1>
   365 000000B3 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   366 000000BC 637320436F2D70726F- <1>
   367 000000C5 636573736F723A2020- <1>
   368 000000CE 2000                <1>
   369 000000D0 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 0Dh, 0Ah
   370 000000D9 38202737380D0A      <1>
   371 000000E0 5741524E494E473A20- <1> 		db      'WARNING: This CPU does not disable interrupts '
   372 000000E9 546869732043505520- <1>
   373 000000F2 646F6573206E6F7420- <1>
   374 000000FB 64697361626C652069- <1>
   375 00000104 6E7465727275707473- <1>
   376 0000010D 20                  <1>
   377 0000010E 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   378 00000117 64696E67207365676D- <1>
   379 00000120 656E74207265676973- <1>
   380 00000129 74657273210D0A00    <1>
   381 00000131 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   382 0000013A 3820273831206F7220- <1>
   383 00000143 6C617465722C20      <1>
   384 0000014A 6F72206F6C64657220- <1> 		db      'or older Intel 80C88', 0Dh, 0Ah, 00h
   385 00000153 496E74656C20383043- <1>
   386 0000015C 38380D0A00          <1>
   387 00000161 486172726973202F20- <1> msg_cpu_harris  db      'Harris / Intersil / newer Intel 80C88', 0Dh, 0Ah, 00h
   388 0000016A 496E74657273696C20- <1>
   389 00000173 2F206E657765722049- <1>
   390 0000017C 6E74656C2038304338- <1>
   391 00000185 380D0A00            <1>
   392 00000189 4E4543205632300D0A- <1> msg_cpu_nec_v20 db      'NEC V20', 0Dh, 0Ah, 00h
   393 00000192 00                  <1>
   394 00000193 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   395 0000019C 370D0A00            <1>
   396 000001A0 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   397 000001A9 646170746572205479- <1>
   398 000001B2 70653A202020202020- <1>
   399 000001BB 2000                <1>
   400 000001BD 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   401 000001C6 566964656F2042494F- <1>
   402 000001CF 532050726573656E74- <1>
   403 000001D8 290D0A00            <1>
   404 000001DC 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   405 000001E2 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   406 000001EB 7263756C65730D0A00  <1>
   407 000001F4 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   408 000001FD 736B20647269766573- <1>
   409 00000206 3A2020202020202020- <1>
   410 0000020F 20447269766520303A- <1>
   411 00000218 2000                <1>
   412 0000021A 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   413 00000223 3A2000              <1>
   414 00000226 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   415 0000022F 2E32352200          <1>
   416 00000234 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   417 0000023D 2E32352200          <1>
   418 00000242 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   419 0000024B 2E352200            <1>
   420 0000024F 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   421 00000258 332E352200          <1>
   422 0000025D 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   423 00000266 332E352200          <1>
   424 0000026B 50532F322041757820- <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   425 00000274 44657669636520284D- <1>
   426 0000027D 6F757365293A202020- <1>
   427 00000286 2000                <1>
   428 00000288 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   429 00000291 00                  <1>
   430 00000292 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   431 0000029B 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   432 000002A4 7274733A2020202020- <1>
   433 000002AD 202020202020202020- <1>
   434 000002B6 2000                <1>
   435 000002B8 434F4D00            <1> msg_serial_com	db	'COM', 00h
   436 000002BC 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   437 000002C5 506F7274733A202020- <1>
   438 000002CE 202020202020202020- <1>
   439 000002D7 2000                <1>
   440 000002D9 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   441 000002DD 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   442 000002E6 414D20284553432074- <1>
   443 000002EF 6F20736B6970293A20- <1>
   444 000002F8 2000                <1>
   445 000002FA 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   446 00000303 4661756C7479206D65- <1>
   447 0000030C 6D6F72792064657465- <1>
   448 00000315 637465642061742000  <1>
   449 0000031E 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   450 00000327 6E76656E74696F6E61- <1>
   451 00000330 6C2052414D3A202020- <1>
   452 00000339 202000              <1>
   453 0000033C 526573657276656420- <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   454 00000345 666F7220454244413A- <1>
   455 0000034E 202020202020202020- <1>
   456 00000357 2000                <1>
   457 00000359 417661696C61626C65- <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   458 00000362 20436F6E76656E7469- <1>
   459 0000036B 6F6E616C2052414D3A- <1>
   460 00000374 2000                <1>
   461 00000376 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   462 0000037D 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   463 00000386 65642C207072657373- <1>
   464 0000038F 20616E79206B657920- <1>
   465 00000398 746F20747279206167- <1>
   466 000003A1 61696E2E2E2E0D0A00  <1>
   467 000003AA 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   468 000003B3 5349430D0A00        <1>
   469 000003B9 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   470 000003C2 5320657874656E7369- <1>
   471 000003CB 6F6E20524F4D206174- <1>
   472 000003D4 2000                <1>
   473 000003D6 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   474 000003DF 6C697A696E672E2E2E- <1>
   475 000003E8 0D0A00              <1>
   476 000003EB 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   477 000003F4 532E2E2E0D0A00      <1>
   478 000003FB 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   479 00000404 432062617474657279- <1>
   480 0000040D 206973206261640D0A- <1>
   481 00000416 00                  <1>
   482 00000417 4552524F523A204E56- <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   483 00000420 52414D20636865636B- <1>
   484 00000429 73756D20697320696E- <1>
   485 00000432 76616C69642C20      <1>
   486 00000439 6C6F6164696E672064- <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   487 00000442 656661756C74207661- <1>
   488 0000044B 6C75657320746F204E- <1>
   489 00000454 5652414D0D0A00      <1>
   490 0000045B 507265737320463120- <1> msg_setup	db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   491 00000464 746F2072756E204E56- <1>
   492 0000046D 52414D207365747570- <1>
   493 00000476 2E2E2E0D0A0D0A00    <1>
   494 0000047E 0D0A                <1> msg_set_menu	db	0Dh, 0Ah
   495 00000480 4E5652414D20536574- <1> 		db	'NVRAM Setup Menu:', 0Dh, 0Ah,
   496 00000489 7570204D656E753A0D- <1>
   497 00000492 0A                  <1>
   498 00000493 66202D204368616E67- <1> 		db	'f - Change first floppy type', 0Dh, 0Ah
   499 0000049C 652066697273742066- <1>
   500 000004A5 6C6F70707920747970- <1>
   501 000004AE 650D0A              <1>
   502 000004B1 67202D204368616E67- <1> 		db	'g - Change second floppy type', 0Dh, 0Ah
   503 000004BA 65207365636F6E6420- <1>
   504 000004C3 666C6F707079207479- <1>
   505 000004CC 70650D0A            <1>
   506 000004D0 70202D205072696E74- <1> 		db	'p - Print current settings', 0Dh, 0Ah
   507 000004D9 2063757272656E7420- <1>
   508 000004E2 73657474696E67730D- <1>
   509 000004EB 0A                  <1>
   510 000004EC 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   511 000004F5 6368616E6765732061- <1>
   512 000004FE 6E6420657869740D0A  <1>
   513 00000507 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   514 00000510 776974686F75742073- <1>
   515 00000519 6176696E6720636861- <1>
   516 00000522 6E6765730D0A        <1>
   517 00000528 0D0A                <1> 		db	0Dh, 0Ah
   518 0000052A 456E74657220796F75- <1> 		db	'Enter your selection: ', 00h
   519 00000533 722073656C65637469- <1>
   520 0000053C 6F6E3A2000          <1>
   521 00000541 0D0A                <1> msg_set_floppy	db	0Dh, 0Ah
   522 00000543 466C6F707079205365- <1> 		db	'Floppy Setup Menu:', 0Dh, 0Ah
   523 0000054C 747570204D656E753A- <1>
   524 00000555 0D0A                <1>
   525 00000557 30202D204E6F20666C- <1> 		db	'0 - No floppy', 0Dh, 0Ah
   526 00000560 6F7070790D0A        <1>
   527 00000566 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"', 0Dh, 0Ah
   528 0000056F 422C20352E3235220D- <1>
   529 00000578 0A                  <1>
   530 00000579 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.24"', 0Dh, 0Ah
   531 00000582 422C20352E3234220D- <1>
   532 0000058B 0A                  <1>
   533 0000058C 33202D20373230204B- <1> 		db	'3 - 720 KB, 3.5"', 0Dh, 0Ah
   534 00000595 422C20332E35220D0A  <1>
   535 0000059E 34202D20312E343420- <1> 		db	'4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   536 000005A7 4D422C20332E35220D- <1>
   537 000005B0 0A                  <1>
   538 000005B1 36202D20322E383820- <1> 		db	'6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   539 000005BA 4D422C20332E35220D- <1>
   540 000005C3 0A                  <1>
   541 000005C4 71202D205265747572- <1> 		db	'q - Return to the main menu', 0Dh, 0Ah
   542 000005CD 6E20746F2074686520- <1>
   543 000005D6 6D61696E206D656E75- <1>
   544 000005DF 0D0A                <1>
   545 000005E1 0D0A                <1> 		db	0Dh, 0Ah
   546 000005E3 456E74657220796F75- <1> 		db	'Enter your selection: ', 00h
   547 000005EC 722073656C65637469- <1>
   548 000005F5 6F6E3A2000          <1>
   549 000005FA [8B00]              <1> tbl_floppy	dw	msg_none
   550 000005FC [2602]              <1> 		dw	msg_floppy_360
   551 000005FE [3402]              <1> 		dw	msg_floppy_1200
   552 00000600 [4202]              <1> 		dw	msg_floppy_720
   553 00000602 [4F02]              <1> 		dw	msg_floppy_1440
   554 00000604 [8B00]              <1> 		dw	msg_none
   555 00000606 [5D02]              <1> 		dw	msg_floppy_2880
   556 00000608 [8B00]              <1> 		dw	msg_none
   557                                  %include	"fnt80-FF.inc"		; font for graphics modes
   558                              <1> ;=========================================================================
   559                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   560                              <1> ;       Characters from 80h to 0FFh
   561                              <1> ;-------------------------------------------------------------------------
   562                              <1> ;
   563                              <1> ; Compiles with NASM 2.07, might work with other versions
   564                              <1> ;
   565                              <1> ; This font is borrowed from kbd package (alt-8x8)
   566                              <1> ;
   567                              <1> ; This program is free software: you can redistribute it and/or modify
   568                              <1> ; it under the terms of the GNU General Public License as published by
   569                              <1> ; the Free Software Foundation, either version 3 of the License, or
   570                              <1> ; (at your option) any later version.
   571                              <1> ;
   572                              <1> ; This program is distributed in the hope that it will be useful,
   573                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   574                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   575                              <1> ; GNU General Public License for more details.
   576                              <1> ;
   577                              <1> ; You should have received a copy of the GNU General Public License
   578                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   579                              <1> ;
   580                              <1> ;=========================================================================
   581                              <1> int_1F:
   582 0000060A 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   583 00000612 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   584 0000061A 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   585 00000622 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   586 0000062A 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   587 00000632 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   588 0000063A DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   589 00000642 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   590 0000064A 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   591 00000652 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   592 0000065A 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   593 00000662 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   594 0000066A C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   595 00000672 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   596 0000067A 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   597 00000682 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   598 0000068A 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   599 00000692 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   600 0000069A 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   601 000006A2 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   602 000006AA 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   603 000006B2 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   604 000006BA 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   605 000006C2 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   606 000006CA DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   607 000006D2 DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   608 000006DA E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   609 000006E2 C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   610 000006EA 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   611 000006F2 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   612 000006FA CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   613 00000702 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   614 0000070A 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   615 00000712 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   616 0000071A 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   617 00000722 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   618 0000072A 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   619 00000732 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   620 0000073A 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   621 00000742 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   622 0000074A 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   623 00000752 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   624 0000075A 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   625 00000762 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   626 0000076A 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   627 00000772 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   628 0000077A 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   629 00000782 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   630 0000078A 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   631 00000792 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   632 0000079A DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   633 000007A2 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   634 000007AA 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   635 000007B2 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   636 000007BA 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   637 000007C2 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   638 000007CA 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   639 000007D2 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   640 000007DA 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   641 000007E2 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   642 000007EA 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   643 000007F2 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   644 000007FA 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   645 00000802 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   646 0000080A 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   647 00000812 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   648 0000081A 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   649 00000822 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   650 0000082A 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   651 00000832 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   652 0000083A 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   653 00000842 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   654 0000084A 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   655 00000852 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   656 0000085A 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   657 00000862 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   658 0000086A 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   659 00000872 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   660 0000087A 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   661 00000882 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   662 0000088A 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   663 00000892 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   664 0000089A 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   665 000008A2 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   666 000008AA 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   667 000008B2 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   668 000008BA 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   669 000008C2 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   670 000008CA 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   671 000008D2 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   672 000008DA 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   673 000008E2 FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   674 000008EA 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   675 000008F2 F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   676 000008FA 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   677 00000902 FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   678 0000090A 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   679 00000912 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   680 0000091A 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   681 00000922 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   682 0000092A 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   683 00000932 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   684 0000093A 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   685 00000942 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   686 0000094A 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   687 00000952 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   688 0000095A 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   689 00000962 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   690 0000096A 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   691 00000972 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   692 0000097A 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   693 00000982 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   694 0000098A 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   695 00000992 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   696 0000099A 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   697 000009A2 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   698 000009AA 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   699 000009B2 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   700 000009BA 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   701 000009C2 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   702 000009CA 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   703 000009D2 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   704 000009DA 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   705 000009E2 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   706 000009EA 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   707 000009F2 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   708 000009FA 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   709 00000A02 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   710                                  ;%include	"inttrace.inc"		; XXX
   711                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   712                              <1> ;=========================================================================
   713                              <1> ; rtc.inc - RTC/CMOS read and write functions
   714                              <1> ;-------------------------------------------------------------------------
   715                              <1> ;
   716                              <1> ; Compiles with NASM 2.07, might work with other versions
   717                              <1> ;
   718                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
   719                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   720                              <1> ;
   721                              <1> ; This program is free software: you can redistribute it and/or modify
   722                              <1> ; it under the terms of the GNU General Public License as published by
   723                              <1> ; the Free Software Foundation, either version 3 of the License, or
   724                              <1> ; (at your option) any later version.
   725                              <1> ;
   726                              <1> ; This program is distributed in the hope that it will be useful,
   727                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   728                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   729                              <1> ; GNU General Public License for more details.
   730                              <1> ;
   731                              <1> ; You should have received a copy of the GNU General Public License
   732                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   733                              <1> ;
   734                              <1> ;=========================================================================
   735                              <1> 
   736                              <1> ;-------------------------------------------------------------------------
   737                              <1> ; RTC ports
   738                              <1> rtc_addr_reg	equ	70h	; RTC address port
   739                              <1> rtc_data_reg	equ	71h	; RTC data port
   740                              <1> 
   741                              <1> ;-------------------------------------------------------------------------
   742                              <1> ; locations in RTC and NVRAM
   743                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   744                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   745                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   746                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   747                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   748                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   749                              <1> cmos_day	equ	06h	; day location in RTC
   750                              <1> cmos_date	equ	07h	; date location in RTC
   751                              <1> cmos_month	equ	08h	; month location in RTC
   752                              <1> cmos_year	equ	09h	; year location in RTC
   753                              <1> cmos_floppy	equ	10h	; floppy type byte
   754                              <1> cmos_equip	equ	14h	; equipment byte
   755                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   756                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   757                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   758                              <1> 
   759                              <1> ;-------------------------------------------------------------------------
   760                              <1> ; RTC control register and their bits
   761                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   762                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   763                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   764                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   765                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   766                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   767                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   768                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   769                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   770                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   771                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   772                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   773                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   774                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   775                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   776                              <1> 
   777                              <1> ;-------------------------------------------------------------------------
   778                              <1> ; NMI flag
   779                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   780                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   781                              <1> 
   782                              <1> ;=========================================================================
   783                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   784                              <1> ; Input:
   785                              <1> ;	AL - address and NMI enable bit
   786                              <1> ;		bits 6-0 - address of byte to read
   787                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   788                              <1> ; Output:
   789                              <1> ;	AL = byte from RTC
   790                              <1> ;-------------------------------------------------------------------------
   791                              <1> rtc_read:
   792 00000A0A FA                  <1> 	cli
   793 00000A0B E670                <1> 	out	rtc_addr_reg,al
   794 00000A0D EB00                <1> 	jmp	$+2
   795 00000A0F EB00                <1> 	jmp	$+2
   796 00000A11 E471                <1> 	in	al,rtc_data_reg
   797 00000A13 FB                  <1> 	sti
   798 00000A14 C3                  <1> 	ret
   799                              <1> 
   800                              <1> ;=========================================================================
   801                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   802                              <1> ; Input:
   803                              <1> ;	AL - address and NMI enable bit
   804                              <1> ;		bits 6-0 - address of byte to read
   805                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   806                              <1> ;	AH = byte to write to RTC
   807                              <1> ;-------------------------------------------------------------------------
   808                              <1> rtc_write:
   809 00000A15 FA                  <1> 	cli
   810 00000A16 E670                <1> 	out	rtc_addr_reg,al
   811 00000A18 EB00                <1> 	jmp	$+2
   812 00000A1A EB00                <1> 	jmp	$+2
   813 00000A1C 86E0                <1> 	xchg	ah,al
   814 00000A1E E671                <1> 	out	rtc_data_reg,al
   815 00000A20 86E0                <1> 	xchg	ah,al
   816 00000A22 FB                  <1> 	sti
   817 00000A23 C3                  <1> 	ret
   818                              <1> 
   819                              <1> ;=========================================================================
   820                              <1> ; rtc_init - Initialize RTC
   821                              <1> ; Notes:
   822                              <1> ;	- makes sure RTC battery is OK, resets time if not
   823                              <1> ;	- disables RTC interrupts
   824                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   825                              <1> ;-------------------------------------------------------------------------
   826                              <1> rtc_init:
   827 00000A24 50                  <1> 	push	ax
   828 00000A25 53                  <1> 	push	bx
   829 00000A26 51                  <1> 	push	cx
   830 00000A27 52                  <1> 	push	dx
   831 00000A28 56                  <1> 	push	si
   832 00000A29 57                  <1> 	push	di
   833 00000A2A B00A                <1> 	mov	al,cmos_control_a	; select control A register
   834 00000A2C B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   835                              <1> 					; set SQW frequency to 1.024 KHz
   836 00000A2E E8E4FF              <1> 	call	rtc_write		; write control register A
   837                              <1> 
   838 00000A31 B00B                <1> 	mov	al,cmos_control_b
   839 00000A33 B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   840                              <1> 					; interrupts disabled
   841 00000A35 E8DDFF              <1> 	call	rtc_write		; write control register B
   842                              <1> 
   843 00000A38 B00C                <1> 	mov	al,cmos_control_c
   844 00000A3A E8CDFF              <1> 	call	rtc_read		; read control register C - reset
   845                              <1> 					; interrupt flags
   846                              <1> 
   847 00000A3D B00D                <1> 	mov	al,cmos_control_d
   848 00000A3F E8C8FF              <1> 	call	rtc_read		; read control register D
   849 00000A42 A880                <1> 	test	al,cmos_vrt
   850 00000A44 7518                <1> 	jnz	.1			; RTC battery is OK
   851 00000A46 BE[FB03]            <1> 	mov	si,msg_rtc_bad
   852 00000A49 E8CE17              <1> 	call	print
   853                              <1> ; RTC is bad, set initial time
   854 00000A4C B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   855 00000A4E 31C9                <1> 	xor	cx,cx
   856 00000A50 31D2                <1> 	xor	dx,dx
   857 00000A52 CD1A                <1> 	int	1Ah
   858 00000A54 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   859 00000A56 B91020              <1> 	mov	cx,2010h		; year 2010
   860 00000A59 BA0101              <1> 	mov	dx,0101h		; January 1st
   861 00000A5C CD1A                <1> 	int	1Ah
   862                              <1> 
   863                              <1> .1:
   864                              <1> ; set timer variables to RTC time
   865 00000A5E B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   866 00000A60 CD1A                <1> 	int	1Ah
   867                              <1> 
   868                              <1> ; convert time to ticks * 2^11
   869                              <1> 
   870                              <1> ; ticks = seconds * 37287
   871 00000A62 88F0                <1> 	mov	al,dh
   872 00000A64 E8AE00              <1> 	call	bcd_to_binary		; convert seconds to binary
   873                              <1> 
   874 00000A67 BAA791              <1> 	mov	dx,37287
   875 00000A6A F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   876                              <1> 
   877 00000A6C 89C6                <1> 	mov	si,ax
   878 00000A6E 89D7                <1> 	mov	di,dx
   879                              <1> 
   880                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   881 00000A70 88C8                <1> 	mov	al,cl
   882 00000A72 E8A000              <1> 	call	bcd_to_binary		; convert minutes to binary
   883                              <1> 
   884 00000A75 89C3                <1> 	mov	bx,ax
   885 00000A77 BA2023              <1> 	mov	dx,8992
   886 00000A7A F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   887                              <1> 
   888 00000A7C 01C6                <1> 	add	si,ax
   889 00000A7E 11D7                <1> 	adc	di,dx
   890                              <1> 
   891 00000A80 89D8                <1> 	mov	ax,bx
   892 00000A82 BA2200              <1> 	mov	dx,34
   893 00000A85 F7E2                <1> 	mul	dx
   894                              <1> 
   895 00000A87 01C7                <1> 	add	di,ax
   896                              <1> 
   897                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   898 00000A89 88E8                <1> 	mov	al,ch
   899 00000A8B E88700              <1> 	call	bcd_to_binary		; convert hours to binary
   900                              <1> 
   901 00000A8E 89C3                <1> 	mov	bx,ax
   902 00000A90 BA6A3B              <1> 	mov	dx,15210
   903 00000A93 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   904                              <1> 
   905 00000A95 01C6                <1> 	add	si,ax
   906 00000A97 11D7                <1> 	adc	di,dx
   907                              <1> 
   908 00000A99 89D8                <1> 	mov	ax,bx
   909 00000A9B BA0008              <1> 	mov	dx,2048
   910 00000A9E F7E2                <1> 	mul	dx			; AX = hours * 2048
   911                              <1> 
   912 00000AA0 01C7                <1> 	add	di,ax
   913                              <1> 
   914                              <1> ; CX:DX = DI:SI / 2048
   915 00000AA2 B10B                <1> 	mov	cl,11
   916 00000AA4 D3EE                <1> 	shr	si,cl
   917 00000AA6 89FA                <1> 	mov	dx,di
   918 00000AA8 B105                <1> 	mov	cl,5
   919 00000AAA D3E2                <1> 	shl	dx,cl
   920 00000AAC 09F2                <1> 	or	dx,si
   921                              <1> 
   922 00000AAE B10B                <1> 	mov	cl,11
   923 00000AB0 D3EF                <1> 	shr	di,cl
   924 00000AB2 89F9                <1> 	mov	cx,di
   925                              <1> 
   926                              <1> 					; CX = high word of tick count
   927                              <1> 					; DX = low word of tick count
   928                              <1> 	
   929 00000AB4 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   930 00000AB6 CD1A                <1> 	int	1Ah	
   931                              <1> 
   932                              <1> 
   933                              <1> ; compare NVRAM checksum with stored value
   934                              <1> 
   935 00000AB8 E86C00              <1> 	call	rtc_checksum
   936                              <1> 
   937 00000ABB B02E                <1> 	mov	al,cmos_sum_hi
   938 00000ABD E84AFF              <1> 	call	rtc_read
   939 00000AC0 88C4                <1> 	mov	ah,al
   940 00000AC2 B02F                <1> 	mov	al,cmos_sum_lo
   941 00000AC4 E843FF              <1> 	call	rtc_read
   942 00000AC7 39C3                <1> 	cmp	bx,ax
   943 00000AC9 742F                <1> 	je	.update_equipment
   944                              <1> 
   945 00000ACB BE[1704]            <1> 	mov	si,msg_rtc_sum
   946 00000ACE E84917              <1> 	call	print
   947                              <1> 
   948                              <1> ; clear NVRAM
   949                              <1> 
   950 00000AD1 B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   951                              <1> 
   952                              <1> .nvram_clear_loop:
   953 00000AD4 E83EFF              <1> 	call	rtc_write
   954 00000AD7 FEC0                <1> 	inc	al
   955 00000AD9 3C20                <1> 	cmp	al,20h			; last address is 20h
   956 00000ADB 76F7                <1> 	jbe	.nvram_clear_loop
   957                              <1> 
   958 00000ADD B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   959 00000AE0 E832FF              <1> 	call	rtc_write
   960                              <1> 
   961 00000AE3 B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
   962 00000AE6 E82CFF              <1> 	call	rtc_write
   963                              <1> 
   964                              <1> ; update checksum
   965                              <1> 
   966 00000AE9 E83B00              <1> 	call	rtc_checksum
   967                              <1> 
   968 00000AEC B02E                <1> 	mov	al,cmos_sum_hi
   969 00000AEE 88FC                <1> 	mov	ah,bh
   970 00000AF0 E822FF              <1> 	call	rtc_write
   971                              <1> 
   972 00000AF3 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
   973 00000AF5 88DC                <1> 	mov	ah,bl
   974 00000AF7 E81BFF              <1> 	call	rtc_write
   975                              <1> 
   976                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
   977                              <1> 
   978                              <1> .update_equipment:
   979 00000AFA B014                <1> 	mov	al,cmos_equip
   980 00000AFC E80BFF              <1> 	call	rtc_read
   981 00000AFF 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
   982 00000B01 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
   983 00000B06 08061000            <1> 	or	byte [equipment_list],al
   984                              <1> 
   985 00000B0A B020                <1> 	mov	al,e_rtc_init_ok	; RTC initialzied successfully
   986 00000B0C E680                <1> 	out	post_reg,al
   987                              <1> 
   988 00000B0E 5F                  <1> 	pop	di
   989 00000B0F 5E                  <1> 	pop	si
   990 00000B10 5A                  <1> 	pop	dx
   991 00000B11 59                  <1> 	pop	cx
   992 00000B12 5B                  <1> 	pop	bx
   993 00000B13 58                  <1> 	pop	ax
   994 00000B14 C3                  <1> 	ret
   995                              <1> 
   996                              <1> bcd_to_binary:
   997 00000B15 51                  <1> 	push	cx
   998 00000B16 88C5                <1> 	mov	ch,al
   999 00000B18 80E50F              <1> 	and	ch,0Fh
  1000 00000B1B B104                <1> 	mov	cl,4
  1001 00000B1D D2E8                <1> 	shr	al,cl
  1002 00000B1F B10A                <1> 	mov	cl,10
  1003 00000B21 F6E1                <1> 	mul	cl
  1004 00000B23 00E8                <1> 	add	al,ch
  1005 00000B25 59                  <1> 	pop	cx
  1006 00000B26 C3                  <1> 	ret
  1007                              <1> 
  1008                              <1> ;=========================================================================
  1009                              <1> ; rtc_checksum - calculate NVRAM checksum
  1010                              <1> ; Input:
  1011                              <1> ;	none
  1012                              <1> ; Output:
  1013                              <1> ;	BX = NVRAM checksum
  1014                              <1> ;-------------------------------------------------------------------------
  1015                              <1> rtc_checksum:
  1016 00000B27 50                  <1> 	push	ax
  1017 00000B28 31DB                <1> 	xor	bx,bx
  1018 00000B2A B410                <1> 	mov	ah,10h			; start from 10h
  1019                              <1> 
  1020                              <1> .checksum_loop:
  1021 00000B2C 88E0                <1> 	mov	al,ah
  1022 00000B2E E8D9FE              <1> 	call	rtc_read
  1023 00000B31 00C3                <1> 	add	bl,al			; BX += AL
  1024 00000B33 80D700              <1> 	adc	bh,0
  1025 00000B36 FEC4                <1> 	inc	ah
  1026 00000B38 80FC20              <1> 	cmp	ah,20h			; last address is 20h
  1027 00000B3B 76EF                <1> 	jbe	.checksum_loop
  1028 00000B3D 58                  <1> 	pop	ax
  1029 00000B3E C3                  <1> 	ret
  1030                              <1> 
  1031                              <1> ;=========================================================================
  1032                              <1> ; rtc_setup - NVRAM configuration utility
  1033                              <1> ; Input:
  1034                              <1> ;	none
  1035                              <1> ; Output:
  1036                              <1> ;	none
  1037                              <1> ;-------------------------------------------------------------------------
  1038                              <1> rtc_setup:
  1039 00000B3F 50                  <1> 	push	ax
  1040 00000B40 53                  <1> 	push	bx
  1041 00000B41 51                  <1> 	push	cx
  1042 00000B42 52                  <1> 	push	dx
  1043 00000B43 56                  <1> 	push	si
  1044                              <1> 
  1045 00000B44 B010                <1> 	mov	al,cmos_floppy
  1046 00000B46 E8C1FE              <1> 	call	rtc_read		; read currently configured floppies
  1047 00000B49 88C1                <1> 	mov	cl,al			; save it to CL
  1048                              <1> 
  1049                              <1> .menu_loop:
  1050 00000B4B BE[7E04]            <1> 	mov	si,msg_set_menu
  1051 00000B4E E8C916              <1> 	call	print
  1052                              <1> 
  1053                              <1> .menu_input:
  1054 00000B51 B400                <1> 	mov	ah,00h
  1055 00000B53 CD16                <1> 	int	16h
  1056 00000B55 0C20                <1> 	or	al,20h			; convert to lower case
  1057 00000B57 B200                <1> 	mov	dl,0			; floppy 0
  1058 00000B59 3C66                <1> 	cmp	al,'f'
  1059 00000B5B 7417                <1> 	je	.set_floppy
  1060 00000B5D FEC2                <1> 	inc	dl			; floppy 1
  1061 00000B5F 3C67                <1> 	cmp	al,'g'
  1062 00000B61 7411                <1> 	je	.set_floppy
  1063 00000B63 3C70                <1> 	cmp	al,'p'
  1064 00000B65 7458                <1> 	je	.print_settings
  1065 00000B67 3C77                <1> 	cmp	al,'w'
  1066 00000B69 7469                <1> 	je	.save
  1067 00000B6B 3C71                <1> 	cmp	al,'q'
  1068 00000B6D 7503E99C00          <1> 	je	.exit
  1069 00000B72 EBDD                <1> 	jmp	.menu_input
  1070                              <1> 
  1071                              <1> .set_floppy:
  1072 00000B74 B40E                <1> 	mov	ah,0Eh			; echo
  1073 00000B76 BB0700              <1> 	mov	bx,0007h
  1074 00000B79 CD10                <1> 	int	10h
  1075 00000B7B BE[4105]            <1> 	mov	si,msg_set_floppy
  1076 00000B7E E89916              <1> 	call	print
  1077                              <1> .floppy_input:
  1078 00000B81 B400                <1> 	mov	ah,00h
  1079 00000B83 CD16                <1> 	int	16h
  1080 00000B85 0C20                <1> 	or	al,20h			; convert to lower case
  1081 00000B87 3C71                <1> 	cmp	al,'q'
  1082 00000B89 742B                <1> 	je	.floppy_exit
  1083 00000B8B 3C30                <1> 	cmp	al,'0'
  1084 00000B8D 72F2                <1> 	jb	.floppy_input
  1085 00000B8F 3C36                <1> 	cmp	al,'6'
  1086 00000B91 77EE                <1> 	ja	.floppy_input
  1087 00000B93 3C35                <1> 	cmp	al,'5'
  1088 00000B95 74EA                <1> 	je	.floppy_input
  1089 00000B97 B40E                <1> 	mov	ah,0Eh			; echo
  1090 00000B99 BB0700              <1> 	mov	bx,0007h
  1091 00000B9C CD10                <1> 	int	10h
  1092 00000B9E 2C30                <1> 	sub	al,'0'
  1093 00000BA0 B6F0                <1> 	mov	dh,0F0h
  1094 00000BA2 08D2                <1> 	or	dl,dl			; drive	0?
  1095 00000BA4 750A                <1> 	jnz	.drive_1
  1096 00000BA6 D0E0                <1> 	shl	al,1
  1097 00000BA8 D0E0                <1> 	shl	al,1
  1098 00000BAA D0E0                <1> 	shl	al,1
  1099 00000BAC D0E0                <1> 	shl	al,1
  1100 00000BAE B60F                <1> 	mov	dh,0Fh
  1101                              <1> .drive_1:
  1102 00000BB0 20F1                <1> 	and	cl,dh
  1103 00000BB2 08C1                <1> 	or	cl,al
  1104 00000BB4 EB95                <1> 	jmp	.menu_loop
  1105                              <1> 
  1106                              <1> .floppy_exit:
  1107 00000BB6 B40E                <1> 	mov	ah,0Eh			; echo
  1108 00000BB8 BB0700              <1> 	mov	bx,0007h
  1109 00000BBB CD10                <1> 	int	10h
  1110 00000BBD EB8C                <1> 	jmp	.menu_loop
  1111                              <1> 
  1112                              <1> .print_settings:
  1113 00000BBF B40E                <1> 	mov	ah,0Eh			; echo
  1114 00000BC1 BB0700              <1> 	mov	bx,0007h
  1115 00000BC4 CD10                <1> 	int	10h
  1116 00000BC6 BE[8800]            <1> 	mov	si,msg_crlf
  1117 00000BC9 E84E16              <1> 	call	print
  1118 00000BCC 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1119 00000BCE E8B309              <1> 	call	print_floppy
  1120 00000BD1 E977FF              <1> 	jmp	.menu_loop
  1121                              <1> 
  1122                              <1> .save:
  1123 00000BD4 50                  <1> 	push	ax
  1124                              <1> 
  1125 00000BD5 B010                <1> 	mov	al,cmos_floppy
  1126 00000BD7 88CC                <1> 	mov	ah,cl
  1127 00000BD9 E839FE              <1> 	call	rtc_write
  1128                              <1> 
  1129 00000BDC 8A261000            <1> 	mov	ah,byte [equipment_list]
  1130 00000BE0 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1131                              <1> 
  1132 00000BE3 F6C170              <1> 	test	cl,70h
  1133 00000BE6 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1134 00000BE8 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1135                              <1> 
  1136                              <1> .second_floppy:
  1137 00000BEB F6C107              <1> 	test	cl,07h
  1138 00000BEE 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1139 00000BF0 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1140                              <1> 					; (even if the first one is missing)
  1141                              <1> 
  1142                              <1> .save_equipment:
  1143 00000BF3 88261000            <1> 	mov	byte [equipment_list],ah
  1144 00000BF7 B014                <1> 	mov	al,cmos_equip
  1145 00000BF9 E819FE              <1> 	call	rtc_write
  1146                              <1> 
  1147 00000BFC E828FF              <1> 	call	rtc_checksum
  1148                              <1> 
  1149 00000BFF B02E                <1> 	mov	al,cmos_sum_hi
  1150 00000C01 88FC                <1> 	mov	ah,bh
  1151 00000C03 E80FFE              <1> 	call	rtc_write
  1152                              <1> 
  1153 00000C06 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1154 00000C08 88DC                <1> 	mov	ah,bl
  1155 00000C0A E808FE              <1> 	call	rtc_write
  1156                              <1> 	
  1157 00000C0D 58                  <1> 	pop	ax
  1158                              <1> 
  1159                              <1> .exit:
  1160 00000C0E B40E                <1> 	mov	ah,0Eh			; echo
  1161 00000C10 BB0700              <1> 	mov	bx,0007h
  1162 00000C13 CD10                <1> 	int	10h
  1163 00000C15 BE[8800]            <1> 	mov	si,msg_crlf
  1164 00000C18 E8FF15              <1> 	call	print
  1165 00000C1B 5E                  <1> 	pop	si
  1166 00000C1C 5A                  <1> 	pop	dx
  1167 00000C1D 59                  <1> 	pop	cx
  1168 00000C1E 5B                  <1> 	pop	bx
  1169 00000C1F 58                  <1> 	pop	ax
  1170 00000C20 C3                  <1> 	ret
  1171                              <1> 
  1172                              <1> ;=========================================================================
  1173                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1174                              <1> ; Input:
  1175                              <1> ;	CX = time to delay (in 15 microsecond units)
  1176                              <1> ; Notes:
  1177                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1178                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1179                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1180                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1181                              <1> ;-------------------------------------------------------------------------
  1182                              <1> delay_15us:
  1183 00000C21 50                  <1> 	push	ax
  1184 00000C22 51                  <1> 	push	cx
  1185                              <1> .zero:
  1186 00000C23 E461                <1> 	in	al,port_b_reg
  1187 00000C25 A810                <1> 	test	al,refresh_flag
  1188 00000C27 74FA                <1> 	jz	.zero
  1189 00000C29 49                  <1> 	dec	cx
  1190 00000C2A 7409                <1> 	jz	.exit
  1191                              <1> .one:
  1192 00000C2C E461                <1> 	in	al,port_b_reg
  1193 00000C2E A810                <1> 	test	al,refresh_flag
  1194 00000C30 75FA                <1> 	jnz	.one
  1195 00000C32 49                  <1> 	dec	cx
  1196 00000C33 75EE                <1> 	jnz	.zero
  1197                              <1> .exit:
  1198 00000C35 59                  <1> 	pop	cx
  1199 00000C36 58                  <1> 	pop	ax
  1200 00000C37 C3                  <1> 	ret
  1201                              <1> 
  1202                              <1> %if 0
  1203                              <1> ;=========================================================================
  1204                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1205                              <1> ; Input:
  1206                              <1> ;	DX:AX	- dividend
  1207                              <1> ;	CX	- divisor
  1208                              <1> ; Output:
  1209                              <1> ;	DX:AX	- quotient
  1210                              <1> ;-------------------------------------------------------------------------
  1211                              <1> divide_32:
  1212                              <1> 	or	dx,dx
  1213                              <1> 	jnz	.1
  1214                              <1> 	div	cx
  1215                              <1> 	xor	dx,dx
  1216                              <1> 	ret
  1217                              <1> .1:
  1218                              <1> 	push	bx
  1219                              <1> 	mov	bx,ax
  1220                              <1> 	mov	ax,dx
  1221                              <1> 	xor	dx,dx
  1222                              <1> 	div	cx
  1223                              <1> 	xchg	bx,ax
  1224                              <1> 	div	cx
  1225                              <1> 	mov	dx,bx
  1226                              <1> 	pop	bx
  1227                              <1> 	ret
  1228                              <1> %endif ; 0
  1229                                  %include	"time1.inc"		; time services
  1230                              <1> ;=========================================================================
  1231                              <1> ; time1.inc - BIOS Time Services
  1232                              <1> ;       INT 1Ah - BIOS Time Services
  1233                              <1> ;		functions AH=00h to AH=07h
  1234                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1235                              <1> ;-------------------------------------------------------------------------
  1236                              <1> ;
  1237                              <1> ; Compiles with NASM 2.07, might work with other versions
  1238                              <1> ;
  1239                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  1240                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1241                              <1> ;
  1242                              <1> ; This program is free software: you can redistribute it and/or modify
  1243                              <1> ; it under the terms of the GNU General Public License as published by
  1244                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1245                              <1> ; (at your option) any later version.
  1246                              <1> ;
  1247                              <1> ; This program is distributed in the hope that it will be useful,
  1248                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1249                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1250                              <1> ; GNU General Public License for more details.
  1251                              <1> ;
  1252                              <1> ; You should have received a copy of the GNU General Public License
  1253                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1254                              <1> ;
  1255                              <1> ;=========================================================================
  1256                              <1> 
  1257                              <1> ;=========================================================================
  1258                              <1> ; int_1A_fn00 - Read current time
  1259                              <1> ; Input:
  1260                              <1> ;	AH = 0 - read current time
  1261                              <1> ; Output:
  1262                              <1> ;	CX = high word of tick count
  1263                              <1> ;	DX = low word of tick count
  1264                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1265                              <1> ;-------------------------------------------------------------------------
  1266                              <1> int_1A_fn00:
  1267 00000C38 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1268 00000C3C 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1269 00000C40 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1270 00000C43 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1271 00000C47 E94B72              <1> 	jmp	int_1A_exit
  1272                              <1> 
  1273                              <1> ;=========================================================================
  1274                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1275                              <1> ; Input:
  1276                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1277                              <1> ;	CX = high word of tick count
  1278                              <1> ;	DX = low word of tick count
  1279                              <1> ; Output:
  1280                              <1> ;	None
  1281                              <1> ;-------------------------------------------------------------------------
  1282                              <1> int_1A_fn01:
  1283 00000C4A 89166C00            <1> 	mov	word [ticks_lo],dx
  1284 00000C4E 890E6E00            <1> 	mov	word [ticks_hi],cx
  1285 00000C52 C606700000          <1> 	mov	byte [new_day],00h
  1286 00000C57 E93B72              <1> 	jmp	int_1A_exit
  1287                              <1> 
  1288                              <1> ;=========================================================================
  1289                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1290                              <1> ; Input:
  1291                              <1> ;	AH = 02h - function 02h - read RTC time
  1292                              <1> ; Output:
  1293                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1294                              <1> ;	CH = BCD hours
  1295                              <1> ;	CL = BCD minutes
  1296                              <1> ;	DH = BCD seconds
  1297                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1298                              <1> ;-------------------------------------------------------------------------
  1299                              <1> int_1A_fn02:
  1300 00000C5A 50                  <1> 	push	ax
  1301 00000C5B B00A                <1> 	mov	al,cmos_control_a
  1302 00000C5D E8AAFD              <1> 	call	rtc_read		; read control A register
  1303 00000C60 A880                <1> 	test	al,cmos_uip
  1304 00000C62 7405                <1> 	jz	.1			; no update in progess
  1305 00000C64 F9                  <1> 	stc
  1306 00000C65 58                  <1> 	pop	ax
  1307 00000C66 E92F72              <1> 	jmp	int_1A_exitf
  1308                              <1> .1:
  1309 00000C69 B00B                <1> 	mov	al,cmos_control_b
  1310 00000C6B E89CFD              <1> 	call	rtc_read		; read control B register
  1311 00000C6E 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1312 00000C70 88C2                <1> 	mov	dl,al
  1313 00000C72 B000                <1> 	mov	al,cmos_seconds
  1314 00000C74 E893FD              <1> 	call	rtc_read		; read seconds
  1315 00000C77 88C6                <1> 	mov	dh,al
  1316 00000C79 B002                <1> 	mov	al,cmos_minutes
  1317 00000C7B E88CFD              <1> 	call	rtc_read		; read minutes
  1318 00000C7E 88C1                <1> 	mov	cl,al
  1319 00000C80 B004                <1> 	mov	al,cmos_hours
  1320 00000C82 E885FD              <1> 	call	rtc_read		; read hours
  1321 00000C85 88C5                <1> 	mov	ch,al
  1322 00000C87 F8                  <1> 	clc
  1323 00000C88 58                  <1> 	pop	ax
  1324 00000C89 E90C72              <1> 	jmp	int_1A_exitf
  1325                              <1> 
  1326                              <1> ;=========================================================================
  1327                              <1> ; int_1A_fn03 - Set real time clock
  1328                              <1> ; Input:
  1329                              <1> ;	AH = 03h - function 03h - set RTC time
  1330                              <1> ;	CH = BCD hours
  1331                              <1> ;	CL = BCD minutes
  1332                              <1> ;	DH = BCD seconds
  1333                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1334                              <1> ; Output:
  1335                              <1> ;	None
  1336                              <1> ;-------------------------------------------------------------------------
  1337                              <1> int_1A_fn03:
  1338 00000C8C 50                  <1> 	push	ax
  1339 00000C8D B00B                <1> 	mov	al,cmos_control_b
  1340 00000C8F E878FD              <1> 	call	rtc_read		; read control B register
  1341 00000C92 88C4                <1> 	mov	ah,al
  1342 00000C94 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1343 00000C97 B00B                <1> 	mov	al,cmos_control_b
  1344 00000C99 E879FD              <1> 	call	rtc_write		; write control B register
  1345                              <1> 
  1346 00000C9C 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1347 00000C9F 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1348 00000CA2 08D4                <1> 	or	ah,dl			; add it from the input
  1349 00000CA4 B00B                <1> 	mov	al,cmos_control_b
  1350 00000CA6 E86CFD              <1> 	call	rtc_write		; write control B register
  1351                              <1> 
  1352 00000CA9 B000                <1> 	mov	al,cmos_seconds
  1353 00000CAB 88F4                <1> 	mov	ah,dh
  1354 00000CAD E865FD              <1> 	call	rtc_write		; write seconds
  1355 00000CB0 B002                <1> 	mov	al,cmos_minutes
  1356 00000CB2 88CC                <1> 	mov	ah,cl
  1357 00000CB4 E85EFD              <1> 	call	rtc_write		; write minutes
  1358 00000CB7 B004                <1> 	mov	al,cmos_hours
  1359 00000CB9 88EC                <1> 	mov	ah,ch
  1360 00000CBB E857FD              <1> 	call	rtc_write		; write hours
  1361                              <1> 
  1362 00000CBE B00B                <1> 	mov	al,cmos_control_b
  1363 00000CC0 E847FD              <1> 	call	rtc_read		; read control B register
  1364 00000CC3 88C4                <1> 	mov	ah,al
  1365 00000CC5 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1366 00000CC8 B00B                <1> 	mov	al,cmos_control_b
  1367 00000CCA E848FD              <1> 	call	rtc_write		; write control B register
  1368 00000CCD 58                  <1> 	pop	ax
  1369 00000CCE E9C471              <1> 	jmp	int_1A_exit
  1370                              <1> 
  1371                              <1> ;=========================================================================
  1372                              <1> ; int_1A_fn04 - Read date from real time clock
  1373                              <1> ; Input:
  1374                              <1> ;	AH = 04h - function 04h - read RTC date
  1375                              <1> ; Output:
  1376                              <1> ;	CH = BCD century
  1377                              <1> ;	CL = BCD year
  1378                              <1> ;	DH = BCD month
  1379                              <1> ;	DL = BCD date
  1380                              <1> ;-------------------------------------------------------------------------
  1381                              <1> int_1A_fn04:
  1382 00000CD1 50                  <1> 	push	ax
  1383 00000CD2 B00A                <1> 	mov	al,cmos_control_a
  1384 00000CD4 E833FD              <1> 	call	rtc_read		; read control A register
  1385 00000CD7 A880                <1> 	test	al,cmos_uip
  1386 00000CD9 7405                <1> 	jz	.1			; no update in progess
  1387 00000CDB F9                  <1> 	stc
  1388 00000CDC 58                  <1> 	pop	ax
  1389 00000CDD E9B871              <1> 	jmp	int_1A_exitf
  1390                              <1> .1:
  1391 00000CE0 B007                <1> 	mov	al,cmos_date
  1392 00000CE2 E825FD              <1> 	call	rtc_read		; read date
  1393 00000CE5 88C2                <1> 	mov	dl,al
  1394 00000CE7 B008                <1> 	mov	al,cmos_month
  1395 00000CE9 E81EFD              <1> 	call	rtc_read		; read month
  1396 00000CEC 88C6                <1> 	mov	dh,al
  1397 00000CEE B009                <1> 	mov	al,cmos_year
  1398 00000CF0 E817FD              <1> 	call	rtc_read		; read year
  1399 00000CF3 88C1                <1> 	mov	cl,al
  1400 00000CF5 B032                <1> 	mov	al,cmos_century
  1401 00000CF7 E810FD              <1> 	call	rtc_read		; read century
  1402 00000CFA 88C5                <1> 	mov	ch,al
  1403 00000CFC F8                  <1> 	clc
  1404 00000CFD 58                  <1> 	pop	ax
  1405 00000CFE E99771              <1> 	jmp	int_1A_exitf
  1406                              <1> 
  1407                              <1> ;=========================================================================
  1408                              <1> ; int_1A_fn05 - Set date inreal time clock
  1409                              <1> ; Input:
  1410                              <1> ;	AH = 05h - function 05h - set RTC date
  1411                              <1> ;	CH = BCD century
  1412                              <1> ;	CL = BCD year
  1413                              <1> ;	DH = BCD month
  1414                              <1> ;	DL = BCD date
  1415                              <1> ; Output:
  1416                              <1> ;	None
  1417                              <1> ;-------------------------------------------------------------------------
  1418                              <1> int_1A_fn05:
  1419 00000D01 50                  <1> 	push	ax
  1420 00000D02 B00B                <1> 	mov	al,cmos_control_b
  1421 00000D04 E803FD              <1> 	call	rtc_read		; read control B register
  1422 00000D07 88C4                <1> 	mov	ah,al
  1423 00000D09 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1424 00000D0C B00B                <1> 	mov	al,cmos_control_b
  1425 00000D0E E804FD              <1> 	call	rtc_write		; write control B register
  1426                              <1> 
  1427 00000D11 B007                <1> 	mov	al,cmos_date
  1428 00000D13 88D4                <1> 	mov	ah,dl
  1429 00000D15 E8FDFC              <1> 	call	rtc_write		; write date
  1430                              <1> 
  1431 00000D18 B008                <1> 	mov	al,cmos_month
  1432 00000D1A 88F4                <1> 	mov	ah,dh
  1433 00000D1C E8F6FC              <1> 	call	rtc_write		; write month
  1434 00000D1F B009                <1> 	mov	al,cmos_year
  1435 00000D21 88CC                <1> 	mov	ah,cl
  1436 00000D23 E8EFFC              <1> 	call	rtc_write		; write year
  1437 00000D26 B032                <1> 	mov	al,cmos_century
  1438 00000D28 88EC                <1> 	mov	ah,ch
  1439 00000D2A E8E8FC              <1> 	call	rtc_write		; write centry
  1440                              <1> 
  1441 00000D2D B00B                <1> 	mov	al,cmos_control_b
  1442 00000D2F E8D8FC              <1> 	call	rtc_read		; read control B register
  1443 00000D32 88C4                <1> 	mov	ah,al
  1444 00000D34 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1445 00000D37 B00B                <1> 	mov	al,cmos_control_b
  1446 00000D39 E8D9FC              <1> 	call	rtc_write		; write control B register
  1447 00000D3C 58                  <1> 	pop	ax
  1448 00000D3D E95571              <1> 	jmp	int_1A_exit
  1449                              <1> 
  1450                              <1> ;=========================================================================
  1451                              <1> ; int_1A_fn06 - Set real time clock alarm
  1452                              <1> ; Input:
  1453                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1454                              <1> ;	CH = BCD hours
  1455                              <1> ;	CL = BCD minutes
  1456                              <1> ;	DH = BCD seconds
  1457                              <1> ; Output:
  1458                              <1> ;	CF = 1 - alarm already set
  1459                              <1> ;-------------------------------------------------------------------------
  1460                              <1> int_1A_fn06:
  1461 00000D40 50                  <1> 	push	ax
  1462 00000D41 B00B                <1> 	mov	al,cmos_control_b
  1463 00000D43 E8C4FC              <1> 	call	rtc_read		; read control B register
  1464 00000D46 A820                <1> 	test	al,cmos_aie
  1465 00000D48 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1466 00000D4A F9                  <1> 	stc
  1467 00000D4B 58                  <1> 	pop	ax
  1468 00000D4C E94971              <1> 	jmp	int_1A_exitf
  1469                              <1> .1:
  1470 00000D4F 88C4                <1> 	mov	ah,al
  1471 00000D51 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1472 00000D54 B00B                <1> 	mov	al,cmos_control_b
  1473 00000D56 E8BCFC              <1> 	call	rtc_write		; write control B register
  1474                              <1> 
  1475 00000D59 B001                <1> 	mov	al,cmos_alarm_secs
  1476 00000D5B 88F4                <1> 	mov	ah,dh
  1477 00000D5D E8B5FC              <1> 	call	rtc_write		; write alarm seconds
  1478 00000D60 B003                <1> 	mov	al,cmos_alarm_mins
  1479 00000D62 88CC                <1> 	mov	ah,cl
  1480 00000D64 E8AEFC              <1> 	call	rtc_write		; write alarm minutes
  1481 00000D67 B005                <1> 	mov	al,cmos_alarm_hrs
  1482 00000D69 88EC                <1> 	mov	ah,ch
  1483 00000D6B E8A7FC              <1> 	call	rtc_write		; write alarm hours
  1484                              <1> 
  1485 00000D6E B00B                <1> 	mov	al,cmos_control_b
  1486 00000D70 E897FC              <1> 	call	rtc_read		; read control B register
  1487 00000D73 88C4                <1> 	mov	ah,al
  1488 00000D75 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1489 00000D78 B00B                <1> 	mov	al,cmos_control_b
  1490 00000D7A E898FC              <1> 	call	rtc_write		; write control B register
  1491                              <1> 
  1492 00000D7D B00B                <1> 	mov	al,cmos_control_b
  1493 00000D7F E888FC              <1> 	call	rtc_read		; read control B register
  1494 00000D82 88C4                <1> 	mov	ah,al
  1495 00000D84 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1496 00000D87 B00B                <1> 	mov	al,cmos_control_b
  1497 00000D89 E889FC              <1> 	call	rtc_write		; write control B register with AIE set
  1498                              <1> 
  1499 00000D8C 58                  <1> 	pop	ax
  1500 00000D8D F8                  <1> 	clc
  1501 00000D8E E90771              <1> 	jmp	int_1A_exitf
  1502                              <1> 
  1503                              <1> ;=========================================================================
  1504                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1505                              <1> ; Input:
  1506                              <1> ;	AH = 07h - function 07h - set RTC time
  1507                              <1> ; Output:
  1508                              <1> ;	None
  1509                              <1> ;-------------------------------------------------------------------------
  1510                              <1> int_1A_fn07:
  1511 00000D91 50                  <1> 	push	ax
  1512                              <1> 
  1513 00000D92 B00B                <1> 	mov	al,cmos_control_b
  1514 00000D94 E873FC              <1> 	call	rtc_read		; read control B register
  1515 00000D97 88C4                <1> 	mov	ah,al
  1516 00000D99 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1517 00000D9C B00B                <1> 	mov	al,cmos_control_b
  1518 00000D9E E874FC              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1519                              <1> 
  1520 00000DA1 58                  <1> 	pop	ax
  1521 00000DA2 E9F070              <1> 	jmp	int_1A_exit
  1522                              <1> 	
  1523                              <1> ;=========================================================================
  1524                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1525                              <1> ; Notes:
  1526                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1527                              <1> ;-------------------------------------------------------------------------
  1528                              <1> int_70:
  1529 00000DA5 50                  <1> 	push	ax
  1530 00000DA6 B020                <1> 	mov	al,20h
  1531 00000DA8 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1532 00000DAA E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1533 00000DAC B00C                <1> 	mov	al,cmos_control_c
  1534 00000DAE E859FC              <1> 	call	rtc_read		; read control C register
  1535 00000DB1 A840                <1> 	test	al,cmos_af		; check for alarm flag
  1536 00000DB3 7402                <1> 	jz	.1
  1537 00000DB5 CD4A                <1> 	int	4Ah			; call INT 4Ah
  1538                              <1> .1:
  1539 00000DB7 58                  <1> 	pop	ax
  1540 00000DB8 CF                  <1> 	iret
  1541                                  %include	"floppy1.inc"		; floppy services
  1542                              <1> ;=========================================================================
  1543                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
  1544                              <1> ;       INT 13h, function AH=00h
  1545                              <1> ;       INT 13h, function AH=01h
  1546                              <1> ;       INT 13h, function AH=08h
  1547                              <1> ;       INT 13h, function AH=15h
  1548                              <1> ;       INT 13h, function AH=16h
  1549                              <1> ;       INT 13h, function AH=17h
  1550                              <1> ;       INT 13h, function AH=18h
  1551                              <1> ;       INT 13h, function AH=08h
  1552                              <1> ;	- see floppy2.inc for other INT 13h functions
  1553                              <1> ;-------------------------------------------------------------------------
  1554                              <1> ;
  1555                              <1> ; Compiles with NASM 2.07, might work with other versions
  1556                              <1> ;
  1557                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  1558                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1559                              <1> ;
  1560                              <1> ; This program is free software: you can redistribute it and/or modify
  1561                              <1> ; it under the terms of the GNU General Public License as published by
  1562                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1563                              <1> ; (at your option) any later version.
  1564                              <1> ;
  1565                              <1> ; This program is distributed in the hope that it will be useful,
  1566                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1567                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1568                              <1> ; GNU General Public License for more details.
  1569                              <1> ;
  1570                              <1> ; You should have received a copy of the GNU General Public License
  1571                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1572                              <1> ;
  1573                              <1> ;=========================================================================
  1574                              <1> 
  1575                              <1> ;-------------------------------------------------------------------------
  1576                              <1> ; FDC registers
  1577                              <1> 
  1578                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1579                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1580                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1581                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1582                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1583                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1584                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1585                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1586                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1587                              <1> 
  1588                              <1> ;-------------------------------------------------------------------------
  1589                              <1> ; DMAC registers
  1590                              <1> 
  1591                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1592                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1593                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1594                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1595                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1596                              <1> 					; first / last flip-flop
  1597                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1598                              <1> 
  1599                              <1> ;-------------------------------------------------------------------------
  1600                              <1> ; Floppy disk services - error codes
  1601                              <1> 
  1602                              <1> fdc_e_success	equ	00h		; successful completion
  1603                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1604                              <1> fdc_e_address	equ	02h		; address mark not found
  1605                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1606                              <1> fdc_e_notfound	equ	04h		; sector not found
  1607                              <1> fdc_e_changed	equ	06h		; disk changed
  1608                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1609                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1610                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1611                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1612                              <1> fdc_e_failure	equ	20h		; controller failure
  1613                              <1> fdc_e_seek	equ	40h		; seek failed
  1614                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1615                              <1> 
  1616                              <1> ;-------------------------------------------------------------------------
  1617                              <1> ; Drive media state for fdc_media_state
  1618                              <1> 
  1619                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1620                              <1> fdc_m_established	equ	10h	; bit 4:    media/drive established
  1621                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1622                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1623                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1624                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1625                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1626                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1627                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1628                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1629                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  1630                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  1631                              <1> 
  1632                              <1> ;-------------------------------------------------------------------------
  1633                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  1634                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  1635                              <1> 
  1636                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  1637                              <1> 
  1638                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  1639                              <1> ;	       unset for read or verify
  1640                              <1> 
  1641                              <1> fdc_write_flag	equ	80h		; write or format operation
  1642                              <1> 
  1643                              <1> ;-------------------------------------------------------------------------
  1644                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  1645                              <1> 
  1646                              <1> cmos_no_floppy	equ	00h
  1647                              <1> cmos_360	equ	01h
  1648                              <1> cmos_1200	equ	02h
  1649                              <1> cmos_720	equ	03h
  1650                              <1> cmos_1440	equ	04h
  1651                              <1> cmos_2880	equ	06h
  1652                              <1> 
  1653                              <1> ;=========================================================================
  1654                              <1> ; int_13_fn00: Reset disk system
  1655                              <1> ; Input:
  1656                              <1> ;	AH = 00h
  1657                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1658                              <1> ; Output:
  1659                              <1> ;	CF clear if successful
  1660                              <1> ;		AH = 00h - successful completion
  1661                              <1> ;	CF set on error
  1662                              <1> ;		AH = 20h - controller failure
  1663                              <1> ;		AH = 80h - timeout / device not ready
  1664                              <1> ; Note:
  1665                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1666                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1667                              <1> ;-------------------------------------------------------------------------
  1668                              <1> int_13_fn00:
  1669 00000DB9 E80700              <1> 	call	fdc_init
  1670 00000DBC 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1671 00000DC0 E9135F              <1> 	jmp	int_13_exit
  1672                              <1> 
  1673                              <1> ;=========================================================================
  1674                              <1> ; fdc_init - Initialize floppy disk controller
  1675                              <1> ; Input:
  1676                              <1> ;	none
  1677                              <1> ; Output:
  1678                              <1> ;	CF clear on success
  1679                              <1> ;		AH = 00h - successful completion
  1680                              <1> ;	CF set if error
  1681                              <1> ;		AH = 20h - controller failure
  1682                              <1> ;		AH = 80h - timeout / device not ready
  1683                              <1> ;-------------------------------------------------------------------------
  1684                              <1> fdc_init:
  1685 00000DC3 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  1686 00000DC8 E80906              <1> 	call	fdc_reset		; reset FDC
  1687 00000DCB 7257                <1> 	jc	fdc_init_error
  1688 00000DCD BAF403              <1> 	mov	dx,fdc_status_reg
  1689 00000DD0 EC                  <1> 	in	al,dx
  1690 00000DD1 A880                <1> 	test	al,80h
  1691 00000DD3 7404                <1> 	jz	.try_again		; try again if FDC not ready
  1692 00000DD5 A840                <1> 	test	al,40h
  1693 00000DD7 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  1694                              <1> .try_again:
  1695 00000DD9 E8F805              <1> 	call	fdc_reset
  1696 00000DDC BAF403              <1> 	mov	dx,fdc_status_reg
  1697 00000DDF EC                  <1> 	in	al,dx
  1698 00000DE0 A880                <1> 	test	al,80h
  1699 00000DE2 7440                <1> 	jz	fdc_init_error
  1700 00000DE4 A840                <1> 	test	al,40h
  1701 00000DE6 753C                <1> 	jnz	fdc_init_error
  1702                              <1> .fdc_ready:
  1703 00000DE8 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  1704 00000DEA E83905              <1> 	call	fdc_write		; send the command
  1705 00000DED 7235                <1> 	jc	fdc_init_error
  1706 00000DEF E88105              <1> 	call	fdc_read		; read ST0
  1707 00000DF2 7230                <1> 	jc	fdc_init_error
  1708 00000DF4 A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  1709 00000DF7 88C4                <1> 	mov	ah,al			; save AL to AH
  1710 00000DF9 E87705              <1> 	call	fdc_read		; read current cylinder
  1711 00000DFC 7226                <1> 	jc	fdc_init_error
  1712 00000DFE A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  1713 00000E01 80E4C0              <1> 	and	ah,0C0h
  1714 00000E04 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  1715 00000E07 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  1716                              <1> 
  1717                              <1> ; fall through to fdc_send_specify
  1718                              <1> 
  1719                              <1> ;=========================================================================
  1720                              <1> ; fdc_send_specify - Send specify command to FDC
  1721                              <1> ; Input:
  1722                              <1> ;	none
  1723                              <1> ; Output:
  1724                              <1> ;	CF clear on success
  1725                              <1> ;		AH = 00 - successful completion
  1726                              <1> ;	CF set if error
  1727                              <1> ;		AH = 20h - controller failure
  1728                              <1> ;	AX,CL,SI trashed
  1729                              <1> ; Note:
  1730                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  1731                              <1> ;-------------------------------------------------------------------------
  1732                              <1> fdc_send_specify:
  1733                              <1> 
  1734 00000E09 1E                  <1> 	push	ds
  1735 00000E0A 31C0                <1> 	xor	ax,ax
  1736 00000E0C 8ED8                <1> 	mov	ds,ax
  1737 00000E0E C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1738 00000E12 B003                <1> 	mov	al,3		 	; FDC Specify command
  1739 00000E14 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  1740 00000E16 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  1741 00000E19 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  1742 00000E1B 1F                  <1> 	pop	ds
  1743 00000E1C E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  1744 00000E1F 7203                <1> 	jc	fdc_init_error
  1745 00000E21 B400                <1> 	mov	ah,fdc_e_success	; successful completion
  1746 00000E23 C3                  <1> 	ret
  1747                              <1> 
  1748                              <1> fdc_init_error:
  1749 00000E24 B420                <1> 	mov	ah,fdc_e_failure
  1750 00000E26 F9                  <1> 	stc
  1751 00000E27 C3                  <1> 	ret
  1752                              <1> 
  1753                              <1> ;=========================================================================
  1754                              <1> ; int_13_fn01 - Get status of last operation
  1755                              <1> ; Input:
  1756                              <1> ;	AH = 01h
  1757                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1758                              <1> ; Output:
  1759                              <1> ;	CF clear if last operation was successful
  1760                              <1> ;		AH = 00h - successful completion
  1761                              <1> ;	CF set on error
  1762                              <1> ;		AH - error code of the last operation
  1763                              <1> ; Note:
  1764                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1765                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1766                              <1> ;-------------------------------------------------------------------------
  1767                              <1> int_13_fn01:
  1768 00000E28 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  1769 00000E2C 08E4                <1> 	or	ah,ah
  1770 00000E2E 7401                <1> 	jz	.no_error
  1771 00000E30 F9                  <1> 	stc
  1772                              <1> .no_error:
  1773 00000E31 E9A25E              <1> 	jmp	int_13_exit
  1774                              <1> 
  1775                              <1> ;=========================================================================
  1776                              <1> ; int_13_fn08: Get drive parameters
  1777                              <1> ; Input:
  1778                              <1> ;	AH = 08h
  1779                              <1> ;	DL = drive number (0 - 7Fh)
  1780                              <1> ; Output:
  1781                              <1> ;	CF clear if successful
  1782                              <1> ;		AX = 0000h
  1783                              <1> ;		BH = 00h
  1784                              <1> ;		BL = CMOS drive type
  1785                              <1> ;		CH = maximal cylinder number - 1
  1786                              <1> ;		CL = maximal sector number
  1787                              <1> ;		DH = maximal head number
  1788                              <1> ;		DL = number of drives
  1789                              <1> ;		ES:DI -> diskette parameter table
  1790                              <1> ;	CF set on error
  1791                              <1> ;		AH = 01h - drive number is greater than 7Fh
  1792                              <1> ; Notes:
  1793                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  1794                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  1795                              <1> ;	- If media type is not established function sets media parameters 
  1796                              <1> ;	based on CMOS drive type
  1797                              <1> ;-------------------------------------------------------------------------
  1798                              <1> int_13_fn08:
  1799 00000E34 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  1800 00000E37 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  1801 00000E3C A01000              <1> 	mov	al,byte [equipment_list]
  1802 00000E3F 2441                <1> 	and	al,equip_floppies|equip_floppy2
  1803 00000E41 B402                <1> 	mov	ah,2			; assume two floppy drives
  1804 00000E43 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  1805 00000E45 7406                <1> 	je	.check_drive_number
  1806 00000E47 FECC                <1> 	dec	ah			; assume one floppy drive
  1807 00000E49 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  1808 00000E4B 757C                <1> 	jne	.no_drives
  1809                              <1> 
  1810                              <1> .check_drive_number:
  1811 00000E4D 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  1812 00000E50 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  1813                              <1> 					; than number of disks?
  1814 00000E52 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  1815 00000E54 E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  1816 00000E57 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  1817                              <1> 
  1818 00000E59 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  1819 00000E5D 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  1820 00000E60 8CC9                <1> 	mov	cx,cs
  1821 00000E62 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  1822                              <1> 
  1823 00000E64 3C01                <1> 	cmp	al,cmos_360
  1824 00000E66 7417                <1> 	je	.set_360
  1825 00000E68 3C03                <1> 	cmp	al,cmos_720
  1826 00000E6A 741E                <1> 	je	.set_720
  1827 00000E6C 3C02                <1> 	cmp	al,cmos_1200
  1828 00000E6E 7425                <1> 	je	.set_1200
  1829 00000E70 3C04                <1> 	cmp	al,cmos_1440
  1830 00000E72 742C                <1> 	je	.set_1440
  1831                              <1> 
  1832                              <1> .set_2880:
  1833 00000E74 B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  1834 00000E76 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  1835 00000E7A B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  1836 00000E7D EB2A                <1> 	jmp	.set_media_type
  1837                              <1> 
  1838                              <1> .set_360:
  1839 00000E7F B093                <1> 	mov	al,fdc_m_360in360
  1840 00000E81 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  1841 00000E85 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  1842 00000E88 EB1F                <1> 	jmp	.set_media_type
  1843                              <1> 
  1844                              <1> .set_720:
  1845 00000E8A B097                <1> 	mov	al,fdc_m_720
  1846 00000E8C 8D3E[896F]          <1> 	lea	di,[media_720]
  1847 00000E90 B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  1848 00000E93 EB14                <1> 	jmp	.set_media_type
  1849                              <1> 
  1850                              <1> .set_1200:
  1851 00000E95 B002                <1> 	mov	al,fdc_m_try_1200in1200
  1852 00000E97 8D3E[7C6F]          <1> 	lea	di,[media_1200]
  1853 00000E9B B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  1854 00000E9E EB09                <1> 	jmp	.set_media_type
  1855                              <1> 
  1856                              <1> .set_1440:
  1857 00000EA0 B007                <1> 	mov	al,fdc_m_try_1440
  1858 00000EA2 8D3E[966F]          <1> 	lea	di,[media_1440]
  1859 00000EA6 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  1860                              <1> 
  1861                              <1> .set_media_type:
  1862 00000EA9 BB9000              <1> 	mov	bx,fdc_media_state
  1863 00000EAC 00D3                <1> 	add	bl,dl			; BX -> drive media state
  1864 00000EAE F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  1865 00000EB1 7502                <1> 	jnz	.set_parameters		; no need to update if established
  1866 00000EB3 8807                <1> 	mov	[bx],al
  1867                              <1> 
  1868                              <1> .set_parameters:
  1869 00000EB5 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  1870 00000EB7 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  1871 00000EBA A24100              <1> 	mov	byte [fdc_last_error],al
  1872 00000EBD 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  1873 00000EC0 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  1874 00000EC3 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  1875 00000EC6 E90D5E              <1> 	jmp	int_13_exit
  1876                              <1> 
  1877                              <1> .no_drives:
  1878 00000EC9 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  1879                              <1> 
  1880                              <1> .non_existent_drive:
  1881 00000ECD 31C9                <1> 	xor	cx,cx
  1882 00000ECF 31FF                <1> 	xor	di,di
  1883 00000ED1 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  1884 00000ED4 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  1885 00000ED7 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  1886 00000ED9 EBDA                <1> 	jmp	.set_parameters
  1887                              <1> 
  1888                              <1> .invalid_drive:
  1889 00000EDB B401                <1> 	mov	ah,fdc_e_invalid
  1890 00000EDD F9                  <1> 	stc
  1891 00000EDE E9F55D              <1> 	jmp	int_13_exit
  1892                              <1> 
  1893                              <1> ;=========================================================================
  1894                              <1> ; int_13_fn15: Get disk type
  1895                              <1> ; Input:
  1896                              <1> ;	AH = 15h
  1897                              <1> ;	DL = drive number (0 or 1)
  1898                              <1> ; Output:
  1899                              <1> ;	AH = type code:
  1900                              <1> ;		00h - no such drive (invalid drive specified)
  1901                              <1> ;		01h - floppy without change-line support
  1902                              <1> ;		02h - floppy with change-line support
  1903                              <1> ;-------------------------------------------------------------------------
  1904                              <1> int_13_fn15:
  1905 00000EE1 B400                <1> 	mov	ah,00h			; assume no drive
  1906 00000EE3 80FA01              <1> 	cmp	dl,1
  1907 00000EE6 7711                <1> 	ja	.exit			; jump if invalid drive number
  1908 00000EE8 E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  1909 00000EEB 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  1910 00000EED B401                <1> 	mov	ah,01h			; assume no change-line support
  1911 00000EEF 3C01                <1> 	cmp	al,cmos_360
  1912 00000EF1 7406                <1> 	je	.exit
  1913 00000EF3 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  1914 00000EF5 7402                <1> 	je	.exit
  1915 00000EF7 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  1916                              <1> 
  1917                              <1> .exit:
  1918 00000EF9 F8                  <1> 	clc
  1919 00000EFA C606410000          <1> 	mov	byte [fdc_last_error],0
  1920 00000EFF E9D45D              <1> 	jmp	int_13_exit
  1921                              <1> 
  1922                              <1> ;=========================================================================
  1923                              <1> ; int_13_fn16 - Detect disk change
  1924                              <1> ; Input:
  1925                              <1> ;	AH = 16h
  1926                              <1> ;	DL = drive number (0 or 1)
  1927                              <1> ; Output:
  1928                              <1> ;	CF clear if change line inactive
  1929                              <1> ;		AH = 00h - disk not changed
  1930                              <1> ;	CF set if change line active or error
  1931                              <1> ;		AH = 01h - invalid drive number
  1932                              <1> ;		AH = 06h - disk changed or change line not supported
  1933                              <1> ;		AH = 80h - timeout / device not ready
  1934                              <1> ;-------------------------------------------------------------------------
  1935                              <1> int_13_fn16:
  1936 00000F02 80FA01              <1> 	cmp	dl,1
  1937 00000F05 7741                <1> 	ja	.invalid_drive
  1938 00000F07 E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  1939 00000F0A 723C                <1> 	jc	.invalid_drive
  1940                              <1> 
  1941 00000F0C 3C01                <1> 	cmp	al,cmos_360
  1942 00000F0E 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  1943 00000F10 3C03                <1> 	cmp	al,cmos_720
  1944 00000F12 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  1945                              <1> 
  1946 00000F14 E86302              <1> 	call	fdc_motor_on		; turn motor on
  1947 00000F17 30E4                <1> 	xor	ah,ah			; assume disk not changed
  1948 00000F19 BAF703              <1> 	mov	dx,fdc_dir_reg
  1949 00000F1C EC                  <1> 	in	al,dx			; read disk change line
  1950 00000F1D D0E0                <1> 	shl	al,1			; bit 7 to CF
  1951 00000F1F 7303                <1> 	jnc	.exit
  1952 00000F21 B406                <1> 	mov	ah,fdc_e_changed
  1953 00000F23 F9                  <1> 	stc
  1954                              <1> 
  1955                              <1> .exit:
  1956 00000F24 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1957 00000F28 9C                  <1> 	pushf
  1958 00000F29 1E                  <1> 	push	ds
  1959 00000F2A 31F6                <1> 	xor	si,si
  1960 00000F2C 8EDE                <1> 	mov	ds,si
  1961 00000F2E C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1962 00000F32 8A4C02              <1> 	mov	cl,byte [si+2]
  1963 00000F35 1F                  <1> 	pop	ds
  1964 00000F36 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  1965 00000F3A 9D                  <1> 	popf
  1966 00000F3B E9985D              <1> 	jmp	int_13_exit
  1967                              <1> 
  1968                              <1> 
  1969                              <1> .no_change_line:
  1970 00000F3E B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  1971 00000F40 F9                  <1> 	stc
  1972 00000F41 88264100            <1> 	mov	byte [fdc_last_error],ah
  1973 00000F45 E98E5D              <1> 	jmp	int_13_exit
  1974                              <1> 
  1975                              <1> .invalid_drive:
  1976 00000F48 B401                <1> 	mov	ah,fdc_e_invalid
  1977 00000F4A F9                  <1> 	stc
  1978 00000F4B E9885D              <1> 	jmp	int_13_exit
  1979                              <1> 
  1980                              <1> ;=========================================================================
  1981                              <1> ; int_13_fn17 - Set disk type for format
  1982                              <1> ; Input:
  1983                              <1> ;	AH = 17h
  1984                              <1> ;	AL = format type
  1985                              <1> ;		01h - 320K / 360K disk in 360K drive
  1986                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  1987                              <1> ;		03h - 1.2M disk in 1.2M drive
  1988                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  1989                              <1> ;	DL = drive number (0 or 1)
  1990                              <1> ; Output:
  1991                              <1> ;	CF clear if successful
  1992                              <1> ;		AH = 00h - successful completion
  1993                              <1> ;	CF set on error
  1994                              <1> ;		AH = 01h - invalid drive number
  1995                              <1> ;		AH = 06h - disk changed
  1996                              <1> ;		AH = 80h - timeout / device not ready
  1997                              <1> ;-------------------------------------------------------------------------
  1998                              <1> int_13_fn17:
  1999 00000F4E 80FA01              <1> 	cmp	dl,1
  2000 00000F51 7762                <1> 	ja	.invalid_parameters
  2001 00000F53 E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  2002 00000F56 725D                <1> 	jc	.invalid_parameters
  2003 00000F58 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  2004 00000F5B 80F900              <1> 	cmp	cl,0			; validate parameters
  2005 00000F5E 7455                <1> 	je	.invalid_parameters
  2006 00000F60 80F904              <1> 	cmp	cl,4
  2007 00000F63 7750                <1> 	ja	.invalid_parameters
  2008 00000F65 BB9000              <1> 	mov	bx,fdc_media_state
  2009 00000F68 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2010 00000F6A 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  2011 00000F6D 7507                <1> 	jne	.not_360in360
  2012 00000F6F C60793              <1> 	mov	byte [bx],fdc_m_360in360
  2013 00000F72 B400                <1> 	mov	ah,0			; no error
  2014 00000F74 EB33                <1> 	jmp	.exit_check_error
  2015                              <1> 
  2016                              <1> .not_360in360:
  2017 00000F76 E80102              <1> 	call	fdc_motor_on
  2018 00000F79 89DE                <1> 	mov	si,bx
  2019 00000F7B E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  2020 00000F7E 80FC06              <1> 	cmp	ah,fdc_e_changed
  2021 00000F81 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  2022 00000F83 80FC80              <1> 	cmp	ah,fdc_e_timeout
  2023 00000F86 750A                <1> 	jne	.set_type		; floppy disk is installed
  2024 00000F88 803F97              <1> 	cmp	byte [bx],97h		; 250 Kbps and not 5.25?
  2025 00000F8B 741C                <1> 	je	.exit_check_error
  2026 00000F8D C60761              <1> 	mov	byte [bx],61h		; 300 Kpbs, try 360 in 1.2M
  2027 00000F90 EB17                <1> 	jmp	.exit_check_error
  2028                              <1> 
  2029                              <1> .set_type:
  2030 00000F92 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  2031 00000F95 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  2032 00000F97 C60797              <1> 	mov	byte [bx],fdc_m_720
  2033 00000F9A EB0D                <1> 	jmp	.exit_check_error
  2034                              <1> 
  2035                              <1> .check_360in1200:
  2036 00000F9C 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  2037 00000F9F 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  2038 00000FA1 C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  2039 00000FA4 EB03                <1> 	jmp	.exit_check_error
  2040                              <1> 
  2041                              <1> .set_1200in1200:
  2042 00000FA6 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  2043                              <1> 
  2044                              <1> .exit_check_error:
  2045 00000FA9 88264100            <1> 	mov	byte [fdc_last_error],ah
  2046 00000FAD 08E4                <1> 	or	ah,ah
  2047 00000FAF 7401                <1> 	jz	.exit			; jump if no error
  2048 00000FB1 F9                  <1> 	stc				; indicate error
  2049                              <1> 
  2050                              <1> .exit:
  2051 00000FB2 E9005D              <1> 	jmp	int_13_upd_exit
  2052                              <1> 
  2053                              <1> .invalid_parameters:
  2054 00000FB5 B401                <1> 	mov	ah,fdc_e_invalid
  2055 00000FB7 EBF9                <1> 	jmp	.exit
  2056                              <1> 
  2057                              <1> ;=========================================================================
  2058                              <1> ; int_13_fn18 - Set media type for format
  2059                              <1> ; Input:
  2060                              <1> ;	AH = 18h
  2061                              <1> ;	DL = drive number (0 or 1)
  2062                              <1> ;	CH = number of cylinders - 1
  2063                              <1> ;	CL = sectors per track
  2064                              <1> ; Output:
  2065                              <1> ;	CF = clear if successful
  2066                              <1> ;		AH = 00h - requested format is supported
  2067                              <1> ;		ES:DI -> diskette parameter table
  2068                              <1> ;	CF = set on error
  2069                              <1> ;		AH = 01h - invalid drive number specified
  2070                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  2071                              <1> ;-------------------------------------------------------------------------
  2072                              <1> int_13_fn18:
  2073 00000FB9 80FA01              <1> 	cmp	dl,1
  2074 00000FBC 7603E99900          <1> 	ja	.invalid_drive
  2075 00000FC1 E84504              <1> 	call	read_cmos_type		; get drive type in AL
  2076 00000FC4 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  2077                              <1> 
  2078 00000FC9 BB9000              <1> 	mov	bx,fdc_media_state
  2079 00000FCC 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2080                              <1> 
  2081 00000FCE 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  2082 00000FD0 7511                <1> 	jne	.try_drive_1200
  2083 00000FD2 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  2084 00000FD6 7403E98300          <1> 	jnz	.unsupported_format
  2085 00000FDB B093                <1> 	mov	al,93h			; 360K in 360K established, 250 Kbps
  2086 00000FDD 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2087 00000FE1 EB54                <1> 	jmp	.set_media
  2088                              <1> 
  2089                              <1> .try_drive_1200:
  2090 00000FE3 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2091 00000FE5 751C                <1> 	jne	.try_drive_2880
  2092 00000FE7 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2093 00000FEB 7508                <1> 	jne	.try_media_360_in_1200
  2094 00000FED B015                <1> 	mov	al,15h			; 1.2M in 1.2M established, 500Kbps
  2095 00000FEF 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
  2096 00000FF3 EB42                <1> 	jmp	.set_media
  2097                              <1> 
  2098                              <1> .try_media_360_in_1200:
  2099 00000FF5 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2100 00000FF9 7563                <1> 	jne	.unsupported_format
  2101 00000FFB B074                <1> 	mov	al,74h			; 360K in 1.2M established, 300Kbps
  2102 00000FFD 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2103 00001001 EB34                <1> 	jmp	.set_media
  2104                              <1> 
  2105                              <1> .try_drive_2880:
  2106 00001003 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2107 00001005 750E                <1> 	jne	.try_drive_1440
  2108 00001007 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2109 0000100B 750C                <1> 	jne	.try_media_1440
  2110 0000100D B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2111 0000100F 8D3E[B06F]          <1> 	lea	di,[media_2880]
  2112 00001013 EB22                <1> 	jmp	.set_media
  2113                              <1> 
  2114                              <1> .try_drive_1440:
  2115 00001015 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2116 00001017 750E                <1> 	jne	.try_drive_720
  2117                              <1> 
  2118                              <1> .try_media_1440:
  2119 00001019 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2120 0000101D 750C                <1> 	jne	.try_media_720
  2121 0000101F B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2122 00001021 8D3E[966F]          <1> 	lea	di,[media_1440]
  2123 00001025 EB10                <1> 	jmp	.set_media
  2124                              <1> 
  2125                              <1> .try_drive_720:
  2126 00001027 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2127 00001029 7533                <1> 	jne	.unsupported_format	; should never happen...
  2128                              <1> 
  2129                              <1> .try_media_720:	
  2130 0000102B 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2131 0000102F 752D                <1> 	jne	.unsupported_format
  2132 00001031 B097                <1> 	mov	al,97h			; other established, 250Kbps
  2133 00001033 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
  2134                              <1> 
  2135                              <1> .set_media:
  2136 00001037 8807                <1> 	mov	byte [bx],al		; set physical media
  2137 00001039 E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2138 0000103C D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2139 0000103E D0C8                <1> 	ror	al,1
  2140 00001040 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2141 00001045 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2142 00001049 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2143 0000104C 8CC9                <1> 	mov	cx,cs
  2144 0000104E 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2145 00001050 C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2146 00001055 30E4                <1> 	xor	ah,ah
  2147 00001057 E95B5C              <1> 	jmp	int_13_upd_exit
  2148                              <1> 
  2149                              <1> .invalid_drive:
  2150 0000105A B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2151 0000105C EB02                <1> 	jmp	.error
  2152                              <1> 
  2153                              <1> .unsupported_format:
  2154 0000105E B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2155                              <1> 
  2156                              <1> .error:
  2157 00001060 F9                  <1> 	stc
  2158 00001061 E9515C              <1> 	jmp	int_13_upd_exit
  2159                              <1> 
  2160                              <1> ;=========================================================================
  2161                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2162                              <1> ; Input:
  2163                              <1> ;	DL = drive number (0 or 1)
  2164                              <1> ; Output:
  2165                              <1> ;	CF clear if successful
  2166                              <1> ;		AH = 00h - successful completion
  2167                              <1> ;	CF set on error
  2168                              <1> ;		AH = 20h - controller failure
  2169                              <1> ;		AH = 20h - timeout
  2170                              <1> ;	AH trashed
  2171                              <1> ;-------------------------------------------------------------------------
  2172                              <1> fdc_recalibrate:
  2173 00001064 56                  <1> 	push	si
  2174 00001065 51                  <1> 	push	cx
  2175 00001066 52                  <1> 	push	dx
  2176 00001067 B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2177 00001069 88D4                <1> 	mov	ah,dl			; drive number
  2178 0000106B B102                <1> 	mov	cl,2			; 2 bytes command
  2179 0000106D 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2180 00001072 E86502              <1> 	call	fdc_send_cmd
  2181 00001075 7244                <1> 	jc	recal_end		; failure
  2182 00001077 E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2183 0000107A 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2184 0000107C B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2185 0000107E B101                <1> 	mov	cl,1			; 1 byte command
  2186 00001080 E85702              <1> 	call	fdc_send_cmd
  2187 00001083 7236                <1> 	jc	recal_end		; failure
  2188 00001085 B90200              <1> 	mov	cx,2			; 2 bytes result
  2189 00001088 E8B402              <1> 	call	fdc_get_result		; store result
  2190 0000108B 722E                <1> 	jc	recal_end		; failure
  2191 0000108D BB4200              <1> 	mov	bx,fdc_ctrl_status
  2192 00001090 B440                <1> 	mov	ah,fdc_e_seek
  2193 00001092 8A17                <1> 	mov	dl,[bx]			; ST0
  2194 00001094 80E260              <1> 	and	dl,60h
  2195 00001097 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2196 0000109A F9                  <1> 	stc				; indicate error
  2197 0000109B 741E                <1> 	je	recal_end		; failure
  2198 0000109D 5A                  <1> 	pop	dx
  2199 0000109E 52                  <1> 	push	dx
  2200 0000109F 30F6                <1> 	xor	dh,dh				 
  2201 000010A1 BB9400              <1> 	mov	bx,fdc_cylinder
  2202 000010A4 01D3                <1> 	add	bx,dx
  2203 000010A6 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2204 000010A9 88D1                <1> 	mov	cl,dl
  2205 000010AB B201                <1> 	mov	dl,1
  2206 000010AD D2E2                <1> 	shl	dl,cl
  2207 000010AF 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2208 000010B3 B94300              <1> 	mov	cx,43h
  2209 000010B6 E868FB              <1> 	call	delay_15us		; 1 ms delay
  2210 000010B9 30E4                <1> 	xor	ah,ah
  2211                              <1> 
  2212                              <1> recal_end:
  2213 000010BB 88264100            <1> 	mov	byte [fdc_last_error],ah
  2214 000010BF 5A                  <1> 	pop	dx
  2215 000010C0 59                  <1> 	pop	cx
  2216 000010C1 5E                  <1> 	pop	si
  2217 000010C2 C3                  <1> 	ret
  2218                              <1> 
  2219                              <1> ;=========================================================================
  2220                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2221                              <1> ; Input:
  2222                              <1> ;	DL = drive number
  2223                              <1> ;	DH = head number
  2224                              <1> ;	CH = cylinder
  2225                              <1> ; Output:
  2226                              <1> ;	CF clear if successful
  2227                              <1> ;		AH = 00h - successful completion
  2228                              <1> ;	CF set on error
  2229                              <1> ;		AH = 20h - controller failure
  2230                              <1> ;		AH = 40h - seek failed
  2231                              <1> ;		AH = 80h - timeout / device not ready
  2232                              <1> ;-------------------------------------------------------------------------
  2233                              <1> fdc_seek:
  2234 000010C3 53                  <1> 	push	bx
  2235 000010C4 51                  <1> 	push	cx
  2236 000010C5 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2237 000010C9 88D1                <1> 	mov	cl,dl
  2238 000010CB FEC1                <1> 	inc	cl
  2239 000010CD D2EC                <1> 	shr	ah,cl
  2240 000010CF 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2241 000010D1 E890FF              <1> 	call	fdc_recalibrate
  2242 000010D4 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2243 000010D6 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2244 000010D9 727F                <1> 	jc	.exit			; no luck...
  2245                              <1> 
  2246                              <1> .skip_recalibrate:
  2247 000010DB B700                <1> 	mov	bh,00h
  2248 000010DD 88D3                <1> 	mov	bl,dl			; BX = drive number
  2249                              <1> 
  2250 000010DF F687900020          <1> 	test	byte [fdc_media_state+bx],20h 	; check double stepping bit
  2251 000010E4 7402                <1> 	jz	.no_double_stepping
  2252 000010E6 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2253                              <1> 
  2254                              <1> .no_double_stepping:
  2255 000010E8 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2256 000010EC 750B                <1> 	jne	.do_seek		; jump if seek is required
  2257 000010EE 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2258 000010F3 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2259 000010F5 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2260 000010F7 EB61                <1> 	jmp	.exit
  2261                              <1> 
  2262                              <1> .do_seek:
  2263 000010F9 88E8                <1> 	mov	al,ch			; cylinder
  2264 000010FB 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2265 000010FD B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2266 000010FF 88F4                <1> 	mov	ah,dh			; head
  2267 00001101 D0E4                <1> 	shl	ah,1
  2268 00001103 D0E4                <1> 	shl	ah,1
  2269 00001105 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2270 00001107 B103                <1> 	mov	cl,3			; 3 bytes command
  2271 00001109 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2272 0000110E E8C901              <1> 	call	fdc_send_cmd
  2273 00001111 7243                <1> 	jc	.set_result		; seek error
  2274 00001113 E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2275 00001116 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2276                              <1> 
  2277 00001118 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2278 0000111A B101                <1> 	mov	cl,1			; 1 byte command
  2279 0000111C E8BB01              <1> 	call	fdc_send_cmd
  2280 0000111F 7235                <1> 	jc	.set_result		; failure
  2281 00001121 B102                <1> 	mov	cl,2
  2282 00001123 53                  <1> 	push	bx
  2283 00001124 E81802              <1> 	call	fdc_get_result		; read result bytes
  2284 00001127 5B                  <1> 	pop	bx
  2285 00001128 722C                <1> 	jc	.set_result		; error
  2286 0000112A B440                <1> 	mov	ah,fdc_e_seek
  2287 0000112C A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2288 0000112F 2460                <1> 	and	al,60h
  2289 00001131 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2290 00001133 F9                  <1> 	stc
  2291 00001134 7420                <1> 	je	.set_result		; seek error
  2292 00001136 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2293                              <1> 
  2294 0000113A 1E                  <1> 	push	ds
  2295 0000113B 31F6                <1> 	xor	si,si
  2296 0000113D 8EDE                <1> 	mov	ds,si
  2297 0000113F C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2298 00001143 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2299 00001146 1F                  <1> 	pop	ds
  2300                              <1> 
  2301 00001147 08C0                <1> 	or	al,al			; head settle time is zero?!
  2302 00001149 7412                <1> 	jz	.get_settle_time
  2303                              <1> 
  2304 0000114B B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2305 0000114D F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2306 0000114F 89C1                <1> 	mov	cx,ax
  2307                              <1> 
  2308                              <1> .wait:
  2309 00001151 E8CDFA              <1> 	call	delay_15us
  2310                              <1> 
  2311                              <1> .wait_end:
  2312 00001154 30E4                <1> 	xor	ah,ah
  2313                              <1> 
  2314                              <1> .set_result:
  2315 00001156 88264100            <1> 	mov	byte [fdc_last_error],ah
  2316                              <1> 
  2317                              <1> .exit:
  2318 0000115A 59                  <1> 	pop	cx
  2319 0000115B 5B                  <1> 	pop	bx
  2320 0000115C C3                  <1> 	ret
  2321                              <1> 
  2322                              <1> .get_settle_time:
  2323 0000115D F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2324 00001162 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2325                              <1> 	
  2326 00001164 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2327 00001168 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2328 0000116B B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2329 0000116E 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2330 00001170 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2331 00001173 74DC                <1> 	je	.wait			; jump if 360K, media established
  2332 00001175 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2333 00001178 EBD7                <1> 	jmp	.wait
  2334                              <1> 
  2335                              <1> ;=========================================================================
  2336                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2337                              <1> ; Input:
  2338                              <1> ;	DL = drive number (0 or 1)
  2339                              <1> ; Output:
  2340                              <1> ;	none
  2341                              <1> ;-------------------------------------------------------------------------
  2342                              <1> fdc_motor_on:
  2343 0000117A 50                  <1> 	push	ax
  2344 0000117B 51                  <1> 	push	cx
  2345 0000117C 52                  <1> 	push	dx
  2346 0000117D FA                  <1> 	cli				; entering critical section
  2347 0000117E C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2348 00001183 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2349 00001188 88D1                <1> 	mov	cl,dl			; CL = drive number
  2350 0000118A D0E2                <1> 	shl	dl,1
  2351 0000118C D0E2                <1> 	shl	dl,1
  2352 0000118E D0E2                <1> 	shl	dl,1
  2353 00001190 D0E2                <1> 	shl	dl,1
  2354 00001192 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2355 00001196 FEC1                <1> 	inc	cl
  2356 00001198 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2357 0000119C D2EA                <1> 	shr	dl,cl
  2358 0000119E 7255                <1> 	jc	.already_on
  2359 000011A0 B201                <1> 	mov	dl,1
  2360 000011A2 FEC9                <1> 	dec	cl
  2361 000011A4 D2E2                <1> 	shl	dl,cl
  2362 000011A6 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2363 000011AA FB                  <1> 	sti				; end of critical section
  2364 000011AB A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2365 000011AE D0C8                <1> 	ror	al,1
  2366 000011B0 D0C8                <1> 	ror	al,1
  2367 000011B2 D0C8                <1> 	ror	al,1
  2368 000011B4 D0C8                <1> 	ror	al,1
  2369 000011B6 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2370 000011B8 BAF203              <1> 	mov	dx,fdc_dor_reg
  2371 000011BB EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2372 000011BC B8FD90              <1> 	mov	ax,90FDh
  2373 000011BF CD15                <1> 	int	15h			; call OS hook
  2374 000011C1 722E                <1> 	jc	.exit
  2375 000011C3 1E                  <1> 	push	ds
  2376 000011C4 56                  <1> 	push	si
  2377 000011C5 31F6                <1> 	xor	si,si
  2378 000011C7 8EDE                <1> 	mov	ds,si
  2379 000011C9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2380 000011CD 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2381 000011D0 5E                  <1> 	pop	si
  2382 000011D1 1F                  <1> 	pop	ds
  2383                              <1> 
  2384 000011D2 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2385 000011D7 7408                <1> 	jz	.read_verify		; jump if not write operation
  2386 000011D9 3C08                <1> 	cmp	al,8
  2387 000011DB 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2388 000011DD B008                <1> 	mov	al,8			; wait at least 1 second for write
  2389 000011DF EB06                <1> 	jmp	.wait_loop
  2390                              <1> 
  2391                              <1> .read_verify:
  2392 000011E1 3C05                <1> 	cmp	al,5
  2393 000011E3 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2394 000011E5 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2395                              <1> 
  2396                              <1> .wait_loop:
  2397 000011E7 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2398 000011EA E834FA              <1> 	call	delay_15us		; wait 125 ms
  2399 000011ED FEC8                <1> 	dec	al
  2400 000011EF 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2401                              <1> 
  2402                              <1> .exit:
  2403 000011F1 59                  <1> 	pop	cx
  2404 000011F2 5A                  <1> 	pop	dx
  2405 000011F3 58                  <1> 	pop	ax
  2406 000011F4 C3                  <1> 	ret
  2407                              <1> 
  2408                              <1> .already_on:
  2409 000011F5 FB                  <1> 	sti
  2410 000011F6 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2411 000011F9 D0C8                <1> 	ror	al,1
  2412 000011FB D0C8                <1> 	ror	al,1
  2413 000011FD D0C8                <1> 	ror	al,1
  2414 000011FF D0C8                <1> 	ror	al,1
  2415 00001201 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2416 00001203 BAF203              <1> 	mov	dx,fdc_dor_reg
  2417 00001206 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2418 00001207 EBE8                <1> 	jmp	.exit
  2419                              <1> 
  2420                              <1> ;=========================================================================
  2421                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2422                              <1> ; Input:
  2423                              <1> ;	CH = cylinder
  2424                              <1> ;	DH = head
  2425                              <1> ; Output:
  2426                              <1> ;	BL = next sector to be transferred
  2427                              <1> ;-------------------------------------------------------------------------	
  2428                              <1> 
  2429                              <1> fdc_end_io:
  2430 00001209 50                  <1> 	push	ax
  2431 0000120A 1E                  <1> 	push	ds
  2432 0000120B 31DB                <1> 	xor	bx,bx
  2433 0000120D 8EDB                <1> 	mov	ds,bx
  2434 0000120F C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2435 00001213 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2436 00001216 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2437 00001219 FEC0                <1> 	inc	al
  2438 0000121B 1F                  <1> 	pop	ds
  2439 0000121C BB4200              <1> 	mov	bx,fdc_ctrl_status
  2440 0000121F 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2441 00001222 7508                <1> 	jne	.exit
  2442 00001224 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2443 00001227 7503                <1> 	jne	.exit
  2444 00001229 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2445                              <1> .exit:
  2446 0000122C 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2447 00001230 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2448 00001232 58                  <1> 	pop	ax
  2449 00001233 C3                  <1> 	ret
  2450                              <1> 
  2451                              <1> ;========================================================================
  2452                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2453                              <1> ; Input:
  2454                              <1> ;	AL = CMOS drive type
  2455                              <1> ;	DS:SI -> drive media type
  2456                              <1> ; Output:
  2457                              <1> ;	CF clear if disk not changed
  2458                              <1> ;		AH = 00h - disk not changed
  2459                              <1> ;	CF set if disk changed or on error
  2460                              <1> ;		AH = 06h - disk changed
  2461                              <1> ;		AH = error code
  2462                              <1> ; Note:
  2463                              <1> ;	Motor needs to be turned on before calling this function
  2464                              <1> ;------------------------------------------------------------------------
  2465                              <1> fdc_disk_change:
  2466 00001234 51                  <1> 	push	cx
  2467 00001235 B400                <1> 	mov	ah,0
  2468 00001237 3C01                <1> 	cmp	al,cmos_360
  2469 00001239 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2470 0000123B 3C03                <1> 	cmp	al,cmos_720
  2471 0000123D 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2472                              <1> .cmos_invalid:
  2473 0000123F 8A04                <1> 	mov	al,[si]			; media type
  2474 00001241 2407                <1> 	and	al,fdc_m_state_bits
  2475 00001243 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2476 00001245 3C03                <1> 	cmp	al,3
  2477 00001247 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2478 00001249 BAF703              <1> 	mov	dx,fdc_dir_reg
  2479 0000124C EC                  <1> 	in	al,dx			; read disk change line
  2480 0000124D D0E0                <1> 	shl	al,1
  2481 0000124F 7326                <1> 	jnc	.exit			; no disk change
  2482 00001251 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2483 00001254 E86CFB              <1> 	call	fdc_init		; full initialization
  2484 00001257 721E                <1> 	jc	.exit
  2485 00001259 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2486 0000125C B501                <1> 	mov	ch,1
  2487 0000125E E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2488 00001261 7214                <1> 	jc	.exit
  2489 00001263 B500                <1> 	mov	ch,0
  2490 00001265 E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2491 00001268 720D                <1> 	jc	.exit
  2492 0000126A B406                <1> 	mov	ah,fdc_e_changed
  2493 0000126C BAF703              <1> 	mov	dx,fdc_dir_reg
  2494 0000126F EC                  <1> 	in	al,dx			; read disk change line
  2495 00001270 D0E0                <1> 	shl	al,1
  2496 00001272 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2497 00001274 B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2498                              <1> 
  2499                              <1> .changed_or_error:
  2500 00001276 F9                  <1> 	stc
  2501                              <1> 
  2502                              <1> .exit:
  2503 00001277 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2504 0000127A 59                  <1> 	pop	cx
  2505 0000127B C3                  <1> 	ret
  2506                              <1> 
  2507                              <1> ;=========================================================================
  2508                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2509                              <1> ; Input:
  2510                              <1> ;	AL = DMA mode byte
  2511                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2512                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2513                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2514                              <1> ;	CX = byte count (minus 1)
  2515                              <1> ;	ES:BX -> buffer address for DMA operation
  2516                              <1> ; Output:
  2517                              <1> ;	CF clear on success
  2518                              <1> ;	CF set if error
  2519                              <1> ;		AH = 08h - DMA overrun
  2520                              <1> ;	AX,BX trashed
  2521                              <1> ; Note:
  2522                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2523                              <1> ;-------------------------------------------------------------------------
  2524                              <1> fdc_configure_dma:
  2525 0000127C 52                  <1> 	push	dx
  2526 0000127D 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2527 0000127F D1C2                <1> 	rol	dx,1
  2528 00001281 D1C2                <1> 	rol	dx,1
  2529 00001283 D1C2                <1> 	rol	dx,1
  2530 00001285 D1C2                <1> 	rol	dx,1
  2531 00001287 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2532 00001289 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2533 0000128C 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2534 0000128F 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2535 00001291 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2536                              <1> 
  2537 00001294 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2538 00001296 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2539 00001298 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2540                              <1> 
  2541 0000129A FA                  <1> 	cli
  2542 0000129B E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2543 0000129D EB00                <1> 	jmp	$+2
  2544 0000129F EB00                <1> 	jmp	$+2
  2545 000012A1 E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2546 000012A3 EB00                <1> 	jmp	$+2
  2547 000012A5 EB00                <1> 	jmp	$+2
  2548 000012A7 88C8                <1> 	mov	al,cl
  2549 000012A9 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2550 000012AB EB00                <1> 	jmp	$+2
  2551 000012AD EB00                <1> 	jmp	$+2
  2552 000012AF 88E8                <1> 	mov	al,ch
  2553 000012B1 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2554 000012B3 EB00                <1> 	jmp	$+2
  2555 000012B5 EB00                <1> 	jmp	$+2
  2556 000012B7 88D0                <1> 	mov	al,dl
  2557 000012B9 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2558 000012BB EB00                <1> 	jmp	$+2
  2559 000012BD EB00                <1> 	jmp	$+2
  2560 000012BF 88F0                <1> 	mov	al,dh
  2561 000012C1 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2562 000012C3 EB00                <1> 	jmp	$+2
  2563 000012C5 EB00                <1> 	jmp	$+2
  2564 000012C7 88E0                <1> 	mov	al,ah
  2565 000012C9 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2566 000012CB EB00                <1> 	jmp	$+2
  2567 000012CD EB00                <1> 	jmp	$+2
  2568 000012CF B002                <1> 	mov	al,2
  2569 000012D1 E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2570 000012D3 FB                  <1> 	sti
  2571                              <1> 
  2572                              <1> .exit:
  2573 000012D4 5A                  <1> 	pop	dx
  2574 000012D5 C3                  <1> 	ret
  2575                              <1> 
  2576                              <1> .dma_boundary:				; Note: CF is already set
  2577 000012D6 B409                <1> 	mov	ah,fdc_e_boundary
  2578 000012D8 EBFA                <1> 	jmp	.exit
  2579                              <1> 
  2580                              <1> ;=========================================================================
  2581                              <1> ; fdc_send_cmd - Send a command to FDC
  2582                              <1> ; Input:
  2583                              <1> ;	AL = 1st byte of the command
  2584                              <1> ;	AH = 2nd byte of the command
  2585                              <1> ;	SI = 3rd and 4th bytes of the command
  2586                              <1> ;	DI = 5th and 6th bytes of the command
  2587                              <1> ;	BL = 7th byte of the command
  2588                              <1> ;	BH = 8th byte of the command
  2589                              <1> ;	CH = 9th byte of the command
  2590                              <1> ;	CL = command length (number of bytes)
  2591                              <1> ; Output:
  2592                              <1> ;	CF clear if successful
  2593                              <1> ;		AH = 00h - successful completion
  2594                              <1> ;	CF set on error
  2595                              <1> ;		AH = 20h - controller failure
  2596                              <1> ;		AH = 80h - timeout / device not ready
  2597                              <1> ;	AX trashed
  2598                              <1> ;-------------------------------------------------------------------------
  2599                              <1> fdc_send_cmd:
  2600 000012DA E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2601 000012DD FEC9                <1> 	dec	cl
  2602 000012DF 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2603 000012E1 88E0                <1> 	mov	al,ah
  2604 000012E3 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2605 000012E6 FEC9                <1> 	dec	cl
  2606 000012E8 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2607 000012EA 89F0                <1> 	mov	ax,si
  2608 000012EC E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2609 000012EF FEC9                <1> 	dec	cl
  2610 000012F1 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2611 000012F3 88E0                <1> 	mov	al,ah
  2612 000012F5 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2613 000012F8 FEC9                <1> 	dec	cl
  2614 000012FA 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2615 000012FC 89F8                <1> 	mov	ax,di
  2616 000012FE E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2617 00001301 FEC9                <1> 	dec	cl
  2618 00001303 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2619 00001305 88E0                <1> 	mov	al,ah
  2620 00001307 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2621 0000130A FEC9                <1> 	dec	cl
  2622 0000130C 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2623 0000130E 88D8                <1> 	mov	al,bl
  2624 00001310 E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2625 00001313 FEC9                <1> 	dec	cl
  2626 00001315 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2627 00001317 88F8                <1> 	mov	al,bh
  2628 00001319 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2629 0000131C FEC9                <1> 	dec	cl
  2630 0000131E 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2631 00001320 88E8                <1> 	mov	al,ch
  2632 00001322 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  2633                              <1> 
  2634                              <1> .send_cmd_exit:
  2635 00001325 C3                  <1> 	ret
  2636                              <1> 
  2637                              <1> ;=========================================================================
  2638                              <1> ; fdc_write - Send byte to FDC
  2639                              <1> ; Input:
  2640                              <1> ;	AL = byte to send
  2641                              <1> ; Output:
  2642                              <1> ;	CF clear if successful
  2643                              <1> ;	CF set if timeout
  2644                              <1> ;		AH = 80h - timeout / device not ready
  2645                              <1> ;-------------------------------------------------------------------------
  2646                              <1> fdc_write:
  2647 00001326 52                  <1> 	push	dx
  2648 00001327 50                  <1> 	push	ax
  2649 00001328 E83502              <1> 	call	fdc_wait_ready
  2650 0000132B 720D                <1> 	jc	.timeout
  2651 0000132D 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  2652 0000132F 3C80                <1> 	cmp	al,fdc_stat_ready
  2653 00001331 7507                <1> 	jne	.timeout
  2654 00001333 58                  <1> 	pop	ax
  2655 00001334 BAF503              <1> 	mov	dx,fdc_data_reg
  2656 00001337 EE                  <1> 	out	dx,al			; write byte
  2657                              <1> 
  2658                              <1> .exit:
  2659 00001338 5A                  <1> 	pop	dx
  2660 00001339 C3                  <1> 	ret
  2661                              <1> 
  2662                              <1> .timeout:
  2663 0000133A 58                  <1> 	pop	ax
  2664 0000133B B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2665 0000133D EBF9                <1> 	jmp	.exit
  2666                              <1> 
  2667                              <1> ;=========================================================================
  2668                              <1> ; fdc_get_result - Read FDC result
  2669                              <1> ; Input:
  2670                              <1> ;	CL = number of result bytes
  2671                              <1> ; Output:
  2672                              <1> ;	CF clear if successful
  2673                              <1> ;		AH = 00h - operation successful
  2674                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  2675                              <1> ;	CF set on error
  2676                              <1> ;		AH = 20h - controller failure
  2677                              <1> ;		AH = 80h - timeout / device not ready
  2678                              <1> ;	AL,BX - trashed
  2679                              <1> ;-------------------------------------------------------------------------
  2680                              <1> fdc_get_result:
  2681 0000133F 52                  <1> 	push	dx
  2682 00001340 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2683                              <1> 
  2684                              <1> .next_byte:
  2685 00001343 E81A02              <1> 	call	fdc_wait_ready
  2686 00001346 7222                <1> 	jc	.timeout
  2687 00001348 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  2688 0000134A 88C4                <1> 	mov	ah,al
  2689 0000134C 80E4EF              <1> 	and	ah,~fdc_stat_busy
  2690 0000134F 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  2691 00001352 7412                <1> 	je	.done			; jump if finished
  2692 00001354 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  2693 00001356 7516                <1> 	jne	.failure		; jump on invalid controller status
  2694 00001358 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  2695 0000135B 7311                <1> 	jnb	.failure		; controller error if so
  2696 0000135D BAF503              <1> 	mov	dx,fdc_data_reg
  2697 00001360 EC                  <1> 	in	al,dx
  2698 00001361 8807                <1> 	mov	byte [bx],al
  2699 00001363 43                  <1> 	inc	bx
  2700 00001364 EBDD                <1> 	jmp	.next_byte
  2701                              <1> 
  2702                              <1> .done:
  2703 00001366 30E4                <1> 	xor	ah,ah			; operation successful
  2704                              <1> 
  2705                              <1> .exit:
  2706 00001368 5A                  <1> 	pop	dx
  2707 00001369 C3                  <1> 	ret
  2708                              <1> 
  2709                              <1> .timeout:
  2710 0000136A B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2711 0000136C EBFA                <1> 	jmp	.exit
  2712                              <1> 
  2713                              <1> .failure:
  2714 0000136E B420                <1> 	mov	ah,fdc_e_failure
  2715 00001370 F9                  <1> 	stc
  2716 00001371 EBF5                <1> 	jmp	.exit
  2717                              <1> 
  2718                              <1> ;=========================================================================
  2719                              <1> ; fdc_read - Read byte from FDC
  2720                              <1> ; Input:
  2721                              <1> ;	none
  2722                              <1> ; Output:
  2723                              <1> ;	CF clear if successful
  2724                              <1> ;		AL = byte read from FDC
  2725                              <1> ;		AH - unchanged
  2726                              <1> ;	CF set on error
  2727                              <1> ;		AH = 20h - controller failure
  2728                              <1> ;		AH = 80h - timeout / device not ready
  2729                              <1> ;	CX trashed
  2730                              <1> ;-------------------------------------------------------------------------
  2731                              <1> fdc_read:
  2732 00001373 52                  <1> 	push	dx
  2733 00001374 BAF403              <1> 	mov	dx,fdc_status_reg
  2734 00001377 E8E601              <1> 	call	fdc_wait_ready
  2735 0000137A 720F                <1> 	jc	.timeout
  2736 0000137C EC                  <1> 	in	al,dx
  2737 0000137D A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  2738 0000137F 740E                <1> 	jz	.failure		; jump if not ready
  2739 00001381 EB00                <1> 	jmp	short $+2		; I/O delay
  2740 00001383 EB00                <1> 	jmp	short $+2
  2741 00001385 BAF503              <1> 	mov	dx,fdc_data_reg
  2742 00001388 EC                  <1> 	in	al,dx			; read the byte
  2743                              <1> 
  2744                              <1> .exit:
  2745 00001389 5A                  <1> 	pop	dx
  2746 0000138A C3                  <1> 	ret
  2747                              <1> 
  2748                              <1> .timeout:
  2749 0000138B B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2750 0000138D EBFA                <1> 	jmp	.exit
  2751                              <1> 
  2752                              <1> .failure:
  2753 0000138F B420                <1> 	mov	ah,fdc_e_failure
  2754 00001391 F9                  <1> 	stc
  2755 00001392 EBF5                <1> 	jmp	.exit
  2756                              <1> 
  2757                              <1> ;=========================================================================
  2758                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  2759                              <1> ; Input:
  2760                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  2761                              <1> ; Output:
  2762                              <1> ;	AH = error code
  2763                              <1> ;-------------------------------------------------------------------------
  2764                              <1> 
  2765                              <1> fdc_get_error:
  2766 00001394 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2767 00001397 8B1F                <1> 	mov	bx,[bx]
  2768 00001399 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  2769 0000139C B400                <1> 	mov	ah,fdc_e_success
  2770 0000139E 7433                <1> 	jz	.exit			; jump if successful completion
  2771 000013A0 F6C340              <1> 	test	bl,40h			; abnormal termination?
  2772 000013A3 B420                <1> 	mov	ah,fdc_e_failure
  2773 000013A5 742C                <1> 	jz	.exit
  2774 000013A7 F6C701              <1> 	test	bh,1			; address mark not found?
  2775 000013AA B402                <1> 	mov	ah,fdc_e_address
  2776 000013AC 7525                <1> 	jnz	.exit
  2777 000013AE F6C702              <1> 	test	bh,2			; disk write protected?
  2778 000013B1 B403                <1> 	mov	ah,fdc_e_wprotect
  2779 000013B3 751E                <1> 	jnz	.exit
  2780 000013B5 F6C704              <1> 	test	bh,4			; sector not found?
  2781 000013B8 B404                <1> 	mov	ah,fdc_e_notfound
  2782 000013BA 7517                <1> 	jnz	.exit
  2783 000013BC F6C710              <1> 	test	bh,10H			; DMA overrun?
  2784 000013BF B408                <1> 	mov	ah,fdc_e_dma
  2785 000013C1 7510                <1> 	jnz	.exit
  2786 000013C3 F6C720              <1> 	test	bh,20H			; CRC error?
  2787 000013C6 B410                <1> 	mov	ah,fdc_e_crc
  2788 000013C8 7509                <1> 	jnz	.exit
  2789 000013CA F6C780              <1> 	test	bh,80h			; access after last sector?
  2790 000013CD B404                <1> 	mov	ah,fdc_e_notfound
  2791 000013CF 7502                <1> 	jnz	.exit
  2792 000013D1 B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  2793                              <1> 
  2794                              <1> .exit:
  2795 000013D3 C3                  <1> 	ret
  2796                              <1> 
  2797                              <1> ;=========================================================================
  2798                              <1> ; fdc_reset - Reset FDC
  2799                              <1> ; Input:
  2800                              <1> ;	none
  2801                              <1> ; Output:
  2802                              <1> ;	Resets FDC flags in BIOS area
  2803                              <1> ;	AX,CX,DX - trashed 
  2804                              <1> ;-------------------------------------------------------------------------
  2805                              <1> 
  2806                              <1> fdc_reset:
  2807 000013D4 FA                  <1> 	cli
  2808 000013D5 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  2809 000013DA 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2810 000013DF A03F00              <1> 	mov	al,byte [fdc_motor_state]
  2811 000013E2 D0C0                <1> 	rol	al,1			; after rol:
  2812 000013E4 D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  2813 000013E6 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  2814 000013E8 D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  2815 000013EA 24FB                <1> 	and	al,0FBh			; clear reserved bit
  2816 000013EC 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  2817 000013EE BAF203              <1> 	mov	dx,fdc_dor_reg
  2818 000013F1 EE                  <1> 	out	dx,al			; send it to FDC
  2819 000013F2 B90300              <1> 	mov	cx,3
  2820 000013F5 E829F8              <1> 	call	delay_15us		; 30-45 us delay
  2821 000013F8 0C0C                <1> 	or	al,0Ch
  2822 000013FA EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  2823 000013FB FB                  <1> 	sti
  2824 000013FC E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2825 000013FF 7207                <1> 	jc	.exit
  2826 00001401 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  2827 00001406 30E4                <1> 	xor	ah,ah			; no errors
  2828                              <1> .exit:
  2829 00001408 C3                  <1> 	ret
  2830                              <1> 
  2831                              <1> ;=========================================================================
  2832                              <1> ; read_cmos_type - Read drive type from CMOS
  2833                              <1> ; Input:
  2834                              <1> ;	DL = drive number (0 or 1)
  2835                              <1> ; Output:
  2836                              <1> ;	CF clear if successful
  2837                              <1> ;		AL = drive type
  2838                              <1> ;	CF set on error (invalid drive type)
  2839                              <1> ;=========================================================================
  2840                              <1> 
  2841                              <1> read_cmos_type:
  2842 00001409 B010                <1> 	mov	al,cmos_floppy
  2843 0000140B E8FCF5              <1> 	call	rtc_read		; read drive type
  2844 0000140E 08D2                <1> 	or	dl,dl			; drive 0?
  2845 00001410 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  2846 00001412 D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  2847 00001414 D0E8                <1> 	shr	al,1
  2848 00001416 D0E8                <1> 	shr	al,1
  2849 00001418 D0E8                <1> 	shr	al,1
  2850                              <1> .drive_1:
  2851 0000141A 240F                <1> 	and	al,0Fh			; mask drive bits
  2852 0000141C 3C00                <1> 	cmp	al,cmos_no_floppy
  2853 0000141E 740A                <1> 	je	.error
  2854 00001420 3C05                <1> 	cmp	al,5			; invalid value
  2855 00001422 7406                <1> 	je	.error
  2856 00001424 3C06                <1> 	cmp	al,cmos_2880
  2857 00001426 7702                <1> 	ja	.error
  2858 00001428 F8                  <1> 	clc
  2859 00001429 C3                  <1> 	ret
  2860                              <1> 
  2861                              <1> .error:
  2862 0000142A F9                  <1> 	stc
  2863 0000142B C3                  <1> 	ret
  2864                              <1> 
  2865                              <1> ;=========================================================================
  2866                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  2867                              <1> ; Input:
  2868                              <1> ;	none, expects drive number in [bp+int_13_dl]
  2869                              <1> ; Output:
  2870                              <1> ;	CF clear if successful
  2871                              <1> ;		AH = 00h
  2872                              <1> ;	CF set on error
  2873                              <1> ;		AH = 20h - invalid CMOS
  2874                              <1> ;-------------------------------------------------------------------------
  2875                              <1> fdc_detect_media:
  2876 0000142C 52                  <1> 	push	dx
  2877 0000142D 51                  <1> 	push	cx
  2878 0000142E 53                  <1> 	push	bx
  2879 0000142F 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  2880 00001432 BB9000              <1> 	mov	bx,fdc_media_state
  2881 00001435 00D3                <1> 	add	bl,dl
  2882 00001437 E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  2883 0000143A B400                <1> 	mov	ah,0
  2884 0000143C 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  2885                              <1> 
  2886 0000143E 3C03                <1> 	cmp	al,cmos_720
  2887 00001440 7410                <1> 	je	.set_720
  2888 00001442 3C02                <1> 	cmp	al,cmos_1200
  2889 00001444 7415                <1> 	je	.detect_1200
  2890 00001446 3C04                <1> 	cmp	al,cmos_1440
  2891 00001448 7427                <1> 	je	.detect_1440
  2892 0000144A 3C06                <1> 	cmp	al,cmos_2880
  2893 0000144C 7439                <1> 	je	.detect_2880
  2894                              <1> 	
  2895 0000144E B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  2896 00001450 EB02                <1> 	jmp	.set_rate
  2897                              <1> 
  2898                              <1> .set_720:
  2899 00001452 B097                <1> 	mov	al,fdc_m_720
  2900                              <1> 
  2901                              <1> .set_rate:
  2902 00001454 50                  <1> 	push	ax
  2903 00001455 E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  2904 00001458 58                  <1> 	pop	ax
  2905 00001459 EB49                <1> 	jmp	.exit_set_media
  2906                              <1> 
  2907                              <1> .detect_1200:
  2908 0000145B B000                <1> 	mov	al,0			; try 500 Kbps
  2909 0000145D E85300              <1> 	call	fdc_read_id
  2910 00001460 B015                <1> 	mov	al,fdc_m_1200in1200
  2911 00001462 7340                <1> 	jnc	.exit_set_media		; jump if successful
  2912 00001464 B040                <1> 	mov	al,40h			; try 300 Kbps
  2913 00001466 E84A00              <1> 	call	fdc_read_id
  2914 00001469 B074                <1> 	mov	al,fdc_m_360in1200
  2915 0000146B 7337                <1> 	jnc	.exit_set_media		; jump if successful
  2916 0000146D B002                <1> 	mov	al,fdc_m_try_1200in1200
  2917 0000146F EB33                <1> 	jmp	.exit_set_media
  2918                              <1> 
  2919                              <1> .detect_1440:
  2920 00001471 B000                <1> 	mov	al,0			; try 500 Kbps
  2921 00001473 E83D00              <1> 	call	fdc_read_id
  2922 00001476 B017                <1> 	mov	al,fdc_m_1440
  2923 00001478 732A                <1> 	jnc	.exit_set_media		; jump if successful
  2924 0000147A B080                <1> 	mov	al,80h			; try 250 Kbps
  2925 0000147C E83400              <1> 	call	fdc_read_id
  2926 0000147F B097                <1> 	mov	al,fdc_m_720
  2927 00001481 7321                <1> 	jnc	.exit_set_media		; jump if successful
  2928 00001483 B007                <1> 	mov	al,fdc_m_try_1440
  2929 00001485 EB1D                <1> 	jmp	.exit_set_media
  2930                              <1> 
  2931                              <1> .detect_2880:
  2932 00001487 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  2933 00001489 E82700              <1> 	call	fdc_read_id
  2934 0000148C B0D7                <1> 	mov	al,fdc_m_2880
  2935 0000148E 7314                <1> 	jnc	.exit_set_media		; jump if successful
  2936 00001490 B000                <1> 	mov	al,0			; try 500 Kbps
  2937 00001492 E81E00              <1> 	call	fdc_read_id
  2938 00001495 B017                <1> 	mov	al,fdc_m_1440
  2939 00001497 730B                <1> 	jnc	.exit_set_media		; jump if successful
  2940 00001499 B080                <1> 	mov	al,80h			; try 250 Kbps
  2941 0000149B E81500              <1> 	call	fdc_read_id
  2942 0000149E B097                <1> 	mov	al,fdc_m_720
  2943 000014A0 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  2944 000014A2 B0C7                <1> 	mov	al,fdc_m_try_2880
  2945                              <1> 
  2946                              <1> .exit_set_media:
  2947 000014A4 8807                <1> 	mov	byte [bx],al		; set media type
  2948                              <1> 
  2949                              <1> .exit:
  2950 000014A6 88264100            <1> 	mov	byte [fdc_last_error],ah
  2951 000014AA 5B                  <1> 	pop	bx
  2952 000014AB 59                  <1> 	pop	cx
  2953 000014AC 5A                  <1> 	pop	dx
  2954 000014AD C3                  <1> 	ret
  2955                              <1> 
  2956                              <1> .invalid_cmos:
  2957 000014AE B420                <1> 	mov	ah,fdc_e_failure
  2958 000014B0 F9                  <1> 	stc
  2959 000014B1 EBF3                <1> 	jmp	.exit
  2960                              <1> 
  2961                              <1> ;=========================================================================
  2962                              <1> ; fdc_read_id - Read ID
  2963                              <1> ; Input:
  2964                              <1> ;	AL = data transfer rate (bits 7-6)
  2965                              <1> ; Output:
  2966                              <1> ;	CF clear if successful
  2967                              <1> ;		AH = 0 - successful completion
  2968                              <1> ;		AL = ID (bits 7-6)
  2969                              <1> ;	CF set on error
  2970                              <1> ;		AH = error code
  2971                              <1> ;-------------------------------------------------------------------------
  2972                              <1> fdc_read_id:
  2973 000014B3 53                  <1> 	push	bx
  2974 000014B4 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  2975 000014B9 E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  2976 000014BC 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  2977 000014BF E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  2978 000014C2 7305                <1> 	jnc	.do_read_id
  2979 000014C4 E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  2980 000014C7 722D                <1> 	jc	.error
  2981                              <1> 
  2982                              <1> .do_read_id:
  2983 000014C9 B90300              <1> 	mov	cx,3			; 3 attempts
  2984                              <1> 
  2985                              <1> .read_id_loop:
  2986 000014CC 51                  <1> 	push	cx
  2987 000014CD B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  2988 000014CF 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  2989 000014D1 B102                <1> 	mov	cl,2			; 2 byte commands
  2990 000014D3 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2991 000014D8 E8FFFD              <1> 	call	fdc_send_cmd
  2992 000014DB 7218                <1> 	jc	.error_cmd
  2993 000014DD E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2994 000014E0 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  2995 000014E2 B107                <1> 	mov	cl,7
  2996 000014E4 E858FE              <1> 	call	fdc_get_result		; read result bytes
  2997 000014E7 720C                <1> 	jc	.error_cmd
  2998 000014E9 E8A8FE              <1> 	call	fdc_get_error		; get error code
  2999 000014EC 59                  <1> 	pop	cx
  3000 000014ED 08E4                <1> 	or	ah,ah
  3001 000014EF 7406                <1> 	jz	.exit			; if no errors
  3002 000014F1 E2D9                <1> 	loop	.read_id_loop		; retry
  3003 000014F3 EB01                <1> 	jmp	.error
  3004                              <1> 
  3005                              <1> .error_cmd:
  3006 000014F5 59                  <1> 	pop	cx
  3007                              <1> 
  3008                              <1> .error:
  3009 000014F6 F9                  <1> 	stc
  3010                              <1> 
  3011                              <1> .exit:
  3012 000014F7 5B                  <1> 	pop	bx
  3013 000014F8 C3                  <1> 	ret
  3014                              <1> 
  3015                              <1> ;=========================================================================
  3016                              <1> ; fdc_select_rate - Select FDC transfer rate
  3017                              <1> ; Input:
  3018                              <1> ;	AL = data transfer rate (bits 7-6)
  3019                              <1> ; Output:
  3020                              <1> ;	none
  3021                              <1> ;-------------------------------------------------------------------------
  3022                              <1> fdc_select_rate:
  3023 000014F9 53                  <1> 	push	bx
  3024 000014FA BB9000              <1> 	mov	bx,fdc_media_state
  3025 000014FD 00D3                <1> 	add	bl,dl			; SI -> drive media state
  3026 000014FF 8A37                <1> 	mov	dh,byte [bx]		; new media status
  3027 00001501 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  3028 00001505 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  3029 00001509 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  3030 0000150B 740E                <1> 	je	.exit			; exit if rate is already selected
  3031 0000150D 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  3032 00001512 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  3033 00001516 88F0                <1> 	mov	al,dh
  3034 00001518 E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  3035                              <1> 
  3036                              <1> .exit:
  3037 0000151B 5B                  <1> 	pop	bx
  3038 0000151C 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  3039 0000151F C3                  <1> 	ret
  3040                              <1> 
  3041                              <1> ;=========================================================================
  3042                              <1> ; fdc_set_rate - Set transfer rate
  3043                              <1> ; Input:
  3044                              <1> ;	AL = transfer rate (bits 7 and 6)
  3045                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  3046                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  3047                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  3048                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  3049                              <1> ; Output:
  3050                              <1> ;	AL = transfer rate (bits 1 and 0)
  3051                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  3052                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  3053                              <1> ;	DX = 3F7h - FDC CCR
  3054                              <1> ;-------------------------------------------------------------------------
  3055                              <1> fdc_set_rate:
  3056 00001520 24C0                <1> 	and	al,fdc_m_rate_bits
  3057 00001522 D0C0                <1> 	rol	al,1
  3058 00001524 D0C0                <1> 	rol	al,1
  3059 00001526 BAF703              <1> 	mov	dx,fdc_ccr_reg
  3060 00001529 EE                  <1> 	out	dx,al
  3061 0000152A C3                  <1> 	ret
  3062                              <1> 
  3063                              <1> ;=========================================================================
  3064                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  3065                              <1> ; Input:
  3066                              <1> ;	none
  3067                              <1> ; Output:
  3068                              <1> ;	CF clear if interrupt had occurred
  3069                              <1> ;		AH = 00h - successful completion
  3070                              <1> ;	CF set if no interrupt
  3071                              <1> ;		AH = 80h - timeout
  3072                              <1> ;	BX = fdc_calib_state
  3073                              <1> ;	AL,CX - trashed
  3074                              <1> ;-------------------------------------------------------------------------
  3075                              <1> fdc_wait_irq:
  3076 0000152B FB                  <1> 	sti
  3077 0000152C F8                  <1> 	clc
  3078 0000152D B80190              <1> 	mov	ax,9001h
  3079 00001530 CD15                <1> 	int	15h			; call OS hook
  3080 00001532 7221                <1> 	jc	.timeout
  3081 00001534 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  3082 00001537 31C9                <1> 	xor	cx,cx
  3083                              <1> 
  3084                              <1> .zero:
  3085 00001539 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3086 0000153C 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3087                              <1> 
  3088                              <1> .zero_loop:
  3089 0000153E E461                <1> 	in	al,port_b_reg
  3090 00001540 A810                <1> 	test	al,refresh_flag
  3091 00001542 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3092 00001544 E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3093 00001546 EB0D                <1> 	jmp	.timeout
  3094                              <1> 
  3095                              <1> .one:
  3096 00001548 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3097 0000154B 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3098                              <1> 
  3099                              <1> .one_loop:
  3100 0000154D E461                <1> 	in	al,port_b_reg
  3101 0000154F A810                <1> 	test	al,refresh_flag
  3102 00001551 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3103 00001553 E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3104                              <1> 
  3105                              <1> .timeout:
  3106 00001555 B480                <1> 	mov	ah,fdc_e_timeout
  3107 00001557 F9                  <1> 	stc
  3108 00001558 C3                  <1> 	ret
  3109                              <1> 
  3110                              <1> .exit:
  3111 00001559 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3112 0000155C B400                <1> 	mov	ah,fdc_e_success
  3113 0000155E F8                  <1> 	clc				; DEBUG - remove after debug
  3114 0000155F C3                  <1> 	ret
  3115                              <1> 
  3116                              <1> ;=========================================================================
  3117                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3118                              <1> ;		   but no more than one second
  3119                              <1> ; Input:
  3120                              <1> ; Output:
  3121                              <1> ;	CF clear if FDC is ready
  3122                              <1> ;		AL = FDC main status register
  3123                              <1> ;	CF set on timeout
  3124                              <1> ;		AL trashed
  3125                              <1> ;	DX - trashed
  3126                              <1> ;-------------------------------------------------------------------------
  3127                              <1> 
  3128                              <1> fdc_wait_ready:
  3129 00001560 51                  <1> 	push	cx
  3130 00001561 BAF403              <1> 	mov	dx,fdc_status_reg
  3131 00001564 31C9                <1> 	xor	cx,cx
  3132                              <1> 
  3133                              <1> .zero:
  3134 00001566 EC                  <1> 	in	al,dx			; read I/O port
  3135 00001567 A880                <1> 	test	al,fdc_stat_ready
  3136 00001569 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3137                              <1> 
  3138                              <1> .zero_loop:
  3139 0000156B E461                <1> 	in	al,port_b_reg
  3140 0000156D A810                <1> 	test	al,refresh_flag
  3141 0000156F 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3142 00001571 49                  <1> 	dec	cx
  3143 00001572 740D                <1> 	jz	.timeout
  3144 00001574 EC                  <1> 	in	al,dx			; read I/O port again
  3145 00001575 A880                <1> 	test	al,fdc_stat_ready
  3146 00001577 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3147                              <1> 
  3148                              <1> .one_loop:
  3149 00001579 E461                <1> 	in	al,port_b_reg
  3150 0000157B A810                <1> 	test	al,refresh_flag
  3151 0000157D 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3152 0000157F E2E5                <1> 	loop	.zero
  3153                              <1> 
  3154                              <1> .timeout:
  3155 00001581 F9                  <1> 	stc
  3156                              <1> 
  3157                              <1> .exit:
  3158 00001582 59                  <1> 	pop	cx
  3159 00001583 C3                  <1> 	ret
  3160                              <1> 
  3161                              <1> ;=========================================================================
  3162                              <1> ; print_floppy - Print floppy configuration
  3163                              <1> ; Input:
  3164                              <1> ;	AL = NVRAM floppy configuration byte
  3165                              <1> ; Ouput:
  3166                              <1> ;	none
  3167                              <1> ;-------------------------------------------------------------------------
  3168                              <1> print_floppy:
  3169 00001584 50                  <1> 	push	ax
  3170 00001585 56                  <1> 	push	si
  3171 00001586 BE[F401]            <1> 	mov	si,msg_floppy
  3172 00001589 E88E0C              <1> 	call	print
  3173 0000158C D0C8                <1> 	ror	al,1
  3174 0000158E D0C8                <1> 	ror	al,1
  3175 00001590 D0C8                <1> 	ror	al,1
  3176 00001592 D0C8                <1> 	ror	al,1
  3177 00001594 89C6                <1> 	mov	si,ax
  3178 00001596 83E607              <1> 	and	si,0007h
  3179 00001599 D1E6                <1> 	shl	si,1
  3180 0000159B 2E8BB4[FA05]        <1>     cs	mov	si,word [tbl_floppy+si]
  3181 000015A0 E8770C              <1> 	call	print
  3182 000015A3 BE[1A02]            <1> 	mov	si,msg_floppy_2
  3183 000015A6 E8710C              <1> 	call	print
  3184 000015A9 D0C8                <1> 	ror	al,1
  3185 000015AB D0C8                <1> 	ror	al,1
  3186 000015AD D0C8                <1> 	ror	al,1
  3187 000015AF D0C8                <1> 	ror	al,1
  3188 000015B1 89C6                <1> 	mov	si,ax
  3189 000015B3 83E607              <1> 	and	si,0007h
  3190 000015B6 D1E6                <1> 	shl	si,1
  3191 000015B8 2E8BB4[FA05]        <1>     cs	mov	si,word [tbl_floppy+si]
  3192 000015BD E85A0C              <1> 	call	print
  3193 000015C0 BE[8800]            <1> 	mov	si,msg_crlf
  3194 000015C3 E8540C              <1> 	call	print
  3195 000015C6 5E                  <1> 	pop	si
  3196 000015C7 58                  <1> 	pop	ax
  3197 000015C8 C3                  <1> 	ret
  3198                                  %include	"kbc.inc"		; keyboard controller functions
  3199                              <1> ;=========================================================================
  3200                              <1> ; kbc.inc - Keyboard controller support
  3201                              <1> ;-------------------------------------------------------------------------
  3202                              <1> ;
  3203                              <1> ; Compiles with NASM 2.07, might work with other versions
  3204                              <1> ;
  3205                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  3206                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3207                              <1> ;
  3208                              <1> ; This program is free software: you can redistribute it and/or modify
  3209                              <1> ; it under the terms of the GNU General Public License as published by
  3210                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3211                              <1> ; (at your option) any later version.
  3212                              <1> ;
  3213                              <1> ; This program is distributed in the hope that it will be useful,
  3214                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3215                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3216                              <1> ; GNU General Public License for more details.
  3217                              <1> ;
  3218                              <1> ; You should have received a copy of the GNU General Public License
  3219                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3220                              <1> ;
  3221                              <1> ;=========================================================================
  3222                              <1> 
  3223                              <1> ;=========================================================================
  3224                              <1> ; Keyboard controller defines - ports, commands, and flags
  3225                              <1> ;-------------------------------------------------------------------------
  3226                              <1> kbc_data_reg	equ	60h
  3227                              <1> kbc_input_reg	equ	60h
  3228                              <1> kbc_output_reg	equ	60h
  3229                              <1> ; keyboard controller return codes
  3230                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3231                              <1> ; keyboard controller status register and its bits
  3232                              <1> kbc_status_reg	equ	64h
  3233                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3234                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3235                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3236                              <1> ; keyboard contoller command register and commands
  3237                              <1> kbc_command_reg	equ	64h
  3238                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3239                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3240                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3241                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3242                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3243                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3244                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3245                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3246                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3247                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3248                              <1> ; keyboard controller control register bits
  3249                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3250                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3251                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3252                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3253                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3254                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3255                              <1> ; keyboard controller input port bits
  3256                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3257                              <1> 
  3258                              <1> ;=========================================================================
  3259                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3260                              <1> ; Input:
  3261                              <1> ;	AL = command
  3262                              <1> ; Output:
  3263                              <1> ;	none
  3264                              <1> ;-------------------------------------------------------------------------
  3265                              <1> kbc_kb_send:
  3266 000015C9 50                  <1> 	push	ax
  3267 000015CA 51                  <1> 	push	cx
  3268 000015CB 88C4                <1> 	mov	ah,al			; save command to AH
  3269 000015CD B90300              <1> 	mov	cx,3			; try 3 times
  3270                              <1> 
  3271                              <1> .1:
  3272 000015D0 51                  <1> 	push	cx
  3273 000015D1 FA                  <1> 	cli
  3274                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3275 000015D2 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3276 000015D7 31C9                <1> 	xor	cx,cx
  3277                              <1> 
  3278                              <1> .2:					; wait for KBC to empty input buffer
  3279 000015D9 E464                <1> 	in	al,kbc_status_reg
  3280 000015DB A802                <1> 	test	al,kbc_stat_ibf
  3281 000015DD E0FA                <1> 	loopnz	.2
  3282                              <1> 
  3283 000015DF 88E0                <1> 	mov	al,ah
  3284 000015E1 E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3285 000015E3 FB                  <1> 	sti
  3286 000015E4 31C9                <1> 	xor	cx,cx
  3287                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3288 000015E6 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3289 000015EB E1F9                <1> 	loopz	.3
  3290 000015ED 59                  <1> 	pop	cx
  3291 000015EE 7507                <1> 	jnz	.4
  3292 000015F0 E2DE                <1> 	loop	.1			; try again
  3293                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3294 000015F2 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3295                              <1> .4:
  3296 000015F7 59                  <1> 	pop	cx
  3297 000015F8 58                  <1> 	pop	ax
  3298 000015F9 C3                  <1> 	ret
  3299                              <1> 
  3300                              <1> ;=========================================================================
  3301                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3302                              <1> ; Input:
  3303                              <1> ;	AL - command byte
  3304                              <1> ;	AH = argument
  3305                              <1> ; Output:
  3306                              <1> ;	ZF == 0 - success
  3307                              <1> ;	ZF == 1 - error
  3308                              <1> ;-------------------------------------------------------------------------
  3309                              <1> kbc_send_cmd:
  3310 000015FA 51                  <1> 	push	cx
  3311 000015FB 88C5                <1> 	mov	ch,al			; save command byte to CH
  3312 000015FD B11E                <1> 	mov	cl,30			; 30 retries
  3313                              <1> .1:
  3314 000015FF FA                  <1> 	cli
  3315 00001600 88E8                <1> 	mov	al,ch
  3316 00001602 E82800              <1> 	call	kbc_send_cmd_byte
  3317 00001605 7522                <1> 	jnz	.exit			; time out
  3318 00001607 E464                <1> 	in	al,kbc_status_reg
  3319 00001609 A801                <1> 	test	al,kbc_stat_obf
  3320 0000160B 7414                <1> 	jz	.3			; output buffer is empty
  3321 0000160D A820                <1> 	test	al,kbc_stat_aobf
  3322 0000160F 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3323 00001611 E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3324                              <1> %ifdef PS2_MOUSE
  3325 00001613 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3326                              <1> %endif ; PS2_MOUSE
  3327 00001618 EB07                <1> 	jmp	.3
  3328                              <1> .2:
  3329 0000161A FB                  <1> 	sti
  3330 0000161B FEC9                <1> 	dec	cl
  3331 0000161D 75E0                <1> 	jnz	.1
  3332 0000161F EB08                <1> 	jmp	.exit			; note: ZF=1
  3333                              <1> .3:
  3334 00001621 88E0                <1> 	mov	al,ah
  3335 00001623 E660                <1> 	out	kbc_input_reg,al
  3336 00001625 FB                  <1> 	sti
  3337 00001626 80C901              <1> 	or	cl,1			; set ZF=0
  3338                              <1> .exit:
  3339 00001629 88E8                <1> 	mov	al,ch			; restore AL
  3340 0000162B 59                  <1> 	pop	cx
  3341 0000162C C3                  <1> 	ret
  3342                              <1> 
  3343                              <1> ;=========================================================================
  3344                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3345                              <1> ; Input:
  3346                              <1> ;	AL - command byte
  3347                              <1> ; Output:
  3348                              <1> ;	ZF == 1 - success
  3349                              <1> ;	ZF == 0 - time out
  3350                              <1> ; Note:
  3351                              <1> ;	XXX - function should be reused in keyboard code
  3352                              <1> ;-------------------------------------------------------------------------
  3353                              <1> kbc_send_cmd_byte:
  3354 0000162D 51                  <1> 	push	cx
  3355 0000162E 50                  <1> 	push	ax
  3356 0000162F 31C9                <1> 	xor	cx,cx
  3357                              <1> 				; wait for KBC to empty input buffer
  3358                              <1> .1:
  3359 00001631 E464                <1> 	in	al,kbc_status_reg
  3360 00001633 A802                <1> 	test	al,kbc_stat_ibf
  3361 00001635 E0FA                <1> 	loopnz	.1
  3362 00001637 750C                <1> 	jnz	.exit		; time out
  3363                              <1> 
  3364 00001639 58                  <1> 	pop	ax
  3365 0000163A E664                <1> 	out	kbc_command_reg,al
  3366                              <1> 
  3367 0000163C 50                  <1> 	push	ax
  3368 0000163D 31C9                <1> 	xor	cx,cx
  3369                              <1> 				; wait for KBC to empty input buffer
  3370                              <1> .2:
  3371 0000163F E464                <1> 	in	al,kbc_status_reg
  3372 00001641 A802                <1> 	test	al,kbc_stat_ibf
  3373 00001643 E0FA                <1> 	loopnz	.2
  3374                              <1> .exit:
  3375 00001645 58                  <1> 	pop	ax
  3376 00001646 59                  <1> 	pop	cx
  3377 00001647 C3                  <1> 	ret
  3378                              <1> 
  3379                              <1> ;=========================================================================
  3380                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3381                              <1> ; Input:
  3382                              <1> ;	none
  3383                              <1> ; Output:
  3384                              <1> ;	AL = keyboard status register
  3385                              <1> ;	ZF == 0 - data is available
  3386                              <1> ;	ZF == 1 - timed out
  3387                              <1> ; Note:
  3388                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3389                              <1> ;	      be merged with kbc_wait_aux_full
  3390                              <1> ;-------------------------------------------------------------------------
  3391                              <1> kbc_wait_output_full:
  3392 00001648 51                  <1> 	push	cx
  3393 00001649 31C9                <1> 	xor	cx,cx
  3394                              <1> .1:
  3395 0000164B E464                <1> 	in	al,kbc_status_reg
  3396 0000164D A801                <1> 	test	al,kbc_stat_obf
  3397 0000164F E1FA                <1> 	loopz	.1
  3398 00001651 09C9                <1> 	or	cx,cx
  3399 00001653 59                  <1> 	pop	cx
  3400 00001654 C3                  <1> 	ret
  3401                              <1> 
  3402                              <1> %ifdef PS2_MOUSE
  3403                              <1> ;=========================================================================
  3404                              <1> ; kbc_aux_read - read data from auxiliary device
  3405                              <1> ; Input:
  3406                              <1> ;	none
  3407                              <1> ; Output:
  3408                              <1> ;	AL = data
  3409                              <1> ;	CF == 0 - data is available
  3410                              <1> ;	CF == 1 - time out
  3411                              <1> ;-------------------------------------------------------------------------
  3412                              <1> kbc_aux_read:
  3413 00001655 51                  <1> 	push	cx
  3414                              <1> ;	xor	cx,cx			; XXX too much?!
  3415 00001656 B91400              <1> 	mov	cx,20			; retry 20 times
  3416                              <1> .1:
  3417 00001659 E86000              <1> 	call	kbc_wait_aux_full
  3418 0000165C 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3419 0000165E E1F9                <1> 	loopz	.1
  3420 00001660 EB0B                <1> 	jmp	.error			; time out
  3421                              <1> .2:
  3422 00001662 B90100              <1> 	mov	cx,1
  3423 00001665 E8B9F5              <1> 	call	delay_15us
  3424 00001668 E460                <1> 	in	al,kbc_output_reg
  3425 0000166A F8                  <1> 	clc
  3426 0000166B EB01                <1> 	jmp	.exit
  3427                              <1> .error:
  3428 0000166D F9                  <1> 	stc
  3429                              <1> .exit:
  3430 0000166E 59                  <1> 	pop	cx
  3431 0000166F C3                  <1> 	ret
  3432                              <1> 
  3433                              <1> ;=========================================================================
  3434                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3435                              <1> ; Input:
  3436                              <1> ;	AL = command
  3437                              <1> ; Output:
  3438                              <1> ;	AH - status:
  3439                              <1> ;		00h - success
  3440                              <1> ;		03h - interface error (time out)
  3441                              <1> ;		04h - resend requested
  3442                              <1> ;	CF == 0 - no error
  3443                              <1> ;	CF == 1 - error
  3444                              <1> ;-------------------------------------------------------------------------
  3445                              <1> kbc_aux_send:
  3446 00001670 51                  <1> 	push	cx
  3447 00001671 88C4                <1> 	mov	ah,al			; store command to AH
  3448 00001673 B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3449 00001675 E882FF              <1> 	call	kbc_send_cmd
  3450 00001678 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3451                              <1> 
  3452                              <1> 					; wait for acknowledge
  3453 0000167A B90A00              <1> 	mov	cx,10			; retry 10 times
  3454                              <1> .1:
  3455 0000167D E83C00              <1> 	call	kbc_wait_aux_full
  3456 00001680 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3457 00001682 E2F9                <1> 	loop	.1
  3458 00001684 EB17                <1> 	jmp	.timeout		; no reply - timeout
  3459                              <1> .2:
  3460 00001686 E460                <1> 	in	al,kbc_output_reg
  3461 00001688 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3462 0000168A 740C                <1> 	je	.ok
  3463 0000168C 3CFE                <1> 	cmp	al,0FEh			; resend?
  3464 0000168E 7411                <1> 	je	.resend
  3465 00001690 3CFC                <1> 	cmp	al,0FCh			; error?
  3466 00001692 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3467 00001694 E2E7                <1> 	loop	.1
  3468 00001696 EB05                <1> 	jmp	.timeout
  3469                              <1> 
  3470                              <1> .ok:
  3471 00001698 30C0                <1> 	xor	al,al			; success - ACK received
  3472 0000169A F8                  <1> 	clc
  3473 0000169B EB07                <1> 	jmp	.exit
  3474                              <1> 
  3475                              <1> .timeout:
  3476 0000169D B003                <1> 	mov	al,03h			; interface error
  3477 0000169F EB02                <1> 	jmp	.error
  3478                              <1> 
  3479                              <1> .resend:
  3480 000016A1 B004                <1> 	mov	al,04h			; resend
  3481                              <1> 
  3482                              <1> .error:
  3483 000016A3 F9                  <1> 	stc
  3484                              <1> 
  3485                              <1> .exit:
  3486 000016A4 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3487 000016A6 59                  <1> 	pop	cx
  3488 000016A7 C3                  <1> 	ret
  3489                              <1> 
  3490                              <1> ;=========================================================================
  3491                              <1> ; kbc_aux_enable - enable auxiliary device
  3492                              <1> ; Input:
  3493                              <1> ;	none
  3494                              <1> ; Output:
  3495                              <1> ;	ZF = 0 - no error
  3496                              <1> ;	ZF = 1 - error
  3497                              <1> ;-------------------------------------------------------------------------
  3498                              <1> kbc_aux_enable:
  3499 000016A8 50                  <1> 	push	ax
  3500 000016A9 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3501 000016AB B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3502                              <1> 					; enable keyboard, enable aux obf
  3503                              <1> 					; interrupt, enable obf interrupt
  3504 000016AD E84AFF              <1> 	call	kbc_send_cmd
  3505 000016B0 58                  <1> 	pop	ax
  3506 000016B1 C3                  <1> 	ret
  3507                              <1> 
  3508                              <1> ;=========================================================================
  3509                              <1> ; kbc_aux_disable - disable auxiliary device
  3510                              <1> ; Input:
  3511                              <1> ;	none
  3512                              <1> ; Output:
  3513                              <1> ;	ZF = 0 - no error
  3514                              <1> ;	ZF = 1 - error
  3515                              <1> ;-------------------------------------------------------------------------
  3516                              <1> kbc_aux_disable:
  3517 000016B2 50                  <1> 	push	ax
  3518 000016B3 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3519 000016B5 B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3520                              <1> 					; enable keyboard, disable aux obf
  3521                              <1> 					; interrupt, enable obf interrupt
  3522 000016B7 E840FF              <1> 	call	kbc_send_cmd
  3523 000016BA 58                  <1> 	pop	ax
  3524 000016BB C3                  <1> 	ret
  3525                              <1> 
  3526                              <1> ;=========================================================================
  3527                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3528                              <1> ; Input:
  3529                              <1> ;	none
  3530                              <1> ; Output:
  3531                              <1> ;	AL = keyboard status register
  3532                              <1> ;	ZF == 0 - data is available
  3533                              <1> ;	ZF == 1 - timed out
  3534                              <1> ;-------------------------------------------------------------------------
  3535                              <1> kbc_wait_aux_full:
  3536 000016BC E889FF              <1> 	call	kbc_wait_output_full
  3537 000016BF 7402                <1> 	jz	.error
  3538 000016C1 A820                <1> 	test	al,kbc_stat_aobf
  3539                              <1> .error:
  3540 000016C3 C3                  <1> 	ret
  3541                              <1> 
  3542                              <1> %endif ; PS2_MOUSE
  3543                              <1> 
  3544                              <1> ;=========================================================================
  3545                              <1> ; kbc_flush - flush all data from i8042 buffers
  3546                              <1> ; Input:
  3547                              <1> ;	none
  3548                              <1> ; Output:
  3549                              <1> ;	CF = 0 - flushed successfully
  3550                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3551                              <1> ;-------------------------------------------------------------------------
  3552                              <1> kbc_flush:
  3553 000016C4 50                  <1> 	push	ax
  3554 000016C5 51                  <1> 	push	cx
  3555 000016C6 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3556                              <1> .flush_next_byte:
  3557 000016C9 E464                <1> 	in	al,kbc_status_reg
  3558 000016CB A801                <1> 	test	al,kbc_stat_obf
  3559 000016CD 740F                <1> 	jz	.flushed
  3560 000016CF 51                  <1> 	push	cx
  3561 000016D0 B90400              <1> 	mov	cx,4
  3562 000016D3 E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3563 000016D6 59                  <1> 	pop	cx
  3564 000016D7 E460                <1> 	in	al,kbc_data_reg
  3565 000016D9 E2EE                <1> 	loop	.flush_next_byte
  3566 000016DB F9                  <1> 	stc				; unable to flush it
  3567 000016DC EB01                <1> 	jmp	.exit
  3568                              <1> .flushed:
  3569 000016DE F8                  <1> 	clc
  3570                              <1> .exit:
  3571 000016DF 59                  <1> 	pop	cx
  3572 000016E0 58                  <1> 	pop	ax
  3573 000016E1 C3                  <1> 	ret
  3574                              <1> 
  3575                              <1> ;=========================================================================
  3576                              <1> ; kbc_init - Initialize keyboard controller
  3577                              <1> ;-------------------------------------------------------------------------
  3578                              <1> kbc_init:
  3579 000016E2 50                  <1> 	push	ax
  3580 000016E3 51                  <1> 	push	cx
  3581 000016E4 52                  <1> 	push	dx
  3582                              <1> 
  3583                              <1> ;-------------------------------------------------------------------------
  3584                              <1> ; test keyboard controller
  3585                              <1> 
  3586 000016E5 E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3587                              <1> 
  3588 000016E8 B90A00              <1> 	mov	cx,10			; try 10 times
  3589                              <1> 
  3590                              <1> .kbc_reset_retry:
  3591 000016EB B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3592 000016ED E83DFF              <1> 	call 	kbc_send_cmd_byte
  3593 000016F0 E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3594                              <1> 
  3595 000016F3 E460                <1> 	in	al,kbc_output_reg
  3596 000016F5 3C55                <1> 	cmp	al,55h			; check for success
  3597 000016F7 E0F2                <1> 	loopne	.kbc_reset_retry
  3598 000016F9 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3599                              <1> 
  3600 000016FE B90A00              <1> 	mov	cx,10			; try 10 times
  3601                              <1> 
  3602                              <1> .kbc_test_retry:
  3603 00001701 B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3604 00001703 E827FF              <1> 	call	kbc_send_cmd_byte
  3605 00001706 E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3606                              <1> 
  3607 00001709 E460                <1> 	in	al,kbc_output_reg
  3608 0000170B 3C00                <1> 	cmp	al,0			; check for success
  3609 0000170D E0F2                <1> 	loopne	.kbc_test_retry
  3610 0000170F 7403E98E00          <1> 	jne	kbd_int_fail
  3611                              <1> 
  3612                              <1> ;-------------------------------------------------------------------------
  3613                              <1> ; read display type and set equipment bits accordingly
  3614                              <1> 
  3615 00001714 B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3616 00001716 E814FF              <1> 	call	kbc_send_cmd_byte
  3617 00001719 E82CFF              <1> 	call	kbc_wait_output_full
  3618                              <1> 
  3619 0000171C E460                <1> 	in	al,kbc_output_reg
  3620 0000171E A840                <1> 	test	al,kbc_in_display
  3621 00001720 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3622 00001722 830E100030          <1> 	or	word [equipment_list],equip_mono
  3623 00001727 EB05                <1> 	jmp	.get_disp_done
  3624                              <1> .get_disp_color:
  3625 00001729 830E100020          <1> 	or	word [equipment_list],equip_color
  3626                              <1> .get_disp_done:
  3627                              <1> 
  3628                              <1> ;-------------------------------------------------------------------------
  3629                              <1> ; initialize keyboard controller
  3630                              <1> 
  3631 0000172E B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  3632 00001730 E8FAFE              <1> 	call	kbc_send_cmd_byte
  3633                              <1> 
  3634 00001733 B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  3635 00001735 E8F5FE              <1> 	call	kbc_send_cmd_byte
  3636                              <1> 
  3637 00001738 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  3638 0000173A B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  3639                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  3640                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  3641                              <1> 					; Bit 4 = 0 - Enable keyboard
  3642                              <1> 					; Bit 3 = 1 - Disable inhibit
  3643                              <1> 					; Bit 2 = 0 - system flag = 0
  3644                              <1> 					; Bit 1 = 0 - reserved
  3645                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  3646 0000173C E8BBFE              <1> 	call	kbc_send_cmd
  3647                              <1> 
  3648 0000173F B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  3649 00001741 E8E9FE              <1> 	call	kbc_send_cmd_byte
  3650                              <1> 
  3651 00001744 B90010              <1> 	mov	cx,1000h
  3652 00001747 E8D7F4              <1> 	call	delay_15us
  3653                              <1> 
  3654 0000174A E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  3655 0000174D E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  3656                              <1> 
  3657                              <1> ;-------------------------------------------------------------------------
  3658                              <1> ; check for PS/2 mouse presence
  3659                              <1> 
  3660 0000174F B90A00              <1> 	mov	cx,10			; try 10 times
  3661                              <1> .mouse_reset_retry:
  3662 00001752 B0FF                <1> 	mov	al,0FFh
  3663 00001754 E819FF              <1> 	call	kbc_aux_send
  3664 00001757 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  3665 00001759 80FC03              <1> 	cmp	ah,03h			; timeout error?
  3666 0000175C E1F4                <1> 	loopz	.mouse_reset_retry
  3667 0000175E EB13                <1> 	jmp	.no_mouse
  3668                              <1> .mouse_reset_ok:
  3669 00001760 E8F2FE              <1> 	call	kbc_aux_read
  3670 00001763 720E                <1> 	jc	.no_mouse
  3671 00001765 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  3672 00001767 750A                <1> 	jne	.no_mouse
  3673 00001769 E8E9FE              <1> 	call	kbc_aux_read
  3674 0000176C 7205                <1> 	jc	.no_mouse
  3675                              <1> ; mouse reset successful, update equipment word accordingly
  3676 0000176E 830E100004          <1> 	or      word [equipment_list],equip_mouse
  3677                              <1> .no_mouse:
  3678                              <1> 
  3679                              <1> ;-------------------------------------------------------------------------
  3680                              <1> ; setup keyboard buffer
  3681                              <1> 
  3682 00001773 B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  3683 00001776 A38000              <1>         mov     word [kbd_buffer_start],ax
  3684 00001779 A31A00              <1>         mov     word [kbd_buffer_head],ax
  3685 0000177C A31C00              <1>         mov     word [kbd_buffer_tail],ax
  3686 0000177F 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  3687 00001782 A38200              <1>         mov     word [kbd_buffer_end],ax
  3688 00001785 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  3689 00001787 A31700              <1>         mov     word [kbd_flags_1],ax
  3690 0000178A A31800              <1>         mov     word [kbd_flags_2],ax
  3691 0000178D A39600              <1>         mov     word [kbd_flags_3],ax
  3692 00001790 A39700              <1>         mov     word [kbd_flags_4],ax
  3693 00001793 B010                <1> 	mov	al,e_kbd_ok
  3694 00001795 E680                <1> 	out	post_reg,al
  3695 00001797 5A                  <1> 	pop	dx
  3696 00001798 59                  <1> 	pop	cx
  3697 00001799 58                  <1> 	pop	ax
  3698 0000179A C3                  <1> 	ret
  3699                              <1> 
  3700                              <1> kbd_ctrl_fail:
  3701 0000179B B060                <1> 	mov	al,e_kbd_ctrl_fail
  3702 0000179D E680                <1> 	out	post_reg,al
  3703                              <1> .1:
  3704 0000179F F4                  <1> 	hlt
  3705 000017A0 EBFD                <1> 	jmp	.1
  3706                              <1> 
  3707                              <1> kbd_int_fail:
  3708 000017A2 240F                <1> 	and	al,0Fh
  3709 000017A4 0463                <1> 	add	al,e_kbd_int_fail
  3710 000017A6 E680                <1> 	out	post_reg,al
  3711                              <1> .1:
  3712 000017A8 F4                  <1> 	hlt
  3713 000017A9 EBFD                <1> 	jmp	.1
  3714                              <1> 
  3715                              <1> kbd_key_fail:
  3716 000017AB B061                <1> 	mov	al,e_kbd_key_fail
  3717 000017AD E680                <1> 	out	post_reg,al
  3718                              <1> .1:
  3719 000017AF F4                  <1> 	hlt
  3720 000017B0 EBFD                <1> 	jmp	.1
  3721                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  3722                              <1> ;=========================================================================
  3723                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  3724                              <1> ;		 and related INT 16h functions:
  3725                              <1> ;	INT 16h - BIOS Keyboard Services
  3726                              <1> ;		- function AH=00h
  3727                              <1> ;		- function AH=01h
  3728                              <1> ;		- function AH=10h
  3729                              <1> ;		- function AH=11h
  3730                              <1> ;-------------------------------------------------------------------------
  3731                              <1> ;
  3732                              <1> ; Compiles with NASM 2.07, might work with other versions
  3733                              <1> ;
  3734                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  3735                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3736                              <1> ;
  3737                              <1> ; This program is free software: you can redistribute it and/or modify
  3738                              <1> ; it under the terms of the GNU General Public License as published by
  3739                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3740                              <1> ; (at your option) any later version.
  3741                              <1> ;
  3742                              <1> ; This program is distributed in the hope that it will be useful,
  3743                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3744                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3745                              <1> ; GNU General Public License for more details.
  3746                              <1> ;
  3747                              <1> ; You should have received a copy of the GNU General Public License
  3748                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3749                              <1> ;
  3750                              <1> ;=========================================================================
  3751                              <1> 
  3752                              <1> ;=========================================================================
  3753                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  3754                              <1> ;                   BIOS scan code translation table
  3755                              <1> ; Note 1: Table starts with scancode == 1
  3756                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  3757                              <1> ;	00 - no flags
  3758                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  3759                              <1> ;	     x in this case equals digit value
  3760                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  3761                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  3762                              <1> ;	8x - F11, F12 BIOS scan codes
  3763                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  3764                              <1> ;-------------------------------------------------------------------------
  3765                              <1> 
  3766                              <1> scan_xlat_table:
  3767                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3768 000017B2 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  3769 000017BA 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  3770 000017C2 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  3771 000017CA 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  3772 000017D2 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  3773 000017DA 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  3774 000017E2 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  3775 000017EA 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  3776 000017F2 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  3777 000017FA 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  3778 00001802 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  3779 0000180A 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  3780 00001812 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  3781 0000181A 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  3782 00001822 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  3783 0000182A 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  3784                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3785 00001832 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  3786 0000183A 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  3787 00001842 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  3788 0000184A 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  3789 00001852 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  3790 0000185A 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  3791 00001862 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  3792 0000186A 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  3793 00001872 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  3794 0000187A 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  3795 00001882 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  3796 0000188A 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  3797 00001892 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  3798 0000189A 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  3799 000018A2 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  3800 000018AA 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  3801                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3802 000018B2 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  3803 000018BA 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  3804 000018C2 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  3805 000018CA 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  3806 000018D2 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  3807 000018DA 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  3808 000018E2 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  3809 000018EA 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  3810 000018F2 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  3811 000018FA 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  3812 00001902 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  3813 0000190A 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  3814 00001912 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  3815 0000191A 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  3816 00001922 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  3817 0000192A 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  3818                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3819 00001932 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  3820 0000193A 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  3821 00001942 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  3822 0000194A 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  3823 00001952 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  3824 0000195A 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  3825 00001962 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  3826 0000196A 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  3827 00001972 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  3828 0000197A 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  3829 00001982 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  3830 0000198A 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  3831 00001992 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  3832 0000199A 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  3833 000019A2 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  3834 000019AA 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  3835                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3836 000019B2 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  3837 000019BA 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  3838 000019C2 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  3839 000019CA 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  3840 000019D2 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  3841 000019DA 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  3842 000019E2 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  3843 000019EA 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  3844 000019F2 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  3845 000019FA 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  3846 00001A02 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  3847 00001A0A F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  3848 00001A12 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  3849 00001A1A 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  3850 00001A22 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  3851 00001A2A 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  3852                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  3853 00001A32 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  3854 00001A3A 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  3855 00001A42 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  3856 00001A4A 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  3857 00001A52 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  3858 00001A5A 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  3859 00001A62 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  3860 00001A6A 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  3861                              <1> .end:
  3862                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  3863                              <1> 
  3864                              <1> ;=========================================================================
  3865                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  3866                              <1> ; Input:
  3867                              <1> ;	AL - scan code
  3868                              <1> ; Output:
  3869                              <1> ;	AX - ASCII character / scan code pair
  3870                              <1> ;-------------------------------------------------------------------------
  3871                              <1> scan_xlat:
  3872 00001A72 53                  <1> 	push	bx
  3873 00001A73 FEC8                <1> 	dec	al
  3874 00001A75 3C58                <1> 	cmp	al,scan_xlat_table_size
  3875 00001A77 7205                <1> 	jb	.1
  3876 00001A79 31C0                <1> 	xor	ax,ax
  3877 00001A7B E9AB00              <1> 	jmp	.exit
  3878                              <1> 
  3879                              <1> .1:
  3880 00001A7E B700                <1> 	mov	bh,00h				; calculate offset of the key
  3881 00001A80 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  3882 00001A82 D1E3                <1> 	shl	bx,1				; BX = AL * 8
  3883 00001A84 D1E3                <1> 	shl	bx,1
  3884 00001A86 D1E3                <1> 	shl	bx,1
  3885                              <1> 
  3886 00001A88 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  3887 00001A8D 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  3888 00001A8F 2E8B87[B817]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  3889                              <1> 	; check for numeric Keypad keys
  3890 00001A94 2EF687[B317]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  3891 00001A9A 7474                <1> 	jz	.check_extended
  3892 00001A9C F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  3893 00001AA1 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  3894                              <1> 						; and so it is not a keypad key
  3895                              <1> 
  3896 00001AA3 2E8A87[B317]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  3897 00001AA8 240F                <1> 	and	al,0Fh				; get the numeric value
  3898 00001AAA 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  3899 00001AAE D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  3900 00001AB0 A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  3901                              <1> 
  3902 00001AB3 31C0                <1> 	xor	ax,ax				; return nothing
  3903 00001AB5 EB72                <1> 	jmp	.exit
  3904                              <1> 
  3905                              <1> .check_ctrl:
  3906 00001AB7 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  3907 00001ABC 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  3908 00001ABE 2E8B87[B617]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  3909 00001AC3 EB4B                <1> 	jmp	.check_extended
  3910                              <1> 
  3911                              <1> .check_locks:
  3912 00001AC5 2EF687[B317]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  3913 00001ACB 741D                <1> 	jz	.check_shift			; not affected by Locks
  3914                              <1> 
  3915 00001ACD 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  3916 00001ACF 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  3917                              <1> 
  3918 00001AD1 F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  3919 00001AD6 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  3920 00001AD8 EB07                <1> 	jmp	.lock_active
  3921                              <1> 
  3922                              <1> .check_num_lock:
  3923 00001ADA F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  3924 00001ADF 7409                <1> 	jz	.check_shift			; Num Lock is not active
  3925                              <1> .lock_active:
  3926                              <1> 	; are any of Shift keys active?
  3927 00001AE1 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  3928 00001AE6 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  3929 00001AE8 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  3930                              <1> 
  3931                              <1> .check_shift:
  3932                              <1> 	; are any of Shift keys active?
  3933 00001AEA F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  3934 00001AEF 7407                <1> 	jz	.no_shift
  3935                              <1> .shift:
  3936 00001AF1 2E8B87[B417]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  3937 00001AF6 EB18                <1> 	jmp	.check_extended
  3938                              <1> 
  3939                              <1> .no_shift:
  3940 00001AF8 88C4                <1> 	mov	ah,al				; Move scan code to AH
  3941 00001AFA FEC4                <1> 	inc	ah
  3942 00001AFC 2E8A87[B217]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  3943 00001B01 2EF687[B317]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  3944 00001B07 7407                <1> 	jz	.check_extended			; not F11 or F12
  3945 00001B09 2E8AA7[B317]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  3946 00001B0E EB19                <1> 	jmp	.exit
  3947                              <1> 
  3948                              <1> .check_extended:
  3949 00001B10 2EF687[B317]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  3950 00001B16 7411                <1> 	jz	.exit				; no extended key
  3951 00001B18 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  3952 00001B1D 740A                <1> 	jz	.exit				; ... not a 0E0h
  3953 00001B1F 3C00                <1> 	cmp	al,00h
  3954 00001B21 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  3955 00001B23 B0E0                <1> 	mov	al,0E0h				; indicate extended key
  3956 00001B25 EB02                <1> 	jmp	.exit
  3957                              <1> 
  3958                              <1> .ascii_code:
  3959 00001B27 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  3960                              <1> 						; key with valid ASCII code
  3961                              <1> 						; (Keypad Enter, *, and /)
  3962                              <1> 
  3963                              <1> .exit:
  3964 00001B29 5B                  <1> 	pop	bx
  3965 00001B2A C3                  <1> 	ret
  3966                              <1> 
  3967                              <1> ;=========================================================================
  3968                              <1> ; int_16_fn00 - get keystroke
  3969                              <1> ; Input:
  3970                              <1> ;	AH = 00h
  3971                              <1> ; Output:
  3972                              <1> ;	AH = BIOS scan code
  3973                              <1> ;	AL = ASCII character
  3974                              <1> ; Notes:
  3975                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  3976                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  3977                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  3978                              <1> ;	- Use function AH=10h for extended keystrokes handling
  3979                              <1> ;-------------------------------------------------------------------------
  3980                              <1> int_16_fn00:
  3981 00001B2B FB                  <1> 	sti
  3982                              <1> .1:
  3983 00001B2C 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  3984 00001B30 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  3985 00001B34 74F6                <1> 	jz	.1			; wait or keystroke
  3986 00001B36 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  3987 00001B38 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  3988                              <1> 					;   location
  3989 00001B3B 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  3990 00001B3F 7504                <1> 	jne	.2
  3991 00001B41 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  3992                              <1> .2:
  3993 00001B45 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  3994 00001B49 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  3995                              <1> 					;   extended key?
  3996 00001B4B 7504                <1> 	jne	.3			; not a convertible key
  3997 00001B4D B000                <1> 	mov	al,00h			; convert to a standard key
  3998 00001B4F EB2C                <1> 	jmp	.exit
  3999                              <1> .3:
  4000 00001B51 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4001 00001B53 74D7                <1> 	je	.1			; an ignored extended key, get next key
  4002 00001B55 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4003                              <1> 					;   (scancode above 84h)
  4004 00001B58 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  4005 00001B5A 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4006 00001B5D 751E                <1> 	jne	.exit
  4007 00001B5F 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4008 00001B61 7504                <1> 	jne	.4
  4009 00001B63 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4010 00001B65 EB16                <1> 	jmp	.exit
  4011                              <1> .4:
  4012 00001B67 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4013 00001B69 7504                <1> 	jne	.5
  4014 00001B6B B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4015 00001B6D EB0E                <1> 	jmp	.exit
  4016                              <1> .5:
  4017 00001B6F 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4018 00001B71 7504                <1> 	jne	.6
  4019 00001B73 B435                <1> 	mov	ah,35h			; standard / scancode
  4020 00001B75 EB06                <1> 	jmp	.exit
  4021                              <1> .6:
  4022 00001B77 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4023 00001B79 7502                <1> 	jne	.exit
  4024 00001B7B B437                <1> 	mov	ah,37h			; standard * scancode
  4025                              <1> .exit:
  4026 00001B7D E9EB4C              <1> 	jmp	int_16_exit
  4027                              <1> 
  4028                              <1> ;=========================================================================
  4029                              <1> ; int_16_fn01 - check for keystroke
  4030                              <1> ; Input:
  4031                              <1> ;	AH = 01h
  4032                              <1> ; Output:
  4033                              <1> ;	ZF = 1 - no keystroke available
  4034                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4035                              <1> ;		AH = BIOS scan code
  4036                              <1> ;		AL = ASCII character
  4037                              <1> ; Notes:
  4038                              <1> ;	- Does not remove keystroke from keyboard buffer
  4039                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4040                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4041                              <1> ;	- Use function AH=11h for extended keystrokes handling
  4042                              <1> ;-------------------------------------------------------------------------
  4043                              <1> int_16_fn01:
  4044 00001B80 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4045 00001B84 8B07                <1> 	mov	ax,word [bx]
  4046 00001B86 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4047 00001B8A 7436                <1> 	jz	.exit			; no keystroke, exit
  4048 00001B8C 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4049                              <1> 					;   extended key?
  4050 00001B8E 7504                <1> 	jne	.1			; not a convertible key
  4051 00001B90 B000                <1> 	mov	al,00h			; convert to a standard key
  4052 00001B92 EB2C                <1> 	jmp	.clear_zf
  4053                              <1> .1:
  4054 00001B94 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4055 00001B96 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  4056 00001B98 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4057                              <1> 					;   (scancode above 84h)
  4058 00001B9B 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  4059 00001B9D 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4060 00001BA0 751E                <1> 	jne	.clear_zf
  4061 00001BA2 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4062 00001BA4 7504                <1> 	jne	.2
  4063 00001BA6 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4064 00001BA8 EB16                <1> 	jmp	.clear_zf
  4065                              <1> .2:
  4066 00001BAA 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4067 00001BAC 7504                <1> 	jne	.3
  4068 00001BAE B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4069 00001BB0 EB0E                <1> 	jmp	.clear_zf
  4070                              <1> .3:
  4071 00001BB2 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4072 00001BB4 7504                <1> 	jne	.4
  4073 00001BB6 B435                <1> 	mov	ah,35h			; standard / scancode
  4074 00001BB8 EB06                <1> 	jmp	.clear_zf
  4075                              <1> .4:
  4076 00001BBA 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4077 00001BBC 7502                <1> 	jne	.clear_zf
  4078 00001BBE B437                <1> 	mov	ah,37h			; standard * scancode
  4079                              <1> 
  4080                              <1> .clear_zf:
  4081 00001BC0 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4082                              <1> .exit:
  4083 00001BC2 E9A94C              <1> 	jmp	int_16_exitf
  4084                              <1> 
  4085                              <1> .discard_key:
  4086 00001BC5 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4087                              <1> 					;   location
  4088 00001BC8 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4089 00001BCC 7504                <1> 	jne	.5
  4090 00001BCE 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4091                              <1> .5:
  4092 00001BD2 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4093 00001BD6 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4094                              <1> 	
  4095                              <1> 
  4096                              <1> ;=========================================================================
  4097                              <1> ; int_16_fn10 - get extended keystroke
  4098                              <1> ; Input:
  4099                              <1> ;	AH = 10h
  4100                              <1> ; Output:
  4101                              <1> ;	AH = BIOS scan code
  4102                              <1> ;	AL = ASCII character
  4103                              <1> ; Note:
  4104                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4105                              <1> ;-------------------------------------------------------------------------
  4106                              <1> int_16_fn10:
  4107 00001BD8 FB                  <1> 	sti
  4108                              <1> .1:
  4109 00001BD9 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4110 00001BDD 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4111 00001BE1 74F6                <1> 	jz	.1			; wait or keystroke
  4112 00001BE3 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4113 00001BE5 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4114                              <1> 					;   location
  4115 00001BE8 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4116 00001BEC 7504                <1> 	jne	.2
  4117 00001BEE 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4118                              <1> .2:
  4119 00001BF2 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4120 00001BF6 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4121 00001BF8 7502                <1> 	jne	.exit			; not a extended key
  4122 00001BFA B000                <1> 	mov	al,00h			; set scancode to zero
  4123                              <1> 
  4124                              <1> .exit:
  4125 00001BFC E96C4C              <1> 	jmp	int_16_exit
  4126                              <1> 
  4127                              <1> ;=========================================================================
  4128                              <1> ; int_16_fn11 - check for extended keystroke
  4129                              <1> ; Input:
  4130                              <1> ;	AH = 01h
  4131                              <1> ; Output:
  4132                              <1> ;	ZF = 1 - no keystroke available
  4133                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4134                              <1> ;		AH = BIOS scan code
  4135                              <1> ;		AL = ASCII character
  4136                              <1> ; Note:
  4137                              <1> ;	- Does not remove keystroke from keyboard buffer
  4138                              <1> ;-------------------------------------------------------------------------
  4139                              <1> int_16_fn11:
  4140 00001BFF 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4141 00001C03 8B07                <1> 	mov	ax,word [bx]
  4142 00001C05 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4143 00001C09 7408                <1> 	jz	.exit			; no keystroke, exit
  4144 00001C0B 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4145 00001C0D 7502                <1> 	jne	.clear_zf		; not a extended key
  4146 00001C0F B000                <1> 	mov	al,00h			; set scancode to zero
  4147                              <1> .clear_zf:
  4148 00001C11 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4149                              <1> .exit:
  4150 00001C13 E9584C              <1> 	jmp	int_16_exitf
  4151                                  %include	"serial1.inc"		; serial port services & detection
  4152                              <1> ;========================================================================
  4153                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
  4154                              <1> ;       INT 14h, function AH=01h
  4155                              <1> ;	INT 14h, function AH=02h
  4156                              <1> ;	detect_serial
  4157                              <1> ;	serial port related definitions and tables
  4158                              <1> ;	- see serial2.inc for other INT 14h functions
  4159                              <1> ;-------------------------------------------------------------------------
  4160                              <1> ;
  4161                              <1> ; Compiles with NASM 2.07, might work with other versions
  4162                              <1> ;
  4163                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4164                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4165                              <1> ;
  4166                              <1> ; This program is free software: you can redistribute it and/or modify
  4167                              <1> ; it under the terms of the GNU General Public License as published by
  4168                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4169                              <1> ; (at your option) any later version.
  4170                              <1> ;
  4171                              <1> ; This program is distributed in the hope that it will be useful,
  4172                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4173                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4174                              <1> ; GNU General Public License for more details.
  4175                              <1> ;
  4176                              <1> ; You should have received a copy of the GNU General Public License
  4177                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4178                              <1> ;
  4179                              <1> ;=========================================================================
  4180                              <1> 
  4181                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
  4182                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
  4183                              <1> 
  4184                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
  4185                              <1> 
  4186                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
  4187                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
  4188                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
  4189                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
  4190                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
  4191                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
  4192                              <1> 
  4193                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
  4194                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
  4195                              <1> uart_mcr_rts	equ	3		; MCR - request to send (RTS)
  4196                              <1> 
  4197                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
  4198                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
  4199                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
  4200                              <1> 
  4201                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
  4202                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
  4203                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
  4204                              <1> 
  4205                              <1> uart_err_timeout equ	80h		; timeout error
  4206                              <1> 
  4207                              <1> num_serial	equ	4		; number of serial ports
  4208                              <1> 
  4209                              <1> ;=========================================================================
  4210                              <1> ; int_14_fn01 - Send character
  4211                              <1> ; Input:
  4212                              <1> ;	AH = 01h - function 01h - send character
  4213                              <1> ;	AL = character to send
  4214                              <1> ;	DX = serial port number (0-3)
  4215                              <1> ; Output:
  4216                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4217                              <1> ;-------------------------------------------------------------------------
  4218                              <1> int_14_fn01:
  4219 00001C16 50                  <1> 	push	ax
  4220 00001C17 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4221 00001C19 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR
  4222 00001C1B B320                <1> 	mov	bl,uart_lsr_thre	; and for THR empty in LSR
  4223 00001C1D E82200              <1> 	call	uart_wait_status
  4224 00001C20 59                  <1> 	pop	cx
  4225 00001C21 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
  4226 00001C23 88C8                <1> 	mov	al,cl
  4227 00001C25 EE                  <1> 	out	dx,al			; sent the character
  4228 00001C26 E93D4B              <1> 	jmp	int_14_exit
  4229                              <1> 
  4230                              <1> int_14_timeout:
  4231 00001C29 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
  4232 00001C2B 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
  4233 00001C2E E9354B              <1> 	jmp	int_14_exit
  4234                              <1> 
  4235                              <1> ;=========================================================================
  4236                              <1> ; int_14_fn02 - Receive character
  4237                              <1> ; Input:
  4238                              <1> ;	AH = 02h - function 02h - receive character
  4239                              <1> ;	DX = serial port number (0-3)
  4240                              <1> ; Output:
  4241                              <1> ;	AL = character received
  4242                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4243                              <1> ;-------------------------------------------------------------------------
  4244                              <1> int_14_fn02:
  4245 00001C31 50                  <1> 	push	ax
  4246 00001C32 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4247 00001C34 B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR
  4248 00001C36 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR
  4249 00001C38 E80700              <1> 	call	uart_wait_status
  4250 00001C3B 59                  <1> 	pop	cx
  4251 00001C3C 75EB                <1> 	jnz	int_14_timeout
  4252 00001C3E EC                  <1> 	in	al,dx			; receive the character
  4253 00001C3F E9244B              <1> 	jmp	int_14_exit
  4254                              <1> 
  4255                              <1> ;=========================================================================
  4256                              <1> ; uart_wait_status - wait for modem and line status
  4257                              <1> ; Input:
  4258                              <1> ;	AL = value to write to MCR (Modem Control Register)
  4259                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
  4260                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
  4261                              <1> ;	DX = UART base address
  4262                              <1> ;	SI = serial port number
  4263                              <1> ; Output:
  4264                              <1> ;	AH = line status
  4265                              <1> ;	ZF = 0 - timeout
  4266                              <1> ;	CX,BX - destroyed
  4267                              <1> ;-------------------------------------------------------------------------
  4268                              <1> uart_wait_status:
  4269 00001C42 52                  <1> 	push	dx
  4270 00001C43 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
  4271 00001C46 EE                  <1> 	out	dx,al			; output MCR value
  4272 00001C47 42                  <1> 	inc	dx
  4273 00001C48 42                  <1> 	inc	dx			; DX = UART MSR address
  4274                              <1> 					; OPTIMIZATION:
  4275                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
  4276 00001C49 E80A00              <1> 	call	wait_for_port		; wait for MSR status
  4277 00001C4C 7506                <1> 	jnz	.wait_exit
  4278 00001C4E 4A                  <1> 	dec	dx			; DX = UART LSR address
  4279                              <1> 					; OPTIMIZATION:
  4280                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
  4281 00001C4F 88DF                <1> 	mov	bh,bl			; BH = LSR mask
  4282 00001C51 E80200              <1> 	call	wait_for_port		; wait for LSR status
  4283                              <1> .wait_exit:
  4284 00001C54 5A                  <1> 	pop	dx
  4285 00001C55 C3                  <1> 	ret
  4286                              <1> 
  4287                              <1> ;=========================================================================
  4288                              <1> ; wait_for_port - wait for set bits in a register
  4289                              <1> ;
  4290                              <1> ; Input:
  4291                              <1> ;	BH = mask to wait for (bits that need to be 1)
  4292                              <1> ;	DX = register address
  4293                              <1> ;	SI = address of the timeout value (in seconds)
  4294                              <1> ; Output:
  4295                              <1> ;	AH = last port reading
  4296                              <1> ;	ZF clear on timeout
  4297                              <1> ;	ZF set on success
  4298                              <1> ;	AL - trashed
  4299                              <1> ;	CX - trashed
  4300                              <1> ;-------------------------------------------------------------------------
  4301                              <1> wait_for_port:
  4302 00001C56 53                  <1> 	push	bx
  4303 00001C57 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
  4304                              <1> 
  4305                              <1> .loop_outer:
  4306 00001C59 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
  4307                              <1> 
  4308                              <1> .loop_inner:
  4309 00001C5C EC                  <1> 	in	al,dx			; read the register
  4310 00001C5D 88C4                <1> 	mov	ah,al			; save register in AH
  4311 00001C5F 20F8                <1> 	and	al,bh
  4312 00001C61 38F8                <1> 	cmp	al,bh			; required bits are set?
  4313 00001C63 7414                <1> 	je	.exit
  4314                              <1> 
  4315                              <1> .zero_loop:
  4316 00001C65 E461                <1> 	in	al,port_b_reg
  4317 00001C67 A810                <1> 	test	al,refresh_flag
  4318 00001C69 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  4319                              <1> 
  4320                              <1> .one_loop:
  4321 00001C6B E461                <1> 	in	al,port_b_reg
  4322 00001C6D A810                <1> 	test	al,refresh_flag
  4323 00001C6F 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  4324 00001C71 E2E9                <1> 	loop	.loop_inner
  4325                              <1> 
  4326 00001C73 FECB                <1> 	dec	bl
  4327 00001C75 75E2                <1> 	jnz	.loop_outer
  4328 00001C77 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
  4329                              <1> 
  4330                              <1> .exit:
  4331 00001C79 5B                  <1> 	pop	bx
  4332 00001C7A C3                  <1> 	ret
  4333                              <1> 
  4334                              <1> ;=========================================================================
  4335                              <1> ; detect_serial - detect and print serial ports
  4336                              <1> ; Input:
  4337                              <1> ;	none
  4338                              <1> ; Output:
  4339                              <1> ;	none (updates BIOS data area)
  4340                              <1> ;-------------------------------------------------------------------------
  4341                              <1> detect_serial:
  4342 00001C7B 50                  <1> 	push	ax
  4343 00001C7C 53                  <1> 	push	bx
  4344 00001C7D 52                  <1> 	push	dx
  4345 00001C7E 56                  <1> 	push	si
  4346 00001C7F BE[9B02]            <1> 	mov	si,msg_serial
  4347 00001C82 E89505              <1> 	call	print
  4348 00001C85 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
  4349 00001C88 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
  4350 00001C8C 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
  4351 00001C90 31DB                <1> 	xor	bx,bx			; BX = 0
  4352                              <1> .detect_loop:
  4353 00001C92 BE[B802]            <1> 	mov	si,msg_serial_com
  4354 00001C95 E88205              <1> 	call	print
  4355 00001C98 88D8                <1> 	mov	al,bl
  4356 00001C9A D0E8                <1> 	shr	al,1
  4357 00001C9C FEC0                <1> 	inc	al			; AL = COM port number (1..4)
  4358 00001C9E E8D805              <1> 	call	print_digit
  4359 00001CA1 BE[9000]            <1> 	mov	si,msg_colon
  4360 00001CA4 E87305              <1> 	call	print
  4361 00001CA7 2E8B97[F71C]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
  4362 00001CAC EC                  <1> 	in	al,dx
  4363 00001CAD B00F                <1> 	mov	al,0Fh
  4364 00001CAF EE                  <1> 	out	dx,al			; enable interrupts
  4365 00001CB0 B000                <1> 	mov	al,00h
  4366 00001CB2 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
  4367 00001CB4 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4368 00001CB5 3C0F                <1> 	cmp	al,0Fh
  4369 00001CB7 7516                <1> 	jne	.no_port		; no port at this address
  4370 00001CB9 B000                <1> 	mov	al,00h
  4371 00001CBB EE                  <1> 	out	dx,al			; disable interrupts
  4372 00001CBC B0FF                <1> 	mov	al,0FFh
  4373 00001CBE E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4374 00001CC0 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4375 00001CC1 3C00                <1> 	cmp	al,00h
  4376 00001CC3 750A                <1> 	jne	.no_port		; no port at this address
  4377 00001CC5 4A                  <1> 	dec	dx			; DX = UART base address
  4378                              <1> 					; OPTIMIZATION:
  4379                              <1> 					; uart_base = uart_ier_reg - 1
  4380 00001CC6 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
  4381                              <1> 					; data area
  4382 00001CC8 89D0                <1> 	mov	ax,dx
  4383 00001CCA E86805              <1> 	call	print_hex
  4384 00001CCD EB0A                <1> 	jmp	.next
  4385                              <1> 
  4386                              <1> .no_port:
  4387 00001CCF C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
  4388 00001CD3 BE[8B00]            <1> 	mov	si,msg_none
  4389 00001CD6 E84105              <1> 	call	print
  4390                              <1> 	
  4391                              <1> .next:
  4392 00001CD9 43                  <1> 	inc	bx
  4393 00001CDA 43                  <1> 	inc	bx
  4394 00001CDB 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
  4395 00001CDE 7408                <1> 	je	.done
  4396 00001CE0 BE[9300]            <1> 	mov	si,msg_semicolon
  4397 00001CE3 E83405              <1> 	call	print
  4398 00001CE6 EBAA                <1> 	jmp	.detect_loop
  4399                              <1> 
  4400                              <1> .done:
  4401 00001CE8 BE[8800]            <1> 	mov	si,msg_crlf
  4402 00001CEB E82C05              <1> 	call	print
  4403                              <1> 
  4404 00001CEE B024                <1> 	mov	al,e_serial_ok		; serial port detection complete
  4405 00001CF0 E680                <1> 	out	post_reg,al
  4406                              <1> 
  4407 00001CF2 5E                  <1> 	pop	si
  4408 00001CF3 5A                  <1> 	pop	dx
  4409 00001CF4 5B                  <1> 	pop	bx
  4410 00001CF5 58                  <1> 	pop	ax
  4411 00001CF6 C3                  <1> 	ret
  4412                              <1> 
  4413                              <1> ;-------------------------------------------------------------------------
  4414                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
  4415 00001CF7 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
  4416 00001CFB E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
  4417                              <1> 
  4418                              <1> ;-------------------------------------------------------------------------
  4419                              <1> ; UART divisor values table
  4420 00001CFF 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
  4421 00001D01 0003                <1> 		dw	uart_osc/16/150		; 150 bps
  4422 00001D03 8001                <1> 		dw	uart_osc/16/300		; 300 bps
  4423 00001D05 C000                <1> 		dw	uart_osc/16/600		; 600 bps
  4424 00001D07 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
  4425 00001D09 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
  4426 00001D0B 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
  4427 00001D0D 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
  4428 00001D0F 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
  4429 00001D11 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
  4430 00001D13 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
  4431 00001D15 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
  4432                              <1> num_divisors	equ ($-uart_divisors)/2
  4433                                  %include	"printer1.inc"		; parallel printer services & detection
  4434                              <1> ;========================================================================
  4435                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
  4436                              <1> ;	INT 17h, function AH=01h 
  4437                              <1> ;	detect_parallel
  4438                              <1> ;	- see printer2.inc for other INT 17h functions
  4439                              <1> ;-------------------------------------------------------------------------
  4440                              <1> ;
  4441                              <1> ; Compiles with NASM 2.07, might work with other versions
  4442                              <1> ;
  4443                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4444                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4445                              <1> ;
  4446                              <1> ; This program is free software: you can redistribute it and/or modify
  4447                              <1> ; it under the terms of the GNU General Public License as published by
  4448                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4449                              <1> ; (at your option) any later version.
  4450                              <1> ;
  4451                              <1> ; This program is distributed in the hope that it will be useful,
  4452                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4453                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4454                              <1> ; GNU General Public License for more details.
  4455                              <1> ;
  4456                              <1> ; You should have received a copy of the GNU General Public License
  4457                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4458                              <1> ;
  4459                              <1> ;=========================================================================
  4460                              <1> 
  4461                              <1> num_parallel	equ	3		; number of parallel ports
  4462                              <1> 
  4463                              <1> prn_data_reg	equ	0		; printer data register (out)
  4464                              <1> 
  4465                              <1> prn_stat_reg	equ	1		; printer status register (in)
  4466                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
  4467                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
  4468                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
  4469                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
  4470                              <1> 
  4471                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
  4472                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
  4473                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
  4474                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
  4475                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
  4476                              <1> 
  4477                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
  4478                              <1> 
  4479                              <1> ;=========================================================================
  4480                              <1> ; int_17_fn01 - Initialize printer port
  4481                              <1> ; Input:
  4482                              <1> ;	AH = 1 - function 01h - initialize printer port
  4483                              <1> ;	DX = printer port number (0-2)
  4484                              <1> ; Output:
  4485                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  4486                              <1> ;-------------------------------------------------------------------------
  4487                              <1> int_17_fn01:
  4488 00001D17 42                  <1> 	inc	dx
  4489 00001D18 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  4490                              <1> 					; OPTIMIZATION:
  4491                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
  4492 00001D19 B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
  4493 00001D1B EE                  <1> 	out	dx,al
  4494 00001D1C 51                  <1> 	push	cx
  4495 00001D1D B9B509              <1> 	mov	cx,prn_init_delay
  4496 00001D20 E8FEEE              <1> 	call	delay_15us
  4497 00001D23 59                  <1> 	pop	cx
  4498 00001D24 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  4499 00001D26 EE                  <1> 	out	dx,al			; deactivate init bit
  4500 00001D27 4A                  <1> 	dec	dx			; OPTIMIZATION:
  4501                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
  4502 00001D28 E90E53              <1> 	jmp	int_17_status		; exit returning status
  4503                              <1> 
  4504                              <1> ;=========================================================================
  4505                              <1> ; detect_parallel - detect and print parallel ports
  4506                              <1> ; Input:
  4507                              <1> ;	none
  4508                              <1> ; Output:
  4509                              <1> ;	none (updates BIOS data area)
  4510                              <1> ; Notes:
  4511                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
  4512                              <1> ;	  enumeration is used:
  4513                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
  4514                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
  4515                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
  4516                              <1> ;-------------------------------------------------------------------------
  4517                              <1> detect_parallel:
  4518 00001D2B 50                  <1> 	push	ax
  4519 00001D2C 53                  <1> 	push	bx
  4520 00001D2D 52                  <1> 	push	dx
  4521 00001D2E 56                  <1> 	push	si
  4522 00001D2F BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
  4523 00001D32 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
  4524 00001D36 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
  4525 00001D3A 31DB                <1> 	xor	bx,bx			; BX = 0
  4526 00001D3C 31FF                <1> 	xor	di,di			; DI = 0
  4527                              <1> .detect_loop:
  4528 00001D3E 2E8B95[B51D]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
  4529 00001D43 B05A                <1> 	mov	al,05Ah			; just some test value
  4530 00001D45 EE                  <1> 	out	dx,al			; write it to the printer data register
  4531 00001D46 B0FF                <1> 	mov	al,0FFh
  4532 00001D48 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4533 00001D4A EC                  <1> 	in	al,dx
  4534 00001D4B 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
  4535 00001D4D 7505                <1> 	jne	.no_port		; no port at this address
  4536 00001D4F 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
  4537                              <1> 					; data area
  4538 00001D52 EB09                <1> 	jmp	.next
  4539                              <1> 
  4540                              <1> .no_port:
  4541 00001D54 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
  4542 00001D59 09FF                <1> 	or	di,di			; no printer port at 3BCh?
  4543 00001D5B 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
  4544                              <1> .next:
  4545 00001D5D 43                  <1> 	inc	bx
  4546 00001D5E 43                  <1> 	inc	bx
  4547                              <1> 
  4548                              <1> .next_skip_3BC:
  4549 00001D5F 47                  <1> 	inc	di
  4550 00001D60 47                  <1> 	inc	di
  4551 00001D61 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
  4552 00001D64 7402                <1> 	je	.print			; done with detection, print findings
  4553 00001D66 EBD6                <1> 	jmp	.detect_loop
  4554                              <1> 
  4555                              <1> .print:
  4556 00001D68 BE[BC02]            <1> 	mov	si,msg_parallel
  4557 00001D6B E8AC04              <1> 	call	print
  4558 00001D6E 31DB                <1> 	xor	bx,bx
  4559                              <1> 
  4560                              <1> .print_loop:
  4561 00001D70 BE[D902]            <1> 	mov	si,msg_parallel_lpt
  4562 00001D73 E8A404              <1> 	call	print
  4563 00001D76 88D8                <1> 	mov	al,bl
  4564 00001D78 D0E8                <1> 	shr	al,1
  4565 00001D7A FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
  4566 00001D7C E8FA04              <1> 	call	print_digit
  4567 00001D7F BE[9000]            <1> 	mov	si,msg_colon
  4568 00001D82 E89504              <1> 	call	print
  4569 00001D85 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
  4570 00001D88 09C0                <1> 	or	ax,ax			; parallel interface installed?
  4571 00001D8A 7405                <1> 	jz	.print_no_port
  4572 00001D8C E8A604              <1> 	call	print_hex
  4573 00001D8F EB06                <1> 	jmp	.print_next
  4574                              <1> 
  4575                              <1> .print_no_port:
  4576 00001D91 BE[8B00]            <1> 	mov	si,msg_none
  4577 00001D94 E88304              <1> 	call	print
  4578                              <1> 
  4579                              <1> .print_next:
  4580 00001D97 43                  <1> 	inc	bx
  4581 00001D98 43                  <1> 	inc	bx
  4582 00001D99 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
  4583 00001D9C 7408                <1> 	je	.done
  4584 00001D9E BE[9300]            <1> 	mov	si,msg_semicolon
  4585 00001DA1 E87604              <1> 	call	print
  4586 00001DA4 EBCA                <1> 	jmp	.print_loop
  4587                              <1> 
  4588                              <1> .done:
  4589 00001DA6 BE[8800]            <1> 	mov	si,msg_crlf
  4590 00001DA9 E86E04              <1> 	call	print
  4591                              <1> 
  4592 00001DAC B025                <1> 	mov	al,e_parallel_ok	; parallel port detection complete
  4593 00001DAE E680                <1> 	out	post_reg,al
  4594                              <1> 
  4595 00001DB0 5E                  <1> 	pop	si
  4596 00001DB1 5A                  <1> 	pop	dx
  4597 00001DB2 5B                  <1> 	pop	bx
  4598 00001DB3 58                  <1> 	pop	ax
  4599 00001DB4 C3                  <1> 	ret
  4600                              <1> 
  4601                              <1> ;-------------------------------------------------------------------------
  4602                              <1> ; parallel port base addresses - used for port detection
  4603 00001DB5 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
  4604                                  %ifdef PS2_MOUSE
  4605                                  %include	"ps2aux.inc"
  4606                              <1> ;=========================================================================
  4607                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  4608                              <1> ;	INT 15h, function AH=0C2h
  4609                              <1> ;	INT 74h - IRQ12 interrupt handler
  4610                              <1> ;-------------------------------------------------------------------------
  4611                              <1> ;
  4612                              <1> ; Compiles with NASM 2.07, might work with other versions
  4613                              <1> ;
  4614                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4615                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4616                              <1> ;
  4617                              <1> ; This program is free software: you can redistribute it and/or modify
  4618                              <1> ; it under the terms of the GNU General Public License as published by
  4619                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4620                              <1> ; (at your option) any later version.
  4621                              <1> ;
  4622                              <1> ; This program is distributed in the hope that it will be useful,
  4623                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4624                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4625                              <1> ; GNU General Public License for more details.
  4626                              <1> ;
  4627                              <1> ; You should have received a copy of the GNU General Public License
  4628                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4629                              <1> ;
  4630                              <1> ;=========================================================================
  4631                              <1> 
  4632                              <1> ;-------------------------------------------------------------------------
  4633                              <1> ; offsets for registers on stack
  4634                              <1> int_15_fnC2_bp	equ	0
  4635                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  4636                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  4637                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  4638                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  4639                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  4640                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  4641                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  4642                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  4643                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  4644                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  4645                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  4646                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  4647                              <1> 
  4648                              <1> ;=========================================================================
  4649                              <1> ; int_15_fnC2 - mouse functions
  4650                              <1> ; Input:
  4651                              <1> ;	AH = 0C2h - mouse functions
  4652                              <1> ;	AL - function:
  4653                              <1> ;		00h - enable / disable PS/2 mouse
  4654                              <1> ;		01h - reset PS/2 mouse
  4655                              <1> ;		02h - set sample rate
  4656                              <1> ;		03h - set resolution
  4657                              <1> ;		04h - read device type
  4658                              <1> ;		05h - initialize PS/2 mouse
  4659                              <1> ;		06h - set scaling or get status
  4660                              <1> ;		07h - set PS/2 mouse driver address
  4661                              <1> ; Output:
  4662                              <1> ;	AH - exit status:
  4663                              <1> ;		00h - no error
  4664                              <1> ;		01h - invalid function call
  4665                              <1> ;		02h - invalid input value
  4666                              <1> ;		03h - interface error
  4667                              <1> ;		04h - request for resend received from 8042
  4668                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  4669                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  4670                              <1> ;-------------------------------------------------------------------------
  4671                              <1> int_15_fnC2:
  4672 00001DBB 50                  <1> 	push	ax
  4673 00001DBC 53                  <1> 	push	bx
  4674 00001DBD 51                  <1> 	push	cx
  4675 00001DBE 52                  <1> 	push	dx
  4676 00001DBF 1E                  <1> 	push	ds
  4677 00001DC0 55                  <1> 	push	bp
  4678 00001DC1 89E5                <1> 	mov	bp,sp			; establish stack addressing
  4679 00001DC3 BB4000              <1> 	mov	bx,biosdseg
  4680 00001DC6 8EDB                <1> 	mov	ds,bx
  4681 00001DC8 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  4682 00001DCC 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  4683 00001DCE 3C08                <1> 	cmp	al,.num_func
  4684 00001DD0 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  4685 00001DD2 E8DDF8              <1> 	call	kbc_aux_disable		; disable auxiliary device
  4686 00001DD5 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  4687 00001DD7 B700                <1> 	mov	bh,0
  4688 00001DD9 D1E3                <1> 	shl	bx,1			; address words
  4689 00001DDB 2EFFA7[E01D]        <1>     cs	jmp	near [.dispatch+bx]
  4690                              <1> 
  4691                              <1> .dispatch:
  4692 00001DE0 [191E]              <1> 	dw	int_15_fnC200
  4693 00001DE2 [3A1E]              <1> 	dw	int_15_fnC201
  4694 00001DE4 [5D1E]              <1> 	dw	int_15_fnC202
  4695 00001DE6 [841E]              <1> 	dw	int_15_fnC203
  4696 00001DE8 [A61E]              <1> 	dw	int_15_fnC204
  4697 00001DEA [BE1E]              <1> 	dw	int_15_fnC205
  4698 00001DEC [021F]              <1> 	dw	int_15_fnC206
  4699 00001DEE [531F]              <1> 	dw	int_15_fnC207
  4700                              <1> .num_func	equ ($-.dispatch)/2
  4701                              <1> 
  4702                              <1> int_15_fnC2_ok:
  4703 00001DF0 B400                <1> 	mov	ah,00h			; no error
  4704 00001DF2 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  4705 00001DF6 EB14                <1> 	jmp	int_15_fnC2_exit
  4706                              <1> 
  4707                              <1> int_15_fnC2_err1:
  4708 00001DF8 B401                <1> 	mov	ah,01h			; invalid function call
  4709 00001DFA EB0C                <1> 	jmp	int_15_fnC2_err
  4710                              <1> 
  4711                              <1> int_15_fnC2_err2:
  4712 00001DFC B402                <1> 	mov	ah,02h			; invalid input value
  4713 00001DFE EB08                <1> 	jmp	int_15_fnC2_err
  4714                              <1> 
  4715                              <1> int_15_fnC2_err3:
  4716 00001E00 B403                <1> 	mov	ah,03h			; interface error
  4717 00001E02 EB04                <1> 	jmp	int_15_fnC2_err
  4718                              <1> 
  4719                              <1> int_15_fnC2_err5:
  4720 00001E04 B405                <1> 	mov	ah,05h			; no driver installed
  4721 00001E06 EB00                <1> 	jmp	int_15_fnC2_err
  4722                              <1> 
  4723                              <1> int_15_fnC2_err:
  4724 00001E08 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  4725                              <1> 
  4726                              <1> int_15_fnC2_exit:
  4727 00001E0C 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  4728 00001E0F E896F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
  4729 00001E12 5D                  <1> 	pop	bp
  4730 00001E13 1F                  <1> 	pop	ds
  4731 00001E14 5A                  <1> 	pop	dx
  4732 00001E15 59                  <1> 	pop	cx
  4733 00001E16 5B                  <1> 	pop	bx
  4734 00001E17 58                  <1> 	pop	ax
  4735 00001E18 CF                  <1> 	iret
  4736                              <1> 
  4737                              <1> ;=========================================================================
  4738                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  4739                              <1> ; Input:
  4740                              <1> ;	AX = 0C200h
  4741                              <1> ;	BH - sub-function:
  4742                              <1> ;		00h - disable
  4743                              <1> ;		01h - enable
  4744                              <1> ;-------------------------------------------------------------------------
  4745                              <1> int_15_fnC200:
  4746 00001E19 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4747 00001E1C 80FF01              <1> 	cmp	bh,01h
  4748 00001E1F 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  4749                              <1> 
  4750 00001E21 F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  4751 00001E26 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  4752                              <1> 
  4753 00001E28 80FF00              <1> 	cmp	bh,00h
  4754 00001E2B 7404                <1> 	je	.disable
  4755 00001E2D B0F4                <1> 	mov	al,0F4h			; device enable command
  4756 00001E2F EB02                <1> 	jmp	.send_it
  4757                              <1> .disable:
  4758 00001E31 B0F5                <1> 	mov	al,0F5h			; device disable command
  4759                              <1> 
  4760                              <1> .send_it:
  4761 00001E33 E83AF8              <1> 	call	kbc_aux_send
  4762 00001E36 72D0                <1> 	jc	int_15_fnC2_err		; error
  4763 00001E38 EBB6                <1> 	jmp	int_15_fnC2_ok
  4764                              <1> 
  4765                              <1> ;=========================================================================
  4766                              <1> ; int_15_fnC201 - reset PS/2 mouse
  4767                              <1> ; Input:
  4768                              <1> ;	AX = 0C201h
  4769                              <1> ; Output:
  4770                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  4771                              <1> ;	     0AAh - BAT successful XXX test!!!
  4772                              <1> ;	     0FCh - BAT error
  4773                              <1> ;	BH = device ID
  4774                              <1> ;-------------------------------------------------------------------------
  4775                              <1> int_15_fnC201:
  4776 00001E3A B90A00              <1> 	mov	cx,10			; try the reset 10 times
  4777                              <1> .1:
  4778 00001E3D B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  4779 00001E3F E82EF8              <1> 	call	kbc_aux_send
  4780 00001E42 7307                <1> 	jnc	.2			; no error - continue
  4781 00001E44 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4782 00001E47 E1F4                <1> 	loopz	.1			; try again
  4783 00001E49 EBBD                <1> 	jmp	int_15_fnC2_err		; error
  4784                              <1> .2:
  4785 00001E4B E807F8              <1> 	call	kbc_aux_read
  4786 00001E4E 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  4787 00001E50 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  4788 00001E53 E8FFF7              <1> 	call	kbc_aux_read
  4789 00001E56 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  4790 00001E58 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  4791 00001E5B EB93                <1> 	jmp	int_15_fnC2_ok
  4792                              <1> 
  4793                              <1> ;=========================================================================
  4794                              <1> ; int_15_fnC202 - set sample rate
  4795                              <1> ; Input:
  4796                              <1> ;	AX = 0C202h
  4797                              <1> ;	BH - sample rate:
  4798                              <1> ;		00h - 10 samples per second
  4799                              <1> ;		01h - 20 samples per second
  4800                              <1> ;		02h - 40 samples per second
  4801                              <1> ;		03h - 60 samples per second
  4802                              <1> ;		04h - 80 samples per second
  4803                              <1> ;		05h - 100 samples per second
  4804                              <1> ;		06h - 200 samples per second
  4805                              <1> ;-------------------------------------------------------------------------
  4806                              <1> int_15_fnC202:
  4807 00001E5D 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4808 00001E60 80FF06              <1> 	cmp	bh,06h
  4809 00001E63 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  4810 00001E65 88FB                <1> 	mov	bl,bh
  4811 00001E67 B700                <1> 	mov	bh,00h			; rate index in BX
  4812                              <1> 
  4813 00001E69 B0F3                <1> 	mov	al,0F3h			; set sample rate
  4814 00001E6B E802F8              <1> 	call	kbc_aux_send
  4815 00001E6E 7298                <1> 	jc	int_15_fnC2_err		; error
  4816                              <1> 
  4817 00001E70 2E8A87[7D1E]        <1>     cs	mov	al,byte [.rate_table+bx]
  4818 00001E75 E8F8F7              <1> 	call	kbc_aux_send
  4819 00001E78 728E                <1> 	jc	int_15_fnC2_err		; error
  4820 00001E7A E973FF              <1> 	jmp	int_15_fnC2_ok
  4821                              <1> 
  4822 00001E7D 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  4823                              <1> 	
  4824                              <1> ;=========================================================================
  4825                              <1> ; int_15_fnC203 - set resolution
  4826                              <1> ; Input:
  4827                              <1> ;	AX = 0C203h
  4828                              <1> ;	BH - resolution value:
  4829                              <1> ;		00h - 1 count per millimeter
  4830                              <1> ;		01h - 2 counts per millimeter
  4831                              <1> ;		02h - 4 counts per millimeter
  4832                              <1> ;		03h - 8 counts per millimeter
  4833                              <1> ;-------------------------------------------------------------------------
  4834                              <1> int_15_fnC203:
  4835 00001E84 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4836 00001E87 80FF03              <1> 	cmp	bh,03h
  4837 00001E8A 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  4838                              <1> 
  4839 00001E8F B0E8                <1> 	mov	al,0E8h			; set resolution
  4840 00001E91 E8DCF7              <1> 	call	kbc_aux_send
  4841 00001E94 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  4842                              <1> 
  4843 00001E99 88F8                <1> 	mov	al,bh
  4844 00001E9B E8D2F7              <1> 	call	kbc_aux_send
  4845 00001E9E 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  4846 00001EA3 E94AFF              <1> 	jmp	int_15_fnC2_ok
  4847                              <1> 
  4848                              <1> ;=========================================================================
  4849                              <1> ; int_15_fnC204 - read device type
  4850                              <1> ; Input:
  4851                              <1> ;	AX = 0C204h
  4852                              <1> ; Output:
  4853                              <1> ;	BH = device type
  4854                              <1> ;-------------------------------------------------------------------------
  4855                              <1> int_15_fnC204:
  4856 00001EA6 B0F2                <1> 	mov	al,0F2h			; read device type
  4857 00001EA8 E8C5F7              <1> 	call	kbc_aux_send
  4858 00001EAB 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  4859 00001EB0 E8A2F7              <1> 	call	kbc_aux_read
  4860 00001EB3 7303E948FF          <1> 	jc	int_15_fnC2_err3
  4861 00001EB8 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  4862 00001EBB E932FF              <1> 	jmp	int_15_fnC2_ok
  4863                              <1> 
  4864                              <1> ;=========================================================================
  4865                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  4866                              <1> ; Input:
  4867                              <1> ;	AX = 0C205h
  4868                              <1> ;	BH = data package size in bytes (03h or 04h)
  4869                              <1> ; Output:
  4870                              <1> ;	none
  4871                              <1> ;-------------------------------------------------------------------------
  4872                              <1> int_15_fnC205:
  4873 00001EBE 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4874 00001EC1 80FF03              <1> 	cmp	bh,03h
  4875 00001EC4 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  4876 00001EC9 80FF04              <1> 	cmp	bh,04h
  4877 00001ECC 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  4878 00001ED1 FECF                <1> 	dec	bh
  4879                              <1> 
  4880 00001ED3 A02700              <1> 	mov	al,byte [mouse_flags_2]
  4881 00001ED6 24F8                <1> 	and	al,0F8h			; mask out package size bits
  4882 00001ED8 08F8                <1> 	or	al,bh			; add the new package size
  4883 00001EDA A22700              <1> 	mov	byte [mouse_flags_2],al
  4884                              <1> 
  4885 00001EDD B90500              <1> 	mov	cx,5			; try the reset 5 times
  4886                              <1> .1:
  4887 00001EE0 B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  4888 00001EE2 E88BF7              <1> 	call	kbc_aux_send
  4889 00001EE5 7308                <1> 	jnc	.2			; no error - continue
  4890 00001EE7 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4891 00001EEA E1F4                <1> 	loopz	.1			; try again
  4892 00001EEC E919FF              <1> 	jmp	int_15_fnC2_err		; error
  4893                              <1> .2:
  4894 00001EEF E863F7              <1> 	call	kbc_aux_read
  4895 00001EF2 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  4896 00001EF7 E85BF7              <1> 	call	kbc_aux_read
  4897 00001EFA 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  4898 00001EFF E9EEFE              <1> 	jmp	int_15_fnC2_ok
  4899                              <1> 
  4900                              <1> ;=========================================================================
  4901                              <1> ; int_15_fnC206 - set scaling or get status
  4902                              <1> ; Input:
  4903                              <1> ;	AX = 0C206h
  4904                              <1> ;	BH - sub-function:
  4905                              <1> ;		00h - return status
  4906                              <1> ;		01h - set scaling factor to 1:1
  4907                              <1> ;		02h - set scaling factor to 2:1
  4908                              <1> ; Output:
  4909                              <1> ;	if BH = 00h on entry:
  4910                              <1> ;		BL - status byte 1:
  4911                              <1> ;			bit 0 = 1 - right button pressed
  4912                              <1> ;			bit 1 = 0 - reserved
  4913                              <1> ;			bit 2 = 1 - left button pressed
  4914                              <1> ;			bit 3 = 0 - reserved
  4915                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  4916                              <1> ;			bit 5 = 0 - disable, 1 - enable
  4917                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  4918                              <1> ;			bit 7 = 0 - reserved
  4919                              <1> ;		CL - status byte 2:
  4920                              <1> ;			00h - 1 count per millimeter
  4921                              <1> ;			01h - 2 counts per millimeter
  4922                              <1> ;			02h - 4 counts per millimeter
  4923                              <1> ;			03h - 8 counts per millimeter
  4924                              <1> ;		DL - status byte 3:
  4925                              <1> ;			0Ah - 10 samples per second
  4926                              <1> ;			14h - 20 samples per second
  4927                              <1> ;			3Ch - 40 samples per second
  4928                              <1> ;			3Ch - 60 samples per second
  4929                              <1> ;			50h - 80 samples per second
  4930                              <1> ;			64h - 100 samples per second
  4931                              <1> ;			0C8h - 200 samples per second
  4932                              <1> ;-------------------------------------------------------------------------
  4933                              <1> int_15_fnC206:
  4934 00001F02 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4935 00001F05 80FF02              <1> 	cmp	bh,02h
  4936 00001F08 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  4937 00001F0D 7433                <1> 	je	.scale_2x1
  4938 00001F0F 80FF01              <1> 	cmp	bh,01h
  4939 00001F12 7432                <1> 	je	.scale_1x1
  4940                              <1> 					; BH == 0, return status
  4941 00001F14 B0E9                <1> 	mov	al,0E9h			; request status command
  4942 00001F16 E857F7              <1> 	call	kbc_aux_send
  4943 00001F19 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  4944 00001F1E E834F7              <1> 	call	kbc_aux_read
  4945 00001F21 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  4946 00001F26 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  4947 00001F29 E829F7              <1> 	call	kbc_aux_read
  4948 00001F2C 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  4949 00001F31 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  4950 00001F34 E81EF7              <1> 	call	kbc_aux_read
  4951 00001F37 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  4952 00001F3C 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  4953 00001F3F E9AEFE              <1> 	jmp	int_15_fnC2_ok
  4954                              <1> 
  4955                              <1> .scale_2x1:
  4956 00001F42 B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  4957 00001F44 EB02                <1> 	jmp	.send_it
  4958                              <1> .scale_1x1:
  4959 00001F46 B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  4960                              <1> .send_it:
  4961 00001F48 E825F7              <1> 	call	kbc_aux_send
  4962 00001F4B 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  4963 00001F50 E99DFE              <1> 	jmp	int_15_fnC2_ok
  4964                              <1> 
  4965                              <1> ;=========================================================================
  4966                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  4967                              <1> ; Input:
  4968                              <1> ;	AX = 0C207h
  4969                              <1> ;	ES:BX - pointer to mouse driver
  4970                              <1> ;-------------------------------------------------------------------------
  4971                              <1> int_15_fnC207:
  4972 00001F53 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  4973 00001F56 891E2200            <1> 	mov	word [mouse_driver],bx
  4974 00001F5A 8CC0                <1> 	mov	ax,es
  4975 00001F5C A32400              <1> 	mov	word [mouse_driver+2],ax
  4976 00001F5F 09C0                <1> 	or	ax,ax
  4977 00001F61 750C                <1> 	jnz	.set_handler
  4978 00001F63 09DB                <1> 	or	bx,bx
  4979 00001F65 7508                <1> 	jnz	.set_handler
  4980                              <1> ; remove handler
  4981 00001F67 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  4982 00001F6C E981FE              <1> 	jmp	int_15_fnC2_ok
  4983                              <1> 
  4984                              <1> .set_handler:
  4985 00001F6F 800E270080          <1> 	or	byte [mouse_flags_2],80h
  4986 00001F74 E979FE              <1> 	jmp	int_15_fnC2_ok
  4987                              <1> 
  4988                              <1> ;=========================================================================
  4989                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  4990                              <1> ;-------------------------------------------------------------------------
  4991                              <1> int_74:
  4992 00001F77 FB                  <1> 	sti
  4993 00001F78 50                  <1> 	push	ax
  4994 00001F79 53                  <1> 	push	bx
  4995 00001F7A 1E                  <1> 	push	ds
  4996 00001F7B B84000              <1> 	mov	ax,biosdseg
  4997 00001F7E 8ED8                <1> 	mov	ds,ax
  4998 00001F80 A10E00              <1> 	mov	ax,word [ebda_segment]
  4999 00001F83 8ED8                <1> 	mov	ds,ax
  5000                              <1> 
  5001 00001F85 E464                <1> 	in	al,kbc_status_reg
  5002 00001F87 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  5003 00001F89 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  5004 00001F8B 7561                <1> 	jne	.exit			; no mouse data in the buffer
  5005                              <1> 
  5006 00001F8D E460                <1> 	in	al,kbc_data_reg
  5007 00001F8F 88C4                <1> 	mov	ah,al			; save to AH
  5008                              <1> 
  5009 00001F91 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5010 00001F94 A880                <1> 	test	al,80h
  5011 00001F96 7456                <1> 	jz	.exit			; no mouse driver installed
  5012                              <1> 
  5013 00001F98 A02600              <1> 	mov	al,byte [mouse_flags_1]
  5014 00001F9B 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  5015 00001F9D BB2800              <1> 	mov	bx,mouse_data
  5016 00001FA0 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  5017 00001FA2 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  5018                              <1> 
  5019 00001FA4 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  5020 00001FA8 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  5021                              <1> 
  5022 00001FAB 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  5023 00001FAD 7306                <1> 	jae	.call_driver
  5024                              <1> 
  5025 00001FAF FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  5026 00001FB3 EB39                <1> 	jmp	.exit
  5027                              <1> 
  5028                              <1> .call_driver:
  5029                              <1> 
  5030                              <1> ;-------------------------------------------------------------------------
  5031                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  5032                              <1> ; package sizes.
  5033                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  5034                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  5035                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  5036                              <1> ;-------------------------------------------------------------------------
  5037                              <1> 
  5038 00001FB5 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  5039 00001FB8 7413                <1> 	jz	.four_bytes
  5040                              <1> 					; put data in stack for 3 bytes format
  5041 00001FBA 31C0                <1> 	xor	ax,ax
  5042 00001FBC A02800              <1> 	mov	al,byte [mouse_data]
  5043 00001FBF 50                  <1> 	push	ax
  5044 00001FC0 A02900              <1> 	mov	al,byte [mouse_data+1]
  5045 00001FC3 50                  <1> 	push	ax
  5046 00001FC4 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5047 00001FC7 50                  <1> 	push	ax
  5048 00001FC8 B000                <1> 	mov	al,00h
  5049 00001FCA 50                  <1> 	push	ax
  5050 00001FCB EB15                <1> 	jmp	.do_call
  5051                              <1> 
  5052                              <1> .four_bytes:				; put data in stack for 4 bytes format
  5053 00001FCD 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  5054 00001FD1 A02800              <1> 	mov	al,byte [mouse_data]
  5055 00001FD4 50                  <1> 	push	ax
  5056 00001FD5 B400                <1> 	mov	ah,00h
  5057 00001FD7 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5058 00001FDA 50                  <1> 	push	ax
  5059 00001FDB A02B00              <1> 	mov	al,byte [mouse_data+3]
  5060 00001FDE 50                  <1> 	push	ax
  5061 00001FDF B000                <1> 	mov	al,00h
  5062 00001FE1 50                  <1> 	push	ax
  5063                              <1> 
  5064                              <1> .do_call:
  5065 00001FE2 FF1E2200            <1> 	call	far [mouse_driver]
  5066 00001FE6 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  5067 00001FE9 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  5068                              <1> 
  5069                              <1> .exit:
  5070 00001FEE B020                <1> 	mov	al,20h
  5071 00001FF0 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  5072 00001FF2 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  5073 00001FF4 1F                  <1> 	pop	ds
  5074 00001FF5 5B                  <1> 	pop	bx
  5075 00001FF6 58                  <1> 	pop	ax
  5076 00001FF7 CF                  <1> 	iret
  5077                                  %endif
  5078                                  %include	"sound.inc"		; sound test
  5079                              <1> ;=========================================================================
  5080                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  5081                              <1> ;-------------------------------------------------------------------------
  5082                              <1> ;
  5083                              <1> ; Compiles with NASM 2.07, might work with other versions
  5084                              <1> ;
  5085                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5086                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5087                              <1> ;
  5088                              <1> ; This program is free software: you can redistribute it and/or modify
  5089                              <1> ; it under the terms of the GNU General Public License as published by
  5090                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5091                              <1> ; (at your option) any later version.
  5092                              <1> ;
  5093                              <1> ; This program is distributed in the hope that it will be useful,
  5094                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5095                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5096                              <1> ; GNU General Public License for more details.
  5097                              <1> ;
  5098                              <1> ; You should have received a copy of the GNU General Public License
  5099                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5100                              <1> ;
  5101                              <1> ;=========================================================================
  5102                              <1> 
  5103 00001FF8 6908                <1> notes	dw	pic_freq/554		; D flat
  5104 00001FFA FFFF                <1> 	dw	-1			; silent
  5105 00001FFC 8814                <1> 	dw	pic_freq/227		; D flat
  5106 00001FFE 980C                <1> 	dw	pic_freq/370		; G flat
  5107 00002000 8814                <1> 	dw	pic_freq/227		; D flat
  5108 00002002 3B0B                <1> 	dw	pic_freq/415		; A flat
  5109 00002004 0000                <1> 	dw	0
  5110                              <1> 
  5111                              <1> ;=========================================================================
  5112                              <1> ; sound - Play power-on sound.
  5113                              <1> ; Input:
  5114                              <1> ;	none
  5115                              <1> ; Output:
  5116                              <1> ;	none, destroys some registers
  5117                              <1> ;-------------------------------------------------------------------------
  5118                              <1> sound:
  5119 00002006 FC                  <1> 	cld
  5120 00002007 BE[F81F]            <1> 	mov	si,notes		; set SI to notes table
  5121                              <1> 
  5122 0000200A B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5123 0000200C E643                <1> 	out	pit_ctl_reg,al
  5124                              <1> 
  5125                              <1> .loop:
  5126 0000200E 2EAD                <1>     cs	lodsw				; load next note to AX
  5127 00002010 83F800              <1> 	cmp	ax,0
  5128 00002013 7422                <1> 	jz	.exit
  5129 00002015 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  5130 00002017 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5131 00002019 88E0                <1> 	mov	al,ah
  5132 0000201B E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5133                              <1> 
  5134 0000201D E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5135 0000201F 0C03                <1>         or      al,03h			; turn on the speaker
  5136 00002021 E661                <1>         out     port_b_reg,al		; write the new value
  5137                              <1> 
  5138                              <1> .silent:
  5139 00002023 B90030              <1> 	mov	cx,3000h
  5140 00002026 E8F8EB              <1> 	call	delay_15us		; delay while note is playing
  5141                              <1> 
  5142 00002029 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5143 0000202B 24FC                <1> 	and	al,0FCh			; turn off the speaker
  5144 0000202D E661                <1>         out     port_b_reg,al		; write the new value
  5145                              <1> 
  5146 0000202F B90001              <1>         mov     cx,0100h
  5147 00002032 E8ECEB              <1> 	call	delay_15us		; delay after the note
  5148                              <1>         
  5149 00002035 EBD7                <1>         jmp     .loop			; play the next note
  5150                              <1> .exit:
  5151 00002037 C3                  <1> 	ret
  5152                              <1> 
  5153                              <1> ;=========================================================================
  5154                              <1> ; beep - Play a beep sound
  5155                              <1> ; Input:
  5156                              <1> ;	BL - duration in 0.1 second
  5157                              <1> ; Output:
  5158                              <1> ;	BL = 0
  5159                              <1> ;-------------------------------------------------------------------------
  5160                              <1> beep:
  5161 00002038 50                  <1> 	push	ax
  5162 00002039 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5163 0000203B E643                <1> 	out	pit_ctl_reg,al
  5164 0000203D B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  5165 00002040 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5166 00002042 88E0                <1> 	mov	al,ah
  5167 00002044 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5168 00002046 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5169 00002048 0C03                <1> 	or	al,03h			; turn on the speaker
  5170 0000204A E661                <1> 	out	port_b_reg,al		; write the new value
  5171                              <1> .loop:
  5172 0000204C B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  5173 0000204F E8CFEB              <1> 	call	delay_15us
  5174 00002052 FECB                <1> 	dec	bl
  5175 00002054 75F6                <1> 	jnz	.loop
  5176 00002056 3403                <1> 	xor	al,03h			; turn off the speaker
  5177 00002058 E661                <1> 	out	port_b_reg,al		; write the new value
  5178 0000205A 58                  <1> 	pop	ax
  5179 0000205B C3                  <1> 	ret
  5180                                  %include	"cpu.inc"		; CPU and FPU detection
  5181                              <1> ;=========================================================================
  5182                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  5183                              <1> ;-------------------------------------------------------------------------
  5184                              <1> ;
  5185                              <1> ; Compiles with NASM 2.07, might work with other versions
  5186                              <1> ;
  5187                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5188                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5189                              <1> ;
  5190                              <1> ; This program is free software: you can redistribute it and/or modify
  5191                              <1> ; it under the terms of the GNU General Public License as published by
  5192                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5193                              <1> ; (at your option) any later version.
  5194                              <1> ;
  5195                              <1> ; This program is distributed in the hope that it will be useful,
  5196                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5197                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5198                              <1> ; GNU General Public License for more details.
  5199                              <1> ;
  5200                              <1> ; You should have received a copy of the GNU General Public License
  5201                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5202                              <1> ;
  5203                              <1> ;=========================================================================
  5204                              <1> 
  5205                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  5206                              <1> 
  5207                              <1> ;=========================================================================
  5208                              <1> ; detect_cpu - detect and print CPU type
  5209                              <1> ; Note:
  5210                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  5211                              <1> ;	  incorrect results if used on other CPU types.
  5212                              <1> ;-------------------------------------------------------------------------
  5213                              <1> detect_cpu:
  5214 0000205C 50                  <1> 	push	ax
  5215 0000205D 56                  <1> 	push	si
  5216 0000205E BE[9600]            <1> 	mov	si,msg_cpu
  5217 00002061 E8B601              <1> 	call	print
  5218                              <1> 
  5219                              <1> ; test for NEC V20
  5220 00002064 B80101              <1> 	mov	ax,0101h
  5221 00002067 D510                <1> 	aad	10h			; NEC V20 ignores the argument
  5222 00002069 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  5223 0000206B 7452                <1> 	je	.nec_v20
  5224                              <1> 
  5225                              <1> ; not NEC V20, test for various 8088 versions
  5226                              <1> .i8088:					; 8088 - NMOS version of 8088
  5227 0000206D FA                  <1> 	cli				; disable interrupts
  5228 0000206E 1E                  <1> 	push	ds
  5229 0000206F 31C0                <1> 	xor	ax,ax
  5230 00002071 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  5231 00002073 B8[CC20]            <1> 	mov	ax,.int_01		; new int 01h offset
  5232 00002076 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  5233 0000207A 50                  <1> 	push	ax			; save to stack
  5234 0000207B 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  5235 0000207D 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  5236 00002081 50                  <1> 	push	ax			; save to stack
  5237 00002082 9C                  <1> 	pushf				; push flags to stack (save)
  5238 00002083 9C                  <1> 	pushf				; push flags to stack (modify)
  5239 00002084 58                  <1> 	pop	ax			; and move them to AX
  5240 00002085 0D0001              <1> 	or	ax,flags_tf		; set TF
  5241 00002088 50                  <1> 	push	ax
  5242 00002089 31C0                <1> 	xor	ax,ax			; AX = 0
  5243 0000208B 9D                  <1> 	popf				; load modified value to FLAGS register
  5244                              <1> 					; enable single-step
  5245 0000208C 90                  <1> 	nop
  5246 0000208D 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  5247                              <1> 					; after PUSH SREG instructions
  5248                              <1> .push_sreg:				; and will not single-step to here
  5249 0000208E 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  5250                              <1> 					; after modifying segment registers
  5251                              <1> .pop_sreg:				; and will not single-step to here
  5252 0000208F 90                  <1> 	nop
  5253 00002090 9D                  <1> 	popf				; restore original FLAGS, disable
  5254                              <1> 					; single-step
  5255                              <1> 
  5256 00002091 5E                  <1> 	pop	si			; get original int 01h segment
  5257 00002092 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  5258 00002096 5E                  <1> 	pop	si			; get original int 01h offset
  5259 00002097 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  5260 0000209B 1F                  <1> 	pop	ds
  5261 0000209C FB                  <1> 	sti				; enable interrupts
  5262 0000209D 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  5263 000020A0 740D                <1> 	jz	.i8088_78
  5264                              <1> 
  5265 000020A2 83F802              <1> 	cmp	ax,0002h
  5266 000020A5 7410                <1> 	jz	.i8088_81
  5267                              <1> 
  5268                              <1> .harris:				; Harris / Intersil 80C88
  5269 000020A7 BE[6101]            <1> 	mov	si,msg_cpu_harris
  5270 000020AA E86D01              <1> 	call	print
  5271 000020AD EB16                <1> 	jmp	.exit
  5272                              <1> 
  5273                              <1> .i8088_78:
  5274 000020AF BE[D000]            <1> 	mov	si,msg_cpu_8088_78
  5275 000020B2 E86501              <1> 	call	print
  5276 000020B5 EB0E                <1> 	jmp	.exit
  5277                              <1> 
  5278                              <1> .i8088_81:
  5279 000020B7 BE[3101]            <1> 	mov	si,msg_cpu_8088_81
  5280 000020BA E85D01              <1> 	call	print
  5281 000020BD EB06                <1> 	jmp	.exit
  5282                              <1> 
  5283                              <1> .nec_v20:
  5284 000020BF BE[8901]            <1> 	mov	si,msg_cpu_nec_v20
  5285 000020C2 E85501              <1> 	call	print
  5286                              <1> 
  5287                              <1> .exit:
  5288 000020C5 B021                <1> 	mov	al,e_cpu_detect_ok	; CPU detection finished
  5289 000020C7 E680                <1> 	out	post_reg,al
  5290                              <1> 
  5291 000020C9 5E                  <1> 	pop	si
  5292 000020CA 58                  <1> 	pop	ax
  5293 000020CB C3                  <1> 	ret
  5294                              <1> 
  5295                              <1> ; stack frame after "push bp"
  5296                              <1> ; BP - word [BP]
  5297                              <1> ; IP - word [BP+2]
  5298                              <1> ; CS - word [BP+4]
  5299                              <1> ; FLAGS - word [BP+6]
  5300                              <1> .int_01:
  5301 000020CC 55                  <1> 	push	bp
  5302 000020CD 89E5                <1> 	mov	bp,sp
  5303 000020CF 817E02[8F20]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  5304 000020D4 7504                <1> 	jne	.1
  5305 000020D6 B001                <1> 	mov	al,01h			; (C) INTEL '79
  5306 000020D8 EB09                <1> 	jmp	.int_01_exit
  5307                              <1> .1:
  5308 000020DA 817E02[8E20]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  5309 000020DF 7502                <1> 	jne	.int_01_exit
  5310 000020E1 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  5311                              <1> .int_01_exit:
  5312 000020E3 5D                  <1> 	pop	bp
  5313 000020E4 CF                  <1> 	iret
  5314                              <1> 
  5315                              <1> ;=========================================================================
  5316                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  5317                              <1> ;-------------------------------------------------------------------------
  5318                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  5319                              <1> detect_fpu:
  5320 000020E5 50                  <1> 	push	ax
  5321 000020E6 51                  <1> 	push	cx
  5322 000020E7 56                  <1> 	push	si
  5323 000020E8 BE[B300]            <1> 	mov	si,msg_fpu
  5324 000020EB E82C01              <1> 	call	print
  5325 000020EE DBE3                <1> 	fninit				; initialize coprocessor
  5326 000020F0 B90300              <1> 	mov	cx,3
  5327                              <1> .wait:
  5328 000020F3 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  5329                              <1> 					;   (can't use fwait, since it could
  5330                              <1> 					;   be no coprocessor at all)
  5331 000020F5 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  5332 000020F9 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  5333 000020FF D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  5334 00002103 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  5335 00002109 750D                <1> 	jne	.no_fpu			;   after finit
  5336                              <1> 
  5337                              <1> .fpu:
  5338 0000210B BE[9301]            <1> 	mov	si,msg_fpu_present
  5339 0000210E E80901              <1> 	call	print
  5340 00002111 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  5341 00002116 EB06                <1> 	jmp	.exit
  5342                              <1> 
  5343                              <1> .no_fpu:
  5344                              <1> 
  5345 00002118 BE[9202]            <1> 	mov	si,msg_absent
  5346 0000211B E8FC00              <1> 	call	print
  5347                              <1> 
  5348                              <1> .exit:
  5349 0000211E 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  5350                              <1> 
  5351 00002122 B022                <1> 	mov	al,e_fpu_detect_ok	; FPU detection finished
  5352 00002124 E680                <1> 	out	post_reg,al
  5353                              <1> 
  5354 00002126 5E                  <1> 	pop	si
  5355 00002127 59                  <1> 	pop	cx
  5356 00002128 58                  <1> 	pop	ax
  5357 00002129 C3                  <1> 	ret
  5358                                  
  5359                                  %ifdef AT_COMPAT
  5360                                  
  5361                                  ;=========================================================================
  5362                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  5363                                  ;-------------------------------------------------------------------------
  5364                                  int_ignore2:
  5365 0000212A 50                      	push	ax
  5366 0000212B B020                    	mov	al,20h
  5367 0000212D E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5368 0000212F E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5369 00002131 58                      	pop	ax
  5370 00002132 CF                      	iret
  5371                                  
  5372                                  ;=========================================================================
  5373                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  5374                                  ;-------------------------------------------------------------------------
  5375                                  int_71:
  5376 00002133 50                      	push	ax
  5377 00002134 B020                    	mov	al,20h
  5378 00002136 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5379 00002138 58                      	pop	ax
  5380 00002139 CD0A                    	int	0Ah		; call IRQ2 ISR
  5381 0000213B CF                      	iret
  5382                                  
  5383                                  ;=========================================================================
  5384                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  5385                                  ;-------------------------------------------------------------------------
  5386                                  int_75:
  5387 0000213C 50                      	push	ax
  5388 0000213D B020                    	mov	al,20h
  5389 0000213F E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5390 00002141 E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5391 00002143 58                      	pop	ax
  5392 00002144 CD02                    	int	02h		; call NMI ISR
  5393 00002146 CF                      	iret
  5394                                  
  5395                                  %endif ; AT_COMPAT
  5396                                  
  5397                                  ;=========================================================================
  5398                                  ; extension_scan - scan for BIOS extensions
  5399                                  ; Input:
  5400                                  ;	DX - start segment
  5401                                  ;	BX - end segment
  5402                                  ; Returns:
  5403                                  ;	DX - address for the continuation of the scan
  5404                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  5405                                  ;-------------------------------------------------------------------------
  5406                                  extension_scan:
  5407 00002147 C70667000000            	mov	word [67h],0
  5408 0000214D C70669000000            	mov	word [69h],0
  5409                                  .scan:
  5410 00002153 8EC2                    	mov	es,dx
  5411 00002155 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  5412 0000215C 7532                    	jnz	.next			; no signature, check next 2 KiB
  5413 0000215E 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  5414 00002162 B400                    	mov	ah,0
  5415 00002164 B105                    	mov	cl,5
  5416 00002166 D3E0                    	shl	ax,cl			; convert size to paragraphs
  5417 00002168 01C2                    	add	dx,ax
  5418 0000216A 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  5419 0000216D 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  5420 00002170 B104                    	mov	cl,4
  5421 00002172 D3E0                    	shl	ax,cl			; convert size to bytes
  5422 00002174 89C1                    	mov	cx,ax
  5423 00002176 B000                    	mov	al,0
  5424 00002178 31F6                    	xor	si,si
  5425                                  .checksum:
  5426 0000217A 260204                      es	add	al,byte [si]
  5427 0000217D 46                      	inc	si
  5428 0000217E E2FA                    	loop	.checksum
  5429 00002180 08C0                    	or	al,al			; AL == 0?
  5430 00002182 750C                    	jnz	.next			; AL not zero - bad checksum
  5431 00002184 C70667000300            	mov	word [67h],3		; extension initialization offset
  5432 0000218A 8C066900                	mov	word [69h],es		; extension segment
  5433 0000218E EB08                    	jmp	.exit
  5434                                  .next:
  5435 00002190 81C28000                	add	dx,80h			; add 2 KiB
  5436 00002194 39DA                    	cmp	dx,bx
  5437 00002196 72BB                    	jb	.scan
  5438                                  .exit:
  5439 00002198 C3                      	ret
  5440                                  
  5441                                  ;=========================================================================
  5442                                  ; ipl - Initial Program Load - try to read and execute boot sector
  5443                                  ;-------------------------------------------------------------------------
  5444                                  ipl:
  5445 00002199 FB                      	sti
  5446 0000219A 31C0                    	xor	ax,ax
  5447 0000219C 8ED8                    	mov	ds,ax
  5448 0000219E C7067800[C76F]          	mov	word [78h],int_1E
  5449 000021A4 8C0E7A00                	mov	word [7Ah],cs
  5450                                  
  5451                                  .retry:
  5452 000021A8 B004                    	mov	al,4			; try booting from floppy 4 times
  5453                                  
  5454                                  .fd_loop:
  5455 000021AA 50                      	push	ax
  5456 000021AB B400                    	mov	ah,00h			; reset disk system
  5457 000021AD B200                    	mov	dl,00h			; drive 0
  5458 000021AF CD13                    	int	13h
  5459 000021B1 722C                    	jb	.fd_failed
  5460 000021B3 B408                    	mov	ah,08h			; get drive parameters
  5461 000021B5 B200                    	mov	dl,00h			; drive 0
  5462 000021B7 CD13                    	int	13h
  5463 000021B9 7224                    	jc	.fd_failed
  5464 000021BB 80FA00                  	cmp	dl,00h
  5465 000021BE 741F                    	jz	.fd_failed		; jump if zero drives
  5466 000021C0 B80102                  	mov	ax,0201h		; read one sector
  5467 000021C3 31D2                    	xor	dx,dx			; head 0, drive 0
  5468 000021C5 8EC2                    	mov	es,dx			; to 0000:7C00
  5469 000021C7 BB007C                  	mov	bx,7C00h
  5470 000021CA B90100                  	mov	cx,0001h		; track 0, sector 1
  5471 000021CD CD13                    	int	13h
  5472 000021CF 720E                    	jc	.fd_failed
  5473 000021D1 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5474 000021D8 7505                    	jnz	.fd_failed
  5475 000021DA EA007C0000              	jmp	0000h:7C00h
  5476                                  
  5477                                  .fd_failed:
  5478 000021DF 58                      	pop	ax
  5479 000021E0 FEC8                    	dec	al
  5480 000021E2 75C6                    	jnz	.fd_loop
  5481                                  
  5482                                  ; try booting from HDD
  5483                                  
  5484 000021E4 B40D                    	mov	ah,0Dh			; reset hard disks
  5485 000021E6 B280                    	mov	dl,80h			; drive 80h
  5486 000021E8 CD13                    	int	13h
  5487 000021EA 7222                    	jc	.hd_failed
  5488 000021EC B80102                  	mov	ax,0201h		; read one sector
  5489 000021EF BA8000                  	mov	dx,0080h		; head 0, drive 80h
  5490 000021F2 31DB                    	xor	bx,bx
  5491 000021F4 8EC3                    	mov	es,bx			; to 0000:7C00
  5492 000021F6 BB007C                  	mov	bx,7C00h
  5493 000021F9 B90100                  	mov	cx,0001h		; track 0, sector 1
  5494 000021FC CD13                    	int	13h
  5495 000021FE 720E                    	jc	.hd_failed
  5496 00002200 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5497 00002207 7505                    	jnz	.hd_failed
  5498 00002209 EA007C0000              	jmp	0000h:7C00h
  5499                                  
  5500                                  .hd_failed:
  5501 0000220E BE[7D03]                	mov	si,msg_boot_failed
  5502 00002211 E80600                  	call	print
  5503 00002214 B400                    	mov	ah,00h
  5504 00002216 CD16                    	int	16h
  5505 00002218 EB8E                    	jmp	.retry
  5506                                  
  5507                                  ;=========================================================================
  5508                                  ; print - print ASCIIZ string to the console
  5509                                  ; Input:
  5510                                  ;	CS:SI - pointer to string to print
  5511                                  ; Output:
  5512                                  ;	none
  5513                                  ;-------------------------------------------------------------------------
  5514                                  print:
  5515 0000221A 9C                      	pushf
  5516 0000221B 50                      	push	ax
  5517 0000221C 53                      	push	bx
  5518 0000221D 56                      	push	si
  5519 0000221E 1E                      	push	ds
  5520 0000221F 0E                      	push	cs
  5521 00002220 1F                      	pop	ds
  5522 00002221 FC                      	cld
  5523                                  .1:
  5524 00002222 AC                      	lodsb
  5525 00002223 08C0                    	or	al,al
  5526 00002225 7408                    	jz	.exit
  5527 00002227 B40E                    	mov	ah,0Eh
  5528 00002229 B30F                    	mov	bl,0Fh
  5529 0000222B CD10                    	int	10h
  5530 0000222D EBF3                    	jmp	.1
  5531                                  .exit:
  5532 0000222F 1F                      	pop	ds
  5533 00002230 5E                      	pop	si
  5534 00002231 5B                      	pop	bx
  5535 00002232 58                      	pop	ax
  5536 00002233 9D                      	popf
  5537 00002234 C3                      	ret
  5538                                  
  5539                                  ;=========================================================================
  5540                                  ; print_hex - print 16-bit number in hexadecimal
  5541                                  ; Input:
  5542                                  ;	AX - number to print
  5543                                  ; Output:
  5544                                  ;	none
  5545                                  ;-------------------------------------------------------------------------
  5546                                  print_hex:
  5547 00002235 51                      	push	cx
  5548 00002236 50                      	push	ax
  5549 00002237 B10C                    	mov	cl,12
  5550 00002239 D3E8                    	shr	ax,cl
  5551 0000223B E83B00                  	call	print_digit
  5552 0000223E 58                      	pop	ax
  5553 0000223F 50                      	push	ax
  5554 00002240 B108                    	mov	cl,8
  5555 00002242 D3E8                    	shr	ax,cl
  5556 00002244 E83200                  	call	print_digit
  5557 00002247 58                      	pop	ax
  5558 00002248 50                      	push	ax
  5559 00002249 B104                    	mov	cl,4
  5560 0000224B D3E8                    	shr	ax,cl
  5561 0000224D E82900                  	call	print_digit
  5562 00002250 58                      	pop	ax
  5563 00002251 50                      	push	ax
  5564 00002252 E82400                  	call	print_digit
  5565 00002255 58                      	pop	ax
  5566 00002256 59                      	pop	cx
  5567 00002257 C3                      	ret
  5568                                  
  5569                                  ;=========================================================================
  5570                                  ; print_dec - print 16-bit number in decimal
  5571                                  ; Input:
  5572                                  ;	AX - number to print
  5573                                  ; Output:
  5574                                  ;	none
  5575                                  ;-------------------------------------------------------------------------
  5576                                  print_dec:
  5577 00002258 50                      	push	ax
  5578 00002259 51                      	push	cx
  5579 0000225A 52                      	push	dx
  5580 0000225B B90A00                  	mov	cx,10		; base = 10
  5581 0000225E E80400                  	call	.print_rec
  5582 00002261 5A                      	pop	dx
  5583 00002262 59                      	pop	cx
  5584 00002263 58                      	pop	ax
  5585 00002264 C3                      	ret
  5586                                  
  5587                                  .print_rec:			; print all digits recursively
  5588 00002265 52                      	push	dx
  5589 00002266 31D2                    	xor	dx,dx		; DX = 0
  5590 00002268 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  5591 0000226A 83F800                  	cmp	ax,0
  5592 0000226D 7403                    	je	.below10
  5593 0000226F E8F3FF                  	call	.print_rec	; print number / 10 recursively
  5594                                  .below10:
  5595 00002272 89D0                    	mov	ax,dx		; reminder is in DX
  5596 00002274 E80200                  	call	print_digit	; print reminder
  5597 00002277 5A                      	pop	dx
  5598 00002278 C3                      	ret
  5599                                  
  5600                                  ;=========================================================================
  5601                                  ; print_digit - print hexadecimal digit
  5602                                  ; Input:
  5603                                  ;	AL - bits 3...0 - digit to print (0...F)
  5604                                  ; Output:
  5605                                  ;	none
  5606                                  ;-------------------------------------------------------------------------
  5607                                  print_digit:
  5608 00002279 50                      	push	ax
  5609 0000227A 53                      	push	bx
  5610 0000227B 240F                    	and	al,0Fh
  5611 0000227D 0430                    	add	al,'0'			; convert to ASCII
  5612 0000227F 3C39                    	cmp	al,'9'			; less or equal 9?
  5613 00002281 7602                    	jna	.1
  5614 00002283 0407                    	add	al,'A'-'9'-1		; a hex digit
  5615                                  .1:
  5616 00002285 B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  5617 00002287 B307                    	mov	bl,07h			; just in case we're in graphic mode
  5618 00002289 CD10                    	int	10h
  5619 0000228B 5B                      	pop	bx
  5620 0000228C 58                      	pop	ax
  5621 0000228D C3                      	ret
  5622                                  
  5623                                  ;=========================================================================
  5624                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  5625                                  ; Input:
  5626                                  ;	AX = memory size in KiB
  5627                                  ; Notes:
  5628                                  ;	- Assumes that EBDA memory was cleaned
  5629                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  5630                                  ;-------------------------------------------------------------------------
  5631                                  reserve_ebda:
  5632                                  %ifdef PS2_MOUSE
  5633 0000228E 50                      	push	ax
  5634 0000228F 51                      	push	cx
  5635 00002290 F70610000400            	test	word [equipment_list],equip_mouse
  5636 00002296 742B                    	jz	.no_mouse
  5637 00002298 A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  5638 0000229B 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  5639 0000229E A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  5640 000022A1 B106                    	mov	cl,6
  5641 000022A3 D3E0                    	shl	ax,cl			; convert to segment
  5642 000022A5 A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  5643 000022A8 1E                      	push	ds
  5644 000022A9 8ED8                    	mov	ds,ax
  5645 000022AB B80100                  	mov	ax,EBDA_SIZE
  5646 000022AE A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  5647 000022B1 1F                      	pop	ds
  5648 000022B2 56                      	push	si
  5649 000022B3 BE[3C03]                	mov	si,msg_ebda
  5650 000022B6 E861FF                  	call	print
  5651 000022B9 E89CFF                  	call	print_dec
  5652 000022BC BE[7603]                	mov	si,msg_kib
  5653 000022BF E858FF                  	call	print
  5654 000022C2 5E                      	pop	si
  5655                                  .no_mouse:
  5656 000022C3 59                      	pop	cx
  5657 000022C4 58                      	pop	ax
  5658                                  %endif ; PS2_MOUSE
  5659 000022C5 C3                      	ret
  5660                                  
  5661                                  ;=========================================================================
  5662                                  ; detect_ram - Determine the size of installed RAM and test it
  5663                                  ; Input:
  5664                                  ;	none
  5665                                  ; Output:
  5666                                  ;	AX = RAM size
  5667                                  ;	CX, SI - trashed
  5668                                  ;-------------------------------------------------------------------------
  5669                                  detect_ram:
  5670 000022C6 B030                    	mov	al,e_ram_start		; RAM scan start
  5671 000022C8 E680                    	out	post_reg,al
  5672                                  
  5673 000022CA 1E                      	push	ds
  5674 000022CB B106                    	mov	cl,6			; for SHL - converting KiB to segment
  5675 000022CD B82000                  	mov	ax,MIN_RAM_SIZE
  5676                                  
  5677                                  .fill_loop:
  5678 000022D0 50                      	push	ax
  5679 000022D1 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  5680 000022D3 8ED8                    	mov	ds,ax
  5681 000022D5 A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  5682 000022D8 58                      	pop	ax
  5683 000022D9 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  5684 000022DC 3D8002                  	cmp	ax,MAX_RAM_SIZE
  5685 000022DF 75EF                    	jne	.fill_loop
  5686 000022E1 B82000                  	mov	ax,MIN_RAM_SIZE
  5687                                  
  5688                                  .size_loop:
  5689 000022E4 50                      	push	ax
  5690 000022E5 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  5691 000022E7 8ED8                    	mov	ds,ax
  5692 000022E9 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  5693 000022ED 750B                    	jne	.size_done
  5694 000022EF 58                      	pop	ax
  5695 000022F0 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  5696 000022F3 3D8002                  	cmp	ax,MAX_RAM_SIZE
  5697 000022F6 7303                    	jnb	.size_exit
  5698 000022F8 EBEA                    	jmp	.size_loop
  5699                                  
  5700                                  .size_done:
  5701 000022FA 58                      	pop	ax
  5702                                  
  5703                                  .size_exit:
  5704 000022FB 1F                      	pop	ds
  5705 000022FC A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  5706                                  
  5707                                  ; AX = detected memory size, now test the RAM
  5708                                  
  5709 000022FF 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  5710 00002305 7474                    	je	.test_done
  5711                                  
  5712 00002307 BE[DD02]                	mov	si,msg_ram_testing
  5713 0000230A E80DFF                  	call	print
  5714 0000230D B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  5715                                  
  5716                                  .test_loop:
  5717 00002310 50                      	push	ax
  5718 00002311 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  5719 00002313 B700                    	mov	bh,00h			; page 0
  5720 00002315 CD10                    	int	10h			; position returned in DX
  5721 00002317 58                      	pop	ax
  5722 00002318 E83DFF                  	call	print_dec
  5723 0000231B 50                      	push	ax
  5724 0000231C B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  5725 0000231E B700                    	mov	bh,00h			; page 0
  5726 00002320 CD10                    	int	10h
  5727 00002322 B401                    	mov	ah,01h
  5728 00002324 CD16                    	int	16h
  5729 00002326 7412                    	jz	.test_no_key
  5730 00002328 B400                    	mov	ah,00h
  5731 0000232A CD16                    	int	16h			; read the keystroke
  5732 0000232C 3C1B                    	cmp	al,1Bh			; ESC?
  5733 0000232E 7421                    	je	.test_esc
  5734 00002330 3D003B                  	cmp	ax,3B00h		; F1?
  5735 00002333 7505                    	jne	.test_no_key
  5736 00002335 800E120001              	or	byte [post_flags],post_setup
  5737                                  
  5738                                  .test_no_key:
  5739 0000233A 58                      	pop	ax
  5740 0000233B E83E00                  	call	ram_test_block
  5741 0000233E 721D                    	jc	.test_error		; error in last test
  5742 00002340 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  5743 00002343 3B061300                	cmp	ax,word [memory_size]
  5744 00002347 72C7                    	jb	.test_loop
  5745                                  
  5746 00002349 50                      	push	ax
  5747 0000234A B031                    	mov	al,e_ram_complete	; RAM scan complete
  5748 0000234C E680                    	out	post_reg,al
  5749 0000234E 58                      	pop	ax
  5750                                  
  5751 0000234F EB2A                    	jmp	.test_done
  5752                                  
  5753                                  .test_esc:
  5754 00002351 58                      	pop	ax
  5755 00002352 A11300                  	mov	ax,word [memory_size]
  5756                                  
  5757 00002355 50                      	push	ax
  5758 00002356 B032                    	mov	al,e_ram_esc		; RAM scan canceled
  5759 00002358 E680                    	out	post_reg,al
  5760 0000235A 58                      	pop	ax
  5761                                  
  5762 0000235B EB1E                    	jmp	.test_done
  5763                                  
  5764                                  .test_error:
  5765 0000235D A31300                  	mov	word [memory_size],ax	; store size of good memory
  5766 00002360 BE[FA02]                	mov	si,msg_ram_error
  5767 00002363 E8B4FE                  	call	print
  5768 00002366 E8EFFE                  	call	print_dec
  5769 00002369 BE[7603]                	mov	si,msg_kib
  5770 0000236C E8ABFE                  	call	print
  5771 0000236F BE[8800]                	mov	si,msg_crlf
  5772 00002372 E8A5FE                  	call	print
  5773                                  
  5774 00002375 50                      	push	ax
  5775 00002376 B080                    	mov	al,e_ram_fail		; RAM scan failed
  5776 00002378 E680                    	out	post_reg,al
  5777 0000237A 58                      	pop	ax
  5778                                  
  5779                                  .test_done:
  5780 0000237B C3                      	ret
  5781                                  
  5782                                  ;=========================================================================
  5783                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  5784                                  ; Input:
  5785                                  ;	AX = address of the memory to test (in KiB)
  5786                                  ; Output:
  5787                                  ;	CF = status
  5788                                  ;		0 = passed
  5789                                  ;		1 = failed
  5790                                  ;-------------------------------------------------------------------------
  5791                                  ram_test_block:
  5792 0000237C 50                      	push	ax
  5793 0000237D 53                      	push	bx
  5794 0000237E 51                      	push	cx
  5795 0000237F 56                      	push	si
  5796 00002380 57                      	push	di
  5797 00002381 1E                      	push	ds
  5798 00002382 06                      	push	es
  5799 00002383 B106                    	mov	cl,6			; convert KiB to segment address
  5800 00002385 D3E0                    	shl	ax,cl			; (multiply by 64)
  5801 00002387 8ED8                    	mov	ds,ax
  5802 00002389 8EC0                    	mov	es,ax
  5803 0000238B 31F6                    	xor	si,si
  5804 0000238D 31FF                    	xor	di,di
  5805 0000238F BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  5806 00002392 B8AA55                  	mov	ax,55AAh		; first test pattern
  5807 00002395 89D9                    	mov	cx,bx
  5808 00002397 F3AB                        rep	stosw				; store test pattern
  5809 00002399 89D9                    	mov	cx,bx			; RAM test block size
  5810                                  .1:
  5811 0000239B AD                      	lodsw
  5812 0000239C 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  5813 0000239F 7522                    	jne	.fail
  5814 000023A1 E2F8                    	loop	.1
  5815 000023A3 31F6                    	xor	si,si
  5816 000023A5 31FF                    	xor	di,di
  5817 000023A7 B855AA                  	mov	ax,0AA55h		; second test pattern
  5818 000023AA 89D9                    	mov	cx,bx			; RAM test block size
  5819 000023AC F3AB                        rep stosw				; store test pattern
  5820 000023AE 89D9                    	mov	cx,bx			; RAM test block size
  5821                                  .2:
  5822 000023B0 AD                      	lodsw
  5823 000023B1 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  5824 000023B4 750D                    	jne	.fail
  5825 000023B6 E2F8                    	loop	.2
  5826 000023B8 31FF                    	xor	di,di
  5827 000023BA 31C0                    	xor	ax,ax			; zero
  5828 000023BC 89D9                    	mov	cx,bx			; RAM test block size
  5829 000023BE F3AB                        rep stosw				; zero the memory
  5830 000023C0 F8                      	clc				; test passed, clear CF
  5831 000023C1 EB01                    	jmp	.exit
  5832                                  
  5833                                  .fail:
  5834 000023C3 F9                      	stc				; test failed, set CF
  5835                                  	
  5836                                  .exit:
  5837 000023C4 07                      	pop	es
  5838 000023C5 1F                      	pop	ds
  5839 000023C6 5F                      	pop	di
  5840 000023C7 5E                      	pop	si
  5841 000023C8 59                      	pop	cx
  5842 000023C9 5B                      	pop	bx
  5843 000023CA 58                      	pop	ax
  5844 000023CB C3                      	ret
  5845                                  
  5846                                  ;=========================================================================
  5847                                  ; print display type
  5848                                  ;-------------------------------------------------------------------------
  5849                                  print_display:
  5850 000023CC BE[A001]                	mov	si,msg_disp
  5851 000023CF E848FE                  	call	print
  5852 000023D2 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  5853 000023D5 2430                    	and	al,equip_video		; get video adapter type
  5854 000023D7 BE[E201]                	mov	si,msg_disp_mda
  5855 000023DA 3C30                    	cmp	al,equip_mono		; monochrome?
  5856 000023DC 740A                    	jz	.print_disp
  5857 000023DE BE[DC01]                	mov	si,msg_disp_cga
  5858 000023E1 3C20                    	cmp	al,equip_color		; CGA?
  5859 000023E3 7403                    	jz	.print_disp
  5860 000023E5 BE[BD01]                	mov	si,msg_disp_ega		; otherwise EGA or later
  5861                                  .print_disp:
  5862 000023E8 E82FFE                  	call	print
  5863 000023EB C3                      	ret
  5864                                  
  5865                                  ;=========================================================================
  5866                                  ; print PS/2 mouse presence
  5867                                  ;-------------------------------------------------------------------------
  5868                                  
  5869                                  print_mouse:
  5870 000023EC BE[6B02]                	mov	si,msg_mouse
  5871 000023EF E828FE                  	call	print
  5872 000023F2 BE[9202]                	mov	si,msg_absent
  5873 000023F5 F606100004              	test	byte [equipment_list],equip_mouse
  5874 000023FA 7403                    	jz	.print_mouse
  5875 000023FC BE[8802]                	mov	si,msg_present
  5876                                  .print_mouse:
  5877 000023FF E818FE                  	call	print
  5878 00002402 C3                      	ret
  5879                                  
  5880                                  ;=========================================================================
  5881                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  5882                                  ;-------------------------------------------------------------------------
  5883                                  
  5884                                  detect_rom_ext:
  5885 00002403 B040                    	mov	al,e_ext_start		; ROM extension scan start
  5886 00002405 E680                    	out	post_reg,al
  5887                                  
  5888 00002407 BA00C8                  	mov	dx,0C800h
  5889 0000240A BB00F8                  	mov	bx,0F800h
  5890                                  
  5891                                  .ext_scan_loop:
  5892 0000240D E837FD                  	call	extension_scan
  5893 00002410 833E670000              	cmp	word [67h],0
  5894 00002415 7429                    	jz	.ext_scan_done		; No ROM extension found
  5895 00002417 B041                    	mov	al,e_ext_detect		; ROM extension found
  5896 00002419 E680                    	out	post_reg,al
  5897 0000241B BE[B903]                	mov	si,msg_rom_found
  5898 0000241E E8F9FD                  	call	print
  5899 00002421 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  5900 00002424 E80EFE                  	call	print_hex
  5901 00002427 BE[D603]                	mov	si,msg_rom_init
  5902 0000242A E8EDFD                  	call	print
  5903 0000242D 53                      	push	bx
  5904 0000242E 52                      	push	dx
  5905 0000242F FF1E6700                	call	far [67h]
  5906 00002433 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  5907 00002436 8ED8                    	mov	ds,ax
  5908 00002438 B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  5909 0000243A E680                    	out	post_reg,al
  5910 0000243C 5A                      	pop	dx
  5911 0000243D 5B                      	pop	bx
  5912 0000243E EBCD                    	jmp	.ext_scan_loop
  5913                                  
  5914                                  .ext_scan_done:
  5915 00002440 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  5916 00002442 E680                    	out	post_reg,al
  5917                                  
  5918 00002444 C3                      	ret
  5919                                  
  5920                                  ;=========================================================================	
  5921                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  5922                                  ;-------------------------------------------------------------------------
  5923                                  interrupt_table:
  5924 00002445 [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
  5925 00002447 [537F]                  	dw	int_dummy		; INT 01 - Single step
  5926 00002449 [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  5927 0000244B [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  5928 0000244D [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  5929 0000244F [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
  5930 00002451 [537F]                  	dw	int_dummy		; INT 06
  5931 00002453 [537F]                  	dw	int_dummy		; INT 07
  5932 00002455 [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  5933 00002457 [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  5934 00002459 [237F]                  	dw	int_ignore		; INT 0A - IRQ2
  5935 0000245B [237F]                  	dw	int_ignore		; INT 0B - IRQ3
  5936 0000245D [237F]                  	dw	int_ignore		; INT 0C - IRQ4
  5937 0000245F [237F]                  	dw	int_ignore		; INT 0D - IRQ5
  5938 00002461 [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  5939 00002463 [237F]                  	dw	int_ignore		; INT 0F - IRQ7
  5940 00002465 [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
  5941 00002467 [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  5942 00002469 [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  5943 0000246B [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  5944 0000246D [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  5945 0000246F [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  5946 00002471 [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  5947 00002473 [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  5948 00002475 [4D63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  5949 00002477 [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  5950 00002479 [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
  5951 0000247B [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  5952 0000247D [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
  5953 0000247F [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
  5954 00002481 [C76F]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  5955 00002483 [0A06]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  5956                                  
  5957                                  interrupt_table2:
  5958 00002485 [A50D]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  5959 00002487 [3321]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  5960 00002489 [2A21]                  	dw	int_ignore2		; INT 72 - IRQ10
  5961 0000248B [2A21]                  	dw	int_ignore2		; INT 73 - IRQ11
  5962                                  %ifndef PS2_MOUSE
  5963                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  5964                                  %else
  5965 0000248D [771F]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  5966                                  %endif
  5967 0000248F [3C21]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  5968 00002491 [2A21]                  	dw	int_ignore2		; INT 76 - IRQ14
  5969 00002493 [2A21]                  	dw	int_ignore2		; INT 77 - IRQ15
  5970                                  
  5971                                  ;=========================================================================
  5972                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  5973                                  ;-------------------------------------------------------------------------	
  5974 00002495 FF<rept>                	setloc	0E05Bh		; POST Entry Point
  5975          ******************       warning: (setloc:7) Inserting 15302 bytes
  5976                                  cold_start:
  5977 0000605B B84000                  	mov	ax,biosdseg
  5978 0000605E 8ED8                    	mov	ds,ax
  5979 00006060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  5980                                  
  5981                                  warm_start:
  5982 00006066 FA                      	cli				; disable interrupts
  5983 00006067 FC                      	cld				; clear direction flag
  5984 00006068 B001                    	mov	al,e_start
  5985 0000606A E680                    	out	post_reg,al		; POST start code
  5986                                  
  5987                                  ;-------------------------------------------------------------------------
  5988                                  ; test CPU's FLAG register
  5989                                  
  5990 0000606C 31C0                    	xor	ax,ax			; AX = 0
  5991 0000606E 724A                    	jb	cpu_fail
  5992 00006070 7048                    	jo	cpu_fail
  5993 00006072 7846                    	js	cpu_fail
  5994 00006074 7544                    	jnz	cpu_fail
  5995 00006076 7B42                    	jpo	cpu_fail
  5996 00006078 83C001                  	add	ax,1			; AX = 1
  5997 0000607B 743D                    	jz	cpu_fail
  5998 0000607D 7A3B                    	jpe	cpu_fail
  5999 0000607F 2D0280                  	sub	ax,8002h
  6000 00006082 7836                    	js	cpu_fail
  6001 00006084 40                      	inc	ax
  6002 00006085 7133                    	jno	cpu_fail
  6003 00006087 D1E0                    	shl	ax,1
  6004 00006089 732F                    	jnb	cpu_fail
  6005 0000608B 752D                    	jnz	cpu_fail
  6006 0000608D D1E0                    	shl	ax,1
  6007 0000608F 7229                    	jb	cpu_fail
  6008                                  
  6009                                  ;-------------------------------------------------------------------------
  6010                                  ; Test CPU registers
  6011                                  
  6012 00006091 B8AAAA                  	mov	ax,0AAAAh
  6013                                  .1:
  6014 00006094 8ED8                    	mov	ds,ax
  6015 00006096 8CDB                    	mov	bx,ds
  6016 00006098 8EC3                    	mov	es,bx
  6017 0000609A 8CC1                    	mov	cx,es
  6018 0000609C 8ED1                    	mov	ss,cx
  6019 0000609E 8CD2                    	mov	dx,ss
  6020 000060A0 89D5                    	mov	bp,dx
  6021 000060A2 89EC                    	mov	sp,bp
  6022 000060A4 89E6                    	mov	si,sp
  6023 000060A6 89F7                    	mov	di,si
  6024 000060A8 81FFAAAA                	cmp	di,0AAAAh
  6025 000060AC 7506                    	jnz	.2
  6026 000060AE 89F8                    	mov	ax,di
  6027 000060B0 F7D0                    	not	ax
  6028 000060B2 EBE0                    	jmp	.1
  6029                                  .2:
  6030 000060B4 81FF5555                	cmp	di,5555h
  6031 000060B8 741A                    	jz	cpu_ok
  6032                                  
  6033                                  cpu_fail:
  6034 000060BA B052                    	mov	al,e_cpu_fail
  6035 000060BC E680                    	out	post_reg,al
  6036                                  
  6037                                  ;-------------------------------------------------------------------------
  6038                                  ; CPU error: continious beep - 400 Hz
  6039                                  
  6040 000060BE B0B6                    	mov	al,0B6h
  6041 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6042 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6043 000060C5 E642                    	out	pit_ch2_reg,al
  6044 000060C7 88E0                    	mov	al,ah
  6045 000060C9 E642                    	out	pit_ch2_reg,al
  6046 000060CB E461                    	in	al,port_b_reg
  6047 000060CD 0C03                    	or	al,3			; turn speaker on and enable
  6048 000060CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6049                                  
  6050                                  .1:
  6051 000060D1 F4                      	hlt
  6052 000060D2 EBFD                    	jmp	.1
  6053                                  
  6054                                  ;-------------------------------------------------------------------------
  6055                                  ; CPU test passed
  6056                                  
  6057                                  cpu_ok:
  6058 000060D4 B002                    	mov	al,e_cpu_ok
  6059 000060D6 E680                    	out	post_reg,al
  6060                                  
  6061                                  ;-------------------------------------------------------------------------
  6062                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  6063                                  
  6064 000060D8 B00D                    	mov	al,0Dh & nmi_disable
  6065 000060DA E670                    	out	rtc_addr_reg,al		; disable NMI
  6066 000060DC EB00                    	jmp	$+2
  6067 000060DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  6068                                  
  6069 000060E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  6070 000060E2 E661                    	out	port_b_reg,al
  6071 000060E4 B000                    	mov	al,00h			; clear turbo bit
  6072 000060E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  6073                                  
  6074 000060E8 BAD803                  	mov	dx,cga_mode_reg
  6075 000060EB EE                      	out	dx,al			; disable video output on CGA
  6076 000060EC FEC0                    	inc	al
  6077 000060EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  6078 000060F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  6079                                  
  6080                                  ;-------------------------------------------------------------------------
  6081                                  ; Initialize DMAC (8237)
  6082                                   
  6083 000060F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  6084 000060F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  6085 000060F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6086 000060F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  6087 000060FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6088 000060FC B042                     	mov	al,42h			; single mode, verify, channel 2
  6089 000060FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6090 00006100 B043                     	mov	al,43h			; single mode, verify, channel 3
  6091 00006102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6092 00006104 B000                     	mov	al,0			; DMA Command register bits:
  6093                                   					; DACK active low, DREQ active high,
  6094                                   					; late write, fixed priority,
  6095                                   					; normal timing, controller enable
  6096                                   					; channel 0 addr hold disable
  6097                                   					; memory to memory disable
  6098 00006106 E608                     	out	08h,al			; DMA Command register
  6099 00006108 E681                     	out	81h,al			; DMA Page, channel 2
  6100 0000610A E682                     	out	82h,al			; DMA Page, channel 3
  6101 0000610C E683                     	out	83h,al			; DMA Page, channels 0,1
  6102 0000610E B003                    	mov	al,e_dmac_ok
  6103 00006110 E680                    	out	post_reg,al
  6104                                  
  6105                                  ;-------------------------------------------------------------------------
  6106                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  6107                                  
  6108                                  low_ram_test:
  6109 00006112 31F6                    	xor	si,si
  6110 00006114 31FF                    	xor	di,di
  6111 00006116 8EDF                    	mov	ds,di
  6112 00006118 8EC7                    	mov	es,di
  6113 0000611A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  6114 0000611E B8AA55                  	mov	ax,55AAh		; first test pattern
  6115 00006121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6116 00006124 F3AB                        rep	stosw				; store test pattern
  6117 00006126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6118                                  .1:
  6119 00006129 AD                      	lodsw
  6120 0000612A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6121 0000612D 7524                    	jne	low_ram_fail
  6122 0000612F E2F8                    	loop	.1
  6123 00006131 31F6                    	xor	si,si
  6124 00006133 31FF                    	xor	di,di
  6125 00006135 B855AA                  	mov	ax,0AA55h		; second test pattern
  6126 00006138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6127 0000613B F3AB                        rep stosw				; store test pattern
  6128 0000613D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6129                                  .2:
  6130 00006140 AD                      	lodsw
  6131 00006141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6132 00006144 750D                    	jne	low_ram_fail
  6133 00006146 E2F8                    	loop	.2
  6134 00006148 31FF                    	xor	di,di
  6135 0000614A 31C0                    	xor	ax,ax			; zero
  6136 0000614C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6137 0000614F F3AB                        rep stosw				; zero the memory
  6138 00006151 EB29                    	jmp	low_ram_ok		; test passed
  6139                                  
  6140                                  low_ram_fail:
  6141 00006153 B054                    	mov	al,e_low_ram_fail	; test failed
  6142 00006155 E680                    	out	post_reg,al
  6143                                  
  6144                                  ;-------------------------------------------------------------------------
  6145                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  6146                                  
  6147 00006157 B0B6                    	mov	al,0B6h
  6148 00006159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6149 0000615B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6150 0000615E E642                    	out	pit_ch2_reg,al
  6151 00006160 88E0                    	mov	al,ah
  6152 00006162 E642                    	out	pit_ch2_reg,al
  6153 00006164 E461                    	in	al,port_b_reg
  6154                                  .1:
  6155 00006166 0C03                    	or	al,3			; turn speaker on and enable
  6156 00006168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6157 0000616A B90000                  	mov	cx,0
  6158                                  .2:
  6159 0000616D 90                      	nop
  6160 0000616E E2FD                    	loop	.2
  6161 00006170 24FC                    	and	al,0FCh			; turn of speaker
  6162 00006172 E661                    	out	port_b_reg,al
  6163 00006174 B90000                  	mov	cx,0
  6164                                  .3:
  6165 00006177 90                      	nop
  6166 00006178 E2FD                    	loop	.3
  6167 0000617A EBEA                    	jmp	.1
  6168                                  
  6169                                  ;-------------------------------------------------------------------------
  6170                                  ; Low memory test passed
  6171                                  
  6172                                  low_ram_ok:
  6173 0000617C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  6174 00006180 B004                    	mov	al,e_low_ram_ok
  6175 00006182 E680                    	out	post_reg,al
  6176                                  
  6177                                  ;-------------------------------------------------------------------------
  6178                                  ; Set up stack - using upper 256 bytes of interrupt table
  6179                                  
  6180 00006184 B83000                  	mov	ax,0030h
  6181 00006187 8ED0                    	mov	ss,ax
  6182 00006189 BC0001                  	mov	sp,0100h
  6183                                  
  6184                                  ;-------------------------------------------------------------------------
  6185                                  ; Initialize interrupt table
  6186                                  
  6187 0000618C 0E                      	push	cs
  6188 0000618D 1F                      	pop	ds
  6189 0000618E 31FF                    	xor	di,di
  6190 00006190 8EC7                    	mov	es,di
  6191 00006192 BE[4524]                	mov	si,interrupt_table
  6192 00006195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  6193 00006198 B800F0                  	mov	ax,bioscseg
  6194                                  .1:
  6195 0000619B A5                      	movsw				; copy ISR address (offset part)
  6196 0000619C AB                      	stosw				; store segment part
  6197 0000619D E2FC                    	loop	.1
  6198                                  %ifdef AT_COMPAT
  6199 0000619F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  6200 000061A2 BE[8524]                	mov	si,interrupt_table2
  6201 000061A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  6202                                  .2:
  6203 000061A8 A5                      	movsw				; copy ISR address (offset part)
  6204 000061A9 AB                      	stosw				; store segment part
  6205 000061AA E2FC                    	loop	.2
  6206                                  %endif ; AT_COMPAT
  6207 000061AC B005                    	mov     al,e_int_ok
  6208 000061AE E680                    	out	post_reg,al
  6209                                  
  6210                                  ;-------------------------------------------------------------------------
  6211                                  ; set DS to BIOS data area
  6212                                  
  6213 000061B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6214 000061B3 8ED8                    	mov	ds,ax
  6215                                  
  6216                                  ;-------------------------------------------------------------------------
  6217                                  ; Initialize PIT (8254 timer)
  6218                                  
  6219 000061B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  6220 000061B7 E643                    	out	pit_ctl_reg,al
  6221 000061B9 B000                    	mov	al,0
  6222 000061BB E640                    	out	pit_ch0_reg,al
  6223 000061BD E640                    	out	pit_ch0_reg,al
  6224 000061BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  6225 000061C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  6226 000061C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  6227 000061C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  6228 000061C7 B040                    	mov	al,40h			; XXX timer latch
  6229 000061C9 E643                    	out	pit_ctl_reg,al
  6230                                  
  6231                                  ;-------------------------------------------------------------------------
  6232                                  ; Play "power on" sound - also tests PIT functionality
  6233 000061CB E838BE                  	call	sound
  6234                                  
  6235 000061CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  6236 000061D0 E680                    	out	post_reg,al
  6237                                  
  6238                                  ;-------------------------------------------------------------------------
  6239                                  ; Initialize PIC (8259)
  6240                                  
  6241                                  %ifdef AT_COMPAT
  6242 000061D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  6243 000061D4 E620                    	out	pic1_reg0,al
  6244 000061D6 E6A0                    	out	pic2_reg0,al
  6245 000061D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  6246 000061DA E621                    	out	pic1_reg1,al
  6247 000061DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  6248 000061DE E6A1                    	out	pic2_reg1,al
  6249 000061E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  6250 000061E2 E621                    	out	pic1_reg1,al
  6251 000061E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  6252 000061E6 E6A1                    	out	pic2_reg1,al
  6253 000061E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  6254 000061EA E621                    	out	pic1_reg1,al
  6255 000061EC E6A1                    	out	pic2_reg1,al
  6256                                  %else
  6257                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  6258                                  	out	pic1_reg0,al
  6259                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  6260                                  	out	pic1_reg1,al
  6261                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  6262                                  	out	pic1_reg1,al
  6263                                  	mov	al,e_pic_ok
  6264                                  	out	post_reg,al
  6265                                  %endif ; AT_COMPAT
  6266                                  
  6267                                  ;-------------------------------------------------------------------------
  6268                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  6269                                  
  6270 000061EE E8F1B4                  	call	kbc_init
  6271                                  
  6272                                  ;-------------------------------------------------------------------------
  6273                                  ; enable interrupts
  6274                                  
  6275                                  %ifdef AT_COMPAT
  6276 000061F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  6277 000061F3 E621                    	out	pic1_reg1,al
  6278                                  %ifndef PS2_MOUSE
  6279                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  6280                                  %else
  6281 000061F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  6282                                  %endif ; PS2_MOUSE
  6283 000061F7 E6A1                    	out	pic2_reg1,al
  6284                                  %else
  6285                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  6286                                  	out	pic1_reg1,al
  6287                                  %endif ; AT_COMPAT
  6288 000061F9 FB                      	sti
  6289                                  
  6290                                  ;-------------------------------------------------------------------------
  6291                                  ; look for video BIOS, initialize it if present
  6292                                  
  6293 000061FA BA00C0                  	mov	dx,0C000h
  6294 000061FD BB00C8                  	mov	bx,0C800h
  6295 00006200 E844BF                  	call	extension_scan
  6296 00006203 833E670000              	cmp	word [67h],0
  6297 00006208 7418                    	jz	.no_video_bios
  6298 0000620A B011                    	mov	al,e_video_bios_ok
  6299 0000620C E680                    	out	post_reg,al
  6300 0000620E FF1E6700                	call	far [67h]
  6301 00006212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6302 00006215 8ED8                    	mov	ds,ax
  6303 00006217 B012                    	mov	al,e_video_init_ok
  6304 00006219 E680                    	out	post_reg,al
  6305                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  6306 0000621B 83261000CF              	and	word [equipment_list],~equip_video
  6307 00006220 EB14                    	jmp	.video_initialized
  6308                                  
  6309                                  .no_video_bios:
  6310 00006222 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  6311 00006226 80E430                  	and	ah,equip_video		; get video adapter type
  6312 00006229 B007                    	mov	al,07h			; monochrome 80x25 mode
  6313 0000622B 80FC30                  	cmp	ah,equip_mono		; monochrome?
  6314 0000622E 7402                    	jz	.set_mode
  6315 00006230 B003                    	mov	al,03h			; color 80x25 mode
  6316                                  
  6317                                  .set_mode:
  6318 00006232 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  6319 00006234 CD10                    	int	10h
  6320                                  
  6321                                  .video_initialized:
  6322                                  
  6323                                  ;-------------------------------------------------------------------------
  6324                                  ; print the copyright message
  6325                                  
  6326 00006236 BE[0000]                	mov	si,msg_copyright
  6327 00006239 E8DEBF                  	call	print
  6328                                  
  6329                                  ;-------------------------------------------------------------------------
  6330                                  ; Initialize RTC / NVRAM
  6331                                  
  6332 0000623C E8E5A7                  	call	rtc_init
  6333                                  
  6334                                  ; read equipment byte from CMOS and set it in BIOS data area
  6335                                  
  6336 0000623F BE[5B04]                	mov	si,msg_setup
  6337 00006242 E8D5BF                  	call	print
  6338                                  
  6339                                  ;-------------------------------------------------------------------------
  6340                                  ; detect and print availability of various equipment
  6341                                  
  6342 00006245 E814BE                  	call	detect_cpu		; detect and print CPU type
  6343 00006248 E89ABE                  	call	detect_fpu		; detect and print FPU presence
  6344                                  
  6345 0000624B E87EC1                  	call	print_display		; print display type
  6346 0000624E E89BC1                  	call	print_mouse		; print mouse presence
  6347                                  
  6348 00006251 E827BA                  	call	detect_serial		; detect serial ports and print findings
  6349 00006254 E8D4BA                  	call	detect_parallel		; detect parallel ports and print
  6350                                  					; findings
  6351                                  
  6352 00006257 B010                    	mov	al,cmos_floppy
  6353 00006259 E8AEA7                  	call	rtc_read		; floppies type to AL
  6354 0000625C E825B3                  	call	print_floppy		; print floppy drive types
  6355                                  
  6356 0000625F E864C0                  	call	detect_ram		; test RAM, get RAM size in AX
  6357                                  
  6358 00006262 BE[1E03]                	mov	si,msg_ram_total
  6359 00006265 E8B2BF                  	call	print
  6360 00006268 E8EDBF                  	call	print_dec		; print RAM size
  6361 0000626B BE[7603]                	mov	si,msg_kib
  6362 0000626E E8A9BF                  	call	print
  6363                                  
  6364 00006271 E81AC0                  	call	reserve_ebda		; reserve EBDA if needed
  6365                                  
  6366 00006274 BE[5903]                	mov	si,msg_ram_avail
  6367 00006277 E8A0BF                  	call	print
  6368 0000627A A11300                  	mov	ax,word [memory_size]
  6369 0000627D E8D8BF                  	call	print_dec		; print remaining RAM size
  6370 00006280 BE[7603]                	mov	si,msg_kib
  6371 00006283 E894BF                  	call	print
  6372                                  
  6373 00006286 E87AC1                  	call	detect_rom_ext		; detect and initialize extension ROMs
  6374                                  
  6375                                  ;-------------------------------------------------------------------------
  6376                                  ; Check for F1 (setup key), run setup utility if pressed
  6377                                  
  6378 00006289 B401                    	mov	ah,01h
  6379 0000628B CD16                    	int	16h
  6380 0000628D 740E                    	jz	.no_key
  6381 0000628F B400                    	mov	ah,00h
  6382 00006291 CD16                    	int	16h			; read the keystroke
  6383 00006293 3D003B                  	cmp	ax,3B00h		; F1?
  6384 00006296 7505                    	jne	.no_key
  6385 00006298 800E120001              	or	byte [post_flags],post_setup
  6386                                  .no_key:
  6387                                  
  6388 0000629D F606120001              	test	byte [post_flags],post_setup
  6389 000062A2 7403                    	jz	.no_setup
  6390 000062A4 E898A8                  	call	rtc_setup
  6391                                  
  6392                                  .no_setup:
  6393                                  
  6394                                  ;-------------------------------------------------------------------------
  6395                                  ; boot the OS
  6396                                  
  6397 000062A7 B049                    	mov	al,e_boot		; boot the OS POST code
  6398 000062A9 E680                    	out	post_reg,al
  6399                                  
  6400 000062AB BE[EB03]                	mov	si,msg_boot
  6401 000062AE E869BF                  	call	print
  6402 000062B1 CD19                    	int	19h			; boot the OS
  6403                                  
  6404                                  ;=========================================================================
  6405                                  ; int_02 - NMI
  6406                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  6407                                  ;	implemented
  6408                                  ;-------------------------------------------------------------------------
  6409 000062B3 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  6410          ******************       warning: (setloc:7) Inserting 16 bytes
  6411                                  int_02:
  6412 000062C3 50                      	push	ax
  6413 000062C4 B00D                    	mov	al,0Dh & nmi_disable
  6414 000062C6 E841A7                  	call	rtc_read		; disable NMI
  6415 000062C9 E461                    	in	al,port_b_reg		; read Port B
  6416 000062CB 88C4                    	mov	ah,al
  6417 000062CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  6418 000062CF E661                    	out	port_b_reg,al
  6419 000062D1 A840                    	test	al,iochk_status
  6420 000062D3 7506                    	jnz	.iochk_nmi
  6421 000062D5 88E0                    	mov	al,ah
  6422 000062D7 E661                    	out	port_b_reg,al		; restore original bits
  6423 000062D9 EB24                    	jmp	.exit
  6424                                  
  6425                                  .iochk_nmi:
  6426 000062DB 56                      	push	si
  6427 000062DC BE[0663]                	mov	si,msg_iochk_nmi
  6428 000062DF E838BF                  	call	print
  6429 000062E2 5E                      	pop	si
  6430                                  .1:
  6431 000062E3 B400                    	mov	ah,0h
  6432 000062E5 CD16                    	int	16h
  6433 000062E7 3C69                    	cmp	al,'i'			; exit from NMI
  6434 000062E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  6435 000062EB 3C49                    	cmp	al,'I'
  6436 000062ED 7410                    	je	.exit
  6437 000062EF 3C72                    	cmp	al,'r'
  6438 000062F1 7503E965FD              	je	cold_start
  6439 000062F6 3C52                    	cmp	al,'R'
  6440 000062F8 7503E95EFD              	je	cold_start
  6441 000062FD EBE4                    	jmp	.1
  6442                                  .exit:
  6443 000062FF B08D                    	mov	al,0Dh | nmi_enable
  6444 00006301 E806A7                  	call	rtc_read		; enable NMI
  6445 00006304 58                      	pop	ax
  6446 00006305 CF                      	iret
  6447                                  
  6448                                  msg_iochk_nmi:
  6449 00006306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  6450 0000630F 206465746563746564-
  6451 00006318 2E2054797065202769-
  6452 00006321 2720746F2069676E6F-
  6453 0000632A 726520494F43484B20-
  6454 00006333 4E4D49732C206F7220-
  6455 0000633C 27722720746F207265-
  6456 00006345 626F6F742E         
  6457 0000634A 0D0A00                  	db	0Dh, 0Ah, 00h
  6458                                  
  6459                                  ;=========================================================================
  6460                                  ; int_18 - execute ROM BASIC
  6461                                  ; Note:
  6462                                  ;	Prints an error message since we don't have ROM BASIC
  6463                                  ;-------------------------------------------------------------------------
  6464                                  int_18:
  6465 0000634D BE[AA03]                	mov	si,msg_no_basic
  6466 00006350 E8C7BE                  	call	print
  6467                                  .1:
  6468 00006353 F4                      	hlt
  6469 00006354 EBFD                    	jmp	.1
  6470                                  
  6471                                  ;=========================================================================
  6472                                  ; int_19 - load and execute the boot sector
  6473                                  ;-------------------------------------------------------------------------
  6474 00006356 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  6475          ******************       warning: (setloc:7) Inserting 924 bytes
  6476                                  int_19:
  6477 000066F2 E9A4BA                  	jmp	ipl
  6478                                  
  6479                                  ;=========================================================================
  6480                                  ; configuration data table
  6481                                  ;-------------------------------------------------------------------------
  6482                                  	setloc	0E6F5h
  6483                                  config_table:
  6484 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  6485                                  .bytes:
  6486                                  %ifdef AT_COMPAT
  6487 000066F7 FC                      	db	0FCh			; byte 2: model = AT
  6488 000066F8 00                      	db	00h			; byte 3: submodel = 0
  6489 000066F9 00                      	db	00h			; byte 4: release = 0
  6490 000066FA 70                      	db	01110000b		; byte 5: feature byte 1
  6491                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  6492                                  ;		||||||`-- bus is Micro Channel instead of ISA
  6493                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  6494                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  6495                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  6496                                  ;		||`-- real time clock installed
  6497                                  ;		|`-- 2nd interrupt controller installed
  6498                                  ;		`-- DMA channel 3 used by hard disk BIOS
  6499 000066FB 00                      	db	00h			; byte 6: feature byte 2
  6500 000066FC 00                      	db	00h			; byte 7: feature byte 3
  6501 000066FD 00                      	db	00h			; byte 8: feature byte 4
  6502 000066FE 00                      	db	00h			; byte 9: feature byte 5
  6503                                  %else
  6504                                  	db	0FEh			; byte 2: model = XT
  6505                                  	db	00h			; byte 3: submodel = 0
  6506                                  	db	00h			; byte 4: release = 0
  6507                                  	db	00000000b		; byte 5: feature byte 1
  6508                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  6509                                  ;		||||||`-- bus is Micro Channel instead of ISA
  6510                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  6511                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  6512                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  6513                                  ;		||`-- real time clock installed
  6514                                  ;		|`-- 2nd interrupt controller installed
  6515                                  ;		`-- DMA channel 3 used by hard disk BIOS
  6516                                  	db	00h			; byte 6: feature byte 2
  6517                                  	db	00h			; byte 7: feature byte 3
  6518                                  	db	00h			; byte 8: feature byte 4
  6519                                  	db	00h			; byte 9: feature byte 5
  6520                                  %endif ; AT_COMPAT
  6521                                  .size	equ	$-.bytes
  6522                                  
  6523                                  ;=========================================================================
  6524                                  ; Includes with fixed entry points (for IBM compatibility)
  6525                                  ;-------------------------------------------------------------------------
  6526                                  
  6527                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  6528                              <1> ;========================================================================
  6529                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  6530                              <1> ;       INT 14h, function AH=00h
  6531                              <1> ;       INT 14h, function AH=03h
  6532                              <1> ;       INT 14h, function AH=04h
  6533                              <1> ;       INT 14h, function AH=05h
  6534                              <1> ;	- see serial1.inc for other INT 14h functions
  6535                              <1> ;-------------------------------------------------------------------------
  6536                              <1> ;
  6537                              <1> ; Compiles with NASM 2.07, might work with other versions
  6538                              <1> ;
  6539                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  6540                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  6541                              <1> ;
  6542                              <1> ; This program is free software: you can redistribute it and/or modify
  6543                              <1> ; it under the terms of the GNU General Public License as published by
  6544                              <1> ; the Free Software Foundation, either version 3 of the License, or
  6545                              <1> ; (at your option) any later version.
  6546                              <1> ;
  6547                              <1> ; This program is distributed in the hope that it will be useful,
  6548                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6549                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6550                              <1> ; GNU General Public License for more details.
  6551                              <1> ;
  6552                              <1> ; You should have received a copy of the GNU General Public License
  6553                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  6554                              <1> ;
  6555                              <1> ;=========================================================================
  6556                              <1> 
  6557                              <1> ;=========================================================================
  6558                              <1> ; int_14 - BIOS Serial Port Communication Services
  6559                              <1> ;-------------------------------------------------------------------------
  6560 000066FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  6561          ******************  <1>  warning: (setloc:7) Inserting 42 bytes
  6562                              <1> int_14:
  6563 00006729 FB                  <1> 	sti
  6564 0000672A 51                  <1> 	push	cx
  6565 0000672B 52                  <1> 	push	dx
  6566 0000672C 56                  <1> 	push	si
  6567 0000672D 1E                  <1> 	push	ds
  6568 0000672E 53                  <1> 	push	bx
  6569 0000672F BB4000              <1> 	mov	bx,biosdseg
  6570 00006732 8EDB                <1> 	mov	ds,bx
  6571 00006734 80FC06              <1> 	cmp	ah,.max/2
  6572 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
  6573 00006739 83FA04              <1> 	cmp	dx,num_serial
  6574 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
  6575 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  6576 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  6577 00006743 89D3                <1> 	mov	bx,dx
  6578 00006745 D1E3                <1> 	shl	bx,1
  6579 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  6580 00006749 09D2                <1> 	or	dx,dx
  6581 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
  6582 0000674D B700                <1> 	mov	bh,0
  6583 0000674F 88E3                <1> 	mov	bl,ah
  6584 00006751 D1E3                <1> 	shl	bx,1
  6585 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
  6586                              <1> .dispatch:
  6587 00006758 [6C67]              <1> 	dw	int_14_fn00
  6588 0000675A [161C]              <1> 	dw	int_14_fn01
  6589 0000675C [311C]              <1> 	dw	int_14_fn02
  6590 0000675E [A167]              <1> 	dw	int_14_fn03
  6591 00006760 [AB67]              <1> 	dw	int_14_fn04
  6592 00006762 [0568]              <1> 	dw	int_14_fn05
  6593                              <1> .max	equ	$-.dispatch
  6594                              <1> 
  6595                              <1> int_14_error:
  6596 00006764 31C0                <1> 	xor	ax,ax
  6597                              <1> 
  6598                              <1> int_14_exit:
  6599 00006766 5B                  <1> 	pop	bx
  6600 00006767 1F                  <1> 	pop	ds
  6601 00006768 5E                  <1> 	pop	si
  6602 00006769 5A                  <1> 	pop	dx
  6603 0000676A 59                  <1> 	pop	cx
  6604 0000676B CF                  <1> 	iret
  6605                              <1> 
  6606                              <1> ;=========================================================================
  6607                              <1> ; int_14_fn00 - Initialize serial port
  6608                              <1> ; Input:
  6609                              <1> ;	AH = 0 - function 00h - initialize serial port
  6610                              <1> ;	AL - initialization parameters
  6611                              <1> ;		bit 1,0	= 10	- 7 data bits
  6612                              <1> ;			= 11	- 8 data bits
  6613                              <1> ;		bit 2	= 0	- 1 stop bit
  6614                              <1> ;			= 1	- 2 stop bits
  6615                              <1> ;		bit 3	= 0	- parity disable
  6616                              <1> ;			= 1	- parity enable
  6617                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  6618                              <1> ;			= 1	- even parity (if parity enabled)
  6619                              <1> ;		bit 7-5 = 000	- 110 bps
  6620                              <1> ;			= 001	- 150 bps
  6621                              <1> ;			= 010	- 300 bps
  6622                              <1> ;			= 011	- 600 bps
  6623                              <1> ;			= 100	- 1200 bps
  6624                              <1> ;			= 101	- 2400 bps
  6625                              <1> ;			= 110	- 4800 bps
  6626                              <1> ;			= 111	- 9600 bps
  6627                              <1> ;	DX = serial port number (0-3)
  6628                              <1> ; Output:
  6629                              <1> ;	AL = modem status
  6630                              <1> ;		bit 0	= 1	- delta clear to send
  6631                              <1> ;		bit 1	= 1	- delta data set ready
  6632                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  6633                              <1> ;		bit 3	= 1	- delta data carrier detect
  6634                              <1> ;		bit 4	= 1	- clear to send
  6635                              <1> ;		bit 5	= 1	- data set ready
  6636                              <1> ;		bit 6	= 1	- ring indicator
  6637                              <1> ;		bit 7	= 1	- data carrier detect
  6638                              <1> ;	AH = line status
  6639                              <1> ;		bit 0	= 1	- data ready
  6640                              <1> ;		bit 1	= 1	- overrun error
  6641                              <1> ;		bit 2	= 1	- parity error
  6642                              <1> ;		bit 3	= 1	- framing error
  6643                              <1> ;		bit 4	= 1	- break interrupt
  6644                              <1> ;		bit 5	= 1	- transmitter holding register
  6645                              <1> ;		bit 6	= 1	- transmitter empty
  6646                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  6647                              <1> ;-------------------------------------------------------------------------
  6648                              <1> int_14_fn00:
  6649 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  6650 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  6651 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  6652 00006773 EE                  <1> 	out	dx,al
  6653 00006774 31DB                <1> 	xor	bx,bx
  6654 00006776 88E3                <1> 	mov	bl,ah
  6655 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  6656 0000677B D0EB                <1> 	shr	bl,1
  6657 0000677D D0EB                <1> 	shr	bl,1
  6658 0000677F D0EB                <1> 	shr	bl,1
  6659 00006781 D0EB                <1> 	shr	bl,1
  6660 00006783 2E8B9F[FF1C]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  6661 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6662 0000678B 88D8                <1> 	mov	al,bl
  6663 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  6664 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  6665 0000678F 88F8                <1> 	mov	al,bh
  6666 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  6667 00006792 42                  <1> 	inc	dx
  6668 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  6669 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  6670 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  6671                              <1> 					; get control bits
  6672 00006798 EE                  <1> 	out	dx,al			; set LCR
  6673 00006799 4A                  <1> 	dec	dx
  6674 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  6675                              <1> 					; OPTIMIZATION:
  6676                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  6677 0000679B B000                <1> 	mov	al,0
  6678 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  6679 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  6680                              <1> 					; OPTIMIZATION:
  6681                              <1> 					; uart_base = uart_ier_reg - 1
  6682 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6683                              <1> 
  6684                              <1> ;=========================================================================
  6685                              <1> ; int_14_fn03 - Return serial port status
  6686                              <1> ; Input:
  6687                              <1> ;	AH = 03h - function 03h - return serial port status
  6688                              <1> ;	DX = serial port number (0-3)
  6689                              <1> ; Output:
  6690                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  6691                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  6692                              <1> ;-------------------------------------------------------------------------
  6693                              <1> int_14_fn03:
  6694 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  6695 000067A4 EC                  <1> 	in	al,dx
  6696 000067A5 88C4                <1> 	mov	ah,al
  6697 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  6698 000067A8 EC                  <1> 	in	al,dx
  6699 000067A9 EBBB                <1> 	jmp	int_14_exit
  6700                              <1> 
  6701                              <1> ;=========================================================================
  6702                              <1> ; int_14_fn04 - Extended initialize serial port
  6703                              <1> ; Input:
  6704                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  6705                              <1> ;	AL - break status:
  6706                              <1> ;		00h = no break
  6707                              <1> ;		01h = break
  6708                              <1> ;	BH - parity:
  6709                              <1> ;		00h = no parity
  6710                              <1> ;		01h = odd parity
  6711                              <1> ;		02h = even parity
  6712                              <1> ;		03h = stick parity odd
  6713                              <1> ;		04h = stick parity even
  6714                              <1> ;	BL - stop bits:
  6715                              <1> ;		00h = 1 stop bit
  6716                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  6717                              <1> ;	CH - word length:
  6718                              <1> ;		00h = 5 bits
  6719                              <1> ;		01h = 6 bits
  6720                              <1> ;		02h = 7 bits
  6721                              <1> ;		03h = 8 bits
  6722                              <1> ;	CL - bps rate:
  6723                              <1> ;		00h = 110 bps
  6724                              <1> ;		01h = 150 bps
  6725                              <1> ;		02h = 300 bps
  6726                              <1> ;		03h = 600 bps
  6727                              <1> ;		04h = 1200 bps
  6728                              <1> ;		05h = 2400 bps
  6729                              <1> ;		06h = 6000 bps
  6730                              <1> ;		07h = 9600 bps
  6731                              <1> ;		08h = 19200 bps
  6732                              <1> ;		09h = 38400 bps
  6733                              <1> ;		0Ah = 57600 bps
  6734                              <1> ;		0Bh = 115200 bps
  6735                              <1> ;	DX = serial port number (0-3)
  6736                              <1> ; Output:
  6737                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  6738                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  6739                              <1> ;-------------------------------------------------------------------------
  6740                              <1> int_14_fn04:
  6741 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  6742 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  6743 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  6744                              <1> 					; exit returning modem and line status
  6745 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  6746 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  6747 000067B7 EE                  <1> 	out	dx,al
  6748 000067B8 31DB                <1> 	xor	bx,bx
  6749 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  6750 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  6751 000067BE 2E8B9F[FF1C]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  6752 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6753 000067C6 88D8                <1> 	mov	al,bl
  6754 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  6755 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  6756 000067CA 88F8                <1> 	mov	al,bh
  6757 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  6758 000067CD 42                  <1> 	inc	dx
  6759 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  6760                              <1> 
  6761 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  6762 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  6763                              <1> 
  6764 000067D4 D0E0                <1> 	shl	al,1
  6765 000067D6 D0E0                <1> 	shl	al,1
  6766 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  6767                              <1> 	
  6768 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  6769 000067DB 53                  <1> 	push	bx			; push it back to the stack
  6770                              <1> 
  6771 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  6772 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  6773 000067E1 FECF                <1> 	dec	bh
  6774 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  6775 000067E6 D0E7                <1> 	shl	bh,1
  6776 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  6777                              <1> 
  6778                              <1> .set_parity:
  6779 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  6780                              <1> 
  6781 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  6782                              <1> 	
  6783 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  6784 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  6785                              <1> 
  6786 000067F3 D0E0                <1> 	shl	al,1
  6787 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  6788                              <1> 
  6789 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  6790 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  6791                              <1> 
  6792 000067FC EE                  <1> 	out	dx,al			; set LCR
  6793 000067FD 4A                  <1> 	dec	dx
  6794 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  6795                              <1> 					; OPTIMIZATION:
  6796                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  6797 000067FF B000                <1> 	mov	al,0
  6798 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  6799 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  6800                              <1> 					; OPTIMIZATION:
  6801                              <1> 					; uart_base = uart_ier_reg - 1
  6802 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6803                              <1> 
  6804                              <1> ;=========================================================================
  6805                              <1> ; int_14_fn05 - Extended serial port control
  6806                              <1> ; Input:
  6807                              <1> ;	AH = 05h - function 05h - extended serial port control
  6808                              <1> ;	AL - sub-function:
  6809                              <1> ;		00h = read modem control register
  6810                              <1> ;		01h = write modem control register
  6811                              <1> ;			BL = modem control register
  6812                              <1> ;	DX = serial port number (0-3)
  6813                              <1> ; Output:
  6814                              <1> ;	AX = status	
  6815                              <1> ;	sub-function AL = 00h:
  6816                              <1> ;		BL = modem control register
  6817                              <1> ;-------------------------------------------------------------------------
  6818                              <1> int_14_fn05:
  6819 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  6820 00006807 750D                <1> 	jnz	int_14_fn05_01
  6821                              <1> 
  6822                              <1> ;-------------------------------------------------------------------------
  6823                              <1> ; sub-function 00h - read modem control register
  6824                              <1> ; int_14_fn05_00:
  6825 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  6826 0000680C EC                  <1> 	in	al,dx
  6827 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  6828 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  6829 00006810 53                  <1> 	push	bx			; put BX back to the stack
  6830 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6831 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6832                              <1> 
  6833                              <1> ;-------------------------------------------------------------------------
  6834                              <1> ; sub-function 01h - write modem control register
  6835                              <1> int_14_fn05_01:
  6836 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  6837 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  6838 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  6839 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  6840 0000681D EE                  <1> 	out	dx,al
  6841 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  6842 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  6843                                  %include	"atkbd.inc"		; INT 16, INT 09
  6844                              <1> ;=========================================================================
  6845                              <1> ; atkbd.inc - AT keyboard support
  6846                              <1> ;       INT 16h - BIOS Keyboard Services
  6847                              <1> ;		- function AH=02h
  6848                              <1> ;		- function AH=03h
  6849                              <1> ;		- function AH=05h
  6850                              <1> ;		- function AH=12h
  6851                              <1> ;		- see scancode.inc for other (scancode related)
  6852                              <1> ;                 INT 16h functions
  6853                              <1> ;       INT 09h - IRQ1 interrupt handler
  6854                              <1> ;-------------------------------------------------------------------------
  6855                              <1> ;
  6856                              <1> ; Compiles with NASM 2.07, might work with other versions
  6857                              <1> ;
  6858                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  6859                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  6860                              <1> ;
  6861                              <1> ; This program is free software: you can redistribute it and/or modify
  6862                              <1> ; it under the terms of the GNU General Public License as published by
  6863                              <1> ; the Free Software Foundation, either version 3 of the License, or
  6864                              <1> ; (at your option) any later version.
  6865                              <1> ;
  6866                              <1> ; This program is distributed in the hope that it will be useful,
  6867                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6868                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6869                              <1> ; GNU General Public License for more details.
  6870                              <1> ;
  6871                              <1> ; You should have received a copy of the GNU General Public License
  6872                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  6873                              <1> ;
  6874                              <1> ;=========================================================================
  6875                              <1> 
  6876                              <1> ;=========================================================================
  6877                              <1> ; Scan codes and keyboard flags
  6878                              <1> ;-------------------------------------------------------------------------
  6879                              <1> 
  6880                              <1> ; scancodes for special keys
  6881                              <1> 
  6882                              <1> kbd_num_code	equ	45h
  6883                              <1> kbd_scroll_code	equ	46h
  6884                              <1> kbd_caps_code	equ	3ah
  6885                              <1> kbd_ctrl_code	equ	1dh
  6886                              <1> kbd_alt_code	equ	38h
  6887                              <1> kbd_rshift_code	equ	36h
  6888                              <1> kbd_prtsc_code	equ	37h
  6889                              <1> kbd_lshift_code	equ	2ah
  6890                              <1> kbd_ins_code	equ	52h
  6891                              <1> kbd_del_code	equ	53h
  6892                              <1> 
  6893                              <1> ; Bits for the various modifier keys
  6894                              <1> 
  6895                              <1> kbd_rshft_bit	equ	1
  6896                              <1> kbd_lshft_bit	equ	2
  6897                              <1> kbd_ctrl_bit	equ	4
  6898                              <1> kbd_alt_bit	equ	8
  6899                              <1> kbd_scroll_bit	equ	10h
  6900                              <1> kbd_num_bit	equ	20h
  6901                              <1> kbd_caps_bit	equ	40h
  6902                              <1> kbd_ins_bit	equ	80h
  6903                              <1> 
  6904                              <1> ;=========================================================================
  6905                              <1> ; int_16 - BIOS keyboard functions
  6906                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  6907                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  6908                              <1> ;	conditions
  6909                              <1> ;-------------------------------------------------------------------------
  6910 00006824 FF<rept>            <1> 	setloc	0E82Eh
  6911          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  6912                              <1> int_16:
  6913 0000682E 53                  <1> 	push	bx
  6914 0000682F 1E                  <1> 	push	ds
  6915 00006830 BB4000              <1> 	mov	bx,biosdseg
  6916 00006833 8EDB                <1> 	mov	ds,bx
  6917 00006835 80FC13              <1> 	cmp	ah,.num_func
  6918 00006838 7331                <1> 	jae	int_16_exit
  6919 0000683A B700                <1> 	mov	bh,0
  6920 0000683C 88E3                <1> 	mov	bl,ah
  6921 0000683E D1E3                <1> 	shl	bx,1
  6922 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
  6923                              <1> 
  6924                              <1> .dispatch:
  6925 00006845 [2B1B]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  6926 00006847 [801B]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  6927 00006849 [7468]              <1> 	dw	int_16_fn02		; get shift status
  6928 0000684B [7968]              <1> 	dw	int_16_fn03		; set delays
  6929 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
  6930 0000684F [A668]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  6931 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
  6932 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
  6933 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
  6934 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
  6935 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
  6936 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  6937 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  6938 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  6939 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  6940 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  6941 00006865 [D81B]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  6942 00006867 [FF1B]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  6943 00006869 [CF68]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  6944                              <1> .num_func	equ	($-.dispatch)/2
  6945                              <1> 
  6946                              <1> int_16_exit:
  6947 0000686B 1F                  <1> 	pop	ds
  6948 0000686C 5B                  <1> 	pop	bx
  6949 0000686D CF                  <1> 	iret
  6950                              <1> 
  6951                              <1> int_16_exitf:
  6952 0000686E 1F                  <1> 	pop	ds
  6953 0000686F 5B                  <1> 	pop	bx
  6954 00006870 FB                  <1> 	sti
  6955 00006871 CA0200              <1> 	retf	2
  6956                              <1> 
  6957                              <1> ;=========================================================================
  6958                              <1> ; int_16_fn02 - get shift flags
  6959                              <1> ; Input:
  6960                              <1> ;	AH = 02h
  6961                              <1> ; Output:
  6962                              <1> ;	AL - shift flags
  6963                              <1> ;            AL bits:
  6964                              <1> ;		7 - Insert active
  6965                              <1> ;		6 - Caps Lock active
  6966                              <1> ;		5 - Num Lock active
  6967                              <1> ;		4 - Scroll Lock active
  6968                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  6969                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  6970                              <1> ;		1 - left shift key pressed
  6971                              <1> ;		0 - right shift key pressed
  6972                              <1> ;-------------------------------------------------------------------------
  6973                              <1> int_16_fn02:
  6974 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  6975 00006877 EBF2                <1> 	jmp	int_16_exit
  6976                              <1> 
  6977                              <1> ;=========================================================================
  6978                              <1> ; int_16_fn03 - set keyboard typematic rate
  6979                              <1> ; Input:
  6980                              <1> ;	AH = 03
  6981                              <1> ;	AL - subfunction
  6982                              <1> ;	     00 - set typematic rate to default
  6983                              <1> ;	     01 - increase initial delay
  6984                              <1> ;	     02 - slow typematic rate by 1/2
  6985                              <1> ;	     04 - turn off typematic chars
  6986                              <1> ;	     05 - set typematic rate/delay
  6987                              <1> ;	BH - repeat delay (AL=5)
  6988                              <1> ;		0 - 250ms	2 - 750ms
  6989                              <1> ;		1 - 500ms	3 - 1000ms
  6990                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  6991                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  6992                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  6993                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  6994                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  6995                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  6996                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  6997                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  6998                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  6999                              <1> ; Output:
  7000                              <1> ;	none
  7001                              <1> ;-------------------------------------------------------------------------
  7002                              <1> int_16_fn03:
  7003 00006879 3C05                <1> 	cmp	al,05
  7004 0000687B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  7005 0000687D 53                  <1> 	push	bx
  7006 0000687E 51                  <1> 	push	cx
  7007 0000687F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7008 00006881 E8A9AD              <1> 	call	kbc_send_cmd_byte
  7009 00006884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  7010 00006887 B105                <1> 	mov	cl,5
  7011 00006889 D2E7                <1> 	shl	bh,cl
  7012 0000688B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  7013 0000688E B0F3                <1> 	mov	al,0F3h
  7014 00006890 E836AD              <1> 	call	kbc_kb_send
  7015 00006893 88F8                <1> 	mov	al,bh
  7016 00006895 E831AD              <1> 	call	kbc_kb_send
  7017 00006898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7018 0000689A E890AD              <1> 	call	kbc_send_cmd_byte
  7019 0000689D B004                <1> 	mov	al,04h
  7020 0000689F E827AD              <1> 	call	kbc_kb_send
  7021 000068A2 59                  <1> 	pop	cx
  7022 000068A3 5B                  <1> 	pop	bx
  7023                              <1> .exit:
  7024 000068A4 EBC5                <1> 	jmp	int_16_exit
  7025                              <1> 
  7026                              <1> ;=========================================================================
  7027                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  7028                              <1> ; Input:
  7029                              <1> ;	AH = 05h
  7030                              <1> ;	CH = BIOS scan code
  7031                              <1> ;	CL = ACII character
  7032                              <1> ; Output:
  7033                              <1> ;	AL - status
  7034                              <1> ;	     00h - success
  7035                              <1> ;	     01h - keyboard buffer full
  7036                              <1> ;-------------------------------------------------------------------------
  7037                              <1> int_16_fn05:
  7038 000068A6 56                  <1> 	push	si
  7039 000068A7 B001                <1> 	mov	al,1			; assume no space
  7040 000068A9 FA                  <1> 	cli				; critical section
  7041 000068AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7042 000068AE 89DE                <1> 	mov	si,bx
  7043 000068B0 83C302              <1> 	add	bx,2
  7044 000068B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7045 000068B7 7504                <1> 	jne	.1
  7046 000068B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7047                              <1> .1:
  7048 000068BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7049 000068C1 7408                <1> 	je	.no_space		; no space in buffer
  7050 000068C3 890C                <1> 	mov	word [si],cx
  7051 000068C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7052 000068C9 B000                <1> 	mov	al,0			; stored successfully
  7053                              <1> .no_space:
  7054 000068CB FB                  <1> 	sti
  7055 000068CC 5E                  <1> 	pop	si
  7056 000068CD EB9C                <1> 	jmp	int_16_exit
  7057                              <1> 
  7058                              <1> ;=========================================================================
  7059                              <1> ; int_16_fn12 - get extended shift flags
  7060                              <1> ; Input:
  7061                              <1> ;	AH = 12h
  7062                              <1> ; Output:
  7063                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  7064                              <1> ;	AH - shift flags 2
  7065                              <1> ;            AH bits:
  7066                              <1> ;		7 - SysRq key pressed
  7067                              <1> ;		6 - Caps Lock pressed
  7068                              <1> ;		5 - Num Lock pressed
  7069                              <1> ;		4 - Scroll Lock pressed
  7070                              <1> ;		3 - right Alt key pressed
  7071                              <1> ;		2 - right Ctrl key pressed
  7072                              <1> ;		1 - left Alt key pressed
  7073                              <1> ;		0 - left Ctrl key pressed
  7074                              <1> ;-------------------------------------------------------------------------
  7075                              <1> int_16_fn12:
  7076 000068CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  7077 000068D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  7078 000068D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  7079 000068D9 7403                <1> 	je	.1
  7080 000068DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  7081                              <1> .1:
  7082 000068DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  7083 000068E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  7084 000068E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  7085 000068E6 08C4                <1> 	or	ah,al			; copy to AH
  7086 000068E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7087 000068EB E97DFF              <1> 	jmp	int_16_exit
  7088                              <1> 
  7089                              <1> ;=========================================================================
  7090                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  7091                              <1> ;-------------------------------------------------------------------------
  7092 000068EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  7093          ******************  <1>  warning: (setloc:7) Inserting 153 bytes
  7094                              <1> int_09:
  7095 00006987 50                  <1> 	push	ax
  7096 00006988 53                  <1> 	push	bx
  7097 00006989 1E                  <1> 	push	ds
  7098                              <1> 
  7099 0000698A B84000              <1> 	mov	ax,biosdseg
  7100 0000698D 8ED8                <1> 	mov	ds,ax
  7101                              <1> 
  7102                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7103                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7104                              <1> 	call    kbc_send_cmd_byte
  7105                              <1> %endif
  7106 0000698F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  7107 00006991 FB                  <1> 	sti
  7108 00006992 B44F                <1> 	mov	ah,4Fh
  7109 00006994 F9                  <1> 	stc
  7110 00006995 CD15                <1> 	int	15h			; keyboard intercept
  7111 00006997 7203E9C401          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  7112                              <1> 
  7113                              <1> ; check for KBC response codes
  7114                              <1> 
  7115 0000699C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  7116 0000699E 7503E9BD01          <1> 	je      keyboard_int_exit
  7117 000069A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  7118 000069A5 7508                <1> 	jne     .2
  7119 000069A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  7120 000069AC E9B101              <1> 	jmp	keyboard_int_exit
  7121                              <1> .2:
  7122 000069AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  7123 000069B1 7508                <1> 	jne	.3
  7124 000069B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  7125 000069B8 E9A501              <1> 	jmp	keyboard_int_exit
  7126                              <1> 
  7127                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  7128                              <1> 
  7129                              <1> .3:
  7130                              <1> 
  7131                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  7132                              <1> 
  7133 000069BB 3CE0                <1> 	cmp	al,0e0h
  7134 000069BD 750D                <1> 	jne	.4
  7135 000069BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  7136 000069C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  7137 000069C9 E99401              <1> 	jmp	keyboard_int_exit
  7138                              <1> .4:
  7139 000069CC 3CE1                <1> 	cmp	al,0e1h
  7140 000069CE 750D                <1> 	jne	.5
  7141 000069D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  7142 000069D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  7143 000069DA E98301              <1> 	jmp	keyboard_int_exit
  7144                              <1> 
  7145                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  7146                              <1> 
  7147                              <1> .5:
  7148 000069DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  7149 000069E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  7150 000069E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  7151 000069E7 7529                <1> 	jne	.6
  7152 000069E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  7153 000069EB 750B                <1> 	jne	.check_minus
  7154 000069ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  7155 000069F3 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  7156                              <1> 
  7157                              <1> .check_minus:
  7158 000069F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  7159 000069FA 7509                <1> 	jne	.check_plus
  7160                              <1> 
  7161                              <1> .turbo_off:
  7162 000069FC E461                <1> 	in	al,port_b_reg
  7163 000069FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  7164 00006A00 E661                <1> 	out	port_b_reg,al
  7165 00006A02 E95B01              <1> 	jmp	keyboard_int_exit
  7166                              <1> 
  7167                              <1> .check_plus:
  7168 00006A05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  7169 00006A07 7509                <1> 	jne	.6
  7170                              <1> 
  7171                              <1> .turbo_on:
  7172 00006A09 E461                <1> 	in	al,port_b_reg
  7173 00006A0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  7174 00006A0D E661                <1> 	out	port_b_reg,al
  7175 00006A0F E94E01              <1> 	jmp	keyboard_int_exit
  7176                              <1> 
  7177                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  7178                              <1> ; in the keyboard flags variables.
  7179                              <1> 
  7180                              <1> .6:
  7181 00006A12 3C52                <1> 	cmp	al,kbd_ins_code
  7182 00006A14 7508                <1> 	jne	.7
  7183 00006A16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  7184 00006A1B E90301              <1> 	jmp	.translate	   	; pass on INS key
  7185                              <1> 
  7186                              <1> .7:
  7187 00006A1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  7188 00006A20 750D                <1> 	jne     .8
  7189 00006A22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  7190 00006A27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  7191 00006A2C E92C01              <1> 	jmp     .no_buffer
  7192                              <1> 
  7193                              <1> ; handle the left and right Shift keys
  7194                              <1> 
  7195                              <1> .8:
  7196 00006A2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  7197 00006A31 7508                <1> 	jne	.9
  7198 00006A33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  7199 00006A38 E92001              <1> 	jmp	.no_buffer
  7200                              <1> .9:
  7201 00006A3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  7202 00006A3D 7508                <1> 	jne     .10
  7203 00006A3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  7204 00006A44 E91401              <1> 	jmp     .no_buffer
  7205                              <1> .10:
  7206 00006A47 3C36                <1> 	cmp	al,kbd_rshift_code
  7207 00006A49 7508                <1> 	jne	.11
  7208 00006A4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  7209 00006A50 E90801              <1> 	jmp	.no_buffer
  7210                              <1> .11:
  7211 00006A53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  7212 00006A55 7508                <1> 	jne     .12
  7213 00006A57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  7214 00006A5C E9FC00              <1> 	jmp	.no_buffer
  7215                              <1> 
  7216                              <1> ; handle the Alt key
  7217                              <1> 
  7218                              <1> .12:
  7219 00006A5F 3C38                <1> 	cmp	al,kbd_alt_code
  7220 00006A61 7508                <1> 	jne	.13
  7221 00006A63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  7222 00006A68 E9F000              <1> 	jmp	.no_buffer
  7223                              <1> .13:
  7224 00006A6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  7225 00006A6D 751C                <1> 	jne	.14
  7226 00006A6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  7227 00006A74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  7228 00006A79 7503E9DD00          <1> 	je	.no_buffer				; nothing there - exit
  7229 00006A7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  7230 00006A81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  7231 00006A86 B400                <1> 	mov	ah,0
  7232 00006A88 E9AF00              <1> 	jmp	.put_in_buffer
  7233                              <1> 
  7234                              <1> ; handle the Ctrl key
  7235                              <1> 
  7236                              <1> .14:
  7237 00006A8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  7238 00006A8D 7508                <1> 	jne	.15
  7239 00006A8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  7240 00006A94 E9C400              <1> 	jmp	.no_buffer
  7241                              <1> .15:
  7242 00006A97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  7243 00006A99 7508                <1> 	jne	.16
  7244 00006A9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  7245 00006AA0 E9B800              <1> 	jmp	.no_buffer
  7246                              <1> 
  7247                              <1> ; handle the Caps Lock key
  7248                              <1> 
  7249                              <1> .16:
  7250 00006AA3 3C3A                <1> 	cmp	al,kbd_caps_code
  7251 00006AA5 750D                <1> 	jne	.17
  7252 00006AA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  7253 00006AAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  7254 00006AB1 E9A700              <1> 	jmp	.no_buffer
  7255                              <1> .17:
  7256 00006AB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  7257 00006AB6 7508                <1> 	jne	.18
  7258 00006AB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  7259 00006ABD E9C400              <1> 	jmp	set_LEDs
  7260                              <1> 
  7261                              <1> ; check if print screen key was pressed
  7262                              <1> 
  7263                              <1> .18:
  7264 00006AC0 3C37                <1> 	cmp	al,kbd_prtsc_code
  7265 00006AC2 7503                <1> 	jne	.test_scroll_loc
  7266 00006AC4 E9B500              <1> 	jmp	print_screen
  7267                              <1> 
  7268                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  7269                              <1> 
  7270                              <1> .test_scroll_loc:
  7271 00006AC7 3C46                <1> 	cmp	al,kbd_scroll_code
  7272 00006AC9 7528                <1> 	jne	.19
  7273 00006ACB F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7274 00006AD0 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  7275                              <1> 
  7276                              <1> ; handle Ctrl-Break
  7277                              <1> 
  7278 00006AD2 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  7279 00006AD6 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  7280 00006ADA 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7281 00006ADE 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  7282 00006AE3 CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  7283 00006AE5 EB74                <1> 	jmp	.no_buffer
  7284                              <1> 
  7285                              <1> ; handle Scroll Lock
  7286                              <1> 
  7287                              <1> .scroll_lock:
  7288 00006AE7 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  7289 00006AEC 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  7290 00006AF1 EB68                <1> 	jmp	.no_buffer
  7291                              <1> .19:
  7292 00006AF3 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  7293 00006AF5 7508                <1> 	jne	.20
  7294 00006AF7 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  7295 00006AFC E98500              <1> 	jmp	set_LEDs
  7296                              <1> 
  7297                              <1> ; handle the Num Lock
  7298                              <1> 
  7299                              <1> .20:
  7300 00006AFF 3C45                <1> 	cmp	al,kbd_num_code
  7301 00006B01 7513                <1> 	jne	.21
  7302 00006B03 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  7303 00006B08 755E                <1> 	jnz	pause			; jump if pause
  7304 00006B0A 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  7305 00006B0F 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  7306 00006B14 EB45                <1> 	jmp	.no_buffer
  7307                              <1> .21:
  7308 00006B16 3CC5                <1> 	cmp	al,kbd_num_code+80h
  7309 00006B18 7507                <1> 	jne	.translate
  7310 00006B1A 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  7311 00006B1F EB63                <1> 	jmp	set_LEDs
  7312                              <1> 
  7313                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  7314                              <1> 
  7315                              <1> .translate:
  7316 00006B21 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  7317 00006B26 7407                <1> 	jz	.check_release
  7318 00006B28 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  7319 00006B2D EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  7320                              <1> .check_release:
  7321 00006B2F A880                <1> 	test	al,80h			; ignore key release and KBC responses
  7322 00006B31 7528                <1> 	jnz	.no_buffer
  7323                              <1> 
  7324 00006B33 E83CAF              <1> 	call	scan_xlat
  7325 00006B36 85C0                <1> 	test	ax,ax		 	; check for bad code
  7326 00006B38 7421                <1> 	je	.no_buffer
  7327                              <1> 
  7328                              <1> .put_in_buffer:
  7329 00006B3A 56                  <1> 	push	si			; XXX - use Int 16h/05?
  7330 00006B3B 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7331 00006B3F 89DE                <1> 	mov	si,bx
  7332 00006B41 83C302              <1> 	add	bx,2
  7333 00006B44 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7334 00006B48 7504                <1> 	jne	.1
  7335 00006B4A 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7336                              <1> .1:
  7337 00006B4E 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7338 00006B52 7406                <1> 	je	.no_space		; no space in buffer
  7339 00006B54 8904                <1> 	mov	word [si],ax
  7340 00006B56 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7341                              <1> 
  7342                              <1> .no_space:
  7343 00006B5A 5E                  <1> 	pop	si
  7344                              <1> 
  7345                              <1> .no_buffer:
  7346 00006B5B 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  7347                              <1> 
  7348                              <1> keyboard_int_exit:
  7349                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7350                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7351                              <1> 	call	kbc_send_cmd_byte
  7352                              <1> %endif
  7353 00006B60 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7354 00006B62 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  7355                              <1> 
  7356                              <1> keyboard_int_exit1:
  7357 00006B64 1F                  <1> 	pop	ds
  7358 00006B65 5B                  <1> 	pop	bx
  7359 00006B66 58                  <1> 	pop	ax
  7360 00006B67 CF                  <1> 	iret
  7361                              <1> 
  7362                              <1> pause:
  7363 00006B68 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  7364 00006B6D 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  7365                              <1> 
  7366 00006B6F B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7367 00006B71 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7368                              <1> 
  7369                              <1> .pause_loop:
  7370 00006B73 F606180008          <1> 	test	byte [kbd_flags_2],08h
  7371 00006B78 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  7372 00006B7A EBE8                <1> 	jmp	keyboard_int_exit1
  7373                              <1> 
  7374                              <1> print_screen:
  7375 00006B7C B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7376 00006B7E E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7377 00006B80 CD05                <1> 	int	5h			; INT 5 - print screen
  7378 00006B82 EBE0                <1> 	jmp	keyboard_int_exit1
  7379                              <1> 
  7380                              <1> ;=========================================================================
  7381                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  7382                              <1> ; 	     variable and update LEDs on the keyboard
  7383                              <1> ;-------------------------------------------------------------------------
  7384                              <1> set_LEDs:
  7385                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7386                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7387                              <1> 	call	kbc_send_cmd_byte
  7388                              <1> %endif
  7389                              <1> 
  7390 00006B84 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7391 00006B86 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7392                              <1> 
  7393 00006B88 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7394 00006B8B D0E8                <1> 	shr	al,1
  7395 00006B8D D0E8                <1> 	shr	al,1
  7396 00006B8F D0E8                <1> 	shr	al,1
  7397 00006B91 D0E8                <1> 	shr	al,1
  7398 00006B93 2407                <1> 	and	al,111b
  7399 00006B95 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  7400 00006B9A 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  7401 00006B9E 88C4                <1> 	mov	ah,al			; save LED bits
  7402                              <1> 
  7403 00006BA0 B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7404 00006BA2 E888AA              <1> 	call	kbc_send_cmd_byte
  7405                              <1> 
  7406 00006BA5 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  7407 00006BA7 E81FAA              <1> 	call	kbc_kb_send		; send the command to the keyboard
  7408 00006BAA 88E0                <1> 	mov	al,ah			; get parameter byte
  7409 00006BAC E81AAA              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  7410                              <1> 
  7411 00006BAF B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7412 00006BB1 E879AA              <1> 	call	kbc_send_cmd_byte
  7413 00006BB4 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  7414 00006BB6 E810AA              <1> 	call	kbc_kb_send
  7415 00006BB9 EBA9                <1> 	jmp	keyboard_int_exit1
  7416                              <1> 
  7417                                  %include	"floppy2.inc"		; INT 13
  7418                              <1> ;=========================================================================
  7419                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  7420                              <1> ;       INT 13h, function AH=02h
  7421                              <1> ;       INT 13h, function AH=03h
  7422                              <1> ;       INT 13h, function AH=04h
  7423                              <1> ;       INT 13h, function AH=05h
  7424                              <1> ;	- see floppy1.inc for other INT 13h functions
  7425                              <1> ;-------------------------------------------------------------------------
  7426                              <1> ;
  7427                              <1> ; Compiles with NASM 2.07, might work with other versions
  7428                              <1> ;
  7429                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7430                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7431                              <1> ;
  7432                              <1> ; This program is free software: you can redistribute it and/or modify
  7433                              <1> ; it under the terms of the GNU General Public License as published by
  7434                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7435                              <1> ; (at your option) any later version.
  7436                              <1> ;
  7437                              <1> ; This program is distributed in the hope that it will be useful,
  7438                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7439                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7440                              <1> ; GNU General Public License for more details.
  7441                              <1> ;
  7442                              <1> ; You should have received a copy of the GNU General Public License
  7443                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7444                              <1> ;
  7445                              <1> ;=========================================================================
  7446                              <1> 
  7447                              <1> ;-------------------------------------------------------------------------
  7448                              <1> ; offsets for registers on stack
  7449                              <1> int_13_bp	equ	0
  7450                              <1> int_13_ds	equ	int_13_bp+2
  7451                              <1> int_13_di	equ	int_13_ds+2
  7452                              <1> int_13_si	equ	int_13_di+2
  7453                              <1> int_13_dx	equ	int_13_si+2
  7454                              <1> int_13_dl	equ	int_13_dx
  7455                              <1> int_13_dh	equ	int_13_dx+1
  7456                              <1> int_13_cx	equ	int_13_dx+2
  7457                              <1> int_13_cl	equ	int_13_cx
  7458                              <1> int_13_ch	equ	int_13_cx+1
  7459                              <1> int_13_bx	equ	int_13_cx+2
  7460                              <1> int_13_bl	equ	int_13_bx
  7461                              <1> int_13_bh	equ	int_13_bx+1
  7462                              <1> int_13_ax	equ	int_13_bx+2
  7463                              <1> int_13_al	equ	int_13_ax
  7464                              <1> int_13_ah	equ	int_13_ax+1
  7465                              <1> int_13_ip	equ	int_13_ax+2
  7466                              <1> int_13_cs	equ	int_13_ip+2
  7467                              <1> int_13_flags	equ	int_13_cs+2
  7468                              <1> int_13_flags_l	equ	int_13_flags
  7469                              <1> 
  7470                              <1> ;=========================================================================
  7471                              <1> ; int_13 - BIOS floppy disk services
  7472                              <1> ; Input:
  7473                              <1> ;	AH = function
  7474                              <1> ;		00h - Reset disk system
  7475                              <1> ;		01h - Get status of last operation
  7476                              <1> ;		02h - Read disk sectors
  7477                              <1> ;		03h - Write disk sectors
  7478                              <1> ;		04h - Verify disk sectors
  7479                              <1> ;		05h - Format track
  7480                              <1> ;		08h - Get drive parameters
  7481                              <1> ;		15h - Get disk type
  7482                              <1> ;		16h - Detect disk change
  7483                              <1> ;		17h - Set disk type for format
  7484                              <1> ;		18h - Set media type for format
  7485                              <1> ; Output:
  7486                              <1> ;	- depends on function
  7487                              <1> ;	- for most functions:
  7488                              <1> ;		CF clear if successful
  7489                              <1> ;			AH = 00h - successful completion
  7490                              <1> ;		CF set on error
  7491                              <1> ;			AH = error code
  7492                              <1> ;-------------------------------------------------------------------------
  7493 00006BBB FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  7494          ******************  <1>  warning: (setloc:7) Inserting 158 bytes
  7495                              <1> int_13:
  7496 00006C59 FB                  <1> 	sti
  7497 00006C5A 50                  <1> 	push	ax
  7498 00006C5B 53                  <1> 	push	bx
  7499 00006C5C 51                  <1> 	push	cx
  7500 00006C5D 52                  <1> 	push	dx
  7501 00006C5E 56                  <1> 	push	si
  7502 00006C5F 57                  <1> 	push	di
  7503 00006C60 1E                  <1> 	push	ds
  7504 00006C61 55                  <1> 	push	bp
  7505 00006C62 89E5                <1> 	mov	bp,sp
  7506 00006C64 80FC19              <1> 	cmp	ah,.num_func
  7507 00006C67 7743                <1> 	ja	.invalid_function
  7508 00006C69 88E0                <1> 	mov	al,ah
  7509 00006C6B 98                  <1> 	cbw
  7510 00006C6C 89C7                <1> 	mov	di,ax
  7511 00006C6E D1E7                <1> 	shl	di,1
  7512 00006C70 B84000              <1> 	mov	ax,biosdseg
  7513 00006C73 8ED8                <1> 	mov	ds,ax
  7514 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  7515                              <1> 
  7516                              <1> .dispatch:
  7517 00006C7A [B90D]              <1> 	dw	int_13_fn00		; Reset disk system
  7518 00006C7C [280E]              <1> 	dw	int_13_fn01		; Get status of last operation
  7519 00006C7E [EF6C]              <1> 	dw	int_13_fn02		; Read disk sectors
  7520 00006C80 [EF6C]              <1> 	dw	int_13_fn03		; Write disk sectors
  7521 00006C82 [EF6C]              <1> 	dw	int_13_fn04		; Verify disk sectors
  7522 00006C84 [5D6E]              <1> 	dw	int_13_fn05		; Format track
  7523 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  7524 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  7525 00006C8A [340E]              <1> 	dw	int_13_fn08		; Get drive parameters
  7526 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  7527 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  7528 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  7529 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  7530 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  7531 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  7532 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  7533 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  7534 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  7535 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  7536 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  7537 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  7538 00006CA4 [E10E]              <1> 	dw	int_13_fn15		; Get disk type
  7539 00006CA6 [020F]              <1> 	dw	int_13_fn16		; Detect disk change
  7540 00006CA8 [4E0F]              <1> 	dw	int_13_fn17		; Set disk type for format
  7541 00006CAA [B90F]              <1> 	dw	int_13_fn18		; Set media type for format
  7542                              <1> .num_func	equ ($-.dispatch)/2
  7543                              <1> 
  7544                              <1> .invalid_function:
  7545 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  7546 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  7547 00006CB2 F9                  <1> 	stc				; error condition
  7548 00006CB3 EB21                <1> 	jmp	int_13_exit
  7549                              <1> 
  7550                              <1> ;-------------------------------------------------------------------------
  7551                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  7552                              <1> 
  7553                              <1> int_13_upd_exit:
  7554 00006CB5 9C                  <1> 	pushf
  7555 00006CB6 50                  <1> 	push	ax
  7556 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  7557 00006CBA 3C01                <1> 	cmp	al,1
  7558 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  7559 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  7560 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  7561 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  7562 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  7563 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  7564 00006CCA 08C0                <1> 	or	al,al
  7565 00006CCC 7402                <1> 	jz	.drive_0
  7566 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  7567                              <1> 
  7568                              <1> .drive_0:
  7569 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  7570                              <1> 
  7571                              <1> .no_update:
  7572 00006CD4 58                  <1> 	pop	ax
  7573 00006CD5 9D                  <1> 	popf
  7574                              <1> 
  7575                              <1> int_13_exit:
  7576 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  7577 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  7578 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  7579 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  7580 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  7581                              <1> 
  7582                              <1> .set_error:
  7583 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  7584 00006CE6 5D                  <1> 	pop	bp
  7585 00006CE7 1F                  <1> 	pop	ds
  7586 00006CE8 5F                  <1> 	pop	di
  7587 00006CE9 5E                  <1> 	pop	si
  7588 00006CEA 5A                  <1> 	pop	dx
  7589 00006CEB 59                  <1> 	pop	cx
  7590 00006CEC 5B                  <1> 	pop	bx
  7591 00006CED 58                  <1> 	pop	ax
  7592 00006CEE CF                  <1> 	iret
  7593                              <1> 
  7594                              <1> ;=========================================================================
  7595                              <1> ; int_13_fn02 - Read disk sectors
  7596                              <1> ; int_13_fn03 - Write disk sectors
  7597                              <1> ; int_13_fn04 - Verify disk sectors
  7598                              <1> ; Input:
  7599                              <1> ;	AH = function
  7600                              <1> ;		02h - read
  7601                              <1> ;		03h - write
  7602                              <1> ;		04h - verify
  7603                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  7604                              <1> ;	CH = cylinder number
  7605                              <1> ;	CL = sector number
  7606                              <1> ;	DH = head number (0 or 1)
  7607                              <1> ;	DL = drive number (0 or 1)
  7608                              <1> ;	ES:BX -> data buffer
  7609                              <1> ; Output:
  7610                              <1> ;	CF clear if successful
  7611                              <1> ;		AH = 00h - successful completion
  7612                              <1> ;		AL = number of sectors transferred or verified
  7613                              <1> ;	CF set on error
  7614                              <1> ;		AH = error code
  7615                              <1> ;-------------------------------------------------------------------------
  7616                              <1> int_13_fn02:
  7617                              <1> int_13_fn03:
  7618                              <1> int_13_fn04:
  7619 00006CEF 80FA01              <1> 	cmp	dl,1
  7620 00006CF2 7603E94801          <1> 	ja	.invalid_drive
  7621 00006CF7 BE9000              <1> 	mov	si,fdc_media_state
  7622 00006CFA 52                  <1> 	push	dx
  7623 00006CFB B600                <1> 	mov	dh,00h
  7624 00006CFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  7625 00006CFF 5A                  <1> 	pop	dx
  7626                              <1> 
  7627 00006D00 E806A7              <1> 	call	read_cmos_type		; get drive type in AL
  7628 00006D03 7303E93701          <1> 	jc	.invalid_drive
  7629                              <1> 
  7630 00006D08 BF3F00              <1> 	mov	di,fdc_motor_state
  7631 00006D0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  7632 00006D0E 80FC03              <1> 	cmp	ah,03h			; write function
  7633 00006D11 7503                <1> 	jne	.motor_on		; jump if not write function
  7634 00006D13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  7635                              <1> 
  7636                              <1> .motor_on:
  7637 00006D16 E861A4              <1> 	call	fdc_motor_on
  7638 00006D19 3C01                <1> 	cmp	al,cmos_360
  7639 00006D1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  7640 00006D20 3C03                <1> 	cmp	al,cmos_720
  7641 00006D22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  7642                              <1> 
  7643 00006D27 E80AA5              <1> 	call	fdc_disk_change
  7644 00006D2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  7645                              <1> 
  7646 00006D2F F60410              <1> 	test	byte [si],fdc_m_established
  7647 00006D32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  7648                              <1> 
  7649 00006D37 E8BFA7              <1> 	call	fdc_select_rate		; select transfer rate
  7650                              <1> 	
  7651                              <1> .fdc_send_specify:
  7652 00006D3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  7653                              <1> 					; 0BFh - specify byte 0 for 1.44M
  7654 00006D3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  7655 00006D40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  7656 00006D42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  7657 00006D44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  7658 00006D47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  7659 00006D49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  7660                              <1> 
  7661                              <1> .fdc_send_specify_cmd:
  7662 00006D4B BE0200              <1> 	mov	si,2			; specify byte 1
  7663 00006D4E B103                <1> 	mov	cl,3			; 3 bytes command
  7664 00006D50 E887A5              <1> 	call	fdc_send_cmd
  7665 00006D53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  7666 00006D58 1E                  <1> 	push	ds
  7667 00006D59 31F6                <1> 	xor	si,si
  7668 00006D5B 8EDE                <1> 	mov	ds,si
  7669 00006D5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  7670 00006D61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  7671 00006D64 B400                <1> 	mov	ah,00h
  7672 00006D66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  7673 00006D68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  7674 00006D6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  7675 00006D6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  7676 00006D70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  7677 00006D72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  7678                              <1> 
  7679                              <1> .calc_dma_count:
  7680 00006D75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  7681 00006D78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  7682 00006D7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  7683 00006D7D 1F                  <1> 	pop	ds
  7684 00006D7E 48                  <1> 	dec	ax			; minus one byte
  7685 00006D7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  7686                              <1> 
  7687 00006D81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  7688 00006D84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  7689 00006D86 80FC02              <1> 	cmp	ah,02h			; read function?
  7690 00006D89 7409                <1> 	je	.configure_dma		; jump if read function
  7691 00006D8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  7692 00006D8D 80FC03              <1> 	cmp	ah,03h			; write function?
  7693 00006D90 7402                <1> 	je	.configure_dma		; jump if write function
  7694 00006D92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  7695                              <1> 
  7696                              <1> .configure_dma:
  7697 00006D94 E8E5A4              <1> 	call	fdc_configure_dma
  7698 00006D97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  7699 00006D9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  7700                              <1> 
  7701 00006D9F E821A3              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  7702 00006DA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  7703                              <1> 
  7704 00006DA7 1E                  <1> 	push	ds
  7705 00006DA8 31C0                <1> 	xor	ax,ax
  7706 00006DAA 8ED8                <1> 	mov	ds,ax
  7707 00006DAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  7708 00006DB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  7709 00006DB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  7710 00006DB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  7711 00006DB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  7712 00006DBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  7713 00006DBD 1F                  <1> 	pop	ds
  7714                              <1> 
  7715 00006DBE BE9000              <1> 	mov	si,fdc_media_state
  7716 00006DC1 B600                <1> 	mov	dh,00h
  7717 00006DC3 01D6                <1> 	add	si,dx
  7718 00006DC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  7719 00006DC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  7720 00006DC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  7721 00006DCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  7722 00006DCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  7723 00006DD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  7724 00006DD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  7725 00006DD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  7726 00006DD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  7727 00006DDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  7728 00006DDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  7729 00006DDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  7730                              <1> 	
  7731                              <1> .gap_set:
  7732 00006DE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  7733 00006DE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  7734 00006DE7 88F4                <1> 	mov	ah,dh			; head
  7735 00006DE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  7736 00006DEB D0E4                <1> 	shl	ah,1
  7737 00006DED D0E4                <1> 	shl	ah,1
  7738 00006DEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  7739 00006DF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  7740 00006DF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  7741 00006DF7 7502                <1> 	jne	.send_command		; jump if not write 
  7742 00006DF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  7743                              <1> 
  7744                              <1> .send_command:
  7745 00006DFB B109                <1> 	mov	cl,9			; 9 bytes command
  7746 00006DFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  7747 00006E02 E8D5A4              <1> 	call	fdc_send_cmd
  7748 00006E05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  7749 00006E07 E821A7              <1> 	call	fdc_wait_irq
  7750 00006E0A 7228                <1> 	jc	.error_fdc_get_result
  7751 00006E0C B107                <1> 	mov	cl,7
  7752 00006E0E E82EA5              <1> 	call	fdc_get_result		; read result bytes
  7753 00006E11 7228                <1> 	jc	.error_end_io
  7754                              <1> 
  7755 00006E13 E87EA5              <1> 	call	fdc_get_error
  7756                              <1> 
  7757                              <1> .exit_end_io:
  7758 00006E16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  7759                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  7760 00006E19 E8EDA3              <1> 	call	fdc_end_io		; return number of last sector in BL
  7761 00006E1C 08C0                <1> 	or	al,al
  7762 00006E1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  7763 00006E20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  7764 00006E22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  7765                              <1> 
  7766                              <1> .zero_sectors:
  7767 00006E25 08E4                <1> 	or	ah,ah
  7768 00006E27 7401                <1> 	jz	.exit			; jump if no errors
  7769                              <1> 
  7770                              <1> .error:
  7771 00006E29 F9                  <1> 	stc				; indicate error
  7772                              <1> 
  7773                              <1> .exit:
  7774 00006E2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  7775 00006E2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  7776 00006E31 E981FE              <1> 	jmp	int_13_upd_exit
  7777                              <1> 
  7778                              <1> .error_fdc_get_result:
  7779 00006E34 B107                <1> 	mov	cl,7
  7780 00006E36 50                  <1> 	push	ax
  7781 00006E37 E805A5              <1> 	call	fdc_get_result		; read result bytes
  7782 00006E3A 58                  <1> 	pop	ax
  7783                              <1> 
  7784                              <1> .error_end_io:
  7785 00006E3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  7786 00006E3D EBD7                <1> 	jmp	.exit_end_io
  7787                              <1> 
  7788                              <1> .invalid_drive:
  7789 00006E3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  7790 00006E42 EBE5                <1> 	jmp	.error
  7791                              <1> 
  7792                              <1> ; 360K and 720K drives don't support change line, and only support
  7793                              <1> ; one media type - set it here
  7794                              <1> 
  7795                              <1> .set_media_360:
  7796 00006E44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  7797 00006E46 EB02                <1> 	jmp	.set_media
  7798                              <1> 
  7799                              <1> .set_media_720:
  7800 00006E48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  7801                              <1> 
  7802                              <1> .set_media:
  7803 00006E4A 8804                <1> 	mov	byte [si],al		; save media state
  7804 00006E4C E8D1A6              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  7805 00006E4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  7806 00006E52 E9E5FE              <1> 	jmp	.fdc_send_specify
  7807                              <1> 
  7808                              <1> ; establish media type
  7809                              <1> 
  7810                              <1> .establish_media:
  7811 00006E55 E8D4A5              <1> 	call	fdc_detect_media
  7812 00006E58 72E1                <1> 	jc	.error_end_io
  7813 00006E5A E9DDFE              <1> 	jmp	.fdc_send_specify
  7814                              <1> 	
  7815                              <1> 
  7816                              <1> ;=========================================================================
  7817                              <1> ; int_13_fn05 - Format track
  7818                              <1> ; Input:
  7819                              <1> ;	AH = 05h
  7820                              <1> ;	CH = track number
  7821                              <1> ;	DH = head number (0 or 1)
  7822                              <1> ;	DL = drive number (0 or 1)
  7823                              <1> ;	ES:BX -> address field buffer
  7824                              <1> ; Output:
  7825                              <1> ;	CF clear if successful
  7826                              <1> ;		AH = 00h - successful completion
  7827                              <1> ;	CF set on error
  7828                              <1> ;		AH = error code 
  7829                              <1> ;-------------------------------------------------------------------------
  7830                              <1> int_13_fn05:
  7831 00006E5D 80FA01              <1> 	cmp	dl,1
  7832 00006E60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  7833 00006E65 E8A1A5              <1> 	call	read_cmos_type		; get drive type in AL
  7834 00006E68 7303E99500          <1> 	jc	.invalid_drive
  7835 00006E6D BE9000              <1> 	mov	si,fdc_media_state
  7836 00006E70 52                  <1> 	push	dx
  7837 00006E71 B600                <1> 	mov	dh,00h
  7838 00006E73 01D6                <1> 	add	si,dx			; SI -> drive media state
  7839 00006E75 5A                  <1> 	pop	dx
  7840 00006E76 803C00              <1> 	cmp	byte [si],0
  7841 00006E79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  7842 00006E7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  7843 00006E83 E8F4A2              <1> 	call	fdc_motor_on
  7844 00006E86 E8ABA3              <1> 	call	fdc_disk_change		; read disk change line
  7845 00006E89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  7846 00006E8B E86BA6              <1> 	call	fdc_select_rate		; select transfer rate
  7847 00006E8E E8789F              <1> 	call	fdc_send_specify	; send FDC Specify command
  7848 00006E91 1E                  <1> 	push	ds
  7849 00006E92 31F6                <1> 	xor	si,si
  7850 00006E94 8EDE                <1> 	mov	ds,si
  7851 00006E96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  7852 00006E9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  7853 00006E9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  7854 00006EA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  7855 00006EA3 1F                  <1> 	pop	ds
  7856 00006EA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  7857 00006EA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  7858 00006EA8 D1E1                <1> 	shl	cx,1
  7859 00006EAA 49                  <1> 	dec	cx	 		; minus one byte...
  7860 00006EAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  7861 00006EAD E8CCA3              <1> 	call	fdc_configure_dma
  7862 00006EB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  7863 00006EB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  7864 00006EB5 56                  <1> 	push	si
  7865 00006EB6 E80AA2              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  7866 00006EB9 5E                  <1> 	pop	si
  7867 00006EBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  7868                              <1> 
  7869 00006EBC 88F4                <1> 	mov	ah,dh
  7870 00006EBE D0E4                <1> 	shl	ah,1
  7871 00006EC0 D0E4                <1> 	shl	ah,1
  7872 00006EC2 08D4                <1> 	or	ah,dl
  7873 00006EC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  7874                              <1> 
  7875 00006EC6 B106                <1> 	mov	cl,6			; 6 byte command
  7876 00006EC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  7877 00006ECD E80AA4              <1> 	call	fdc_send_cmd
  7878 00006ED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  7879 00006ED2 E856A6              <1> 	call	fdc_wait_irq
  7880 00006ED5 720A                <1> 	jc	.exit_end_io
  7881 00006ED7 B107                <1> 	mov	cl,7
  7882 00006ED9 E863A4              <1> 	call	fdc_get_result		; read result bytes
  7883 00006EDC 7203                <1> 	jc	.exit_end_io
  7884 00006EDE E8B3A4              <1> 	call	fdc_get_error		; get error code
  7885                              <1> 
  7886                              <1> .exit_end_io:
  7887 00006EE1 E825A3              <1> 	call	fdc_end_io
  7888 00006EE4 08E4                <1> 	or	ah,ah
  7889 00006EE6 7401                <1> 	jz	.exit			; jump if no errors
  7890                              <1> 
  7891                              <1> .error:
  7892 00006EE8 F9                  <1> 	stc				; indicate error
  7893                              <1> 
  7894                              <1> .exit:
  7895 00006EE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  7896 00006EED E9C5FD              <1> 	jmp	int_13_upd_exit
  7897                              <1> 
  7898                              <1> .error_fdc_get_result:
  7899 00006EF0 B107                <1> 	mov	cl,7
  7900 00006EF2 50                  <1> 	push	ax
  7901 00006EF3 E849A4              <1> 	call	fdc_get_result		; read result bytes
  7902 00006EF6 58                  <1> 	pop	ax
  7903 00006EF7 EBE8                <1> 	jmp	.exit_end_io
  7904                              <1> 
  7905                              <1> .error_end_io:
  7906 00006EF9 E80DA3              <1> 	call	fdc_end_io
  7907 00006EFC EBEA                <1> 	jmp	.error
  7908                              <1> 
  7909                              <1> .timeout:
  7910 00006EFE B480                <1> 	mov	ah,fdc_e_timeout
  7911 00006F00 EBE6                <1> 	jmp	.error
  7912                              <1> 
  7913                              <1> .invalid_drive:
  7914 00006F02 B401                <1> 	mov	ah,fdc_e_invalid
  7915 00006F04 EBE2                <1> 	jmp	.error
  7916                              <1> 
  7917                              <1> ;=========================================================================
  7918                              <1> ; int_0E - IRQ6 (FDC) service routine
  7919                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  7920                              <1> ;-------------------------------------------------------------------------
  7921 00006F06 FF<rept>            <1> 	setloc	0EF57h
  7922          ******************  <1>  warning: (setloc:7) Inserting 81 bytes
  7923                              <1> 
  7924                              <1> int_0E:
  7925 00006F57 50                  <1> 	push	ax
  7926 00006F58 1E                  <1> 	push	ds
  7927 00006F59 B84000              <1> 	mov	ax,biosdseg
  7928 00006F5C 8ED8                <1> 	mov	ds,ax
  7929 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  7930 00006F63 1F                  <1> 	pop	ds
  7931 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  7932 00006F66 E620                <1> 	out	pic1_reg0,al
  7933 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  7934 00006F6B CD15                <1> 	int	15h
  7935 00006F6D 58                  <1> 	pop	ax
  7936 00006F6E CF                  <1> 	iret
  7937                              <1> 
  7938                              <1> ;=========================================================================
  7939                              <1> ; Disk parameter tables in INT 1Eh format
  7940                              <1> ; Byte 0: First byte for specify command:
  7941                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  7942                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  7943                              <1> ; Byte 1: Second byte for specify command:
  7944                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  7945                              <1> ;	bit 0: non-DMA mode (always 0)
  7946                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  7947                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  7948                              <1> ; Byte 4: sectors per track
  7949                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  7950                              <1> ; Byte 6: special sector size (0FFh - not used)
  7951                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  7952                              <1> ; Byte 8: format filler byte (default 0F6h)
  7953                              <1> ; Byte 9: head settle time in milliseconds
  7954                              <1> ; Byte A: motor start time, in 1/8 seconds
  7955                              <1> ; Byte B: number of cylinders minus one
  7956                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  7957                              <1> ;-------------------------------------------------------------------------
  7958                              <1> media_360_in_360:
  7959 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  7960 00006F78 0F08                <1>
  7961 00006F7A 2780                <1> 	db	27h, 80h
  7962                              <1> media_1200:
  7963 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  7964 00006F85 0F08                <1>
  7965 00006F87 4F00                <1> 	db	4Fh, 00h
  7966                              <1> media_720:
  7967 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  7968 00006F92 0F08                <1>
  7969 00006F94 4F80                <1> 	db	4Fh, 80h
  7970                              <1> media_1440:
  7971 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  7972 00006F9F 0F08                <1>
  7973 00006FA1 4F00                <1> 	db	4Fh, 00h
  7974                              <1> media_360_in_1200:
  7975 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  7976 00006FAC 0F08                <1>
  7977 00006FAE 2740                <1> 	db	27h, 40h
  7978                              <1> media_2880:
  7979 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  7980 00006FB9 0F08                <1>
  7981 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  7982                              <1> 
  7983                              <1> ;=========================================================================
  7984                              <1> ; Disk parameter table for IBM compatibility
  7985                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  7986                              <1> ;-------------------------------------------------------------------------
  7987 00006FBD FF<rept>            <1> 	setloc	0EFC7h
  7988          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  7989                              <1> int_1E:
  7990 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  7991 00006FD0 0F08                <1>
  7992                                  %include	"printer2.inc"		; INT 17
  7993                              <1> ;=========================================================================
  7994                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  7995                              <1> ;       INT 17h, function AH=00h
  7996                              <1> ;	INT 17h, function AH=02h
  7997                              <1> ;	- see printer1.inc for other INT 17h functions
  7998                              <1> ;-------------------------------------------------------------------------
  7999                              <1> ;
  8000                              <1> ; Compiles with NASM 2.07, might work with other versions
  8001                              <1> ;
  8002                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8003                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8004                              <1> ;
  8005                              <1> ; This program is free software: you can redistribute it and/or modify
  8006                              <1> ; it under the terms of the GNU General Public License as published by
  8007                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8008                              <1> ; (at your option) any later version.
  8009                              <1> ;
  8010                              <1> ; This program is distributed in the hope that it will be useful,
  8011                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8012                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8013                              <1> ; GNU General Public License for more details.
  8014                              <1> ;
  8015                              <1> ; You should have received a copy of the GNU General Public License
  8016                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8017                              <1> ;
  8018                              <1> ;=========================================================================
  8019                              <1> 
  8020                              <1> ;=========================================================================
  8021                              <1> ; int_17  - BIOS Printer Services
  8022                              <1> ;-------------------------------------------------------------------------
  8023                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  8024                              <1> int_17:
  8025 00006FD2 FB                  <1> 	sti
  8026 00006FD3 53                  <1> 	push	bx
  8027 00006FD4 52                  <1> 	push	dx
  8028 00006FD5 56                  <1> 	push	si
  8029 00006FD6 1E                  <1> 	push	ds
  8030 00006FD7 BB4000              <1> 	mov	bx,biosdseg
  8031 00006FDA 8EDB                <1> 	mov	ds,bx
  8032 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
  8033 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  8034 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  8035 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  8036 00006FE6 89D3                <1> 	mov	bx,dx
  8037 00006FE8 D1E3                <1> 	shl	bx,1
  8038 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  8039 00006FED 09D2                <1> 	or	dx,dx
  8040 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  8041                              <1> 
  8042 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  8043                              <1> 
  8044 00006FF3 08E4                <1> 	or	ah,ah
  8045 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  8046 00006FF7 FECC                <1> 	dec	ah
  8047 00006FF9 7503E919AD          <1> 	jz	int_17_fn01		; AH = 01h
  8048 00006FFE FECC                <1> 	dec	ah
  8049 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  8050                              <1> 
  8051                              <1> int_17_exit:
  8052 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  8053 00007005 88D8                <1> 	mov	al,bl			; restore AL
  8054                              <1> 
  8055                              <1> int_17_error:
  8056 00007007 1F                  <1> 	pop	ds
  8057 00007008 5E                  <1> 	pop	si
  8058 00007009 5A                  <1> 	pop	dx
  8059 0000700A 5B                  <1> 	pop	bx
  8060 0000700B CF                  <1> 	iret
  8061                              <1> 
  8062                              <1> ;=========================================================================
  8063                              <1> ; int_17_fn00 - Print character
  8064                              <1> ; Input:
  8065                              <1> ;	AH = 0 - function 00h - print character
  8066                              <1> ;	AL = character to print
  8067                              <1> ;	DX = printer port number (0-2)
  8068                              <1> ; Output:
  8069                              <1> ;	AH = printer status:
  8070                              <1> ;		bit 0	= 1	- timeout error
  8071                              <1> ;		bit 1,2		- reserved
  8072                              <1> ;		bit 3	= 1	- I/O error
  8073                              <1> ;		bit 4	= 1	- printed selected
  8074                              <1> ;		bit 5	= 1	- out of paper
  8075                              <1> ;		bit 6	= 1	- acknowledge from printer
  8076                              <1> ;		bit 7	= 1	- printer not busy
  8077                              <1> ;-------------------------------------------------------------------------
  8078                              <1> int_17_fn00:
  8079 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  8080 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8081                              <1> 					; OPTIMIZATION:
  8082                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8083 0000700E EC                  <1> 	in	al,dx			; read status
  8084 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  8085 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  8086 00007014 750C                <1>         jnz     .not_busy
  8087                              <1> 
  8088 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  8089 00007019 CD15                <1> 	int	15h			; call OS hook
  8090                              <1> 
  8091 0000701B B780                <1> 	mov	bh,prn_stat_busy
  8092 0000701D E836AC              <1> 	call	wait_for_port		; wait for printer to be ready
  8093 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  8094                              <1> 
  8095                              <1> .not_busy:
  8096 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  8097                              <1> 					; OPTIMIZATION:
  8098                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  8099 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  8100 00007025 EE                  <1> 	out	dx,al			; activate strobe
  8101 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  8102 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  8103 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  8104 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  8105 0000702E EBD2                <1> 	jmp	int_17_exit
  8106                              <1> 
  8107                              <1> .timeout:
  8108 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  8109 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  8110 00007036 EBCA                <1> 	jmp	int_17_exit
  8111                              <1> 
  8112                              <1> ;=========================================================================
  8113                              <1> ; int_17_fn02 - Return printer status
  8114                              <1> ; Input:
  8115                              <1> ;	AH = 2 - function 02h - return printer status
  8116                              <1> ;	DX = printer port number (0-2)
  8117                              <1> ; Output:
  8118                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  8119                              <1> ;-------------------------------------------------------------------------
  8120                              <1> int_17_fn02:
  8121 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8122                              <1> 					; OPTIMIZATION:
  8123                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8124                              <1> int_17_status:
  8125 00007039 EC                  <1> 	in	al,dx			; read the status
  8126 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  8127 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  8128 0000703F EBC1                <1> 	jmp	int_17_exit
  8129                                  %include	"video.inc"		; INT 10
  8130                              <1> ;=========================================================================
  8131                              <1> ; video.inc - BIOS video services
  8132                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  8133                              <1> ;-------------------------------------------------------------------------
  8134                              <1> ;
  8135                              <1> ; Compiles with NASM 2.07, might work with other versions
  8136                              <1> ;
  8137                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  8138                              <1> ;
  8139                              <1> ; This program is free software: you can redistribute it and/or modify
  8140                              <1> ; it under the terms of the GNU General Public License as published by
  8141                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8142                              <1> ; (at your option) any later version.
  8143                              <1> ;
  8144                              <1> ; This program is distributed in the hope that it will be useful,
  8145                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8146                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8147                              <1> ; GNU General Public License for more details.
  8148                              <1> ;
  8149                              <1> ; You should have received a copy of the GNU General Public License
  8150                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8151                              <1> ;
  8152                              <1> ;=========================================================================
  8153                              <1> 
  8154                              <1> ;-------------------------------------------------------------------------
  8155                              <1> ; CRTC registers
  8156                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  8157                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  8158                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  8159                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  8160                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  8161                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  8162                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  8163                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  8164                              <1> 
  8165                              <1> ;-------------------------------------------------------------------------
  8166                              <1> ; control characters
  8167                              <1> bel	equ	07h
  8168                              <1> bs	equ	08h
  8169                              <1> lf	equ	0Ah
  8170                              <1> cr	equ	0Dh
  8171                              <1> 
  8172 00007041 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  8173          ******************  <1>  warning: (setloc:7) Inserting 4 bytes
  8174                              <1> 
  8175                              <1> int_10_dispatch:
  8176 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
  8177 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  8178 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
  8179 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  8180 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
  8181 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
  8182 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
  8183 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
  8184 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
  8185 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
  8186 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
  8187 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
  8188 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  8189 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  8190 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
  8191 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
  8192                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  8193                              <1> 
  8194                              <1> 
  8195                              <1> ;-------------------------------------------------------------------------
  8196                              <1> ; offsets for registers on stack
  8197                              <1> 
  8198                              <1> int_10_ax	equ	0
  8199                              <1> int_10_al	equ	int_10_ax
  8200                              <1> int_10_ah	equ	int_10_ax+1
  8201                              <1> int_10_bx	equ	int_10_ax+2
  8202                              <1> int_10_bl	equ	int_10_bx
  8203                              <1> int_10_bh	equ	int_10_bx+1
  8204                              <1> int_10_cx	equ	int_10_bx+2
  8205                              <1> int_10_ch	equ	int_10_cx+1
  8206                              <1> int_10_dx	equ	int_10_cx+2
  8207                              <1> 
  8208                              <1> ;=========================================================================
  8209                              <1> ; int_10 - BIOS video services
  8210                              <1> ; Input:
  8211                              <1> ;	AH - Function
  8212                              <1> ;		00h - Set video mode
  8213                              <1> ;		01h - Set text mode cursor shape
  8214                              <1> ;		02h - Set cursor position
  8215                              <1> ;		03h - Get cursor position and shape
  8216                              <1> ;		04h - Read light pen position
  8217                              <1> ;		05h - Select active display page
  8218                              <1> ;		06h - Scroll up window
  8219                              <1> ;		07h - Scroll down window
  8220                              <1> ;		08h - Read character and attribute at cursor position
  8221                              <1> ;		09h - Write character and attribute at cursor position
  8222                              <1> ;		0Ah - Write character only at cursor position
  8223                              <1> ;		0Bh -
  8224                              <1> ;			BH = 00h - Set background/border color
  8225                              <1> ;			BH = 01h - Set palette
  8226                              <1> ;		0Ch - Write graphics pixel
  8227                              <1> ;		0Dh - Read graphics pixel
  8228                              <1> ;		0Eh - Teletype output
  8229                              <1> ;		0Fh - Get current video mode
  8230                              <1> ;-------------------------------------------------------------------------
  8231                              <1> 	setloc	0F065h			; int 10 Entry Point
  8232                              <1> int_10:
  8233 00007065 FB                  <1> 	sti
  8234 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  8235 00007067 55                  <1> 	push	bp
  8236 00007068 06                  <1> 	push	es
  8237 00007069 1E                  <1> 	push	ds
  8238 0000706A 56                  <1> 	push	si
  8239 0000706B 57                  <1> 	push	di
  8240 0000706C 52                  <1> 	push	dx
  8241 0000706D 51                  <1> 	push	cx
  8242 0000706E 53                  <1> 	push	bx
  8243 0000706F 50                  <1> 	push	ax
  8244 00007070 BB4000              <1> 	mov	bx,biosdseg
  8245 00007073 8EDB                <1> 	mov	ds,bx
  8246 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  8247 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  8248 0000707C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  8249 0000707F 7202                <1> 	jb	.color			; it is CGA
  8250 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  8251                              <1> 
  8252                              <1> .color:
  8253 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  8254 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  8255 00007087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  8256 0000708A 730B                <1> 	jae	.exit			; invalid function
  8257 0000708C B700                <1> 	mov	bh,0
  8258 0000708E 88E3                <1> 	mov	bl,ah
  8259 00007090 D1E3                <1> 	shl	bx,1
  8260 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  8261                              <1> 
  8262                              <1> .exit:
  8263 00007097 58                  <1> 	pop	ax
  8264 00007098 5B                  <1> 	pop	bx
  8265 00007099 59                  <1> 	pop	cx
  8266 0000709A 5A                  <1> 	pop	dx
  8267 0000709B 5F                  <1> 	pop	di
  8268 0000709C 5E                  <1> 	pop	si
  8269 0000709D 1F                  <1> 	pop	ds
  8270 0000709E 07                  <1> 	pop	es
  8271 0000709F 5D                  <1> 	pop	bp
  8272 000070A0 CF                  <1> 	iret
  8273                              <1> 
  8274                              <1> 
  8275                              <1> ;=========================================================================
  8276                              <1> ; int_1D - Video parameters tables
  8277                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  8278                              <1> ; video mode initialization
  8279                              <1> ;-------------------------------------------------------------------------
  8280 000070A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  8281          ******************  <1>  warning: (setloc:7) Inserting 3 bytes
  8282                              <1> int_1D:
  8283                              <1> 	; CGA test 40x25 modes
  8284 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  8285 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8286                              <1> 
  8287                              <1> 	; CGA text 80x25 modes
  8288 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  8289 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8290                              <1> 
  8291                              <1> 	; CGA graphics modes
  8292 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  8293 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  8294                              <1> 
  8295                              <1> 	; MDA text 80x25 mode
  8296 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  8297 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  8298                              <1> 
  8299                              <1> page_size:
  8300 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  8301 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  8302 000070E8 0040                <1> 	dw	4000h			; graphics modes
  8303 000070EA 0040                <1> 	dw	4000h
  8304                              <1> 
  8305                              <1> columns:
  8306 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  8307 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  8308 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  8309 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  8310                              <1> 
  8311 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  8312                              <1> 
  8313 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  8314                              <1> 
  8315                              <1> ;=========================================================================
  8316                              <1> ; int_10_fn00 - Set video mode
  8317                              <1> ; Input:
  8318                              <1> ;	AH = 00h
  8319                              <1> ;	AL = video mode
  8320                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  8321                              <1> ;		01h - CGA - text 40x25, 16 colors
  8322                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  8323                              <1> ;		03h - CGA - text 80x25, 16 colors
  8324                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  8325                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  8326                              <1> ;		06h - CGA - graphics 640x200, monochrome
  8327                              <1> ;		07h - MDA - text 80x25, monochrome
  8328                              <1> ;-------------------------------------------------------------------------
  8329                              <1> int_10_fn00:
  8330 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  8331 00007107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  8332 0000710A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  8333 0000710D B000                <1> 	mov	al,0
  8334 0000710F 80FB07              <1> 	cmp	bl,07h
  8335 00007112 7206                <1> 	jb	.color			; jump if monochrome mode
  8336 00007114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  8337 00007116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  8338 00007118 FEC0                <1> 	inc	al
  8339                              <1> 
  8340                              <1> .color:
  8341 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  8342 0000711C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  8343 00007120 80C204              <1> 	add	dl,4
  8344 00007123 EE                  <1> 	out	dx,al			; Reset the video
  8345 00007124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  8346 00007128 B700                <1> 	mov	bh,0
  8347 0000712A 53                  <1> 	push	bx
  8348 0000712B 06                  <1> 	push	es
  8349 0000712C 31C0                <1> 	xor	ax,ax
  8350 0000712E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  8351 00007130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  8352 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  8353 0000713A 01DE                <1> 	add	si,bx
  8354                              <1> 
  8355 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  8356 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  8357 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  8358                              <1> 
  8359 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  8360                              <1> 
  8361                              <1> .setup_crt_loop:
  8362 00007149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  8363 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  8364 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  8365 00007151 46                  <1> 	inc	si			;  ...point to next
  8366 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  8367 00007154 07                  <1> 	pop	es
  8368 00007155 31FF                <1> 	xor	di,di
  8369 00007157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  8370 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  8371 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  8372 0000715F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  8373 00007161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  8374 00007163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  8375                              <1> 
  8376                              <1> .text_fill:
  8377 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  8378                              <1> 
  8379                              <1> .clear_screen:
  8380 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  8381                              <1> 
  8382 0000716B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  8383 0000716F 80C204              <1> 	add	dl,4
  8384 00007172 5B                  <1> 	pop	bx
  8385 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  8386 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  8387 00007179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  8388 0000717C 42                  <1> 	inc	dx
  8389 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  8390 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  8391 00007182 7502                <1> 	jnz	.set_palette
  8392 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  8393                              <1> 
  8394                              <1> .set_palette:
  8395 00007186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  8396 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  8397                              <1> 
  8398 0000718A 8CD8                <1> 	mov	ax,ds
  8399 0000718C 8EC0                <1> 	mov	es,ax
  8400 0000718E 31C0                <1> 	xor	ax,ax
  8401 00007190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  8402 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  8403 00007196 BF4E00              <1> 	mov	di,video_page_offt
  8404 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  8405                              <1> 
  8406 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  8407 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  8408 000071A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  8409                              <1> 					; but it means that for mode 7
  8410                              <1> 					; we'll get graphics page size?!
  8411 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  8412 000071AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  8413 000071AE C3                  <1> 	ret
  8414                              <1> 
  8415                              <1> ;=========================================================================
  8416                              <1> ; int_10_fn01 - Set text-mode cursor shape
  8417                              <1> ; Input:
  8418                              <1> ;	AH = 01h
  8419                              <1> ;	CH = cursor scan line start
  8420                              <1> ;	CL = cursor scan line end
  8421                              <1> ; Output:
  8422                              <1> ;	none
  8423                              <1> ;-------------------------------------------------------------------------
  8424                              <1> int_10_fn01:
  8425 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  8426 000071B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  8427 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  8428 000071B8 C3                  <1> 	ret
  8429                              <1> 
  8430                              <1> ;=========================================================================
  8431                              <1> ; int_10_fn02 - Set cursor position
  8432                              <1> ; Input:
  8433                              <1> ;	AH = 02h
  8434                              <1> ;	BH = page number
  8435                              <1> ;	DH = cursor row (00h is top)
  8436                              <1> ;	DL = cursor column (00h is left)
  8437                              <1> ; Output:
  8438                              <1> ;	none
  8439                              <1> ;-------------------------------------------------------------------------
  8440                              <1> int_10_fn02:
  8441 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8442 000071BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  8443 000071C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  8444                              <1> 
  8445                              <1> ;=========================================================================
  8446                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  8447                              <1> ;	BL = page
  8448                              <1> ;	DH = cursor row (00h is top)
  8449                              <1> ;	DL = cursor column (00h is left)
  8450                              <1> ;-------------------------------------------------------------------------
  8451                              <1> set_cur_pos:
  8452 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  8453 000071C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  8454 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  8455 000071CB D1E8                <1> 	shr	ax,1
  8456 000071CD 89C1                <1> 	mov	cx,ax
  8457 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  8458 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  8459                              <1> bios_set_cur_pos:
  8460 000071D4 B700                <1> 	mov	bh,0
  8461 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  8462 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  8463 000071DB C3                  <1> 	ret
  8464                              <1> 
  8465                              <1> ;=========================================================================
  8466                              <1> ; int_10_fn03 - Get cursor position and shape
  8467                              <1> ; Input:
  8468                              <1> ;	AH = 03h
  8469                              <1> ;	BH = page number
  8470                              <1> ; Output:
  8471                              <1> ;	CH = cursor start scan line
  8472                              <1> ;	CL = cursor end scan line
  8473                              <1> ;	DH = cursor row (00h is top)
  8474                              <1> ;	DL = cursor column (00h is left)
  8475                              <1> ;-------------------------------------------------------------------------
  8476                              <1> int_10_fn03:
  8477 000071DC B700                <1> 	mov	bh,0
  8478 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8479 000071E1 D0E3                <1> 	shl	bl,1
  8480 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  8481 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  8482 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  8483 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  8484 000071EF C3                  <1> 	ret
  8485                              <1> 
  8486                              <1> ;=========================================================================
  8487                              <1> ; int_10_fn04 - Read light pen position
  8488                              <1> ; Input:
  8489                              <1> ;	AH = 04h
  8490                              <1> ; Output:
  8491                              <1> ;	AH - light pen trigger flag
  8492                              <1> ;		00h not down/triggered
  8493                              <1> ;		01h down/triggered
  8494                              <1> ;	If light pen is triggered:
  8495                              <1> ;		DH = character row
  8496                              <1> ;		DL = character column
  8497                              <1> ;		CH = pixel row
  8498                              <1> ;		BX = pixel column
  8499                              <1> ;-------------------------------------------------------------------------
  8500                              <1> int_10_fn04:
  8501 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  8502 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  8503 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  8504 000071FB EC                  <1> 	in	al,dx			; read it
  8505 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  8506 000071FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  8507 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  8508 00007202 7501                <1> 	jnz	.read_pen		; continue if triggered
  8509 00007204 C3                  <1> 	ret				; not triggered - return
  8510                              <1> 
  8511                              <1> .read_pen:
  8512 00007205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  8513 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  8514 0000720B EE                  <1> 	out	dx,al			; select it
  8515 0000720C 42                  <1> 	inc	dx			; CRTC data register
  8516 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  8517 0000720E 88C4                <1> 	mov	ah,al
  8518 00007210 4A                  <1> 	dec	dx			; CRTC index register
  8519 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  8520 00007213 EE                  <1> 	out	dx,al			; select it
  8521 00007214 42                  <1> 	inc	dx			; CRTC data register
  8522 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  8523                              <1> 
  8524 00007216 B700                <1> 	mov	bh,0
  8525 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  8526 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  8527 00007221 29D8                <1> 	sub	ax,bx
  8528 00007223 7902                <1> 	jns	.1
  8529 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  8530                              <1> 
  8531                              <1> .1:
  8532 00007227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  8533 0000722A 7325                <1> 	jnb	.text			; calculate character position if text
  8534 0000722C B228                <1> 	mov	dl,40			; divide by 40
  8535 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  8536 00007230 B700                <1> 	mov	bh,0
  8537 00007232 88E3                <1> 	mov	bl,ah
  8538 00007234 B103                <1> 	mov	cl,3
  8539 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  8540 00007238 88C5                <1> 	mov	ch,al
  8541 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  8542 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  8543 0000723E 88C6                <1> 	mov	dh,al
  8544 00007240 D0EE                <1> 	shr	dh,1
  8545 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  8546 00007244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  8547 00007249 751A                <1> 	jnz	.exit
  8548 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  8549 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  8550 0000724F EB14                <1> 	jmp	.exit
  8551                              <1> 
  8552                              <1> .text:
  8553 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  8554 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  8555 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  8556 00007259 B103                <1> 	mov	cl,3
  8557 0000725B D2E4                <1> 	shl	ah,cl
  8558 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  8559 0000725F B700                <1> 	mov	bh,0
  8560 00007261 88C3                <1> 	mov	bl,al
  8561 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  8562                              <1> 
  8563                              <1> .exit:
  8564 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  8565 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  8566 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  8567 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  8568                              <1> 
  8569                              <1> .reset_pen:
  8570 00007272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  8571 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  8572 00007279 EE                  <1> 	out	dx,al			; reset it
  8573 0000727A C3                  <1> 	ret
  8574                              <1> 
  8575                              <1> .correction:
  8576 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  8577                              <1> 
  8578                              <1> ;=========================================================================
  8579                              <1> ; int_10_fn05 - Select active display page
  8580                              <1> ; Input:
  8581                              <1> ;	AH = 05h
  8582                              <1> ;	AL - new page number (00h is the first page)
  8583                              <1> ; Output:
  8584                              <1> ;	none
  8585                              <1> ;-------------------------------------------------------------------------
  8586                              <1> int_10_fn05:
  8587 00007283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  8588 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  8589 00007288 B400                <1> 	mov	ah,0
  8590 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  8591 0000728E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  8592 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  8593 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  8594 00007295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  8595 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  8596                              <1> 
  8597 0000729A B700                <1> 	mov	bh,0
  8598 0000729C D1E3                <1> 	shl	bx,1
  8599 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  8600 000072A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  8601 000072A4 D1E8                <1> 	shr	ax,1
  8602 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  8603 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  8604 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  8605 000072AD C3                  <1> 	ret
  8606                              <1> 
  8607                              <1> ;=========================================================================
  8608                              <1> ; int_10_fn06 - scroll up window
  8609                              <1> ; int_10_fn07 - scroll down window
  8610                              <1> ; Input:
  8611                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  8612                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  8613                              <1> ;	BH = attribute used to write blank rows at bottom of window
  8614                              <1> ;	CH,CL = row,column of window's upper left corner
  8615                              <1> ;	DH,DL = row,column of window's lower right corner
  8616                              <1> ; Output:
  8617                              <1> ;	none
  8618                              <1> ; TODO:
  8619                              <1> ;	optimize graphics fill
  8620                              <1> ;-------------------------------------------------------------------------
  8621                              <1> int_10_fn06:
  8622                              <1> int_10_fn07:
  8623 000072AE E86604              <1> 	call	vid_check_mode
  8624 000072B1 7303E9D900          <1> 	jb	.graphics_scroll
  8625                              <1> 
  8626 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  8627 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  8628 000072BD 720A                <1> 	jb	.no_snow
  8629 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  8630 000072C4 7703                <1> 	ja	.no_snow
  8631 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  8632                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  8633                              <1> .no_snow:
  8634 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  8635 000072CC 50                  <1> 	push	ax
  8636 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  8637 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  8638 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  8639                              <1> 
  8640                              <1> .1:
  8641 000072D6 E89804              <1> 	call	vid_position_to_offset
  8642 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  8643 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  8644                              <1> 
  8645                              <1> ; calculate scroll window size (DX)
  8646                              <1> 
  8647 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  8648 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  8649 000072E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  8650                              <1> 
  8651                              <1> ; calculate offset between the source and the destination (AX)
  8652                              <1> 
  8653 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  8654 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  8655 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  8656 000072F0 52                  <1> 	push    dx
  8657 000072F1 B400                <1>         mov     ah,0
  8658 000072F3 F7E3                <1>         mul     bx
  8659 000072F5 5A                  <1>         pop     dx
  8660                              <1> 
  8661 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  8662 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  8663 000072FA 1E                  <1> 	push	ds
  8664 000072FB 8CC1                <1> 	mov	cx,es
  8665 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  8666 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  8667 00007303 7405                <1> 	jz	.2			; jump if scroll up
  8668 00007305 F7D8                <1> 	neg	ax			; negate offset
  8669 00007307 F7DB                <1> 	neg	bx			; negate distance
  8670 00007309 FD                  <1> 	std				; copy backwards
  8671                              <1> 
  8672                              <1> .2:
  8673 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  8674 0000730D 08C9                <1> 	or	cl,cl
  8675 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  8676 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  8677 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  8678 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  8679                              <1> 
  8680 00007316 09DB                <1> 	or	bx,bx
  8681 00007318 7434                <1> 	jz	.text_full_row_scroll
  8682                              <1> 
  8683                              <1> .text_scroll_loop:
  8684 0000731A B500                <1> 	mov	ch,0
  8685 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  8686                              <1> 
  8687 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  8688 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  8689 00007322 E85800              <1> 	call	.retrace_wait
  8690                              <1> 
  8691                              <1> .text_scroll_no_retrace:
  8692 00007325 F3A5                <1> 	repz	movsw			; copy one row
  8693                              <1> 
  8694                              <1> ;.text_scroll_next_row:
  8695 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  8696 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  8697 0000732B FECE                <1> 	dec	dh			; decrement row counter
  8698 0000732D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  8699                              <1> 
  8700                              <1> .text_fill:
  8701 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  8702 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  8703                              <1> 
  8704                              <1> .text_fill_only:
  8705 00007334 B500                <1> 	mov	ch,0
  8706 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  8707 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  8708                              <1> 
  8709                              <1> .text_fill_loop:
  8710 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  8711 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  8712 0000733F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  8713 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  8714                              <1> 
  8715                              <1> .text_fill_no_retrace:
  8716 00007344 F3AB                <1> 	repz	stosw			; fill one row
  8717 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  8718 00007348 FECE                <1> 	dec	dh			; decrement row counter
  8719 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  8720                              <1> 
  8721 0000734C 1F                  <1> 	pop	ds
  8722 0000734D C3                  <1> 	ret
  8723                              <1> 
  8724                              <1> .text_full_row_scroll:
  8725 0000734E 09C0                <1> 	or	ax,ax
  8726 00007350 741F                <1> 	jz	.text_full_row_no_snow
  8727 00007352 50                  <1> 	push	ax
  8728 00007353 88D0                <1> 	mov	al,dl
  8729 00007355 F6E6                <1> 	mul	dh
  8730                              <1> 
  8731                              <1> .text_full_row_loop:
  8732 00007357 B9F000              <1> 	mov	cx,240
  8733 0000735A 39C8                <1> 	cmp	ax,cx
  8734 0000735C 7705                <1> 	ja	.copy_chunk
  8735 0000735E 91                  <1> 	xchg	ax,cx
  8736 0000735F 31C0                <1> 	xor	ax,ax
  8737 00007361 EB02                <1> 	jmp	.do_copy
  8738                              <1> 
  8739                              <1> .copy_chunk:
  8740 00007363 29C8                <1> 	sub	ax,cx
  8741                              <1> 
  8742                              <1> .do_copy:
  8743 00007365 E81500              <1> 	call	.retrace_wait
  8744 00007368 F3A5                <1> 	rep	movsw
  8745 0000736A 09C0                <1> 	or	ax,ax
  8746 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  8747 0000736E 58                  <1> 	pop	ax
  8748 0000736F EBBE                <1> 	jmp	.text_fill
  8749                              <1> 
  8750                              <1> .text_full_row_no_snow:
  8751 00007371 50                  <1> 	push	ax
  8752 00007372 88D0                <1> 	mov	al,dl
  8753 00007374 F6E6                <1> 	mul	dh
  8754 00007376 89C1                <1> 	mov	cx,ax
  8755 00007378 F3A5                <1> 	rep	movsw
  8756 0000737A 58                  <1> 	pop	ax
  8757 0000737B EBB2                <1> 	jmp	.text_fill
  8758                              <1> 
  8759                              <1> ;-------------------------------------------------------------------------
  8760                              <1> ; .retrace_wait - next till the next vertical retrace
  8761                              <1> 
  8762                              <1> .retrace_wait:
  8763 0000737D 50                  <1> 	push	ax
  8764 0000737E 52                  <1> 	push	dx
  8765 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  8766                              <1> 
  8767                              <1> .retrace_wait_not_set:
  8768 00007382 EC                  <1> 	in	al,dx
  8769 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8770 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  8771                              <1> 
  8772                              <1> .retrace_wait_set:
  8773 00007387 EC                  <1> 	in	al,dx
  8774 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8775 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  8776 0000738C 5A                  <1> 	pop	dx
  8777 0000738D 58                  <1> 	pop	ax
  8778                              <1> 
  8779                              <1> .retrace_exit:
  8780 0000738E C3                  <1> 	ret
  8781                              <1> 
  8782                              <1> ;-------------------------------------------------------------------------
  8783                              <1> ; .graphics_scroll - scroll for graphics modes
  8784                              <1> 
  8785                              <1> .graphics_scroll:
  8786 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  8787 00007392 50                  <1> 	push	ax
  8788 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  8789 00007397 7403                <1> 	jz	.3			; jump if scroll down
  8790 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  8791                              <1> 
  8792                              <1> .3:
  8793 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  8794 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  8795                              <1> 
  8796                              <1> ; calculate scroll windows size (DX)
  8797                              <1> 
  8798 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  8799 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  8800 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  8801 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  8802 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  8803 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  8804 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  8805 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  8806 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  8807 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  8808 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  8809 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  8810 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  8811                              <1> 
  8812                              <1> .4:
  8813 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  8814 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  8815 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  8816                              <1> 					;   for copying backwards
  8817                              <1> 
  8818                              <1> .5:
  8819 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  8820 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  8821 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  8822 000073CF 53                  <1> 	push	bx
  8823 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  8824 000073D2 B050                <1> 	mov	al,50h
  8825 000073D4 F6E3                <1> 	mul	bl
  8826 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  8827 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  8828 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  8829 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  8830 000073E1 BB5020              <1> 	mov	bx,2050h
  8831 000073E4 FD                  <1> 	std				; copy backwards
  8832                              <1> 
  8833                              <1> .6:
  8834 000073E5 89FE                <1> 	mov	si,di
  8835 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  8836 000073E9 58                  <1> 	pop	ax
  8837 000073EA 8CC1                <1> 	mov	cx,es
  8838 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  8839 000073EE 08C0                <1> 	or	al,al
  8840 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  8841 000073F2 50                  <1> 	push	ax
  8842                              <1> 
  8843                              <1> .graphics_scroll_loop:
  8844 000073F3 B500                <1> 	mov	ch,0
  8845 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  8846 000073F7 56                  <1> 	push	si
  8847 000073F8 57                  <1> 	push	di
  8848 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  8849 000073FB 5F                  <1> 	pop	di
  8850 000073FC 5E                  <1> 	pop	si
  8851 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  8852 00007401 81C70020            <1> 	add	di,2000h
  8853 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  8854 00007407 56                  <1> 	push	si
  8855 00007408 57                  <1> 	push	di
  8856 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  8857 0000740B 5F                  <1> 	pop	di
  8858 0000740C 5E                  <1> 	pop	si
  8859 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  8860 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  8861 00007411 FECE                <1> 	dec	dh			; decrement row counter
  8862 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  8863                              <1> 
  8864 00007415 58                  <1> 	pop	ax
  8865 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  8866                              <1> 
  8867                              <1> .graphics_fill:
  8868 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  8869 0000741B B500                <1> 	mov	ch,0
  8870                              <1> 
  8871                              <1> .graphics_fill_loop:
  8872 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  8873 0000741F 57                  <1> 	push	di
  8874 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  8875 00007422 5F                  <1> 	pop	di
  8876 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  8877 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  8878 00007429 57                  <1> 	push	di
  8879 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  8880 0000742C 5F                  <1> 	pop	di
  8881 0000742D 29DF                <1> 	sub	di,bx
  8882 0000742F FECE                <1> 	dec	dh			; decrement row counter
  8883 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  8884 00007433 C3                  <1> 	ret
  8885                              <1> 
  8886                              <1> ;=========================================================================
  8887                              <1> ; int_10_fn08 - Read character and attribute
  8888                              <1> ; Input:
  8889                              <1> ;	AH = 08h
  8890                              <1> ; Output:
  8891                              <1> ;	AL - character read
  8892                              <1> ;	BH - video attribute (text modes only)
  8893                              <1> ; int_10_fn09 - Write character and attribute
  8894                              <1> ; Input:
  8895                              <1> ;	AH = 09h
  8896                              <1> ;	AL - character to write
  8897                              <1> ;	BH - page number
  8898                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  8899                              <1> ;	CX - number of times to write character
  8900                              <1> ; Output:
  8901                              <1> ;	none
  8902                              <1> ; int_10_fn0A - Write character only
  8903                              <1> ; Input:
  8904                              <1> ;	AH = 0Ah
  8905                              <1> ;	AL - character to write
  8906                              <1> ;	BH - page number
  8907                              <1> ;	CX - repeat count
  8908                              <1> ; Output:
  8909                              <1> ;	none
  8910                              <1> ;-------------------------------------------------------------------------
  8911                              <1> int_10_fn08:
  8912                              <1> int_10_fn09:
  8913                              <1> int_10_fn0A:
  8914 00007434 E8E002              <1> 	call	vid_check_mode
  8915 00007437 7277                <1> 	jb	.graphics		; jump if graphics mode
  8916 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  8917 0000743C B700                <1> 	mov	bh,0
  8918 0000743E 53                  <1> 	push	bx
  8919 0000743F E82803              <1> 	call	vid_current_offset
  8920 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  8921 00007444 58                  <1> 	pop	ax			; AX = page number
  8922 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  8923 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  8924 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  8925 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  8926 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  8927 00007454 1E                  <1> 	push	ds
  8928 00007455 8CC3                <1> 	mov	bx,es
  8929 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  8930 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  8931 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  8932 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  8933                              <1> 
  8934                              <1> .read_retrace_wait:
  8935 00007460 EC                  <1> 	in	al,dx
  8936 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8937 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  8938 00007465 FA                  <1> 	cli
  8939                              <1> 
  8940                              <1> .read_no_retrace_wait:
  8941 00007466 EC                  <1> 	in	al,dx
  8942 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8943 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  8944                              <1> 
  8945 0000746B AD                  <1> 	lodsw				; read character and attribute
  8946 0000746C FB                  <1> 	sti
  8947 0000746D 1F                  <1> 	pop	ds
  8948 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  8949 00007471 C3                  <1> 	ret
  8950                              <1> 
  8951                              <1> .text_write:
  8952 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  8953 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  8954 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  8955 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  8956 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  8957                              <1> 
  8958                              <1> .write_char_retrace:
  8959 0000747F EC                  <1> 	in	al,dx
  8960 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8961 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  8962                              <1> 
  8963                              <1> .write_retrace_wait1:
  8964 00007484 EC                  <1> 	in	al,dx
  8965 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8966 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  8967 00007489 FA                  <1> 	cli
  8968                              <1> 
  8969                              <1> .write_no_retrace_wait1:
  8970 0000748A EC                  <1> 	in	al,dx
  8971 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8972 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  8973                              <1> 
  8974                              <1> .do_write_char_attr:
  8975 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  8976 00007491 AB                  <1> 	stosw				; write it to video memory
  8977 00007492 FB                  <1> 	sti
  8978 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  8979 00007495 1F                  <1> 	pop	ds
  8980 00007496 C3                  <1> 	ret
  8981                              <1> 
  8982                              <1> .text_write_char_only:
  8983 00007497 EC                  <1> 	in	al,dx
  8984 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  8985 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  8986                              <1> 
  8987                              <1> .write_retrace_wait2:
  8988 0000749C EC                  <1> 	in	al,dx
  8989 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8990 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  8991 000074A1 FA                  <1> 	cli
  8992                              <1> 
  8993                              <1> .write_no_retrace_wait2:
  8994 000074A2 EC                  <1> 	in	al,dx
  8995 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  8996 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  8997                              <1> 
  8998                              <1> .do_write_char_only:
  8999 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  9000 000074A9 AA                  <1> 	stosb				; write it to video memory
  9001 000074AA FB                  <1> 	sti
  9002 000074AB 47                  <1> 	inc	di			; skip attribute
  9003 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  9004 000074AE 1F                  <1> 	pop	ds
  9005 000074AF C3                  <1> 	ret
  9006                              <1> 
  9007                              <1> .graphics:
  9008 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  9009 000074B4 7503E9B300          <1> 	jz	.graphics_read
  9010                              <1> 
  9011 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  9012 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  9013 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  9014 000074C1 1E                  <1> 	push	ds
  9015 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  9016 000074C5 B400                <1> 	mov	ah,0
  9017 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  9018 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  9019 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  9020 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  9021 000074D0 EB0C                <1> 	jmp	.CG9_03
  9022                              <1> 
  9023                              <1> .CG9_02:
  9024 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  9025 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  9026 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  9027 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  9028 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  9029                              <1> 
  9030                              <1> .CG9_03:
  9031 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  9032 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  9033 000074E1 D3E0                <1> 	shl	ax,cl
  9034 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  9035 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  9036 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  9037 000074ED 1E                  <1> 	push	ds
  9038 000074EE 8EDA                <1> 	mov	ds,dx
  9039 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  9040 000074F2 D1E7                <1> 	shl	di,1
  9041 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  9042 000074F7 83E003              <1> 	and	ax,3
  9043 000074FA BB5555              <1> 	mov	bx,5555h
  9044 000074FD F7E3                <1> 	mul	bx
  9045 000074FF 89C2                <1> 	mov	dx,ax
  9046 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  9047                              <1> 
  9048                              <1> .CG9_04:
  9049 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  9050 00007506 57                  <1> 	push	di
  9051 00007507 56                  <1> 	push	si
  9052                              <1> 
  9053                              <1> .CG9_05:
  9054 00007508 AC                  <1> 	lodsb				; Read the screen
  9055 00007509 51                  <1> 	push	cx
  9056 0000750A 53                  <1> 	push	bx
  9057 0000750B 31DB                <1> 	xor	bx,bx
  9058 0000750D B90800              <1> 	mov	cx,8
  9059                              <1> 
  9060                              <1> .CG9_06:
  9061 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  9062 00007512 D1DB                <1> 	rcr	bx,1
  9063 00007514 D1FB                <1> 	sar	bx,1
  9064 00007516 E2F8                <1> 	loop	.CG9_06
  9065                              <1> 
  9066 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  9067 0000751A 5B                  <1> 	pop	bx
  9068 0000751B 59                  <1> 	pop	cx
  9069 0000751C 21D0                <1> 	and	ax,dx
  9070 0000751E 86E0                <1> 	xchg	ah,al
  9071 00007520 08DB                <1> 	or	bl,bl
  9072 00007522 7903                <1> 	jns	.CG9_07
  9073 00007524 263305              <1>     es	xor	ax,word [di]
  9074                              <1> 
  9075                              <1> .CG9_07:
  9076 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  9077 0000752A 81F70020            <1> 	xor	di,2000h
  9078 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  9079 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  9080 00007534 83C750              <1> 	add	di,50h			; Else advance character
  9081                              <1> 
  9082                              <1> .CG9_08:
  9083 00007537 FECF                <1> 	dec	bh			; Show another char written
  9084 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  9085 0000753B 5E                  <1> 	pop	si
  9086 0000753C 5F                  <1> 	pop	di
  9087 0000753D 47                  <1> 	inc	di
  9088 0000753E 47                  <1> 	inc	di
  9089 0000753F E2C3                <1> 	loop	.CG9_04
  9090 00007541 1F                  <1> 	pop	ds
  9091 00007542 C3                  <1> 	ret
  9092                              <1> 
  9093                              <1> .CG8_02:
  9094 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  9095 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  9096                              <1> 
  9097                              <1> .CG8_03:
  9098 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  9099 0000754B 57                  <1> 	push	di
  9100 0000754C 56                  <1> 	push	si
  9101                              <1> 
  9102                              <1> .CG8_04:
  9103 0000754D AC                  <1> 	lodsb				; Read from one plane
  9104 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  9105 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  9106 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  9107                              <1> 
  9108                              <1> .CG8_05:
  9109 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  9110 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  9111 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  9112 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  9113 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  9114                              <1> 
  9115                              <1> .CG8_06:
  9116 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  9117 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  9118 00007565 5E                  <1> 	pop	si
  9119 00007566 5F                  <1> 	pop	di
  9120 00007567 47                  <1> 	inc	di
  9121 00007568 E2DF                <1> 	loop	.CG8_03
  9122 0000756A 1F                  <1> 	pop	ds
  9123 0000756B C3                  <1> 	ret
  9124                              <1> 
  9125                              <1> .graphics_read:
  9126 0000756C FC                  <1> 	cld				; Increment upwards
  9127 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  9128 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  9129 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  9130 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  9131 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  9132 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  9133 0000757F 8CC0                <1> 	mov	ax,es
  9134 00007581 1E                  <1> 	push	ds
  9135 00007582 57                  <1> 	push	di
  9136 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  9137 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  9138 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  9139 00007589 D1E6                <1> 	shl	si,1
  9140 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  9141                              <1> 
  9142                              <1> CGR_02:
  9143 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  9144 00007590 86E0                <1> 	xchg	ah,al
  9145 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  9146 00007595 B200                <1> 	mov	dl,0
  9147                              <1> 
  9148                              <1> CGR_03:
  9149 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  9150 00007599 F8                  <1> 	clc
  9151 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  9152 0000759C F9                  <1> 	stc				; Else show not set
  9153                              <1> 
  9154                              <1> CGR_04:
  9155 0000759D D0D2                <1> 	rcl	dl,1
  9156 0000759F D1E9                <1> 	shr	cx,1
  9157 000075A1 D1E9                <1> 	shr	cx,1
  9158 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  9159 000075A5 368815              <1>     ss	mov	byte [di],dl
  9160 000075A8 47                  <1> 	inc	di
  9161 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  9162 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  9163 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  9164 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  9165                              <1> 
  9166                              <1> CGR_05:
  9167 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  9168 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  9169 000075B6 EB17                <1> 	jmp	short	CGR_08
  9170                              <1> 
  9171                              <1> CGR_06:
  9172 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  9173                              <1> 
  9174                              <1> CGR_07:
  9175 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  9176 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  9177 000075BF 47                  <1> 	inc	di			;  ...advance
  9178 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  9179 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  9180 000075C7 47                  <1> 	inc	di			;  ...advance
  9181 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  9182 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  9183 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  9184                              <1> 
  9185                              <1> CGR_08:
  9186 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  9187 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  9188 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  9189 000075D6 8CD2                <1> 	mov	dx,ss
  9190 000075D8 8EDA                <1> 	mov	ds,dx
  9191 000075DA 5E                  <1> 	pop	si
  9192 000075DB B000                <1> 	mov	al,0
  9193                              <1> 
  9194                              <1> CGR_09:
  9195 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  9196                              <1> 
  9197                              <1> CGR_10:
  9198 000075E0 56                  <1> 	push	si
  9199 000075E1 57                  <1> 	push	di
  9200 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  9201 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  9202 000075E7 5F                  <1> 	pop	di
  9203 000075E8 5E                  <1> 	pop	si
  9204 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  9205 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  9206 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  9207 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  9208 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  9209                              <1> 
  9210 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  9211 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  9212 000075F7 31DB                <1> 	xor	bx,bx
  9213 000075F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  9214 000075FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  9215 000075FF 8CC3                <1> 	mov	bx,es
  9216 00007601 09FB                <1> 	or	bx,di
  9217 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  9218 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  9219                              <1> 
  9220                              <1> CGR_11:
  9221 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  9222 0000760A 1F                  <1> 	pop	ds
  9223 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  9224 0000760E C3                  <1> 	ret
  9225                              <1> 
  9226                              <1> ;=========================================================================
  9227                              <1> ; int_10_fn0B - Set background color or palette
  9228                              <1> ; Input:
  9229                              <1> ; 	AH - 0Bh
  9230                              <1> ;	BH = 00h - set background / border color
  9231                              <1> ;		BL - background (graphics modes) or border (text modes)
  9232                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  9233                              <1> ;		BL - palette ID:
  9234                              <1> ;			00h - background, green, red, and yellow (brown)
  9235                              <1> ;			01h - background, cyan, magenta, and white
  9236                              <1> ; Output:
  9237                              <1> ;	none
  9238                              <1> ;-------------------------------------------------------------------------
  9239                              <1> int_10_fn0B:
  9240 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  9241 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  9242 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  9243 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  9244                              <1> 
  9245 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  9246 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  9247 00007620 08E0                <1> 	or	al,ah			; apply new color
  9248 00007622 EB09                <1> 	jmp	.write_palet_reg
  9249                              <1> 
  9250                              <1> .set_palette:
  9251 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  9252 00007626 F6C401              <1> 	test	ah,01h
  9253 00007629 7402                <1> 	jz	.write_palet_reg
  9254 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  9255                              <1> 
  9256                              <1> .write_palet_reg:
  9257 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  9258 00007630 8B166300            <1> 	mov	dx,word [video_port]
  9259 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  9260 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  9261 00007638 C3                  <1> 	ret
  9262                              <1> 
  9263                              <1> ;=========================================================================
  9264                              <1> ; int_10_fn0C - Write graphics pixel
  9265                              <1> ; Input:
  9266                              <1> ;	AH = 0Ch
  9267                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  9268                              <1> ;	CX = column
  9269                              <1> ;	DX = row
  9270                              <1> ; Output:
  9271                              <1> ;	none
  9272                              <1> ;-------------------------------------------------------------------------
  9273                              <1> int_10_fn0C:
  9274 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  9275 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9276 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9277 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  9278 00007643 2401                <1> 	and	al,1			; one bit per pixel
  9279 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9280 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  9281 00007649 EB0F                <1> 	jmp	.prepare_mask
  9282                              <1> 
  9283                              <1> .mode_320x200:
  9284 0000764B D0E1                <1> 	shl	cl,1
  9285 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9286 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  9287 00007652 2403                <1> 	and	al,3			; two bit per pixel
  9288 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9289 00007656 D0C8                <1> 	ror	al,1
  9290 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  9291                              <1> 
  9292                              <1> .prepare_mask:
  9293 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  9294 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  9295 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  9296 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  9297 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  9298 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  9299 00007667 EB04                <1> 	jmp	.write_pixel
  9300                              <1> 
  9301                              <1> .set_color:
  9302 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  9303 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  9304                              <1> 
  9305                              <1> .write_pixel:
  9306 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  9307 00007670 C3                  <1> 	ret
  9308                              <1> 
  9309                              <1> ;=========================================================================
  9310                              <1> ; int_10_fn0D - Read graphics pixel
  9311                              <1> ; Input:
  9312                              <1> ;	AH = 0Dh
  9313                              <1> ;	CX = column
  9314                              <1> ;	DX = row
  9315                              <1> ; Output:
  9316                              <1> ;	AL = pixel color 
  9317                              <1> ;-------------------------------------------------------------------------
  9318                              <1> int_10_fn0D:
  9319 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  9320 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  9321 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9322 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  9323 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  9324 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  9325 0000767F EB0A                <1> 	jmp	.exit
  9326                              <1> 
  9327                              <1> .mode_320x200:
  9328 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  9329 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  9330 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  9331 00007687 D0C0                <1> 	rol	al,1
  9332 00007689 2403                <1> 	and	al,3			; two bits per pixel
  9333                              <1> 
  9334                              <1> .exit:
  9335 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  9336 0000768E C3                  <1> 	ret
  9337                              <1> 
  9338                              <1> ;=========================================================================
  9339                              <1> ; int_10_fn0E - Teletype output
  9340                              <1> ; Input:
  9341                              <1> ;	AH = 0Eh
  9342                              <1> ;	AL = character to write
  9343                              <1> ;	BL = foreground color (graphics modes only)
  9344                              <1> ; Output:
  9345                              <1> ;	none
  9346                              <1> ; Notes:
  9347                              <1> ;	- writes character to the active video page
  9348                              <1> ;	- support following control characters: BEL, BS, LF, CR
  9349                              <1> ;-------------------------------------------------------------------------
  9350                              <1> int_10_fn0E:
  9351 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9352 00007693 B700                <1> 	mov	bh,0
  9353 00007695 D0E3                <1> 	shl	bl,1			; word index
  9354 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  9355                              <1> 
  9356 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  9357 0000769D 3C08                <1> 	cmp	al,bs
  9358 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  9359 000076A1 3C0A                <1> 	cmp	al,lf
  9360 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  9361 000076A5 3C07                <1> 	cmp	al,bel
  9362 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  9363 000076A9 3C0D                <1> 	cmp	al,cr
  9364 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  9365 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  9366 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  9367 000076B2 B90100              <1> 	mov	cx,1			; one character
  9368 000076B5 CD10                <1> 	int	10h			; write character
  9369 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  9370 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  9371 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  9372 000076BF B200                <1> 	mov	dl,0			; move to the first position
  9373                              <1> 
  9374                              <1> .lf:
  9375 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  9376 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  9377 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  9378 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  9379                              <1> 
  9380                              <1> .bs:
  9381 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  9382 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  9383 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
  9384 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  9385                              <1> 
  9386                              <1> .cr:
  9387 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  9388                              <1> 
  9389                              <1> .set_cursor_pos:
  9390 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9391 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  9392                              <1> 
  9393                              <1> .bel:
  9394 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
  9395 000076DE E857A9              <1> 	call	beep
  9396 000076E1 C3                  <1> 	ret
  9397                              <1> 
  9398                              <1> .scroll:
  9399 000076E2 B402                <1> 	mov	ah,02h
  9400 000076E4 CD10                <1> 	int	10h			; set new cursor position
  9401 000076E6 E82E00              <1> 	call	vid_check_mode
  9402 000076E9 B700                <1> 	mov	bh,0
  9403 000076EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
  9404 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  9405 000076EF CD10                <1> 	int	10h			; read attirbute at current position
  9406 000076F1 88E7                <1> 	mov	bh,ah
  9407                              <1> 
  9408                              <1> .do_scroll:
  9409 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  9410 000076F5 B001                <1> 	mov	al,1			; scroll one line
  9411 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  9412 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
  9413 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  9414 000076FF FECA                <1> 	dec	dl
  9415 00007701 CD10                <1> 	int	10h			; scroll page up
  9416 00007703 C3                  <1> 	ret
  9417                              <1> 
  9418                              <1> ;=========================================================================
  9419                              <1> ; int_10_fn0F - Get current video mode
  9420                              <1> ; Input:
  9421                              <1> ;	AH = 0Fh
  9422                              <1> ; Output:
  9423                              <1> ;	AL = video mode
  9424                              <1> ;	AH = characters per column
  9425                              <1> ;	BH = active video page
  9426                              <1> ;-------------------------------------------------------------------------
  9427                              <1> int_10_fn0F:
  9428 00007704 A04A00              <1> 	mov	al,byte [video_columns]
  9429 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
  9430 0000770A A04900              <1> 	mov	al,byte [video_mode]
  9431 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
  9432 00007710 A06200              <1> 	mov	al,byte [video_page]
  9433 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
  9434 00007716 C3                  <1> 	ret
  9435                              <1> 
  9436                              <1> ;=========================================================================
  9437                              <1> ; vid_check_mode - Check current video mode
  9438                              <1> ; Input:
  9439                              <1> ;	none
  9440                              <1> ; Output:
  9441                              <1> ;	ZF set if monochrome mode (mode 07h)
  9442                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  9443                              <1> ;-------------------------------------------------------------------------
  9444                              <1> vid_check_mode:
  9445 00007717 50                  <1> 	push	ax
  9446 00007718 A04900              <1> 	mov	al,byte [video_mode]
  9447 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  9448 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
  9449 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  9450 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  9451 00007722 7303                <1> 	jnb	.exit			; jump if not graphics
  9452 00007724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
  9453 00007726 F9                  <1> 	stc				; XXX
  9454                              <1> 
  9455                              <1> .exit:
  9456 00007727 58                  <1> 	pop	ax
  9457 00007728 C3                  <1> 	ret
  9458                              <1> 
  9459                              <1> ;=========================================================================
  9460                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  9461                              <1> ; Input:
  9462                              <1> ;	AH = register number
  9463                              <1> ;	CX = word to write
  9464                              <1> ; Output:
  9465                              <1> ;	AX trashed
  9466                              <1> ; Note:
  9467                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  9468                              <1> ;-------------------------------------------------------------------------
  9469                              <1> vid_crtc_writew:
  9470 00007729 88E8                <1> 	mov	al,ch
  9471 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  9472 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
  9473 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  9474                              <1> 
  9475                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  9476                              <1> 
  9477                              <1> ;=========================================================================
  9478                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  9479                              <1> ; Input:
  9480                              <1> ;	AH = register number
  9481                              <1> ;	AL = byte to write
  9482                              <1> ; Output:
  9483                              <1> ;	none
  9484                              <1> ;-------------------------------------------------------------------------
  9485                              <1> vid_crtc_writeb:
  9486 00007732 52                  <1> 	push	dx
  9487 00007733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  9488 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  9489 00007739 EE                  <1> 	out	dx,al			; write register number
  9490 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  9491 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
  9492 0000773E EE                  <1> 	out	dx,al			; write byte
  9493 0000773F 5A                  <1> 	pop	dx
  9494 00007740 C3                  <1> 	ret
  9495                              <1> 
  9496                              <1> ;=========================================================================
  9497                              <1> ; vid_pixel_address - calculate pixel address and mask
  9498                              <1> ; Input:
  9499                              <1> ;	CX - column
  9500                              <1> ;	DX - row
  9501                              <1> ; Output:
  9502                              <1> ;	SI - pixel address
  9503                              <1> ;	CH - pixel mask
  9504                              <1> ;	CL - pixel position in the byte
  9505                              <1> ;	ZF - mode
  9506                              <1> ;		0 = 320x200
  9507                              <1> ;		1 = 640x200
  9508                              <1> ;-------------------------------------------------------------------------
  9509                              <1> vid_pixel_address:
  9510 00007741 31F6                <1> 	xor	si,si			; SI = 0
  9511 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
  9512 00007745 7303                <1> 	jnb	.even			; jump if on even row 
  9513 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  9514                              <1> 
  9515                              <1> .even:
  9516 0000774A B050                <1> 	mov	al,50h			; bytes in each row
  9517 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
  9518                              <1> 
  9519 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
  9520 00007750 89CA                <1> 	mov	dx,cx			; DX - column
  9521 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  9522 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  9523 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
  9524 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
  9525 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  9526                              <1> 
  9527                              <1> .1:
  9528 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  9529 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  9530 00007764 01D6                <1> 	add	si,dx			; add column address to SI
  9531 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  9532 00007768 9D                  <1> 	popf
  9533 00007769 C3                  <1> 	ret
  9534                              <1> 
  9535                              <1> ;=========================================================================
  9536                              <1> ; vid_current_offset - convert current cursor position to offset
  9537                              <1> ;		       relative to page starting address
  9538                              <1> ; Input:
  9539                              <1> ;	BL = page
  9540                              <1> ; Output:
  9541                              <1> ;	AX = offset
  9542                              <1> ;-------------------------------------------------------------------------
  9543                              <1> vid_current_offset:
  9544 0000776A B700                <1> 	mov	bh,0
  9545 0000776C D1E3                <1> 	shl	bx,1				; word index
  9546 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  9547                              <1> 
  9548                              <1> ; fall through to vid_position_to_offset
  9549                              <1> 
  9550                              <1> ;=========================================================================
  9551                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  9552                              <1> ;			   relative to page starting address
  9553                              <1> ; Input:
  9554                              <1> ;	AH = row
  9555                              <1> ;	AL = column
  9556                              <1> ; Output:
  9557                              <1> ;	AX = offset
  9558                              <1> ;-------------------------------------------------------------------------
  9559                              <1> vid_position_to_offset:
  9560 00007771 53                  <1> 	push	bx
  9561 00007772 88C3                <1> 	mov	bl,al			; BL = column
  9562 00007774 88E0                <1> 	mov	al,ah			; AL = row
  9563 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  9564 0000777A B700                <1> 	mov	bh,0			;
  9565 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  9566 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  9567 00007780 5B                  <1> 	pop	bx
  9568 00007781 C3                  <1> 	ret
  9569                              <1> 
  9570                              <1> ;=========================================================================
  9571                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  9572                              <1> ; Input:
  9573                              <1> ;	AH = row
  9574                              <1> ;	AL = column
  9575                              <1> ; Output:
  9576                              <1> ;	AX = offset
  9577                              <1> ;-------------------------------------------------------------------------
  9578                              <1> vid_gfx_pos_to_offset:
  9579 00007782 53                  <1> 	push	bx
  9580 00007783 88C3                <1> 	mov	bl,al			; BL = column
  9581 00007785 88E0                <1> 	mov	al,ah			; AL = row
  9582 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  9583 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  9584 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  9585 0000778F B700                <1> 	mov	bh,0
  9586 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  9587 00007793 5B                  <1> 	pop	bx
  9588 00007794 C3                  <1> 	ret
  9589                                  
  9590                                  ;=========================================================================
  9591                                  ; int_12 - Get memory size
  9592                                  ; Input:
  9593                                  ;	none
  9594                                  ; Output:
  9595                                  ;	AX = memory size
  9596                                  ;-------------------------------------------------------------------------
  9597 00007795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
  9598          ******************       warning: (setloc:7) Inserting 172 bytes
  9599                                  int_12:
  9600 00007841 FB                      	sti
  9601 00007842 1E                      	push	ds
  9602 00007843 B84000                  	mov	ax,biosdseg
  9603 00007846 8ED8                    	mov	ds,ax
  9604 00007848 A11300                  	mov	ax,word [memory_size]
  9605 0000784B 1F                      	pop	ds
  9606 0000784C CF                      	iret
  9607                                  
  9608                                  ;=========================================================================
  9609                                  ; int_11 - Get equipment list
  9610                                  ; Input:
  9611                                  ;	none
  9612                                  ; Output:
  9613                                  ;	AX = equipment list
  9614                                  ;-------------------------------------------------------------------------
  9615                                  	setloc	0F84Dh			; INT 11 Entry Point
  9616                                  int_11:
  9617 0000784D FB                      	sti
  9618 0000784E 1E                      	push	ds
  9619 0000784F B84000                  	mov	ax,biosdseg
  9620 00007852 8ED8                    	mov	ds,ax
  9621 00007854 A11000                  	mov	ax,word [equipment_list]
  9622 00007857 1F                      	pop	ds
  9623 00007858 CF                      	iret
  9624                                  
  9625                                  ;=========================================================================
  9626                                  ; Includes with fixed entry points (for IBM compatibility)
  9627                                  ;-------------------------------------------------------------------------
  9628                                  
  9629                                  %include	"misc.inc"
  9630                              <1> ;=========================================================================
  9631                              <1> ; misc.inc - Miscellaneous BIOS Services
  9632                              <1> ;       INT 15h, functions:
  9633                              <1> ;       	4Fh	- OS hook keyboard intercept
  9634                              <1> ;		90h	- Device busy loop
  9635                              <1> ;		91h	- Interrupt completed
  9636                              <1> ;		0C0h	- Get system configruation
  9637                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  9638                              <1> ;		
  9639                              <1> ;-------------------------------------------------------------------------
  9640                              <1> ;
  9641                              <1> ; Compiles with NASM 2.07, might work with other versions
  9642                              <1> ;
  9643                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  9644                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  9645                              <1> ;
  9646                              <1> ; This program is free software: you can redistribute it and/or modify
  9647                              <1> ; it under the terms of the GNU General Public License as published by
  9648                              <1> ; the Free Software Foundation, either version 3 of the License, or
  9649                              <1> ; (at your option) any later version.
  9650                              <1> ;
  9651                              <1> ; This program is distributed in the hope that it will be useful,
  9652                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9653                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9654                              <1> ; GNU General Public License for more details.
  9655                              <1> ;
  9656                              <1> ; You should have received a copy of the GNU General Public License
  9657                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  9658                              <1> ;
  9659                              <1> ;=========================================================================
  9660                              <1> 
  9661                              <1> ;-------------------------------------------------------------------------
  9662                              <1> ; offsets for registers on stack
  9663                              <1> int_15_bp	equ	0
  9664                              <1> int_15_ip	equ	int_15_bp+2
  9665                              <1> int_15_cs	equ	int_15_ip+2
  9666                              <1> int_15_flags	equ	int_15_cs+2
  9667                              <1> 
  9668                              <1> ;=========================================================================
  9669                              <1> ; int_15 - Miscellaneous BIOS services
  9670                              <1> ; Input:
  9671                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  9672                              <1> ;		- Does nothing
  9673                              <1> ;	AH = 0C2h - PS/2 mouse services
  9674                              <1> ;		- Implemented in ps2aux.inc
  9675                              <1> ;-------------------------------------------------------------------------
  9676                              <1> 	setloc	0F859h			; INT 15 Entry Point
  9677                              <1> int_15:
  9678 00007859 FB                  <1> 	sti
  9679 0000785A 80FC4F              <1> 	cmp	ah,4Fh
  9680 0000785D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
  9681 0000785F 80FCC0              <1> 	cmp	ah,0C0h
  9682 00007862 742E                <1> 	je	int_15_fnC0
  9683 00007864 3D0190              <1> 	cmp	ax,9001h
  9684 00007867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
  9685 00007869 3DFD90              <1> 	cmp	ax,90FDh
  9686 0000786C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
  9687 0000786E 3D0191              <1> 	cmp	ax,9101h
  9688 00007871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  9689                              <1> 
  9690                              <1> %ifdef PS2_MOUSE
  9691 00007873 80FCC2              <1> 	cmp	ah,0C2h
  9692 00007876 7503                <1> 	jne	.1
  9693 00007878 E940A5              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  9694                              <1> .1:
  9695                              <1> %endif
  9696                              <1> 
  9697 0000787B B486                <1> 	mov	ah,86h			; no cassete present
  9698                              <1> 
  9699                              <1> int_15_err:
  9700 0000787D 55                  <1> 	push	bp
  9701 0000787E 89E5                <1> 	mov	bp,sp
  9702 00007880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  9703 00007884 5D                  <1> 	pop	bp
  9704 00007885 CF                  <1> 	iret
  9705                              <1> 
  9706                              <1> int_15_ok:
  9707 00007886 55                  <1> 	push	bp
  9708 00007887 89E5                <1> 	mov	bp,sp
  9709 00007889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  9710 0000788D 5D                  <1> 	pop	bp
  9711 0000788E CF                  <1> 	iret
  9712                              <1> 
  9713                              <1> int_15_os_hook:
  9714 0000788F B400                <1> 	mov	ah,00h
  9715                              <1> 
  9716                              <1> int_15_exit:
  9717 00007891 CF                  <1> 	iret
  9718                              <1> 
  9719                              <1> ;=========================================================================
  9720                              <1> ; int_15_fnC0 - Get configuration
  9721                              <1> ; Input:
  9722                              <1> ;	AH = 0C0h - get configuration
  9723                              <1> ; Output:
  9724                              <1> ;	AH = 00h - function supported
  9725                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  9726                              <1> ;	CF = 0 (success)
  9727                              <1> ;-------------------------------------------------------------------------
  9728                              <1> int_15_fnC0:
  9729 00007892 B400                <1> 	mov	ah,00h
  9730 00007894 BB00F0              <1> 	mov	bx,bioscseg
  9731 00007897 8EC3                <1> 	mov	es,bx
  9732 00007899 BB[F566]            <1> 	mov	bx,config_table
  9733 0000789C EBE8                <1> 	jmp	int_15_ok
  9734                                  %include	"fnt00-7F.inc"
  9735                              <1> ;=========================================================================
  9736                              <1> ; fnt00-7F.inc - Font for graphics modes
  9737                              <1> ;       Characters from 00h to 7Fh
  9738                              <1> ;-------------------------------------------------------------------------
  9739                              <1> ;
  9740                              <1> ; Compiles with NASM 2.07, might work with other versions
  9741                              <1> ;
  9742                              <1> ; This font is borrowed from kbd package (alt-8x8)
  9743                              <1> ;
  9744                              <1> ; This program is free software: you can redistribute it and/or modify
  9745                              <1> ; it under the terms of the GNU General Public License as published by
  9746                              <1> ; the Free Software Foundation, either version 3 of the License, or
  9747                              <1> ; (at your option) any later version.
  9748                              <1> ;
  9749                              <1> ; This program is distributed in the hope that it will be useful,
  9750                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9751                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9752                              <1> ; GNU General Public License for more details.
  9753                              <1> ;
  9754                              <1> ; You should have received a copy of the GNU General Public License
  9755                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  9756                              <1> ;
  9757                              <1> ;=========================================================================
  9758 0000789E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
  9759          ******************  <1>  warning: (setloc:7) Inserting 464 bytes
  9760                              <1> gfx_font:
  9761 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  9762 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  9763 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  9764 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  9765 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  9766 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  9767 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  9768 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  9769 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  9770 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  9771 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  9772 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  9773 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  9774 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  9775 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  9776 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  9777 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  9778 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  9779 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  9780 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  9781 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  9782 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  9783 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  9784 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  9785 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  9786 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  9787 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  9788 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  9789 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  9790 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  9791 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  9792 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  9793 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  9794 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  9795 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  9796 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  9797 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  9798 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  9799 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  9800 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  9801 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  9802 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  9803 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  9804 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  9805 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  9806 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  9807 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  9808 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  9809 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  9810 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  9811 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  9812 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  9813 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  9814 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  9815 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  9816 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  9817 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  9818 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  9819 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  9820 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  9821 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  9822 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  9823 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  9824 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  9825 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  9826 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  9827 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  9828 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  9829 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  9830 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  9831 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  9832 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  9833 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  9834 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  9835 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  9836 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  9837 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  9838 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  9839 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  9840 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  9841 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  9842 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  9843 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  9844 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  9845 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  9846 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  9847 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  9848 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  9849 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  9850 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  9851 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  9852 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  9853 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  9854 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  9855 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  9856 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  9857 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  9858 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  9859 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  9860 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  9861 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  9862 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  9863 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  9864 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  9865 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  9866 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  9867 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  9868 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  9869 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  9870 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  9871 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  9872 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  9873 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  9874 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  9875 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  9876 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  9877 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  9878 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  9879 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  9880 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  9881 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  9882 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  9883 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  9884 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  9885 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  9886 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  9887 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  9888 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  9889                                  %include	"time2.inc"
  9890                              <1> ;=========================================================================
  9891                              <1> ; time2.int - BIOS Time Services
  9892                              <1> ;       INT 1Ah - BIOS Time Serivces
  9893                              <1> ;		dispatcher
  9894                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  9895                              <1> ;-------------------------------------------------------------------------
  9896                              <1> ;
  9897                              <1> ; Compiles with NASM 2.07, might work with other versions
  9898                              <1> ;
  9899                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  9900                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  9901                              <1> ;
  9902                              <1> ; This program is free software: you can redistribute it and/or modify
  9903                              <1> ; it under the terms of the GNU General Public License as published by
  9904                              <1> ; the Free Software Foundation, either version 3 of the License, or
  9905                              <1> ; (at your option) any later version.
  9906                              <1> ;
  9907                              <1> ; This program is distributed in the hope that it will be useful,
  9908                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9909                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9910                              <1> ; GNU General Public License for more details.
  9911                              <1> ;
  9912                              <1> ; You should have received a copy of the GNU General Public License
  9913                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  9914                              <1> ;
  9915                              <1> ;=========================================================================
  9916                              <1> 
  9917                              <1> ;=========================================================================
  9918                              <1> ; int_1A - BIOS Time Services
  9919                              <1> ; Note: see time1.inc for functions implementation
  9920                              <1> ;-------------------------------------------------------------------------
  9921                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  9922                              <1> int_1A:
  9923 00007E6E 53                  <1> 	push	bx
  9924 00007E6F 1E                  <1> 	push	ds
  9925 00007E70 BB4000              <1> 	mov	bx,biosdseg
  9926 00007E73 8EDB                <1> 	mov	ds,bx
  9927 00007E75 80FC08              <1> 	cmp	ah,.max/2
  9928 00007E78 731B                <1> 	jae	int_1A_exit
  9929 00007E7A B700                <1> 	mov	bh,0
  9930 00007E7C 88E3                <1> 	mov	bl,ah
  9931 00007E7E D1E3                <1> 	shl	bx,1
  9932 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
  9933                              <1> .dispatch:
  9934 00007E85 [380C]              <1> 	dw	int_1A_fn00
  9935 00007E87 [4A0C]              <1> 	dw	int_1A_fn01
  9936 00007E89 [5A0C]              <1> 	dw	int_1A_fn02
  9937 00007E8B [8C0C]              <1> 	dw	int_1A_fn03
  9938 00007E8D [D10C]              <1> 	dw	int_1A_fn04
  9939 00007E8F [010D]              <1> 	dw	int_1A_fn05
  9940 00007E91 [400D]              <1> 	dw	int_1A_fn06
  9941 00007E93 [910D]              <1> 	dw	int_1A_fn07
  9942                              <1> .max	equ	$-.dispatch
  9943                              <1> int_1A_exit:
  9944 00007E95 1F                  <1> 	pop	ds
  9945 00007E96 5B                  <1> 	pop	bx
  9946 00007E97 CF                  <1> 	iret
  9947                              <1> int_1A_exitf:
  9948 00007E98 1F                  <1> 	pop	ds
  9949 00007E99 5B                  <1> 	pop	bx
  9950 00007E9A CA0200              <1> 	retf	2
  9951                              <1> 
  9952                              <1> ;=========================================================================
  9953                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  9954                              <1> ;-------------------------------------------------------------------------
  9955 00007E9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
  9956          ******************  <1>  warning: (setloc:7) Inserting 8 bytes
  9957                              <1> int_08:
  9958 00007EA5 50                  <1> 	push	ax
  9959 00007EA6 1E                  <1> 	push	ds
  9960 00007EA7 B84000              <1> 	mov	ax,biosdseg
  9961 00007EAA 8ED8                <1> 	mov	ds,ax
  9962 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  9963 00007EB1 7413                <1> 	jz	.1
  9964 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  9965 00007EB7 750D                <1> 	jnz	.1
  9966 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  9967 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  9968 00007EC0 52                  <1> 	push	dx
  9969 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  9970 00007EC4 EE                  <1> 	out	dx,al
  9971 00007EC5 5A                  <1> 	pop	dx
  9972                              <1> .1:
  9973 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
  9974 00007ECA 7504                <1> 	jnz	.2
  9975 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
  9976                              <1> .2:
  9977 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  9978 00007ED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  9979 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  9980 00007EDD 7512                <1> 	jnz	.3
  9981 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
  9982 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
  9983 00007EEB C70670000100        <1> 	mov	word [new_day],1
  9984                              <1> .3:
  9985 00007EF1 CD1C                <1> 	int	1Ch			; User timer interrupt
  9986 00007EF3 B020                <1> 	mov	al,20h
  9987 00007EF5 E620                <1> 	out	pic1_reg0,al
  9988 00007EF7 1F                  <1> 	pop	ds
  9989 00007EF8 58                  <1> 	pop	ax
  9990 00007EF9 CF                  <1> 	iret
  9991                                  
  9992                                  ;=========================================================================
  9993                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  9994                                  ;-------------------------------------------------------------------------
  9995 00007EFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  9996          ******************       warning: (setloc:7) Inserting 41 bytes
  9997                                  int_ignore:
  9998 00007F23 50                      	push	ax
  9999 00007F24 1E                      	push	ds
 10000 00007F25 B84000                  	mov	ax,biosdseg
 10001 00007F28 8ED8                    	mov	ds,ax
 10002 00007F2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
 10003 00007F2C E620                    	out	pic1_reg0,al
 10004 00007F2E 90                      	nop
 10005 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
 10006 00007F31 88C4                    	mov	ah,al
 10007 00007F33 08C0                    	or	al,al
 10008 00007F35 7504                    	jnz	.1
 10009 00007F37 B4FF                    	mov	ah,0FFh
 10010 00007F39 EB0A                    	jmp	.2
 10011                                  .1:
 10012 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
 10013 00007F3D 08E0                    	or	al,ah
 10014 00007F3F E621                    	out	pic1_reg1,al
 10015 00007F41 B020                    	mov	al,20h			; end of interrupt
 10016 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
 10017                                  .2:
 10018 00007F45 88266B00                	mov	byte [last_irq],ah
 10019 00007F49 1F                      	pop	ds
 10020 00007F4A 58                      	pop	ax
 10021 00007F4B CF                      	iret
 10022                                  
 10023                                  ;=========================================================================
 10024                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
 10025                                  ;-------------------------------------------------------------------------
 10026 00007F4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
 10027          ******************       warning: (setloc:7) Inserting 7 bytes
 10028                                  int_dummy:
 10029 00007F53 CF                      	iret
 10030                                  
 10031                                  ;=========================================================================
 10032                                  ; int_05 - BIOS Print Screen
 10033                                  ;-------------------------------------------------------------------------
 10034                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
 10035                                  int_05:
 10036 00007F54 FB                      	sti
 10037 00007F55 50                      	push	ax
 10038 00007F56 53                      	push	bx
 10039 00007F57 51                      	push	cx
 10040 00007F58 52                      	push	dx
 10041 00007F59 1E                      	push	ds
 10042 00007F5A B84000                  	mov	ax,biosdseg
 10043 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
 10044 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
 10045 00007F64 746A                    	je	.exit			; print screen is already in progress
 10046 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
 10047                                  					; signal that print screen is running
 10048                                  
 10049 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
 10050 00007F6D CD10                    	int	10h			; returns number of columns in AH
 10051                                  					; and active display page in BH
 10052 00007F6F 88E1                    	mov	cl,ah			; store number columns
 10053                                  
 10054 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
 10055 00007F75 08ED                    	or	ch,ch
 10056 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
 10057                                  
 10058 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
 10059 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
 10060 00007F7E 7602                    	jbe	.get_cursor_pos
 10061                                  
 10062                                  .wrong_num_rows:
 10063 00007F80 B519                    	mov	ch,25			; assume 25 rows
 10064                                  
 10065                                  .get_cursor_pos:
 10066 00007F82 B403                    	mov	ah,03h			; get cursor position and size
 10067 00007F84 CD10                    	int	10h			; returns cursor position in DX
 10068 00007F86 52                      	push	dx			; save original position / DX in stack
 10069                                  
 10070                                  	
 10071 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
 10072 00007F89 E85100                  	call	.print_char
 10073 00007F8C 7548                    	jnz	.error
 10074 00007F8E B40A                    	mov	ah,0Ah
 10075 00007F90 E84A00                  	call	.print_char
 10076 00007F93 7541                    	jnz	.error
 10077                                  
 10078 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
 10079                                  
 10080                                  .row_loop:
 10081 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
 10082                                  
 10083                                  .column_loop:
 10084 00007F99 B402                    	mov	ah,02h
 10085 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
 10086                                  
 10087 00007F9D B408                    	mov	ah,08h
 10088 00007F9F CD10                    	int	10h			; read character at cursor position
 10089                                  
 10090 00007FA1 3C20                    	cmp	al,20h			; control character?
 10091 00007FA3 7302                    	jae	.continue		; no, print it
 10092 00007FA5 B020                    	mov	al,20h			; print space instead
 10093                                  
 10094                                  .continue:
 10095 00007FA7 E83300                  	call	.print_char
 10096 00007FAA 752A                    	jnz	.error
 10097 00007FAC FEC2                    	inc	dl
 10098 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
 10099 00007FB0 72E7                    	jb	.column_loop		; print next column
 10100                                  
 10101 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
 10102 00007FB4 E82600                  	call	.print_char
 10103 00007FB7 751D                    	jnz	.error
 10104 00007FB9 B40A                    	mov	ah,0Ah
 10105 00007FBB E81F00                  	call	.print_char
 10106 00007FBE 7516                    	jnz	.error
 10107                                  
 10108 00007FC0 FEC6                    	inc	dh
 10109 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
 10110 00007FC4 72D1                    	jb	.row_loop		; print next row
 10111                                  
 10112 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
 10113                                  					; ready for the next call
 10114                                  
 10115                                  .restore_cursor:
 10116 00007FCB 5A                      	pop	dx			; DX = original cursor position
 10117 00007FCC B402                    	mov	ah,02h
 10118 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
 10119                                  
 10120                                  .exit:
 10121 00007FD0 1F                      	pop	ds
 10122 00007FD1 5A                      	pop	dx
 10123 00007FD2 59                      	pop	cx
 10124 00007FD3 5B                      	pop	bx
 10125 00007FD4 58                      	pop	ax
 10126 00007FD5 CF                      	iret
 10127                                  
 10128                                  .error:
 10129 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
 10130                                  					; signal failure
 10131 00007FDB EBEE                    	jmp	.restore_cursor
 10132                                  	
 10133                                  
 10134                                  .print_char:
 10135 00007FDD 52                      	push	dx
 10136 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
 10137 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
 10138 00007FE2 CD17                    	int	17h
 10139 00007FE4 5A                      	pop	dx
 10140 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
 10141 00007FE8 C3                      	ret
 10142                                  
 10143                                  ;=========================================================================
 10144                                  ; start - at power up or reset execution starts here (F000:FFF0)
 10145                                  ;-------------------------------------------------------------------------
 10146 00007FE9 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
 10147          ******************       warning: (setloc:7) Inserting 7 bytes
 10148                                  start:
 10149 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
 10150                                  
 10151                                  	setloc	0FFF5h			; ROM Date in ASCII
 10152 00007FF5 31322F33312F3132        	db	DATE			; BIOS release date MM/DD/YY
 10153 00007FFD 20                      	db	20h
 10154                                  
 10155                                  	setloc	0FFFEh			; System Model
 10156                                  %ifdef AT_COMPAT
 10157 00007FFE FC                      	db	0fch			; system is an IBM AT compatible
 10158                                  %else
 10159                                  	db	0feh			; system is an IBM PC/XT compatible
 10160                                  %endif ; AT_COMPAT
 10161 00007FFF FF                      	db	0ffh
