     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Sergey's XT board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "config.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; config.inc - Compilation time settings and settings
    71                              <1> ;-------------------------------------------------------------------------
    72                              <1> ;
    73                              <1> ; Compiles with NASM 2.07, might work with other versions
    74                              <1> ;
    75                              <1> ; Copyright (C) 2011 Sergey Kiselev.
    76                              <1> ; Provided for hobbyist use on the Sergey's XT board.
    77                              <1> ;
    78                              <1> ; This program is free software: you can redistribute it and/or modify
    79                              <1> ; it under the terms of the GNU General Public License as published by
    80                              <1> ; the Free Software Foundation, either version 3 of the License, or
    81                              <1> ; (at your option) any later version.
    82                              <1> ;
    83                              <1> ; This program is distributed in the hope that it will be useful,
    84                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    85                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    86                              <1> ; GNU General Public License for more details.
    87                              <1> ;
    88                              <1> ; You should have received a copy of the GNU General Public License
    89                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    90                              <1> ;
    91                              <1> ;=========================================================================
    92                              <1> 
    93                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
    94                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
    95                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
    96                              <1> %define MIN_RAM_SIZE 32			; At least 32 KiB to boot the system
    97                              <1> %define MAX_RAM_SIZE 640		; Scan this much memory during POST
    98                              <1> %define RAM_TEST_BLOCK 16384		; block size for RAM test
    99                              <1> %define EBDA_SIZE 1			; 1KB reserved for EBDA
   100                              <1> 					; EBDA is required for PS/2 aux support
   101                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   102                                  %include "errno.inc"
   103                              <1> ;=========================================================================
   104                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   105                              <1> ;-------------------------------------------------------------------------
   106                              <1> ;
   107                              <1> ; Compiles with NASM 2.07, might work with other versions
   108                              <1> ;
   109                              <1> ; Copyright (C) 2011 Sergey Kiselev.
   110                              <1> ; Provided for hobbyist use on the Sergey's XT board.
   111                              <1> ;
   112                              <1> ; This program is free software: you can redistribute it and/or modify
   113                              <1> ; it under the terms of the GNU General Public License as published by
   114                              <1> ; the Free Software Foundation, either version 3 of the License, or
   115                              <1> ; (at your option) any later version.
   116                              <1> ;
   117                              <1> ; This program is distributed in the hope that it will be useful,
   118                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   119                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   120                              <1> ; GNU General Public License for more details.
   121                              <1> ;
   122                              <1> ; You should have received a copy of the GNU General Public License
   123                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   124                              <1> ;
   125                              <1> ;=========================================================================
   126                              <1> 
   127                              <1> e_start		equ	01h		; BIOS POST started
   128                              <1> e_cpu_ok	equ	02h		; CPU test passed
   129                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   130                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   131                              <1> e_int_ok	equ	05h		; interrupt table initialized
   132                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   133                              <1> e_pic_ok	equ	08h		; PIC initialized
   134                              <1> e_kbd_ok	equ	10h		; KBD test passed
   135                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   136                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   137                              <1> e_cpu_fail	equ	82h		; CPU test failed
   138                              <1> e_low_ram_fail	equ	84h		; low RAM test failed
   139                              <1> e_kbd_ctrl_fail	equ	85h		; KBD test - controller selftest failed
   140                              <1> e_kbd_key_fail	equ	86h		; KBD test - echo test failed
   141                              <1> e_kbd_timeout	equ	88h		; KBD timeout
   142                              <1> e_kbd_int_fail	equ	90h		; KBD test - interface test failed
   143                                  
   144                                  %imacro setloc  1.nolist
   145                                   times   (%1-($-$$)) db 0FFh
   146                                  %endm
   147                                  
   148                                  
   149                                  bioscseg	equ	0F000h
   150                                  biosdseg	equ	0040h
   151                                  
   152                                  pic1_reg0	equ	20h
   153                                  pic1_reg1	equ	21h
   154                                  pit_ch0_reg	equ	40h
   155                                  pit_ch1_reg	equ	41h
   156                                  pit_ch2_reg	equ	42h
   157                                  pit_ctl_reg	equ	43h
   158                                  port_b_reg	equ	61h
   159                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   160                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   161                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   162                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   163                                  post_reg	equ	80h
   164                                  pic2_reg0	equ	0A0h
   165                                  pic2_reg1	equ	0A1h
   166                                  cga_mode_reg	equ	3D8h
   167                                  mda_mode_reg	equ	3B8h
   168                                  
   169                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   170                                  
   171                                  ;========================================================================
   172                                  ; BIOS data area variables
   173                                  ;------------------------------------------------------------------------
   174                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   175                                  equipment_list	equ	10h	; word - equpment list
   176                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   177                                  equip_fpu	equ	0000000000000010b	; FPU installed
   178                                  equip_mouse	equ	0000000000000100b
   179                                  equip_video	equ	0000000000110000b	; video type bit mask
   180                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   181                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   182                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   183                                  ;			|||||||||||||||`-- floppy drives installed
   184                                  ;			||||||||||||||`-- FPU installed
   185                                  ;			|||||||||||||`-- PS/2 mouse installed
   186                                  ;			||||||||||||`-- reserved
   187                                  ;			||||||||||`--- initial video mode
   188                                  ;			||||||||`---- number of floppy drives - 1
   189                                  ;			|||||||`---- O = DMA installed
   190                                  ;			||||`------ number of serial ports
   191                                  ;			|||`------ game adapter installed
   192                                  ;			||`------ internal modem?!
   193                                  ;			`------- number of parallel ports
   194                                  
   195                                  post_flags	equ	12h	; byte - post flags
   196                                  post_setup	equ	01h	; run NVRAM setup
   197                                  memory_size	equ	13h	; word - memory size in KiB
   198                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   199                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   200                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   201                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   202                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   203                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   204                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   205                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   206                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   207                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   208                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   209                                  video_mode	equ	49h	; byte - active video mode number
   210                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   211                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   212                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   213                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   214                                  video_cur_shape	equ	60h	; word - cursor shape
   215                                  video_page	equ	62h	; byte - active video page
   216                                  video_port	equ	63h	; word - I/O port for the display adapter
   217                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   218                                  video_palet_reg	equ	66h	; byte - color palette
   219                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   220                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   221                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   222                                  new_day		equ	70h	; byte - 1 = new day flag
   223                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   224                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   225                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   226                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   227                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   228                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   229                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   230                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   231                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   232                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   233                                  
   234                                  ;=========================================================================
   235                                  ; Extended BIOS data area variables
   236                                  ;-------------------------------------------------------------------------
   237                                  ebda_size	equ	0h
   238                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   239                                  mouse_flags_1	equ	26h
   240                                  mouse_flags_2	equ	27h
   241                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   242                                  
   243 00000000 FF<rept>                	setloc	8000h		; Use only upper 32 KiB of ROM
   244                                  
   245                                  ;=========================================================================
   246                                  ; Includes
   247                                  ;-------------------------------------------------------------------------
   248                                  %include	"messages.inc"		; POST messages
   249                              <1> ;=========================================================================
   250                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   251                              <1> ;-------------------------------------------------------------------------
   252                              <1> ;
   253                              <1> ; Compiles with NASM 2.07, might work with other versions
   254                              <1> ;
   255                              <1> ; Copyright (C) 2011 Sergey Kiselev.
   256                              <1> ; Provided for hobbyist use on the Sergey's XT board.
   257                              <1> ;
   258                              <1> ; This program is free software: you can redistribute it and/or modify
   259                              <1> ; it under the terms of the GNU General Public License as published by
   260                              <1> ; the Free Software Foundation, either version 3 of the License, or
   261                              <1> ; (at your option) any later version.
   262                              <1> ;
   263                              <1> ; This program is distributed in the hope that it will be useful,
   264                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   265                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   266                              <1> ; GNU General Public License for more details.
   267                              <1> ;
   268                              <1> ; You should have received a copy of the GNU General Public License
   269                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   270                              <1> ;
   271                              <1> ;=========================================================================
   272                              <1> 
   273 00008000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   274 00008002 536572676579277320- <1> 		db	"Sergey's XT BIOS, Version 0.7e. "
   275 0000800B 58542042494F532C20- <1>
   276 00008014 56657273696F6E2030- <1>
   277 0000801D 2E37652E20          <1>
   278 00008022 436F70797269676874- <1> 		db	"Copyright (C) 2010, 2011 Sergey Kiselev", 0Dh, 0Ah
   279 0000802B 202843292032303130- <1>
   280 00008034 2C2032303131205365- <1>
   281 0000803D 72676579204B697365- <1>
   282 00008046 6C65760D0A          <1>
   283 0000804B 446973747269627574- <1> 		db	"Distributed under the terms of "
   284 00008054 656420756E64657220- <1>
   285 0000805D 746865207465726D73- <1>
   286 00008066 206F6620            <1>
   287 0000806A 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   288 00008073 656E6572616C205075- <1>
   289 0000807C 626C6963204C696365- <1>
   290 00008085 6E73650D0A          <1>
   291 0000808A 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   292 0000808D 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   293 00008096 6573736F723A202020- <1>
   294 0000809F 202020202020202020- <1>
   295 000080A8 2000                <1>
   296 000080AA 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   297 000080B3 637320436F2D70726F- <1>
   298 000080BC 636573736F723A2020- <1>
   299 000080C5 2000                <1>
   300 000080C7 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 0Dh, 0Ah
   301 000080D0 38202737380D0A      <1>
   302 000080D7 5741524E494E473A20- <1> 		db      'WARNING: This CPU does not disable interrupts '
   303 000080E0 546869732043505520- <1>
   304 000080E9 646F6573206E6F7420- <1>
   305 000080F2 64697361626C652069- <1>
   306 000080FB 6E7465727275707473- <1>
   307 00008104 20                  <1>
   308 00008105 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   309 0000810E 64696E67207365676D- <1>
   310 00008117 656E74207265676973- <1>
   311 00008120 74657273210D0A00    <1>
   312 00008128 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   313 00008131 3820273831206F7220- <1>
   314 0000813A 6C617465722C20      <1>
   315 00008141 6F7220496E74656C20- <1> 		db      'or Intel 80C88', 0Dh, 0Ah, 00h
   316 0000814A 38304338380D0A00    <1>
   317 00008152 486172726973202F20- <1> msg_cpu_harris  db      'Harris / Intersil 80C88', 0Dh, 0Ah, 00h
   318 0000815B 496E74657273696C20- <1>
   319 00008164 38304338380D0A00    <1>
   320 0000816C 4E4543205632300D0A- <1> msg_cpu_nec_v20 db      'NEC V20', 0Dh, 0Ah, 00h
   321 00008175 00                  <1>
   322 00008176 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   323 0000817F 370D0A00            <1>
   324 00008183 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   325 0000818C 646170746572205479- <1>
   326 00008195 70653A202020202020- <1>
   327 0000819E 2000                <1>
   328 000081A0 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   329 000081A9 566964656F2042494F- <1>
   330 000081B2 532050726573656E74- <1>
   331 000081BB 290D0A00            <1>
   332 000081BF 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   333 000081C5 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   334 000081CE 7263756C65730D0A00  <1>
   335 000081D7 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   336 000081E0 736B20647269766573- <1>
   337 000081E9 3A2020202020202020- <1>
   338 000081F2 20447269766520303A- <1>
   339 000081FB 2000                <1>
   340 000081FD 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   341 00008206 3A2000              <1>
   342 00008209 6E6F6E6500          <1> msg_floppy_none	db	'none', 00h
   343 0000820E 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   344 00008217 2E32352200          <1>
   345 0000821C 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   346 00008225 2E32352200          <1>
   347 0000822A 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   348 00008233 2E352200            <1>
   349 00008237 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   350 00008240 332E352200          <1>
   351 00008245 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   352 0000824E 332E352200          <1>
   353 00008253 50532F322041757820- <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   354 0000825C 44657669636520284D- <1>
   355 00008265 6F757365293A202020- <1>
   356 0000826E 2000                <1>
   357 00008270 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   358 00008279 00                  <1>
   359 0000827A 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   360 00008283 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   361 0000828C 414D20284553432074- <1>
   362 00008295 6F20736B6970293A20- <1>
   363 0000829E 2000                <1>
   364 000082A0 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   365 000082A9 4661756C7479206D65- <1>
   366 000082B2 6D6F72792064657465- <1>
   367 000082BB 637465642061742000  <1>
   368 000082C4 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   369 000082CD 6E76656E74696F6E61- <1>
   370 000082D6 6C2052414D3A202020- <1>
   371 000082DF 202000              <1>
   372 000082E2 526573657276656420- <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   373 000082EB 666F7220454244413A- <1>
   374 000082F4 202020202020202020- <1>
   375 000082FD 2000                <1>
   376 000082FF 417661696C61626C65- <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   377 00008308 20436F6E76656E7469- <1>
   378 00008311 6F6E616C2052414D3A- <1>
   379 0000831A 2000                <1>
   380 0000831C 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   381 00008323 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   382 0000832C 65642C207072657373- <1>
   383 00008335 20616E79206B657920- <1>
   384 0000833E 746F20747279206167- <1>
   385 00008347 61696E2E2E2E0D0A00  <1>
   386 00008350 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   387 00008359 5349430D0A00        <1>
   388 0000835F 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM, initializing...', 0Dh, 0Ah, 0
   389 00008368 5320657874656E7369- <1>
   390 00008371 6F6E20524F4D2C2069- <1>
   391 0000837A 6E697469616C697A69- <1>
   392 00008383 6E672E2E2E0D0A00    <1>
   393 0000838B 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   394 00008394 532E2E2E0D0A00      <1>
   395 0000839B 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   396 000083A4 432062617474657279- <1>
   397 000083AD 206973206261640D0A- <1>
   398 000083B6 00                  <1>
   399 000083B7 4552524F523A204E56- <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   400 000083C0 52414D20636865636B- <1>
   401 000083C9 73756D20697320696E- <1>
   402 000083D2 76616C69642C20      <1>
   403 000083D9 6C6F6164696E672064- <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   404 000083E2 656661756C74207661- <1>
   405 000083EB 6C75657320746F204E- <1>
   406 000083F4 5652414D0D0A00      <1>
   407 000083FB 507265737320463120- <1> msg_setup	db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   408 00008404 746F2072756E204E56- <1>
   409 0000840D 52414D207365747570- <1>
   410 00008416 2E2E2E0D0A0D0A00    <1>
   411 0000841E 0D0A                <1> msg_set_menu	db	0Dh, 0Ah
   412 00008420 4E5652414D20536574- <1> 		db	'NVRAM Setup Menu:', 0Dh, 0Ah,
   413 00008429 7570204D656E753A0D- <1>
   414 00008432 0A                  <1>
   415 00008433 66202D204368616E67- <1> 		db	'f - Change first floppy type', 0Dh, 0Ah
   416 0000843C 652066697273742066- <1>
   417 00008445 6C6F70707920747970- <1>
   418 0000844E 650D0A              <1>
   419 00008451 67202D204368616E67- <1> 		db	'g - Change second floppy type', 0Dh, 0Ah
   420 0000845A 65207365636F6E6420- <1>
   421 00008463 666C6F707079207479- <1>
   422 0000846C 70650D0A            <1>
   423 00008470 70202D205072696E74- <1> 		db	'p - Print current settings', 0Dh, 0Ah
   424 00008479 2063757272656E7420- <1>
   425 00008482 73657474696E67730D- <1>
   426 0000848B 0A                  <1>
   427 0000848C 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   428 00008495 6368616E6765732061- <1>
   429 0000849E 6E6420657869740D0A  <1>
   430 000084A7 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   431 000084B0 776974686F75742073- <1>
   432 000084B9 6176696E6720636861- <1>
   433 000084C2 6E6765730D0A        <1>
   434 000084C8 0D0A                <1> 		db	0Dh, 0Ah
   435 000084CA 456E74657220796F75- <1> 		db	'Enter your selection: ', 00h
   436 000084D3 722073656C65637469- <1>
   437 000084DC 6F6E3A2000          <1>
   438 000084E1 0D0A                <1> msg_set_floppy	db	0Dh, 0Ah
   439 000084E3 466C6F707079205365- <1> 		db	'Floppy Setup Menu:', 0Dh, 0Ah
   440 000084EC 747570204D656E753A- <1>
   441 000084F5 0D0A                <1>
   442 000084F7 30202D204E6F20666C- <1> 		db	'0 - No floppy', 0Dh, 0Ah
   443 00008500 6F7070790D0A        <1>
   444 00008506 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"', 0Dh, 0Ah
   445 0000850F 422C20352E3235220D- <1>
   446 00008518 0A                  <1>
   447 00008519 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.24"', 0Dh, 0Ah
   448 00008522 422C20352E3234220D- <1>
   449 0000852B 0A                  <1>
   450 0000852C 33202D20373230204B- <1> 		db	'3 - 720 KB, 3.5"', 0Dh, 0Ah
   451 00008535 422C20332E35220D0A  <1>
   452 0000853E 34202D20312E343420- <1> 		db	'4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   453 00008547 4D422C20332E35220D- <1>
   454 00008550 0A                  <1>
   455 00008551 36202D20322E383820- <1> 		db	'6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   456 0000855A 4D422C20332E35220D- <1>
   457 00008563 0A                  <1>
   458 00008564 71202D205265747572- <1> 		db	'q - Return to the main menu', 0Dh, 0Ah
   459 0000856D 6E20746F2074686520- <1>
   460 00008576 6D61696E206D656E75- <1>
   461 0000857F 0D0A                <1>
   462 00008581 0D0A                <1> 		db	0Dh, 0Ah
   463 00008583 456E74657220796F75- <1> 		db	'Enter your selection: ', 00h
   464 0000858C 722073656C65637469- <1>
   465 00008595 6F6E3A2000          <1>
   466 0000859A [0982]              <1> tbl_floppy	dw	msg_floppy_none
   467 0000859C [0E82]              <1> 		dw	msg_floppy_360
   468 0000859E [1C82]              <1> 		dw	msg_floppy_1200
   469 000085A0 [2A82]              <1> 		dw	msg_floppy_720
   470 000085A2 [3782]              <1> 		dw	msg_floppy_1440
   471 000085A4 [0982]              <1> 		dw	msg_floppy_none
   472 000085A6 [4582]              <1> 		dw	msg_floppy_2880
   473 000085A8 [0982]              <1> 		dw	msg_floppy_none
   474                                  %include	"fnt80-FF.inc"		; font for graphics modes
   475                              <1> ;=========================================================================
   476                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   477                              <1> ;       Characters from 80h to 0FFh
   478                              <1> ;-------------------------------------------------------------------------
   479                              <1> ;
   480                              <1> ; Compiles with NASM 2.07, might work with other versions
   481                              <1> ;
   482                              <1> ; This font is borrowed from kbd package (alt-8x8)
   483                              <1> ;
   484                              <1> ; This program is free software: you can redistribute it and/or modify
   485                              <1> ; it under the terms of the GNU General Public License as published by
   486                              <1> ; the Free Software Foundation, either version 3 of the License, or
   487                              <1> ; (at your option) any later version.
   488                              <1> ;
   489                              <1> ; This program is distributed in the hope that it will be useful,
   490                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   491                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   492                              <1> ; GNU General Public License for more details.
   493                              <1> ;
   494                              <1> ; You should have received a copy of the GNU General Public License
   495                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   496                              <1> ;
   497                              <1> ;=========================================================================
   498                              <1> int_1F:
   499 000085AA 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   500 000085B2 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   501 000085BA 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   502 000085C2 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   503 000085CA 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   504 000085D2 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   505 000085DA DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   506 000085E2 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   507 000085EA 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   508 000085F2 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   509 000085FA 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   510 00008602 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   511 0000860A C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   512 00008612 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   513 0000861A 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   514 00008622 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   515 0000862A 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   516 00008632 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   517 0000863A 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   518 00008642 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   519 0000864A 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   520 00008652 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   521 0000865A 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   522 00008662 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   523 0000866A DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   524 00008672 DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   525 0000867A E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   526 00008682 C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   527 0000868A 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   528 00008692 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   529 0000869A CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   530 000086A2 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   531 000086AA 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   532 000086B2 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   533 000086BA 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   534 000086C2 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   535 000086CA 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   536 000086D2 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   537 000086DA 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   538 000086E2 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   539 000086EA 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   540 000086F2 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   541 000086FA 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   542 00008702 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   543 0000870A 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   544 00008712 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   545 0000871A 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   546 00008722 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   547 0000872A 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   548 00008732 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   549 0000873A DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   550 00008742 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   551 0000874A 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   552 00008752 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   553 0000875A 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   554 00008762 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   555 0000876A 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   556 00008772 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   557 0000877A 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   558 00008782 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   559 0000878A 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   560 00008792 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   561 0000879A 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   562 000087A2 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   563 000087AA 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   564 000087B2 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   565 000087BA 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   566 000087C2 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   567 000087CA 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   568 000087D2 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   569 000087DA 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   570 000087E2 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   571 000087EA 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   572 000087F2 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   573 000087FA 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   574 00008802 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   575 0000880A 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   576 00008812 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   577 0000881A 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   578 00008822 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   579 0000882A 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   580 00008832 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   581 0000883A 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   582 00008842 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   583 0000884A 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   584 00008852 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   585 0000885A 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   586 00008862 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   587 0000886A 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   588 00008872 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   589 0000887A 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   590 00008882 FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   591 0000888A 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   592 00008892 F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   593 0000889A 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   594 000088A2 FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   595 000088AA 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   596 000088B2 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   597 000088BA 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   598 000088C2 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   599 000088CA 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   600 000088D2 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   601 000088DA 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   602 000088E2 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   603 000088EA 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   604 000088F2 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   605 000088FA 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   606 00008902 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   607 0000890A 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   608 00008912 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   609 0000891A 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   610 00008922 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   611 0000892A 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   612 00008932 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   613 0000893A 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   614 00008942 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   615 0000894A 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   616 00008952 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   617 0000895A 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   618 00008962 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   619 0000896A 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   620 00008972 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   621 0000897A 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   622 00008982 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   623 0000898A 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   624 00008992 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   625 0000899A 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   626 000089A2 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   627                                  ;%include	"inttrace.inc"		; XXX
   628                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   629                              <1> ;=========================================================================
   630                              <1> ; rtc.inc - RTC/CMOS read and write functions
   631                              <1> ;-------------------------------------------------------------------------
   632                              <1> ;
   633                              <1> ; Compiles with NASM 2.07, might work with other versions
   634                              <1> ;
   635                              <1> ; Copyright (C) 2011 Sergey Kiselev.
   636                              <1> ; Provided for hobbyist use on the Sergey's XT board.
   637                              <1> ;
   638                              <1> ; This program is free software: you can redistribute it and/or modify
   639                              <1> ; it under the terms of the GNU General Public License as published by
   640                              <1> ; the Free Software Foundation, either version 3 of the License, or
   641                              <1> ; (at your option) any later version.
   642                              <1> ;
   643                              <1> ; This program is distributed in the hope that it will be useful,
   644                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   645                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   646                              <1> ; GNU General Public License for more details.
   647                              <1> ;
   648                              <1> ; You should have received a copy of the GNU General Public License
   649                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   650                              <1> ;
   651                              <1> ;=========================================================================
   652                              <1> 
   653                              <1> ;-------------------------------------------------------------------------
   654                              <1> ; RTC ports
   655                              <1> rtc_addr_reg	equ	70h	; RTC address port
   656                              <1> rtc_data_reg	equ	71h	; RTC data port
   657                              <1> 
   658                              <1> ;-------------------------------------------------------------------------
   659                              <1> ; locations in RTC and NVRAM
   660                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   661                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   662                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   663                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   664                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   665                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   666                              <1> cmos_day	equ	06h	; day location in RTC
   667                              <1> cmos_date	equ	07h	; date location in RTC
   668                              <1> cmos_month	equ	08h	; month location in RTC
   669                              <1> cmos_year	equ	09h	; year location in RTC
   670                              <1> cmos_floppy	equ	10h	; floppy type byte
   671                              <1> cmos_equip	equ	14h	; equipment byte
   672                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   673                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   674                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   675                              <1> 
   676                              <1> ;-------------------------------------------------------------------------
   677                              <1> ; RTC control register and their bits
   678                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   679                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   680                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   681                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   682                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   683                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   684                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   685                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   686                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   687                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   688                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   689                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   690                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   691                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   692                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   693                              <1> 
   694                              <1> ;-------------------------------------------------------------------------
   695                              <1> ; NMI flag
   696                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   697                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   698                              <1> 
   699                              <1> ;=========================================================================
   700                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   701                              <1> ; Input:
   702                              <1> ;	AL - address and NMI enable bit
   703                              <1> ;		bits 6-0 - address of byte to read
   704                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   705                              <1> ; Output:
   706                              <1> ;	AL = byte from RTC
   707                              <1> ;-------------------------------------------------------------------------
   708                              <1> rtc_read:
   709 000089AA FA                  <1> 	cli
   710 000089AB E670                <1> 	out	rtc_addr_reg,al
   711 000089AD EB00                <1> 	jmp	$+2
   712 000089AF EB00                <1> 	jmp	$+2
   713 000089B1 E471                <1> 	in	al,rtc_data_reg
   714 000089B3 FB                  <1> 	sti
   715 000089B4 C3                  <1> 	ret
   716                              <1> 
   717                              <1> ;=========================================================================
   718                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   719                              <1> ; Input:
   720                              <1> ;	AL - address and NMI enable bit
   721                              <1> ;		bits 6-0 - address of byte to read
   722                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   723                              <1> ;	AH = byte to write to RTC
   724                              <1> ;-------------------------------------------------------------------------
   725                              <1> rtc_write:
   726 000089B5 FA                  <1> 	cli
   727 000089B6 E670                <1> 	out	rtc_addr_reg,al
   728 000089B8 EB00                <1> 	jmp	$+2
   729 000089BA EB00                <1> 	jmp	$+2
   730 000089BC 86E0                <1> 	xchg	ah,al
   731 000089BE E671                <1> 	out	rtc_data_reg,al
   732 000089C0 86E0                <1> 	xchg	ah,al
   733 000089C2 FB                  <1> 	sti
   734 000089C3 C3                  <1> 	ret
   735                              <1> 
   736                              <1> ;=========================================================================
   737                              <1> ; rtc_init - Initialize RTC
   738                              <1> ; Notes:
   739                              <1> ;	- makes sure RTC battery is OK, resets time if not
   740                              <1> ;	- disables RTC interrupts
   741                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   742                              <1> ;-------------------------------------------------------------------------
   743                              <1> rtc_init:
   744 000089C4 50                  <1> 	push	ax
   745 000089C5 53                  <1> 	push	bx
   746 000089C6 51                  <1> 	push	cx
   747 000089C7 52                  <1> 	push	dx
   748 000089C8 56                  <1> 	push	si
   749 000089C9 57                  <1> 	push	di
   750 000089CA B00A                <1> 	mov	al,cmos_control_a	; select control A register
   751 000089CC B426                <1> 	mov	ah,26h
   752 000089CE E8E4FF              <1> 	call	rtc_write
   753                              <1> 
   754 000089D1 B00B                <1> 	mov	al,cmos_control_b
   755 000089D3 B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   756 000089D5 E8DDFF              <1> 	call	rtc_write		; write control B register
   757                              <1> 
   758 000089D8 B00C                <1> 	mov	al,cmos_control_c
   759 000089DA E8CDFF              <1> 	call	rtc_read		; read control C register - reset
   760                              <1> 					; interrupt flags
   761                              <1> 
   762 000089DD B00D                <1> 	mov	al,cmos_control_d
   763 000089DF E8C8FF              <1> 	call	rtc_read		; read control D register
   764 000089E2 A880                <1> 	test	al,cmos_vrt
   765 000089E4 7518                <1> 	jnz	.1			; RTC battery is OK
   766 000089E6 BE[9B83]            <1> 	mov	si,msg_rtc_bad
   767 000089E9 E81916              <1> 	call	print
   768                              <1> ; RTC is bad, set initial time
   769 000089EC B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   770 000089EE 31C9                <1> 	xor	cx,cx
   771 000089F0 31D2                <1> 	xor	dx,dx
   772 000089F2 CD1A                <1> 	int	1Ah
   773 000089F4 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   774 000089F6 B91020              <1> 	mov	cx,2010h		; year 2010
   775 000089F9 BA0101              <1> 	mov	dx,0101h		; January 1st
   776 000089FC CD1A                <1> 	int	1Ah
   777                              <1> 
   778                              <1> .1:
   779                              <1> ; set timer variables to RTC time
   780 000089FE B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   781 00008A00 CD1A                <1> 	int	1Ah
   782                              <1> 
   783                              <1> ; convert time to ticks * 2^11
   784                              <1> 
   785                              <1> ; ticks = seconds * 37287
   786 00008A02 88F0                <1> 	mov	al,dh
   787 00008A04 E8AA00              <1> 	call	bcd_to_binary		; convert seconds to binary
   788                              <1> 
   789 00008A07 BAA791              <1> 	mov	dx,37287
   790 00008A0A F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   791                              <1> 
   792 00008A0C 89C6                <1> 	mov	si,ax
   793 00008A0E 89D7                <1> 	mov	di,dx
   794                              <1> 
   795                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   796 00008A10 88C8                <1> 	mov	al,cl
   797 00008A12 E89C00              <1> 	call	bcd_to_binary		; convert minutes to binary
   798                              <1> 
   799 00008A15 89C3                <1> 	mov	bx,ax
   800 00008A17 BA2023              <1> 	mov	dx,8992
   801 00008A1A F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   802                              <1> 
   803 00008A1C 01C6                <1> 	add	si,ax
   804 00008A1E 11D7                <1> 	adc	di,dx
   805                              <1> 
   806 00008A20 89D8                <1> 	mov	ax,bx
   807 00008A22 BA2200              <1> 	mov	dx,34
   808 00008A25 F7E2                <1> 	mul	dx
   809                              <1> 
   810 00008A27 01C7                <1> 	add	di,ax
   811                              <1> 
   812                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   813 00008A29 88E8                <1> 	mov	al,ch
   814 00008A2B E88300              <1> 	call	bcd_to_binary		; convert hours to binary
   815                              <1> 
   816 00008A2E 89C3                <1> 	mov	bx,ax
   817 00008A30 BA6A3B              <1> 	mov	dx,15210
   818 00008A33 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   819                              <1> 
   820 00008A35 01C6                <1> 	add	si,ax
   821 00008A37 11D7                <1> 	adc	di,dx
   822                              <1> 
   823 00008A39 89D8                <1> 	mov	ax,bx
   824 00008A3B BA0008              <1> 	mov	dx,2048
   825 00008A3E F7E2                <1> 	mul	dx			; AX = hours * 2048
   826                              <1> 
   827 00008A40 01C7                <1> 	add	di,ax
   828                              <1> 
   829                              <1> ; CX:DX = DI:SI / 2048
   830 00008A42 B10B                <1> 	mov	cl,11
   831 00008A44 D3EE                <1> 	shr	si,cl
   832 00008A46 89FA                <1> 	mov	dx,di
   833 00008A48 B105                <1> 	mov	cl,5
   834 00008A4A D3E2                <1> 	shl	dx,cl
   835 00008A4C 09F2                <1> 	or	dx,si
   836                              <1> 
   837 00008A4E B10B                <1> 	mov	cl,11
   838 00008A50 D3EF                <1> 	shr	di,cl
   839 00008A52 89F9                <1> 	mov	cx,di
   840                              <1> 
   841                              <1> 					; CX = high word of tick count
   842                              <1> 					; DX = low word of tick count
   843                              <1> 	
   844 00008A54 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   845 00008A56 CD1A                <1> 	int	1Ah	
   846                              <1> 
   847                              <1> 
   848                              <1> ; compare NVRAM checksum with stored value
   849                              <1> 
   850 00008A58 E86800              <1> 	call	rtc_checksum
   851                              <1> 
   852 00008A5B B02E                <1> 	mov	al,cmos_sum_hi
   853 00008A5D E84AFF              <1> 	call	rtc_read
   854 00008A60 88C4                <1> 	mov	ah,al
   855 00008A62 B02F                <1> 	mov	al,cmos_sum_lo
   856 00008A64 E843FF              <1> 	call	rtc_read
   857 00008A67 39C3                <1> 	cmp	bx,ax
   858 00008A69 742F                <1> 	je	.update_equipment
   859                              <1> 
   860 00008A6B BE[B783]            <1> 	mov	si,msg_rtc_sum
   861 00008A6E E89415              <1> 	call	print
   862                              <1> 
   863                              <1> ; clear NVRAM
   864                              <1> 
   865 00008A71 B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   866                              <1> 
   867                              <1> .nvram_clear_loop:
   868 00008A74 E83EFF              <1> 	call	rtc_write
   869 00008A77 FEC0                <1> 	inc	al
   870 00008A79 3C20                <1> 	cmp	al,20h			; last address is 20h
   871 00008A7B 76F7                <1> 	jbe	.nvram_clear_loop
   872                              <1> 
   873 00008A7D B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   874 00008A80 E832FF              <1> 	call	rtc_write
   875                              <1> 
   876 00008A83 B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
   877 00008A86 E82CFF              <1> 	call	rtc_write
   878                              <1> 
   879                              <1> ; update checksum
   880                              <1> 
   881 00008A89 E83700              <1> 	call	rtc_checksum
   882                              <1> 
   883 00008A8C B02E                <1> 	mov	al,cmos_sum_hi
   884 00008A8E 88FC                <1> 	mov	ah,bh
   885 00008A90 E822FF              <1> 	call	rtc_write
   886                              <1> 
   887 00008A93 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
   888 00008A95 88DC                <1> 	mov	ah,bl
   889 00008A97 E81BFF              <1> 	call	rtc_write
   890                              <1> 
   891                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
   892                              <1> 
   893                              <1> .update_equipment:
   894 00008A9A B014                <1> 	mov	al,cmos_equip
   895 00008A9C E80BFF              <1> 	call	rtc_read
   896 00008A9F 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
   897 00008AA1 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
   898 00008AA6 08061000            <1> 	or	byte [equipment_list],al
   899                              <1> 
   900 00008AAA 5F                  <1> 	pop	di
   901 00008AAB 5E                  <1> 	pop	si
   902 00008AAC 5A                  <1> 	pop	dx
   903 00008AAD 59                  <1> 	pop	cx
   904 00008AAE 5B                  <1> 	pop	bx
   905 00008AAF 58                  <1> 	pop	ax
   906 00008AB0 C3                  <1> 	ret
   907                              <1> 
   908                              <1> bcd_to_binary:
   909 00008AB1 51                  <1> 	push	cx
   910 00008AB2 88C5                <1> 	mov	ch,al
   911 00008AB4 80E50F              <1> 	and	ch,0Fh
   912 00008AB7 B104                <1> 	mov	cl,4
   913 00008AB9 D2E8                <1> 	shr	al,cl
   914 00008ABB B10A                <1> 	mov	cl,10
   915 00008ABD F6E1                <1> 	mul	cl
   916 00008ABF 00E8                <1> 	add	al,ch
   917 00008AC1 59                  <1> 	pop	cx
   918 00008AC2 C3                  <1> 	ret
   919                              <1> 
   920                              <1> ;=========================================================================
   921                              <1> ; rtc_checksum - calculate NVRAM checksum
   922                              <1> ; Input:
   923                              <1> ;	none
   924                              <1> ; Output:
   925                              <1> ;	BX = NVRAM checksum
   926                              <1> ;-------------------------------------------------------------------------
   927                              <1> rtc_checksum:
   928 00008AC3 50                  <1> 	push	ax
   929 00008AC4 31DB                <1> 	xor	bx,bx
   930 00008AC6 B410                <1> 	mov	ah,10h			; start from 10h
   931                              <1> 
   932                              <1> .checksum_loop:
   933 00008AC8 88E0                <1> 	mov	al,ah
   934 00008ACA E8DDFE              <1> 	call	rtc_read
   935 00008ACD 00C3                <1> 	add	bl,al			; BX += AL
   936 00008ACF 80D700              <1> 	adc	bh,0
   937 00008AD2 FEC4                <1> 	inc	ah
   938 00008AD4 80FC20              <1> 	cmp	ah,20h			; last address is 20h
   939 00008AD7 76EF                <1> 	jbe	.checksum_loop
   940 00008AD9 58                  <1> 	pop	ax
   941 00008ADA C3                  <1> 	ret
   942                              <1> 
   943                              <1> ;=========================================================================
   944                              <1> ; rtc_setup - NVRAM configuration utility
   945                              <1> ; Input:
   946                              <1> ;	none
   947                              <1> ; Output:
   948                              <1> ;	none
   949                              <1> ;-------------------------------------------------------------------------
   950                              <1> rtc_setup:
   951 00008ADB 50                  <1> 	push	ax
   952 00008ADC 53                  <1> 	push	bx
   953 00008ADD 51                  <1> 	push	cx
   954 00008ADE 52                  <1> 	push	dx
   955 00008ADF 56                  <1> 	push	si
   956                              <1> 
   957 00008AE0 B010                <1> 	mov	al,cmos_floppy
   958 00008AE2 E8C5FE              <1> 	call	rtc_read		; read currently configured floppies
   959 00008AE5 88C1                <1> 	mov	cl,al			; save it to CL
   960                              <1> 
   961                              <1> .menu_loop:
   962 00008AE7 BE[1E84]            <1> 	mov	si,msg_set_menu
   963 00008AEA E81815              <1> 	call	print
   964                              <1> 
   965                              <1> .menu_input:
   966 00008AED B400                <1> 	mov	ah,00h
   967 00008AEF CD16                <1> 	int	16h
   968 00008AF1 0C20                <1> 	or	al,20h			; convert to lower case
   969 00008AF3 B200                <1> 	mov	dl,0			; floppy 0
   970 00008AF5 3C66                <1> 	cmp	al,'f'
   971 00008AF7 7417                <1> 	je	.set_floppy
   972 00008AF9 FEC2                <1> 	inc	dl			; floppy 1
   973 00008AFB 3C67                <1> 	cmp	al,'g'
   974 00008AFD 7411                <1> 	je	.set_floppy
   975 00008AFF 3C70                <1> 	cmp	al,'p'
   976 00008B01 7458                <1> 	je	.print_settings
   977 00008B03 3C77                <1> 	cmp	al,'w'
   978 00008B05 7469                <1> 	je	.save
   979 00008B07 3C71                <1> 	cmp	al,'q'
   980 00008B09 7503E99C00          <1> 	je	.exit
   981 00008B0E EBDD                <1> 	jmp	.menu_input
   982                              <1> 
   983                              <1> .set_floppy:
   984 00008B10 B40E                <1> 	mov	ah,0Eh			; echo
   985 00008B12 BB0700              <1> 	mov	bx,0007h
   986 00008B15 CD10                <1> 	int	10h
   987 00008B17 BE[E184]            <1> 	mov	si,msg_set_floppy
   988 00008B1A E8E814              <1> 	call	print
   989                              <1> .floppy_input:
   990 00008B1D B400                <1> 	mov	ah,00h
   991 00008B1F CD16                <1> 	int	16h
   992 00008B21 0C20                <1> 	or	al,20h			; convert to lower case
   993 00008B23 3C71                <1> 	cmp	al,'q'
   994 00008B25 742B                <1> 	je	.floppy_exit
   995 00008B27 3C30                <1> 	cmp	al,'0'
   996 00008B29 72F2                <1> 	jb	.floppy_input
   997 00008B2B 3C36                <1> 	cmp	al,'6'
   998 00008B2D 77EE                <1> 	ja	.floppy_input
   999 00008B2F 3C35                <1> 	cmp	al,'5'
  1000 00008B31 74EA                <1> 	je	.floppy_input
  1001 00008B33 B40E                <1> 	mov	ah,0Eh			; echo
  1002 00008B35 BB0700              <1> 	mov	bx,0007h
  1003 00008B38 CD10                <1> 	int	10h
  1004 00008B3A 2C30                <1> 	sub	al,'0'
  1005 00008B3C B6F0                <1> 	mov	dh,0F0h
  1006 00008B3E 08D2                <1> 	or	dl,dl			; drive	0?
  1007 00008B40 750A                <1> 	jnz	.drive_1
  1008 00008B42 D0E0                <1> 	shl	al,1
  1009 00008B44 D0E0                <1> 	shl	al,1
  1010 00008B46 D0E0                <1> 	shl	al,1
  1011 00008B48 D0E0                <1> 	shl	al,1
  1012 00008B4A B60F                <1> 	mov	dh,0Fh
  1013                              <1> .drive_1:
  1014 00008B4C 20F1                <1> 	and	cl,dh
  1015 00008B4E 08C1                <1> 	or	cl,al
  1016 00008B50 EB95                <1> 	jmp	.menu_loop
  1017                              <1> 
  1018                              <1> .floppy_exit:
  1019 00008B52 B40E                <1> 	mov	ah,0Eh			; echo
  1020 00008B54 BB0700              <1> 	mov	bx,0007h
  1021 00008B57 CD10                <1> 	int	10h
  1022 00008B59 EB8C                <1> 	jmp	.menu_loop
  1023                              <1> 
  1024                              <1> .print_settings:
  1025 00008B5B B40E                <1> 	mov	ah,0Eh			; echo
  1026 00008B5D BB0700              <1> 	mov	bx,0007h
  1027 00008B60 CD10                <1> 	int	10h
  1028 00008B62 BE[8A80]            <1> 	mov	si,msg_crlf
  1029 00008B65 E89D14              <1> 	call	print
  1030 00008B68 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1031 00008B6A E8B309              <1> 	call	print_floppy
  1032 00008B6D E977FF              <1> 	jmp	.menu_loop
  1033                              <1> 
  1034                              <1> .save:
  1035 00008B70 50                  <1> 	push	ax
  1036                              <1> 
  1037 00008B71 B010                <1> 	mov	al,cmos_floppy
  1038 00008B73 88CC                <1> 	mov	ah,cl
  1039 00008B75 E83DFE              <1> 	call	rtc_write
  1040                              <1> 
  1041 00008B78 8A261000            <1> 	mov	ah,byte [equipment_list]
  1042 00008B7C 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1043                              <1> 
  1044 00008B7F F6C170              <1> 	test	cl,70h
  1045 00008B82 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1046 00008B84 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1047                              <1> 
  1048                              <1> .second_floppy:
  1049 00008B87 F6C107              <1> 	test	cl,07h
  1050 00008B8A 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1051 00008B8C 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1052                              <1> 					; (even if the first one is missing)
  1053                              <1> 
  1054                              <1> .save_equipment:
  1055 00008B8F 88261000            <1> 	mov	byte [equipment_list],ah
  1056 00008B93 B014                <1> 	mov	al,cmos_equip
  1057 00008B95 E81DFE              <1> 	call	rtc_write
  1058                              <1> 
  1059 00008B98 E828FF              <1> 	call	rtc_checksum
  1060                              <1> 
  1061 00008B9B B02E                <1> 	mov	al,cmos_sum_hi
  1062 00008B9D 88FC                <1> 	mov	ah,bh
  1063 00008B9F E813FE              <1> 	call	rtc_write
  1064                              <1> 
  1065 00008BA2 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1066 00008BA4 88DC                <1> 	mov	ah,bl
  1067 00008BA6 E80CFE              <1> 	call	rtc_write
  1068                              <1> 	
  1069 00008BA9 58                  <1> 	pop	ax
  1070                              <1> 
  1071                              <1> .exit:
  1072 00008BAA B40E                <1> 	mov	ah,0Eh			; echo
  1073 00008BAC BB0700              <1> 	mov	bx,0007h
  1074 00008BAF CD10                <1> 	int	10h
  1075 00008BB1 BE[8A80]            <1> 	mov	si,msg_crlf
  1076 00008BB4 E84E14              <1> 	call	print
  1077 00008BB7 5E                  <1> 	pop	si
  1078 00008BB8 5A                  <1> 	pop	dx
  1079 00008BB9 59                  <1> 	pop	cx
  1080 00008BBA 5B                  <1> 	pop	bx
  1081 00008BBB 58                  <1> 	pop	ax
  1082 00008BBC C3                  <1> 	ret
  1083                              <1> 
  1084                              <1> ;=========================================================================
  1085                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1086                              <1> ; Input:
  1087                              <1> ;	CX = time to delay (in 15 microsecond units)
  1088                              <1> ; Notes:
  1089                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1090                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1091                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1092                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1093                              <1> ;-------------------------------------------------------------------------
  1094                              <1> delay_15us:
  1095 00008BBD 50                  <1> 	push	ax
  1096 00008BBE 51                  <1> 	push	cx
  1097                              <1> .zero:
  1098 00008BBF E461                <1> 	in	al,port_b_reg
  1099 00008BC1 A810                <1> 	test	al,refresh_flag
  1100 00008BC3 74FA                <1> 	jz	.zero
  1101 00008BC5 49                  <1> 	dec	cx
  1102 00008BC6 7409                <1> 	jz	.exit
  1103                              <1> .one:
  1104 00008BC8 E461                <1> 	in	al,port_b_reg
  1105 00008BCA A810                <1> 	test	al,refresh_flag
  1106 00008BCC 75FA                <1> 	jnz	.one
  1107 00008BCE 49                  <1> 	dec	cx
  1108 00008BCF 75EE                <1> 	jnz	.zero
  1109                              <1> .exit:
  1110 00008BD1 59                  <1> 	pop	cx
  1111 00008BD2 58                  <1> 	pop	ax
  1112 00008BD3 C3                  <1> 	ret
  1113                              <1> 
  1114                              <1> %if 0
  1115                              <1> ;=========================================================================
  1116                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1117                              <1> ; Input:
  1118                              <1> ;	DX:AX	- dividend
  1119                              <1> ;	CX	- divisor
  1120                              <1> ; Output:
  1121                              <1> ;	DX:AX	- quotient
  1122                              <1> ;-------------------------------------------------------------------------
  1123                              <1> divide_32:
  1124                              <1> 	or	dx,dx
  1125                              <1> 	jnz	.1
  1126                              <1> 	div	cx
  1127                              <1> 	xor	dx,dx
  1128                              <1> 	ret
  1129                              <1> .1:
  1130                              <1> 	push	bx
  1131                              <1> 	mov	bx,ax
  1132                              <1> 	mov	ax,dx
  1133                              <1> 	xor	dx,dx
  1134                              <1> 	div	cx
  1135                              <1> 	xchg	bx,ax
  1136                              <1> 	div	cx
  1137                              <1> 	mov	dx,bx
  1138                              <1> 	pop	bx
  1139                              <1> 	ret
  1140                              <1> %endif ; 0
  1141                                  %include	"time1.inc"		; time services
  1142                              <1> ;=========================================================================
  1143                              <1> ; time1.inc - BIOS Time Services
  1144                              <1> ;       INT 1Ah - BIOS Time Services
  1145                              <1> ;		functions AH=00h to AH=07h
  1146                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1147                              <1> ;-------------------------------------------------------------------------
  1148                              <1> ;
  1149                              <1> ; Compiles with NASM 2.07, might work with other versions
  1150                              <1> ;
  1151                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  1152                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  1153                              <1> ;
  1154                              <1> ; This program is free software: you can redistribute it and/or modify
  1155                              <1> ; it under the terms of the GNU General Public License as published by
  1156                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1157                              <1> ; (at your option) any later version.
  1158                              <1> ;
  1159                              <1> ; This program is distributed in the hope that it will be useful,
  1160                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1161                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1162                              <1> ; GNU General Public License for more details.
  1163                              <1> ;
  1164                              <1> ; You should have received a copy of the GNU General Public License
  1165                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1166                              <1> ;
  1167                              <1> ;=========================================================================
  1168                              <1> 
  1169                              <1> ;=========================================================================
  1170                              <1> ; int_1A_fn00 - Read current time
  1171                              <1> ; Input:
  1172                              <1> ;	AH = 0 - read current time
  1173                              <1> ; Output:
  1174                              <1> ;	CX = high word of tick count
  1175                              <1> ;	DX = low word of tick count
  1176                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1177                              <1> ;-------------------------------------------------------------------------
  1178                              <1> int_1A_fn00:
  1179 00008BD4 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1180 00008BD8 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1181 00008BDC A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1182 00008BDF 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1183 00008BE3 E9AF72              <1> 	jmp	int_1A_exit
  1184                              <1> 
  1185                              <1> ;=========================================================================
  1186                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1187                              <1> ; Input:
  1188                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1189                              <1> ;	CX = high word of tick count
  1190                              <1> ;	DX = low word of tick count
  1191                              <1> ; Output:
  1192                              <1> ;	None
  1193                              <1> ;-------------------------------------------------------------------------
  1194                              <1> int_1A_fn01:
  1195 00008BE6 89166C00            <1> 	mov	word [ticks_lo],dx
  1196 00008BEA 890E6E00            <1> 	mov	word [ticks_hi],cx
  1197 00008BEE C606700000          <1> 	mov	byte [new_day],00h
  1198 00008BF3 E99F72              <1> 	jmp	int_1A_exit
  1199                              <1> 
  1200                              <1> ;=========================================================================
  1201                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1202                              <1> ; Input:
  1203                              <1> ;	AH = 02h - function 02h - read RTC time
  1204                              <1> ; Output:
  1205                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1206                              <1> ;	CH = BCD hours
  1207                              <1> ;	CL = BCD minutes
  1208                              <1> ;	DH = BCD seconds
  1209                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1210                              <1> ;-------------------------------------------------------------------------
  1211                              <1> int_1A_fn02:
  1212 00008BF6 50                  <1> 	push	ax
  1213 00008BF7 B00A                <1> 	mov	al,cmos_control_a
  1214 00008BF9 E8AEFD              <1> 	call	rtc_read		; read control A register
  1215 00008BFC A880                <1> 	test	al,cmos_uip
  1216 00008BFE 7405                <1> 	jz	.1			; no update in progess
  1217 00008C00 F9                  <1> 	stc
  1218 00008C01 58                  <1> 	pop	ax
  1219 00008C02 E99372              <1> 	jmp	int_1A_exitf
  1220                              <1> .1:
  1221 00008C05 B00B                <1> 	mov	al,cmos_control_b
  1222 00008C07 E8A0FD              <1> 	call	rtc_read		; read control B register
  1223 00008C0A 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1224 00008C0C 88C2                <1> 	mov	dl,al
  1225 00008C0E B000                <1> 	mov	al,cmos_seconds
  1226 00008C10 E897FD              <1> 	call	rtc_read		; read seconds
  1227 00008C13 88C6                <1> 	mov	dh,al
  1228 00008C15 B002                <1> 	mov	al,cmos_minutes
  1229 00008C17 E890FD              <1> 	call	rtc_read		; read minutes
  1230 00008C1A 88C1                <1> 	mov	cl,al
  1231 00008C1C B004                <1> 	mov	al,cmos_hours
  1232 00008C1E E889FD              <1> 	call	rtc_read		; read hours
  1233 00008C21 88C5                <1> 	mov	ch,al
  1234 00008C23 F8                  <1> 	clc
  1235 00008C24 58                  <1> 	pop	ax
  1236 00008C25 E97072              <1> 	jmp	int_1A_exitf
  1237                              <1> 
  1238                              <1> ;=========================================================================
  1239                              <1> ; int_1A_fn03 - Set real time clock
  1240                              <1> ; Input:
  1241                              <1> ;	AH = 03h - function 03h - set RTC time
  1242                              <1> ;	CH = BCD hours
  1243                              <1> ;	CL = BCD minutes
  1244                              <1> ;	DH = BCD seconds
  1245                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1246                              <1> ; Output:
  1247                              <1> ;	None
  1248                              <1> ;-------------------------------------------------------------------------
  1249                              <1> int_1A_fn03:
  1250 00008C28 50                  <1> 	push	ax
  1251 00008C29 B00B                <1> 	mov	al,cmos_control_b
  1252 00008C2B E87CFD              <1> 	call	rtc_read		; read control B register
  1253 00008C2E 88C4                <1> 	mov	ah,al
  1254 00008C30 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1255 00008C33 B00B                <1> 	mov	al,cmos_control_b
  1256 00008C35 E87DFD              <1> 	call	rtc_write		; write control B register
  1257                              <1> 
  1258 00008C38 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1259 00008C3B 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1260 00008C3E 08D4                <1> 	or	ah,dl			; add it from the input
  1261 00008C40 B00B                <1> 	mov	al,cmos_control_b
  1262 00008C42 E870FD              <1> 	call	rtc_write		; write control B register
  1263                              <1> 
  1264 00008C45 B000                <1> 	mov	al,cmos_seconds
  1265 00008C47 88F4                <1> 	mov	ah,dh
  1266 00008C49 E869FD              <1> 	call	rtc_write		; write seconds
  1267 00008C4C B002                <1> 	mov	al,cmos_minutes
  1268 00008C4E 88CC                <1> 	mov	ah,cl
  1269 00008C50 E862FD              <1> 	call	rtc_write		; write minutes
  1270 00008C53 B004                <1> 	mov	al,cmos_hours
  1271 00008C55 88EC                <1> 	mov	ah,ch
  1272 00008C57 E85BFD              <1> 	call	rtc_write		; write hours
  1273                              <1> 
  1274 00008C5A B00B                <1> 	mov	al,cmos_control_b
  1275 00008C5C E84BFD              <1> 	call	rtc_read		; read control B register
  1276 00008C5F 88C4                <1> 	mov	ah,al
  1277 00008C61 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1278 00008C64 B00B                <1> 	mov	al,cmos_control_b
  1279 00008C66 E84CFD              <1> 	call	rtc_write		; write control B register
  1280 00008C69 58                  <1> 	pop	ax
  1281 00008C6A E92872              <1> 	jmp	int_1A_exit
  1282                              <1> 
  1283                              <1> ;=========================================================================
  1284                              <1> ; int_1A_fn04 - Read date from real time clock
  1285                              <1> ; Input:
  1286                              <1> ;	AH = 04h - function 04h - read RTC date
  1287                              <1> ; Output:
  1288                              <1> ;	CH = BCD century
  1289                              <1> ;	CL = BCD year
  1290                              <1> ;	DH = BCD month
  1291                              <1> ;	DL = BCD date
  1292                              <1> ;-------------------------------------------------------------------------
  1293                              <1> int_1A_fn04:
  1294 00008C6D 50                  <1> 	push	ax
  1295 00008C6E B00A                <1> 	mov	al,cmos_control_a
  1296 00008C70 E837FD              <1> 	call	rtc_read		; read control A register
  1297 00008C73 A880                <1> 	test	al,cmos_uip
  1298 00008C75 7405                <1> 	jz	.1			; no update in progess
  1299 00008C77 F9                  <1> 	stc
  1300 00008C78 58                  <1> 	pop	ax
  1301 00008C79 E91C72              <1> 	jmp	int_1A_exitf
  1302                              <1> .1:
  1303 00008C7C B007                <1> 	mov	al,cmos_date
  1304 00008C7E E829FD              <1> 	call	rtc_read		; read date
  1305 00008C81 88C2                <1> 	mov	dl,al
  1306 00008C83 B008                <1> 	mov	al,cmos_month
  1307 00008C85 E822FD              <1> 	call	rtc_read		; read month
  1308 00008C88 88C6                <1> 	mov	dh,al
  1309 00008C8A B009                <1> 	mov	al,cmos_year
  1310 00008C8C E81BFD              <1> 	call	rtc_read		; read year
  1311 00008C8F 88C1                <1> 	mov	cl,al
  1312 00008C91 B032                <1> 	mov	al,cmos_century
  1313 00008C93 E814FD              <1> 	call	rtc_read		; read century
  1314 00008C96 88C5                <1> 	mov	ch,al
  1315 00008C98 F8                  <1> 	clc
  1316 00008C99 58                  <1> 	pop	ax
  1317 00008C9A E9FB71              <1> 	jmp	int_1A_exitf
  1318                              <1> 
  1319                              <1> ;=========================================================================
  1320                              <1> ; int_1A_fn05 - Set date inreal time clock
  1321                              <1> ; Input:
  1322                              <1> ;	AH = 05h - function 05h - set RTC date
  1323                              <1> ;	CH = BCD century
  1324                              <1> ;	CL = BCD year
  1325                              <1> ;	DH = BCD month
  1326                              <1> ;	DL = BCD date
  1327                              <1> ; Output:
  1328                              <1> ;	None
  1329                              <1> ;-------------------------------------------------------------------------
  1330                              <1> int_1A_fn05:
  1331 00008C9D 50                  <1> 	push	ax
  1332 00008C9E B00B                <1> 	mov	al,cmos_control_b
  1333 00008CA0 E807FD              <1> 	call	rtc_read		; read control B register
  1334 00008CA3 88C4                <1> 	mov	ah,al
  1335 00008CA5 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1336 00008CA8 B00B                <1> 	mov	al,cmos_control_b
  1337 00008CAA E808FD              <1> 	call	rtc_write		; write control B register
  1338                              <1> 
  1339 00008CAD B007                <1> 	mov	al,cmos_date
  1340 00008CAF 88D4                <1> 	mov	ah,dl
  1341 00008CB1 E801FD              <1> 	call	rtc_write		; write date
  1342                              <1> 
  1343 00008CB4 B008                <1> 	mov	al,cmos_month
  1344 00008CB6 88F4                <1> 	mov	ah,dh
  1345 00008CB8 E8FAFC              <1> 	call	rtc_write		; write month
  1346 00008CBB B009                <1> 	mov	al,cmos_year
  1347 00008CBD 88CC                <1> 	mov	ah,cl
  1348 00008CBF E8F3FC              <1> 	call	rtc_write		; write year
  1349 00008CC2 B032                <1> 	mov	al,cmos_century
  1350 00008CC4 88EC                <1> 	mov	ah,ch
  1351 00008CC6 E8ECFC              <1> 	call	rtc_write		; write centry
  1352                              <1> 
  1353 00008CC9 B00B                <1> 	mov	al,cmos_control_b
  1354 00008CCB E8DCFC              <1> 	call	rtc_read		; read control B register
  1355 00008CCE 88C4                <1> 	mov	ah,al
  1356 00008CD0 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1357 00008CD3 B00B                <1> 	mov	al,cmos_control_b
  1358 00008CD5 E8DDFC              <1> 	call	rtc_write		; write control B register
  1359 00008CD8 58                  <1> 	pop	ax
  1360 00008CD9 E9B971              <1> 	jmp	int_1A_exit
  1361                              <1> 
  1362                              <1> ;=========================================================================
  1363                              <1> ; int_1A_fn06 - Set real time clock alarm
  1364                              <1> ; Input:
  1365                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1366                              <1> ;	CH = BCD hours
  1367                              <1> ;	CL = BCD minutes
  1368                              <1> ;	DH = BCD seconds
  1369                              <1> ; Output:
  1370                              <1> ;	CF = 1 - alarm already set
  1371                              <1> ;-------------------------------------------------------------------------
  1372                              <1> int_1A_fn06:
  1373 00008CDC 50                  <1> 	push	ax
  1374 00008CDD B00B                <1> 	mov	al,cmos_control_b
  1375 00008CDF E8C8FC              <1> 	call	rtc_read		; read control B register
  1376 00008CE2 A820                <1> 	test	al,cmos_aie
  1377 00008CE4 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1378 00008CE6 F9                  <1> 	stc
  1379 00008CE7 58                  <1> 	pop	ax
  1380 00008CE8 E9AD71              <1> 	jmp	int_1A_exitf
  1381                              <1> .1:
  1382 00008CEB 88C4                <1> 	mov	ah,al
  1383 00008CED 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1384 00008CF0 B00B                <1> 	mov	al,cmos_control_b
  1385 00008CF2 E8C0FC              <1> 	call	rtc_write		; write control B register
  1386                              <1> 
  1387 00008CF5 B001                <1> 	mov	al,cmos_alarm_secs
  1388 00008CF7 88F4                <1> 	mov	ah,dh
  1389 00008CF9 E8B9FC              <1> 	call	rtc_write		; write alarm seconds
  1390 00008CFC B003                <1> 	mov	al,cmos_alarm_mins
  1391 00008CFE 88CC                <1> 	mov	ah,cl
  1392 00008D00 E8B2FC              <1> 	call	rtc_write		; write alarm minutes
  1393 00008D03 B005                <1> 	mov	al,cmos_alarm_hrs
  1394 00008D05 88EC                <1> 	mov	ah,ch
  1395 00008D07 E8ABFC              <1> 	call	rtc_write		; write alarm hours
  1396                              <1> 
  1397 00008D0A B00B                <1> 	mov	al,cmos_control_b
  1398 00008D0C E89BFC              <1> 	call	rtc_read		; read control B register
  1399 00008D0F 88C4                <1> 	mov	ah,al
  1400 00008D11 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1401 00008D14 B00B                <1> 	mov	al,cmos_control_b
  1402 00008D16 E89CFC              <1> 	call	rtc_write		; write control B register
  1403                              <1> 
  1404 00008D19 B00B                <1> 	mov	al,cmos_control_b
  1405 00008D1B E88CFC              <1> 	call	rtc_read		; read control B register
  1406 00008D1E 88C4                <1> 	mov	ah,al
  1407 00008D20 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1408 00008D23 B00B                <1> 	mov	al,cmos_control_b
  1409 00008D25 E88DFC              <1> 	call	rtc_write		; write control B register with AIE set
  1410                              <1> 
  1411 00008D28 58                  <1> 	pop	ax
  1412 00008D29 F8                  <1> 	clc
  1413 00008D2A E96B71              <1> 	jmp	int_1A_exitf
  1414                              <1> 
  1415                              <1> ;=========================================================================
  1416                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1417                              <1> ; Input:
  1418                              <1> ;	AH = 07h - function 07h - set RTC time
  1419                              <1> ; Output:
  1420                              <1> ;	None
  1421                              <1> ;-------------------------------------------------------------------------
  1422                              <1> int_1A_fn07:
  1423 00008D2D 50                  <1> 	push	ax
  1424                              <1> 
  1425 00008D2E B00B                <1> 	mov	al,cmos_control_b
  1426 00008D30 E877FC              <1> 	call	rtc_read		; read control B register
  1427 00008D33 88C4                <1> 	mov	ah,al
  1428 00008D35 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1429 00008D38 B00B                <1> 	mov	al,cmos_control_b
  1430 00008D3A E878FC              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1431                              <1> 
  1432 00008D3D 58                  <1> 	pop	ax
  1433 00008D3E E95471              <1> 	jmp	int_1A_exit
  1434                              <1> 	
  1435                              <1> ;=========================================================================
  1436                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1437                              <1> ; Notes:
  1438                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1439                              <1> ;-------------------------------------------------------------------------
  1440                              <1> int_70:
  1441 00008D41 50                  <1> 	push	ax
  1442 00008D42 B020                <1> 	mov	al,20h
  1443 00008D44 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1444 00008D46 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1445 00008D48 B00C                <1> 	mov	al,cmos_control_c
  1446 00008D4A E85DFC              <1> 	call	rtc_read		; read control C register
  1447 00008D4D A840                <1> 	test	al,cmos_af		; check for alarm flag
  1448 00008D4F 7402                <1> 	jz	.1
  1449 00008D51 CD4A                <1> 	int	4Ah			; call INT 4Ah
  1450                              <1> .1:
  1451 00008D53 58                  <1> 	pop	ax
  1452 00008D54 CF                  <1> 	iret
  1453                                  %include	"floppy1.inc"		; floppy services
  1454                              <1> ;=========================================================================
  1455                              <1> ; floppy1.inc - BIOS floppy disk services
  1456                              <1> ;       INT 13h, function AH=00h
  1457                              <1> ;       INT 13h, function AH=01h
  1458                              <1> ;       INT 13h, function AH=08h
  1459                              <1> ;       INT 13h, function AH=15h
  1460                              <1> ;       INT 13h, function AH=16h
  1461                              <1> ;       INT 13h, function AH=17h
  1462                              <1> ;       INT 13h, function AH=18h
  1463                              <1> ;       INT 13h, function AH=08h
  1464                              <1> ;	- see floppy2.inc for other INT 13h functions
  1465                              <1> ;-------------------------------------------------------------------------
  1466                              <1> ;
  1467                              <1> ; Compiles with NASM 2.07, might work with other versions
  1468                              <1> ;
  1469                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  1470                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  1471                              <1> ;
  1472                              <1> ; This program is free software: you can redistribute it and/or modify
  1473                              <1> ; it under the terms of the GNU General Public License as published by
  1474                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1475                              <1> ; (at your option) any later version.
  1476                              <1> ;
  1477                              <1> ; This program is distributed in the hope that it will be useful,
  1478                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1479                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1480                              <1> ; GNU General Public License for more details.
  1481                              <1> ;
  1482                              <1> ; You should have received a copy of the GNU General Public License
  1483                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1484                              <1> ;
  1485                              <1> ;=========================================================================
  1486                              <1> 
  1487                              <1> ;-------------------------------------------------------------------------
  1488                              <1> ; FDC registers
  1489                              <1> 
  1490                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1491                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1492                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1493                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1494                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1495                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1496                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1497                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1498                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1499                              <1> 
  1500                              <1> ;-------------------------------------------------------------------------
  1501                              <1> ; DMAC registers
  1502                              <1> 
  1503                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1504                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1505                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1506                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1507                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1508                              <1> 					; first / last flip-flop
  1509                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1510                              <1> 
  1511                              <1> ;-------------------------------------------------------------------------
  1512                              <1> ; Floppy disk services - error codes
  1513                              <1> 
  1514                              <1> fdc_e_success	equ	00h		; successful completion
  1515                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1516                              <1> fdc_e_address	equ	02h		; address mark not found
  1517                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1518                              <1> fdc_e_notfound	equ	04h		; sector not found
  1519                              <1> fdc_e_changed	equ	06h		; disk changed
  1520                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1521                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1522                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1523                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1524                              <1> fdc_e_failure	equ	20h		; controller failure
  1525                              <1> fdc_e_seek	equ	40h		; seek failed
  1526                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1527                              <1> 
  1528                              <1> ;-------------------------------------------------------------------------
  1529                              <1> ; Drive media state for fdc_media_state
  1530                              <1> 
  1531                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1532                              <1> fdc_m_established	equ	10h	; bit 4:    media/drive established
  1533                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1534                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1535                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1536                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1537                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1538                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1539                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1540                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1541                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  1542                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  1543                              <1> 
  1544                              <1> ;-------------------------------------------------------------------------
  1545                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  1546                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  1547                              <1> 
  1548                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  1549                              <1> 
  1550                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  1551                              <1> ;	       unset for read or verify
  1552                              <1> 
  1553                              <1> fdc_write_flag	equ	80h		; write or format operation
  1554                              <1> 
  1555                              <1> ;-------------------------------------------------------------------------
  1556                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  1557                              <1> 
  1558                              <1> cmos_no_floppy	equ	00h
  1559                              <1> cmos_360	equ	01h
  1560                              <1> cmos_1200	equ	02h
  1561                              <1> cmos_720	equ	03h
  1562                              <1> cmos_1440	equ	04h
  1563                              <1> cmos_2880	equ	06h
  1564                              <1> 
  1565                              <1> ;=========================================================================
  1566                              <1> ; int_13_fn00: Reset disk system
  1567                              <1> ; Input:
  1568                              <1> ;	AH = 00h
  1569                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1570                              <1> ; Output:
  1571                              <1> ;	CF clear if successful
  1572                              <1> ;		AH = 00h - successful completion
  1573                              <1> ;	CF set on error
  1574                              <1> ;		AH = 20h - controller failure
  1575                              <1> ;		AH = 80h - timeout / device not ready
  1576                              <1> ; Note:
  1577                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1578                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1579                              <1> ;-------------------------------------------------------------------------
  1580                              <1> int_13_fn00:
  1581 00008D55 E80700              <1> 	call	fdc_init
  1582 00008D58 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1583 00008D5C E9775F              <1> 	jmp	int_13_exit
  1584                              <1> 
  1585                              <1> ;=========================================================================
  1586                              <1> ; fdc_init - Initialize floppy disk controller
  1587                              <1> ; Input:
  1588                              <1> ;	none
  1589                              <1> ; Output:
  1590                              <1> ;	CF clear on success
  1591                              <1> ;		AH = 00h - successful completion
  1592                              <1> ;	CF set if error
  1593                              <1> ;		AH = 20h - controller failure
  1594                              <1> ;		AH = 80h - timeout / device not ready
  1595                              <1> ;-------------------------------------------------------------------------
  1596                              <1> fdc_init:
  1597 00008D5F 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  1598 00008D64 E80906              <1> 	call	fdc_reset		; reset FDC
  1599 00008D67 7257                <1> 	jc	fdc_init_error
  1600 00008D69 BAF403              <1> 	mov	dx,fdc_status_reg
  1601 00008D6C EC                  <1> 	in	al,dx
  1602 00008D6D A880                <1> 	test	al,80h
  1603 00008D6F 7404                <1> 	jz	.try_again		; try again if FDC not ready
  1604 00008D71 A840                <1> 	test	al,40h
  1605 00008D73 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  1606                              <1> .try_again:
  1607 00008D75 E8F805              <1> 	call	fdc_reset
  1608 00008D78 BAF403              <1> 	mov	dx,fdc_status_reg
  1609 00008D7B EC                  <1> 	in	al,dx
  1610 00008D7C A880                <1> 	test	al,80h
  1611 00008D7E 7440                <1> 	jz	fdc_init_error
  1612 00008D80 A840                <1> 	test	al,40h
  1613 00008D82 753C                <1> 	jnz	fdc_init_error
  1614                              <1> .fdc_ready:
  1615 00008D84 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  1616 00008D86 E83905              <1> 	call	fdc_write		; send the command
  1617 00008D89 7235                <1> 	jc	fdc_init_error
  1618 00008D8B E88105              <1> 	call	fdc_read		; read ST0
  1619 00008D8E 7230                <1> 	jc	fdc_init_error
  1620 00008D90 A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  1621 00008D93 88C4                <1> 	mov	ah,al			; save AL to AH
  1622 00008D95 E87705              <1> 	call	fdc_read		; read current cylinder
  1623 00008D98 7226                <1> 	jc	fdc_init_error
  1624 00008D9A A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  1625 00008D9D 80E4C0              <1> 	and	ah,0C0h
  1626 00008DA0 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  1627 00008DA3 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  1628                              <1> 
  1629                              <1> ; fall through to fdc_send_specify
  1630                              <1> 
  1631                              <1> ;=========================================================================
  1632                              <1> ; fdc_send_specify - Send specify command to FDC
  1633                              <1> ; Input:
  1634                              <1> ;	none
  1635                              <1> ; Output:
  1636                              <1> ;	CF clear on success
  1637                              <1> ;		AH = 00 - successful completion
  1638                              <1> ;	CF set if error
  1639                              <1> ;		AH = 20h - controller failure
  1640                              <1> ;	AX,CL,SI trashed
  1641                              <1> ; Note:
  1642                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  1643                              <1> ;-------------------------------------------------------------------------
  1644                              <1> fdc_send_specify:
  1645                              <1> 
  1646 00008DA5 1E                  <1> 	push	ds
  1647 00008DA6 31C0                <1> 	xor	ax,ax
  1648 00008DA8 8ED8                <1> 	mov	ds,ax
  1649 00008DAA C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1650 00008DAE B003                <1> 	mov	al,3		 	; FDC Specify command
  1651 00008DB0 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  1652 00008DB2 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  1653 00008DB5 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  1654 00008DB7 1F                  <1> 	pop	ds
  1655 00008DB8 E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  1656 00008DBB 7203                <1> 	jc	fdc_init_error
  1657 00008DBD B400                <1> 	mov	ah,fdc_e_success	; successful completion
  1658 00008DBF C3                  <1> 	ret
  1659                              <1> 
  1660                              <1> fdc_init_error:
  1661 00008DC0 B420                <1> 	mov	ah,fdc_e_failure
  1662 00008DC2 F9                  <1> 	stc
  1663 00008DC3 C3                  <1> 	ret
  1664                              <1> 
  1665                              <1> ;=========================================================================
  1666                              <1> ; int_13_fn01 - Get status of last operation
  1667                              <1> ; Input:
  1668                              <1> ;	AH = 01h
  1669                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1670                              <1> ; Output:
  1671                              <1> ;	CF clear if last operation was successful
  1672                              <1> ;		AH = 00h - successful completion
  1673                              <1> ;	CF set on error
  1674                              <1> ;		AH - error code of the last operation
  1675                              <1> ; Note:
  1676                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1677                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1678                              <1> ;-------------------------------------------------------------------------
  1679                              <1> int_13_fn01:
  1680 00008DC4 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  1681 00008DC8 08E4                <1> 	or	ah,ah
  1682 00008DCA 7401                <1> 	jz	.no_error
  1683 00008DCC F9                  <1> 	stc
  1684                              <1> .no_error:
  1685 00008DCD E9065F              <1> 	jmp	int_13_exit
  1686                              <1> 
  1687                              <1> ;=========================================================================
  1688                              <1> ; int_13_fn08: Get drive parameters
  1689                              <1> ; Input:
  1690                              <1> ;	AH = 08h
  1691                              <1> ;	DL = drive number (0 - 7Fh)
  1692                              <1> ; Output:
  1693                              <1> ;	CF clear if successful
  1694                              <1> ;		AX = 0000h
  1695                              <1> ;		BH = 00h
  1696                              <1> ;		BL = CMOS drive type
  1697                              <1> ;		CH = maximal cylinder number - 1
  1698                              <1> ;		CL = maximal sector number
  1699                              <1> ;		DH = maximal head number
  1700                              <1> ;		DL = number of drives
  1701                              <1> ;		ES:DI -> diskette parameter table
  1702                              <1> ;	CF set on error
  1703                              <1> ;		AH = 01h - drive number is greater than 7Fh
  1704                              <1> ; Notes:
  1705                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  1706                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  1707                              <1> ;	- If media type is not established function sets media parameters 
  1708                              <1> ;	based on CMOS drive type
  1709                              <1> ;-------------------------------------------------------------------------
  1710                              <1> int_13_fn08:
  1711 00008DD0 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  1712 00008DD3 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  1713 00008DD8 A01000              <1> 	mov	al,byte [equipment_list]
  1714 00008DDB 2441                <1> 	and	al,equip_floppies|equip_floppy2
  1715 00008DDD B402                <1> 	mov	ah,2			; assume two floppy drives
  1716 00008DDF 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  1717 00008DE1 7406                <1> 	je	.check_drive_number
  1718 00008DE3 FECC                <1> 	dec	ah			; assume one floppy drive
  1719 00008DE5 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  1720 00008DE7 757C                <1> 	jne	.no_drives
  1721                              <1> 
  1722                              <1> .check_drive_number:
  1723 00008DE9 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  1724 00008DEC 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  1725                              <1> 					; than number of disks?
  1726 00008DEE 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  1727 00008DF0 E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  1728 00008DF3 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  1729                              <1> 
  1730 00008DF5 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  1731 00008DF9 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  1732 00008DFC 8CC9                <1> 	mov	cx,cs
  1733 00008DFE 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  1734                              <1> 
  1735 00008E00 3C01                <1> 	cmp	al,cmos_360
  1736 00008E02 7417                <1> 	je	.set_360
  1737 00008E04 3C03                <1> 	cmp	al,cmos_720
  1738 00008E06 741E                <1> 	je	.set_720
  1739 00008E08 3C02                <1> 	cmp	al,cmos_1200
  1740 00008E0A 7425                <1> 	je	.set_1200
  1741 00008E0C 3C04                <1> 	cmp	al,cmos_1440
  1742 00008E0E 742C                <1> 	je	.set_1440
  1743                              <1> 
  1744                              <1> .set_2880:
  1745 00008E10 B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  1746 00008E12 8D3E[B0EF]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  1747 00008E16 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  1748 00008E19 EB2A                <1> 	jmp	.set_media_type
  1749                              <1> 
  1750                              <1> .set_360:
  1751 00008E1B B093                <1> 	mov	al,fdc_m_360in360
  1752 00008E1D 8D3E[6FEF]          <1> 	lea	di,[media_360_in_360]
  1753 00008E21 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  1754 00008E24 EB1F                <1> 	jmp	.set_media_type
  1755                              <1> 
  1756                              <1> .set_720:
  1757 00008E26 B097                <1> 	mov	al,fdc_m_720
  1758 00008E28 8D3E[89EF]          <1> 	lea	di,[media_720]
  1759 00008E2C B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  1760 00008E2F EB14                <1> 	jmp	.set_media_type
  1761                              <1> 
  1762                              <1> .set_1200:
  1763 00008E31 B002                <1> 	mov	al,fdc_m_try_1200in1200
  1764 00008E33 8D3E[7CEF]          <1> 	lea	di,[media_1200]
  1765 00008E37 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  1766 00008E3A EB09                <1> 	jmp	.set_media_type
  1767                              <1> 
  1768                              <1> .set_1440:
  1769 00008E3C B007                <1> 	mov	al,fdc_m_try_1440
  1770 00008E3E 8D3E[96EF]          <1> 	lea	di,[media_1440]
  1771 00008E42 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  1772                              <1> 
  1773                              <1> .set_media_type:
  1774 00008E45 BB9000              <1> 	mov	bx,fdc_media_state
  1775 00008E48 00D3                <1> 	add	bl,dl			; BX -> drive media state
  1776 00008E4A F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  1777 00008E4D 7502                <1> 	jnz	.set_parameters		; no need to update if established
  1778 00008E4F 8807                <1> 	mov	[bx],al
  1779                              <1> 
  1780                              <1> .set_parameters:
  1781 00008E51 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  1782 00008E53 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  1783 00008E56 A24100              <1> 	mov	byte [fdc_last_error],al
  1784 00008E59 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  1785 00008E5C 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  1786 00008E5F 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  1787 00008E62 E9715E              <1> 	jmp	int_13_exit
  1788                              <1> 
  1789                              <1> .no_drives:
  1790 00008E65 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  1791                              <1> 
  1792                              <1> .non_existent_drive:
  1793 00008E69 31C9                <1> 	xor	cx,cx
  1794 00008E6B 31FF                <1> 	xor	di,di
  1795 00008E6D 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  1796 00008E70 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  1797 00008E73 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  1798 00008E75 EBDA                <1> 	jmp	.set_parameters
  1799                              <1> 
  1800                              <1> .invalid_drive:
  1801 00008E77 B401                <1> 	mov	ah,fdc_e_invalid
  1802 00008E79 F9                  <1> 	stc
  1803 00008E7A E9595E              <1> 	jmp	int_13_exit
  1804                              <1> 
  1805                              <1> ;=========================================================================
  1806                              <1> ; int_13_fn15: Get disk type
  1807                              <1> ; Input:
  1808                              <1> ;	AH = 15h
  1809                              <1> ;	DL = drive number (0 or 1)
  1810                              <1> ; Output:
  1811                              <1> ;	AH = type code:
  1812                              <1> ;		00h - no such drive (invalid drive specified)
  1813                              <1> ;		01h - floppy without change-line support
  1814                              <1> ;		02h - floppy with change-line support
  1815                              <1> ;-------------------------------------------------------------------------
  1816                              <1> int_13_fn15:
  1817 00008E7D B400                <1> 	mov	ah,00h			; assume no drive
  1818 00008E7F 80FA01              <1> 	cmp	dl,1
  1819 00008E82 7711                <1> 	ja	.exit			; jump if invalid drive number
  1820 00008E84 E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  1821 00008E87 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  1822 00008E89 B401                <1> 	mov	ah,01h			; assume no change-line support
  1823 00008E8B 3C01                <1> 	cmp	al,cmos_360
  1824 00008E8D 7406                <1> 	je	.exit
  1825 00008E8F 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  1826 00008E91 7402                <1> 	je	.exit
  1827 00008E93 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  1828                              <1> 
  1829                              <1> .exit:
  1830 00008E95 F8                  <1> 	clc
  1831 00008E96 C606410000          <1> 	mov	byte [fdc_last_error],0
  1832 00008E9B E9385E              <1> 	jmp	int_13_exit
  1833                              <1> 
  1834                              <1> ;=========================================================================
  1835                              <1> ; int_13_fn16 - Detect disk change
  1836                              <1> ; Input:
  1837                              <1> ;	AH = 16h
  1838                              <1> ;	DL = drive number (0 or 1)
  1839                              <1> ; Output:
  1840                              <1> ;	CF clear if change line inactive
  1841                              <1> ;		AH = 00h - disk not changed
  1842                              <1> ;	CF set if change line active or error
  1843                              <1> ;		AH = 01h - invalid drive number
  1844                              <1> ;		AH = 06h - disk changed or change line not supported
  1845                              <1> ;		AH = 80h - timeout / device not ready
  1846                              <1> ;-------------------------------------------------------------------------
  1847                              <1> int_13_fn16:
  1848 00008E9E 80FA01              <1> 	cmp	dl,1
  1849 00008EA1 7741                <1> 	ja	.invalid_drive
  1850 00008EA3 E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  1851 00008EA6 723C                <1> 	jc	.invalid_drive
  1852                              <1> 
  1853 00008EA8 3C01                <1> 	cmp	al,cmos_360
  1854 00008EAA 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  1855 00008EAC 3C03                <1> 	cmp	al,cmos_720
  1856 00008EAE 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  1857                              <1> 
  1858 00008EB0 E86302              <1> 	call	fdc_motor_on		; turn motor on
  1859 00008EB3 30E4                <1> 	xor	ah,ah			; assume disk not changed
  1860 00008EB5 BAF703              <1> 	mov	dx,fdc_dir_reg
  1861 00008EB8 EC                  <1> 	in	al,dx			; read disk change line
  1862 00008EB9 D0E0                <1> 	shl	al,1			; bit 7 to CF
  1863 00008EBB 7303                <1> 	jnc	.exit
  1864 00008EBD B406                <1> 	mov	ah,fdc_e_changed
  1865 00008EBF F9                  <1> 	stc
  1866                              <1> 
  1867                              <1> .exit:
  1868 00008EC0 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1869 00008EC4 9C                  <1> 	pushf
  1870 00008EC5 1E                  <1> 	push	ds
  1871 00008EC6 31F6                <1> 	xor	si,si
  1872 00008EC8 8EDE                <1> 	mov	ds,si
  1873 00008ECA C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1874 00008ECE 8A4C02              <1> 	mov	cl,byte [si+2]
  1875 00008ED1 1F                  <1> 	pop	ds
  1876 00008ED2 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  1877 00008ED6 9D                  <1> 	popf
  1878 00008ED7 E9FC5D              <1> 	jmp	int_13_exit
  1879                              <1> 
  1880                              <1> 
  1881                              <1> .no_change_line:
  1882 00008EDA B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  1883 00008EDC F9                  <1> 	stc
  1884 00008EDD 88264100            <1> 	mov	byte [fdc_last_error],ah
  1885 00008EE1 E9F25D              <1> 	jmp	int_13_exit
  1886                              <1> 
  1887                              <1> .invalid_drive:
  1888 00008EE4 B401                <1> 	mov	ah,fdc_e_invalid
  1889 00008EE6 F9                  <1> 	stc
  1890 00008EE7 E9EC5D              <1> 	jmp	int_13_exit
  1891                              <1> 
  1892                              <1> ;=========================================================================
  1893                              <1> ; int_13_fn17 - Set disk type for format
  1894                              <1> ; Input:
  1895                              <1> ;	AH = 17h
  1896                              <1> ;	AL = format type
  1897                              <1> ;		01h - 320K / 360K disk in 360K drive
  1898                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  1899                              <1> ;		03h - 1.2M disk in 1.2M drive
  1900                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  1901                              <1> ;	DL = drive number (0 or 1)
  1902                              <1> ; Output:
  1903                              <1> ;	CF clear if successful
  1904                              <1> ;		AH = 00h - successful completion
  1905                              <1> ;	CF set on error
  1906                              <1> ;		AH = 01h - invalid drive number
  1907                              <1> ;		AH = 06h - disk changed
  1908                              <1> ;		AH = 80h - timeout / device not ready
  1909                              <1> ;-------------------------------------------------------------------------
  1910                              <1> int_13_fn17:
  1911 00008EEA 80FA01              <1> 	cmp	dl,1
  1912 00008EED 7762                <1> 	ja	.invalid_parameters
  1913 00008EEF E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  1914 00008EF2 725D                <1> 	jc	.invalid_parameters
  1915 00008EF4 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  1916 00008EF7 80F900              <1> 	cmp	cl,0			; validate parameters
  1917 00008EFA 7455                <1> 	je	.invalid_parameters
  1918 00008EFC 80F904              <1> 	cmp	cl,4
  1919 00008EFF 7750                <1> 	ja	.invalid_parameters
  1920 00008F01 BB9000              <1> 	mov	bx,fdc_media_state
  1921 00008F04 00D3                <1> 	add	bl,dl			; BX -> drive media state
  1922 00008F06 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  1923 00008F09 7507                <1> 	jne	.not_360in360
  1924 00008F0B C60793              <1> 	mov	byte [bx],fdc_m_360in360
  1925 00008F0E B400                <1> 	mov	ah,0			; no error
  1926 00008F10 EB33                <1> 	jmp	.exit_check_error
  1927                              <1> 
  1928                              <1> .not_360in360:
  1929 00008F12 E80102              <1> 	call	fdc_motor_on
  1930 00008F15 89DE                <1> 	mov	si,bx
  1931 00008F17 E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  1932 00008F1A 80FC06              <1> 	cmp	ah,fdc_e_changed
  1933 00008F1D 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  1934 00008F1F 80FC80              <1> 	cmp	ah,fdc_e_timeout
  1935 00008F22 750A                <1> 	jne	.set_type		; floppy disk is installed
  1936 00008F24 803F97              <1> 	cmp	byte [bx],97h		; 250 Kbps and not 5.25?
  1937 00008F27 741C                <1> 	je	.exit_check_error
  1938 00008F29 C60761              <1> 	mov	byte [bx],61h		; 300 Kpbs, try 360 in 1.2M
  1939 00008F2C EB17                <1> 	jmp	.exit_check_error
  1940                              <1> 
  1941                              <1> .set_type:
  1942 00008F2E 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  1943 00008F31 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  1944 00008F33 C60797              <1> 	mov	byte [bx],fdc_m_720
  1945 00008F36 EB0D                <1> 	jmp	.exit_check_error
  1946                              <1> 
  1947                              <1> .check_360in1200:
  1948 00008F38 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  1949 00008F3B 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  1950 00008F3D C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  1951 00008F40 EB03                <1> 	jmp	.exit_check_error
  1952                              <1> 
  1953                              <1> .set_1200in1200:
  1954 00008F42 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  1955                              <1> 
  1956                              <1> .exit_check_error:
  1957 00008F45 88264100            <1> 	mov	byte [fdc_last_error],ah
  1958 00008F49 08E4                <1> 	or	ah,ah
  1959 00008F4B 7401                <1> 	jz	.exit			; jump if no error
  1960 00008F4D F9                  <1> 	stc				; indicate error
  1961                              <1> 
  1962                              <1> .exit:
  1963 00008F4E E9645D              <1> 	jmp	int_13_upd_exit
  1964                              <1> 
  1965                              <1> .invalid_parameters:
  1966 00008F51 B401                <1> 	mov	ah,fdc_e_invalid
  1967 00008F53 EBF9                <1> 	jmp	.exit
  1968                              <1> 
  1969                              <1> ;=========================================================================
  1970                              <1> ; int_13_fn18 - Set media type for format
  1971                              <1> ; Input:
  1972                              <1> ;	AH = 18h
  1973                              <1> ;	DL = drive number (0 or 1)
  1974                              <1> ;	CH = number of cylinders - 1
  1975                              <1> ;	CL = sectors per track
  1976                              <1> ; Output:
  1977                              <1> ;	CF = clear if successful
  1978                              <1> ;		AH = 00h - requested format is supported
  1979                              <1> ;		ES:DI -> diskette parameter table
  1980                              <1> ;	CF = set on error
  1981                              <1> ;		AH = 01h - invalid drive number specified
  1982                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  1983                              <1> ;-------------------------------------------------------------------------
  1984                              <1> int_13_fn18:
  1985 00008F55 80FA01              <1> 	cmp	dl,1
  1986 00008F58 7603E99900          <1> 	ja	.invalid_drive
  1987 00008F5D E84504              <1> 	call	read_cmos_type		; get drive type in AL
  1988 00008F60 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  1989                              <1> 
  1990 00008F65 BB9000              <1> 	mov	bx,fdc_media_state
  1991 00008F68 00D3                <1> 	add	bl,dl			; BX -> drive media state
  1992                              <1> 
  1993 00008F6A 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  1994 00008F6C 7511                <1> 	jne	.try_drive_1200
  1995 00008F6E 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  1996 00008F72 7403E98300          <1> 	jnz	.unsupported_format
  1997 00008F77 B093                <1> 	mov	al,93h			; 360K in 360K established, 250 Kbps
  1998 00008F79 8D3E[6FEF]          <1> 	lea	di,[media_360_in_360]
  1999 00008F7D EB54                <1> 	jmp	.set_media
  2000                              <1> 
  2001                              <1> .try_drive_1200:
  2002 00008F7F 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2003 00008F81 751C                <1> 	jne	.try_drive_2880
  2004 00008F83 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2005 00008F87 7508                <1> 	jne	.try_media_360_in_1200
  2006 00008F89 B015                <1> 	mov	al,15h			; 1.2M in 1.2M established, 500Kbps
  2007 00008F8B 8D3E[7CEF]          <1> 	lea	di,[media_1200]		; 1.2M
  2008 00008F8F EB42                <1> 	jmp	.set_media
  2009                              <1> 
  2010                              <1> .try_media_360_in_1200:
  2011 00008F91 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2012 00008F95 7563                <1> 	jne	.unsupported_format
  2013 00008F97 B074                <1> 	mov	al,74h			; 360K in 1.2M established, 300Kbps
  2014 00008F99 8D3E[A3EF]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2015 00008F9D EB34                <1> 	jmp	.set_media
  2016                              <1> 
  2017                              <1> .try_drive_2880:
  2018 00008F9F 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2019 00008FA1 750E                <1> 	jne	.try_drive_1440
  2020 00008FA3 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2021 00008FA7 750C                <1> 	jne	.try_media_1440
  2022 00008FA9 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2023 00008FAB 8D3E[B0EF]          <1> 	lea	di,[media_2880]
  2024 00008FAF EB22                <1> 	jmp	.set_media
  2025                              <1> 
  2026                              <1> .try_drive_1440:
  2027 00008FB1 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2028 00008FB3 750E                <1> 	jne	.try_drive_720
  2029                              <1> 
  2030                              <1> .try_media_1440:
  2031 00008FB5 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2032 00008FB9 750C                <1> 	jne	.try_media_720
  2033 00008FBB B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2034 00008FBD 8D3E[96EF]          <1> 	lea	di,[media_1440]
  2035 00008FC1 EB10                <1> 	jmp	.set_media
  2036                              <1> 
  2037                              <1> .try_drive_720:
  2038 00008FC3 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2039 00008FC5 7533                <1> 	jne	.unsupported_format	; should never happen...
  2040                              <1> 
  2041                              <1> .try_media_720:	
  2042 00008FC7 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2043 00008FCB 752D                <1> 	jne	.unsupported_format
  2044 00008FCD B097                <1> 	mov	al,97h			; other established, 250Kbps
  2045 00008FCF 8D3E[89EF]          <1> 	lea	di,[media_720]		; 720K
  2046                              <1> 
  2047                              <1> .set_media:
  2048 00008FD3 8807                <1> 	mov	byte [bx],al		; set physical media
  2049 00008FD5 E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2050 00008FD8 D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2051 00008FDA D0C8                <1> 	ror	al,1
  2052 00008FDC 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2053 00008FE1 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2054 00008FE5 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2055 00008FE8 8CC9                <1> 	mov	cx,cs
  2056 00008FEA 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2057 00008FEC C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2058 00008FF1 30E4                <1> 	xor	ah,ah
  2059 00008FF3 E9BF5C              <1> 	jmp	int_13_upd_exit
  2060                              <1> 
  2061                              <1> .invalid_drive:
  2062 00008FF6 B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2063 00008FF8 EB02                <1> 	jmp	.error
  2064                              <1> 
  2065                              <1> .unsupported_format:
  2066 00008FFA B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2067                              <1> 
  2068                              <1> .error:
  2069 00008FFC F9                  <1> 	stc
  2070 00008FFD E9B55C              <1> 	jmp	int_13_upd_exit
  2071                              <1> 
  2072                              <1> ;=========================================================================
  2073                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2074                              <1> ; Input:
  2075                              <1> ;	DL = drive number (0 or 1)
  2076                              <1> ; Output:
  2077                              <1> ;	CF clear if successful
  2078                              <1> ;		AH = 00h - successful completion
  2079                              <1> ;	CF set on error
  2080                              <1> ;		AH = 20h - controller failure
  2081                              <1> ;		AH = 20h - timeout
  2082                              <1> ;	AH trashed
  2083                              <1> ;-------------------------------------------------------------------------
  2084                              <1> fdc_recalibrate:
  2085 00009000 56                  <1> 	push	si
  2086 00009001 51                  <1> 	push	cx
  2087 00009002 52                  <1> 	push	dx
  2088 00009003 B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2089 00009005 88D4                <1> 	mov	ah,dl			; drive number
  2090 00009007 B102                <1> 	mov	cl,2			; 2 bytes command
  2091 00009009 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2092 0000900E E86502              <1> 	call	fdc_send_cmd
  2093 00009011 7244                <1> 	jc	recal_end		; failure
  2094 00009013 E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2095 00009016 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2096 00009018 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2097 0000901A B101                <1> 	mov	cl,1			; 1 byte command
  2098 0000901C E85702              <1> 	call	fdc_send_cmd
  2099 0000901F 7236                <1> 	jc	recal_end		; failure
  2100 00009021 B90200              <1> 	mov	cx,2			; 2 bytes result
  2101 00009024 E8B402              <1> 	call	fdc_get_result		; store result
  2102 00009027 722E                <1> 	jc	recal_end		; failure
  2103 00009029 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2104 0000902C B440                <1> 	mov	ah,fdc_e_seek
  2105 0000902E 8A17                <1> 	mov	dl,[bx]			; ST0
  2106 00009030 80E260              <1> 	and	dl,60h
  2107 00009033 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2108 00009036 F9                  <1> 	stc				; indicate error
  2109 00009037 741E                <1> 	je	recal_end		; failure
  2110 00009039 5A                  <1> 	pop	dx
  2111 0000903A 52                  <1> 	push	dx
  2112 0000903B 30F6                <1> 	xor	dh,dh				 
  2113 0000903D BB9400              <1> 	mov	bx,fdc_cylinder
  2114 00009040 01D3                <1> 	add	bx,dx
  2115 00009042 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2116 00009045 88D1                <1> 	mov	cl,dl
  2117 00009047 B201                <1> 	mov	dl,1
  2118 00009049 D2E2                <1> 	shl	dl,cl
  2119 0000904B 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2120 0000904F B94300              <1> 	mov	cx,43h
  2121 00009052 E868FB              <1> 	call	delay_15us		; 1 ms delay
  2122 00009055 30E4                <1> 	xor	ah,ah
  2123                              <1> 
  2124                              <1> recal_end:
  2125 00009057 88264100            <1> 	mov	byte [fdc_last_error],ah
  2126 0000905B 5A                  <1> 	pop	dx
  2127 0000905C 59                  <1> 	pop	cx
  2128 0000905D 5E                  <1> 	pop	si
  2129 0000905E C3                  <1> 	ret
  2130                              <1> 
  2131                              <1> ;=========================================================================
  2132                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2133                              <1> ; Input:
  2134                              <1> ;	DL = drive number
  2135                              <1> ;	DH = head number
  2136                              <1> ;	CH = cylinder
  2137                              <1> ; Output:
  2138                              <1> ;	CF clear if successful
  2139                              <1> ;		AH = 00h - successful completion
  2140                              <1> ;	CF set on error
  2141                              <1> ;		AH = 20h - controller failure
  2142                              <1> ;		AH = 40h - seek failed
  2143                              <1> ;		AH = 80h - timeout / device not ready
  2144                              <1> ;-------------------------------------------------------------------------
  2145                              <1> fdc_seek:
  2146 0000905F 53                  <1> 	push	bx
  2147 00009060 51                  <1> 	push	cx
  2148 00009061 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2149 00009065 88D1                <1> 	mov	cl,dl
  2150 00009067 FEC1                <1> 	inc	cl
  2151 00009069 D2EC                <1> 	shr	ah,cl
  2152 0000906B 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2153 0000906D E890FF              <1> 	call	fdc_recalibrate
  2154 00009070 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2155 00009072 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2156 00009075 727F                <1> 	jc	.exit			; no luck...
  2157                              <1> 
  2158                              <1> .skip_recalibrate:
  2159 00009077 B700                <1> 	mov	bh,00h
  2160 00009079 88D3                <1> 	mov	bl,dl			; BX = drive number
  2161                              <1> 
  2162 0000907B F687900020          <1> 	test	byte [fdc_media_state+bx],20h 	; check double stepping bit
  2163 00009080 7402                <1> 	jz	.no_double_stepping
  2164 00009082 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2165                              <1> 
  2166                              <1> .no_double_stepping:
  2167 00009084 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2168 00009088 750B                <1> 	jne	.do_seek		; jump if seek is required
  2169 0000908A 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2170 0000908F 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2171 00009091 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2172 00009093 EB61                <1> 	jmp	.exit
  2173                              <1> 
  2174                              <1> .do_seek:
  2175 00009095 88E8                <1> 	mov	al,ch			; cylinder
  2176 00009097 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2177 00009099 B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2178 0000909B 88F4                <1> 	mov	ah,dh			; head
  2179 0000909D D0E4                <1> 	shl	ah,1
  2180 0000909F D0E4                <1> 	shl	ah,1
  2181 000090A1 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2182 000090A3 B103                <1> 	mov	cl,3			; 3 bytes command
  2183 000090A5 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2184 000090AA E8C901              <1> 	call	fdc_send_cmd
  2185 000090AD 7243                <1> 	jc	.set_result		; seek error
  2186 000090AF E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2187 000090B2 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2188                              <1> 
  2189 000090B4 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2190 000090B6 B101                <1> 	mov	cl,1			; 1 byte command
  2191 000090B8 E8BB01              <1> 	call	fdc_send_cmd
  2192 000090BB 7235                <1> 	jc	.set_result		; failure
  2193 000090BD B102                <1> 	mov	cl,2
  2194 000090BF 53                  <1> 	push	bx
  2195 000090C0 E81802              <1> 	call	fdc_get_result		; read result bytes
  2196 000090C3 5B                  <1> 	pop	bx
  2197 000090C4 722C                <1> 	jc	.set_result		; error
  2198 000090C6 B440                <1> 	mov	ah,fdc_e_seek
  2199 000090C8 A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2200 000090CB 2460                <1> 	and	al,60h
  2201 000090CD 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2202 000090CF F9                  <1> 	stc
  2203 000090D0 7420                <1> 	je	.set_result		; seek error
  2204 000090D2 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2205                              <1> 
  2206 000090D6 1E                  <1> 	push	ds
  2207 000090D7 31F6                <1> 	xor	si,si
  2208 000090D9 8EDE                <1> 	mov	ds,si
  2209 000090DB C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2210 000090DF 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2211 000090E2 1F                  <1> 	pop	ds
  2212                              <1> 
  2213 000090E3 08C0                <1> 	or	al,al			; head settle time is zero?!
  2214 000090E5 7412                <1> 	jz	.get_settle_time
  2215                              <1> 
  2216 000090E7 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2217 000090E9 F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2218 000090EB 89C1                <1> 	mov	cx,ax
  2219                              <1> 
  2220                              <1> .wait:
  2221 000090ED E8CDFA              <1> 	call	delay_15us
  2222                              <1> 
  2223                              <1> .wait_end:
  2224 000090F0 30E4                <1> 	xor	ah,ah
  2225                              <1> 
  2226                              <1> .set_result:
  2227 000090F2 88264100            <1> 	mov	byte [fdc_last_error],ah
  2228                              <1> 
  2229                              <1> .exit:
  2230 000090F6 59                  <1> 	pop	cx
  2231 000090F7 5B                  <1> 	pop	bx
  2232 000090F8 C3                  <1> 	ret
  2233                              <1> 
  2234                              <1> .get_settle_time:
  2235 000090F9 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2236 000090FE 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2237                              <1> 	
  2238 00009100 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2239 00009104 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2240 00009107 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2241 0000910A 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2242 0000910C 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2243 0000910F 74DC                <1> 	je	.wait			; jump if 360K, media established
  2244 00009111 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2245 00009114 EBD7                <1> 	jmp	.wait
  2246                              <1> 
  2247                              <1> ;=========================================================================
  2248                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2249                              <1> ; Input:
  2250                              <1> ;	DL = drive number (0 or 1)
  2251                              <1> ; Output:
  2252                              <1> ;	none
  2253                              <1> ;-------------------------------------------------------------------------
  2254                              <1> fdc_motor_on:
  2255 00009116 50                  <1> 	push	ax
  2256 00009117 51                  <1> 	push	cx
  2257 00009118 52                  <1> 	push	dx
  2258 00009119 FA                  <1> 	cli				; entering critical section
  2259 0000911A C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2260 0000911F 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2261 00009124 88D1                <1> 	mov	cl,dl			; CL = drive number
  2262 00009126 D0E2                <1> 	shl	dl,1
  2263 00009128 D0E2                <1> 	shl	dl,1
  2264 0000912A D0E2                <1> 	shl	dl,1
  2265 0000912C D0E2                <1> 	shl	dl,1
  2266 0000912E 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2267 00009132 FEC1                <1> 	inc	cl
  2268 00009134 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2269 00009138 D2EA                <1> 	shr	dl,cl
  2270 0000913A 7255                <1> 	jc	.already_on
  2271 0000913C B201                <1> 	mov	dl,1
  2272 0000913E FEC9                <1> 	dec	cl
  2273 00009140 D2E2                <1> 	shl	dl,cl
  2274 00009142 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2275 00009146 FB                  <1> 	sti				; end of critical section
  2276 00009147 A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2277 0000914A D0C8                <1> 	ror	al,1
  2278 0000914C D0C8                <1> 	ror	al,1
  2279 0000914E D0C8                <1> 	ror	al,1
  2280 00009150 D0C8                <1> 	ror	al,1
  2281 00009152 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2282 00009154 BAF203              <1> 	mov	dx,fdc_dor_reg
  2283 00009157 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2284 00009158 B8FD90              <1> 	mov	ax,90FDh
  2285 0000915B CD15                <1> 	int	15h			; call OS hook
  2286 0000915D 722E                <1> 	jc	.exit
  2287 0000915F 1E                  <1> 	push	ds
  2288 00009160 56                  <1> 	push	si
  2289 00009161 31F6                <1> 	xor	si,si
  2290 00009163 8EDE                <1> 	mov	ds,si
  2291 00009165 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2292 00009169 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2293 0000916C 5E                  <1> 	pop	si
  2294 0000916D 1F                  <1> 	pop	ds
  2295                              <1> 
  2296 0000916E F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2297 00009173 7408                <1> 	jz	.read_verify		; jump if not write operation
  2298 00009175 3C08                <1> 	cmp	al,8
  2299 00009177 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2300 00009179 B008                <1> 	mov	al,8			; wait at least 1 second for write
  2301 0000917B EB06                <1> 	jmp	.wait_loop
  2302                              <1> 
  2303                              <1> .read_verify:
  2304 0000917D 3C05                <1> 	cmp	al,5
  2305 0000917F 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2306 00009181 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2307                              <1> 
  2308                              <1> .wait_loop:
  2309 00009183 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2310 00009186 E834FA              <1> 	call	delay_15us		; wait 125 ms
  2311 00009189 FEC8                <1> 	dec	al
  2312 0000918B 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2313                              <1> 
  2314                              <1> .exit:
  2315 0000918D 59                  <1> 	pop	cx
  2316 0000918E 5A                  <1> 	pop	dx
  2317 0000918F 58                  <1> 	pop	ax
  2318 00009190 C3                  <1> 	ret
  2319                              <1> 
  2320                              <1> .already_on:
  2321 00009191 FB                  <1> 	sti
  2322 00009192 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2323 00009195 D0C8                <1> 	ror	al,1
  2324 00009197 D0C8                <1> 	ror	al,1
  2325 00009199 D0C8                <1> 	ror	al,1
  2326 0000919B D0C8                <1> 	ror	al,1
  2327 0000919D 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2328 0000919F BAF203              <1> 	mov	dx,fdc_dor_reg
  2329 000091A2 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2330 000091A3 EBE8                <1> 	jmp	.exit
  2331                              <1> 
  2332                              <1> ;=========================================================================
  2333                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2334                              <1> ; Input:
  2335                              <1> ;	CH = cylinder
  2336                              <1> ;	DH = head
  2337                              <1> ; Output:
  2338                              <1> ;	BL = next sector to be transferred
  2339                              <1> ;-------------------------------------------------------------------------	
  2340                              <1> 
  2341                              <1> fdc_end_io:
  2342 000091A5 50                  <1> 	push	ax
  2343 000091A6 1E                  <1> 	push	ds
  2344 000091A7 31DB                <1> 	xor	bx,bx
  2345 000091A9 8EDB                <1> 	mov	ds,bx
  2346 000091AB C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2347 000091AF 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2348 000091B2 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2349 000091B5 FEC0                <1> 	inc	al
  2350 000091B7 1F                  <1> 	pop	ds
  2351 000091B8 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2352 000091BB 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2353 000091BE 7508                <1> 	jne	.exit
  2354 000091C0 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2355 000091C3 7503                <1> 	jne	.exit
  2356 000091C5 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2357                              <1> .exit:
  2358 000091C8 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2359 000091CC 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2360 000091CE 58                  <1> 	pop	ax
  2361 000091CF C3                  <1> 	ret
  2362                              <1> 
  2363                              <1> ;========================================================================
  2364                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2365                              <1> ; Input:
  2366                              <1> ;	AL = CMOS drive type
  2367                              <1> ;	DS:SI -> drive media type
  2368                              <1> ; Output:
  2369                              <1> ;	CF clear if disk not changed
  2370                              <1> ;		AH = 00h - disk not changed
  2371                              <1> ;	CF set if disk changed or on error
  2372                              <1> ;		AH = 06h - disk changed
  2373                              <1> ;		AH = error code
  2374                              <1> ; Note:
  2375                              <1> ;	Motor needs to be turned on before calling this function
  2376                              <1> ;------------------------------------------------------------------------
  2377                              <1> fdc_disk_change:
  2378 000091D0 51                  <1> 	push	cx
  2379 000091D1 B400                <1> 	mov	ah,0
  2380 000091D3 3C01                <1> 	cmp	al,cmos_360
  2381 000091D5 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2382 000091D7 3C03                <1> 	cmp	al,cmos_720
  2383 000091D9 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2384                              <1> .cmos_invalid:
  2385 000091DB 8A04                <1> 	mov	al,[si]			; media type
  2386 000091DD 2407                <1> 	and	al,fdc_m_state_bits
  2387 000091DF 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2388 000091E1 3C03                <1> 	cmp	al,3
  2389 000091E3 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2390 000091E5 BAF703              <1> 	mov	dx,fdc_dir_reg
  2391 000091E8 EC                  <1> 	in	al,dx			; read disk change line
  2392 000091E9 D0E0                <1> 	shl	al,1
  2393 000091EB 7326                <1> 	jnc	.exit			; no disk change
  2394 000091ED 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2395 000091F0 E86CFB              <1> 	call	fdc_init		; full initialization
  2396 000091F3 721E                <1> 	jc	.exit
  2397 000091F5 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2398 000091F8 B501                <1> 	mov	ch,1
  2399 000091FA E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2400 000091FD 7214                <1> 	jc	.exit
  2401 000091FF B500                <1> 	mov	ch,0
  2402 00009201 E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2403 00009204 720D                <1> 	jc	.exit
  2404 00009206 B406                <1> 	mov	ah,fdc_e_changed
  2405 00009208 BAF703              <1> 	mov	dx,fdc_dir_reg
  2406 0000920B EC                  <1> 	in	al,dx			; read disk change line
  2407 0000920C D0E0                <1> 	shl	al,1
  2408 0000920E 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2409 00009210 B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2410                              <1> 
  2411                              <1> .changed_or_error:
  2412 00009212 F9                  <1> 	stc
  2413                              <1> 
  2414                              <1> .exit:
  2415 00009213 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2416 00009216 59                  <1> 	pop	cx
  2417 00009217 C3                  <1> 	ret
  2418                              <1> 
  2419                              <1> ;=========================================================================
  2420                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2421                              <1> ; Input:
  2422                              <1> ;	AL = DMA mode byte
  2423                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2424                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2425                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2426                              <1> ;	CX = byte count (minus 1)
  2427                              <1> ;	ES:BX -> buffer address for DMA operation
  2428                              <1> ; Output:
  2429                              <1> ;	CF clear on success
  2430                              <1> ;	CF set if error
  2431                              <1> ;		AH = 08h - DMA overrun
  2432                              <1> ;	AX,BX trashed
  2433                              <1> ; Note:
  2434                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2435                              <1> ;-------------------------------------------------------------------------
  2436                              <1> fdc_configure_dma:
  2437 00009218 52                  <1> 	push	dx
  2438 00009219 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2439 0000921B D1C2                <1> 	rol	dx,1
  2440 0000921D D1C2                <1> 	rol	dx,1
  2441 0000921F D1C2                <1> 	rol	dx,1
  2442 00009221 D1C2                <1> 	rol	dx,1
  2443 00009223 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2444 00009225 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2445 00009228 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2446 0000922B 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2447 0000922D 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2448                              <1> 
  2449 00009230 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2450 00009232 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2451 00009234 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2452                              <1> 
  2453 00009236 FA                  <1> 	cli
  2454 00009237 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2455 00009239 EB00                <1> 	jmp	$+2
  2456 0000923B EB00                <1> 	jmp	$+2
  2457 0000923D E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2458 0000923F EB00                <1> 	jmp	$+2
  2459 00009241 EB00                <1> 	jmp	$+2
  2460 00009243 88C8                <1> 	mov	al,cl
  2461 00009245 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2462 00009247 EB00                <1> 	jmp	$+2
  2463 00009249 EB00                <1> 	jmp	$+2
  2464 0000924B 88E8                <1> 	mov	al,ch
  2465 0000924D E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2466 0000924F EB00                <1> 	jmp	$+2
  2467 00009251 EB00                <1> 	jmp	$+2
  2468 00009253 88D0                <1> 	mov	al,dl
  2469 00009255 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2470 00009257 EB00                <1> 	jmp	$+2
  2471 00009259 EB00                <1> 	jmp	$+2
  2472 0000925B 88F0                <1> 	mov	al,dh
  2473 0000925D E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2474 0000925F EB00                <1> 	jmp	$+2
  2475 00009261 EB00                <1> 	jmp	$+2
  2476 00009263 88E0                <1> 	mov	al,ah
  2477 00009265 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2478 00009267 EB00                <1> 	jmp	$+2
  2479 00009269 EB00                <1> 	jmp	$+2
  2480 0000926B B002                <1> 	mov	al,2
  2481 0000926D E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2482 0000926F FB                  <1> 	sti
  2483                              <1> 
  2484                              <1> .exit:
  2485 00009270 5A                  <1> 	pop	dx
  2486 00009271 C3                  <1> 	ret
  2487                              <1> 
  2488                              <1> .dma_boundary:				; Note: CF is already set
  2489 00009272 B409                <1> 	mov	ah,fdc_e_boundary
  2490 00009274 EBFA                <1> 	jmp	.exit
  2491                              <1> 
  2492                              <1> ;=========================================================================
  2493                              <1> ; fdc_send_cmd - Send a command to FDC
  2494                              <1> ; Input:
  2495                              <1> ;	AL = 1st byte of the command
  2496                              <1> ;	AH = 2nd byte of the command
  2497                              <1> ;	SI = 3rd and 4th bytes of the command
  2498                              <1> ;	DI = 5th and 6th bytes of the command
  2499                              <1> ;	BL = 7th byte of the command
  2500                              <1> ;	BH = 8th byte of the command
  2501                              <1> ;	CH = 9th byte of the command
  2502                              <1> ;	CL = command length (number of bytes)
  2503                              <1> ; Output:
  2504                              <1> ;	CF clear if successful
  2505                              <1> ;		AH = 00h - successful completion
  2506                              <1> ;	CF set on error
  2507                              <1> ;		AH = 20h - controller failure
  2508                              <1> ;		AH = 80h - timeout / device not ready
  2509                              <1> ;	AX trashed
  2510                              <1> ;-------------------------------------------------------------------------
  2511                              <1> fdc_send_cmd:
  2512 00009276 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2513 00009279 FEC9                <1> 	dec	cl
  2514 0000927B 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2515 0000927D 88E0                <1> 	mov	al,ah
  2516 0000927F E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2517 00009282 FEC9                <1> 	dec	cl
  2518 00009284 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2519 00009286 89F0                <1> 	mov	ax,si
  2520 00009288 E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2521 0000928B FEC9                <1> 	dec	cl
  2522 0000928D 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2523 0000928F 88E0                <1> 	mov	al,ah
  2524 00009291 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2525 00009294 FEC9                <1> 	dec	cl
  2526 00009296 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2527 00009298 89F8                <1> 	mov	ax,di
  2528 0000929A E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2529 0000929D FEC9                <1> 	dec	cl
  2530 0000929F 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2531 000092A1 88E0                <1> 	mov	al,ah
  2532 000092A3 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2533 000092A6 FEC9                <1> 	dec	cl
  2534 000092A8 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2535 000092AA 88D8                <1> 	mov	al,bl
  2536 000092AC E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2537 000092AF FEC9                <1> 	dec	cl
  2538 000092B1 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2539 000092B3 88F8                <1> 	mov	al,bh
  2540 000092B5 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2541 000092B8 FEC9                <1> 	dec	cl
  2542 000092BA 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2543 000092BC 88E8                <1> 	mov	al,ch
  2544 000092BE E80100              <1> 	call	fdc_write		; send CH (9th byte)
  2545                              <1> 
  2546                              <1> .send_cmd_exit:
  2547 000092C1 C3                  <1> 	ret
  2548                              <1> 
  2549                              <1> ;=========================================================================
  2550                              <1> ; fdc_write - Send byte to FDC
  2551                              <1> ; Input:
  2552                              <1> ;	AL = byte to send
  2553                              <1> ; Output:
  2554                              <1> ;	CF clear if successful
  2555                              <1> ;	CF set if timeout
  2556                              <1> ;		AH = 80h - timeout / device not ready
  2557                              <1> ;-------------------------------------------------------------------------
  2558                              <1> fdc_write:
  2559 000092C2 52                  <1> 	push	dx
  2560 000092C3 50                  <1> 	push	ax
  2561 000092C4 E83502              <1> 	call	fdc_wait_ready
  2562 000092C7 720D                <1> 	jc	.timeout
  2563 000092C9 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  2564 000092CB 3C80                <1> 	cmp	al,fdc_stat_ready
  2565 000092CD 7507                <1> 	jne	.timeout
  2566 000092CF 58                  <1> 	pop	ax
  2567 000092D0 BAF503              <1> 	mov	dx,fdc_data_reg
  2568 000092D3 EE                  <1> 	out	dx,al			; write byte
  2569                              <1> 
  2570                              <1> .exit:
  2571 000092D4 5A                  <1> 	pop	dx
  2572 000092D5 C3                  <1> 	ret
  2573                              <1> 
  2574                              <1> .timeout:
  2575 000092D6 58                  <1> 	pop	ax
  2576 000092D7 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2577 000092D9 EBF9                <1> 	jmp	.exit
  2578                              <1> 
  2579                              <1> ;=========================================================================
  2580                              <1> ; fdc_get_result - Read FDC result
  2581                              <1> ; Input:
  2582                              <1> ;	CL = number of result bytes
  2583                              <1> ; Output:
  2584                              <1> ;	CF clear if successful
  2585                              <1> ;		AH = 00h - operation successful
  2586                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  2587                              <1> ;	CF set on error
  2588                              <1> ;		AH = 20h - controller failure
  2589                              <1> ;		AH = 80h - timeout / device not ready
  2590                              <1> ;	AL,BX - trashed
  2591                              <1> ;-------------------------------------------------------------------------
  2592                              <1> fdc_get_result:
  2593 000092DB 52                  <1> 	push	dx
  2594 000092DC BB4200              <1> 	mov	bx,fdc_ctrl_status
  2595                              <1> 
  2596                              <1> .next_byte:
  2597 000092DF E81A02              <1> 	call	fdc_wait_ready
  2598 000092E2 7222                <1> 	jc	.timeout
  2599 000092E4 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  2600 000092E6 88C4                <1> 	mov	ah,al
  2601 000092E8 80E4EF              <1> 	and	ah,~fdc_stat_busy
  2602 000092EB 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  2603 000092EE 7412                <1> 	je	.done			; jump if finished
  2604 000092F0 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  2605 000092F2 7516                <1> 	jne	.failure		; jump on invalid controller status
  2606 000092F4 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  2607 000092F7 7311                <1> 	jnb	.failure		; controller error if so
  2608 000092F9 BAF503              <1> 	mov	dx,fdc_data_reg
  2609 000092FC EC                  <1> 	in	al,dx
  2610 000092FD 8807                <1> 	mov	byte [bx],al
  2611 000092FF 43                  <1> 	inc	bx
  2612 00009300 EBDD                <1> 	jmp	.next_byte
  2613                              <1> 
  2614                              <1> .done:
  2615 00009302 30E4                <1> 	xor	ah,ah			; operation successful
  2616                              <1> 
  2617                              <1> .exit:
  2618 00009304 5A                  <1> 	pop	dx
  2619 00009305 C3                  <1> 	ret
  2620                              <1> 
  2621                              <1> .timeout:
  2622 00009306 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2623 00009308 EBFA                <1> 	jmp	.exit
  2624                              <1> 
  2625                              <1> .failure:
  2626 0000930A B420                <1> 	mov	ah,fdc_e_failure
  2627 0000930C F9                  <1> 	stc
  2628 0000930D EBF5                <1> 	jmp	.exit
  2629                              <1> 
  2630                              <1> ;=========================================================================
  2631                              <1> ; fdc_read - Read byte from FDC
  2632                              <1> ; Input:
  2633                              <1> ;	none
  2634                              <1> ; Output:
  2635                              <1> ;	CF clear if successful
  2636                              <1> ;		AL = byte read from FDC
  2637                              <1> ;		AH - unchanged
  2638                              <1> ;	CF set on error
  2639                              <1> ;		AH = 20h - controller failure
  2640                              <1> ;		AH = 80h - timeout / device not ready
  2641                              <1> ;	CX trashed
  2642                              <1> ;-------------------------------------------------------------------------
  2643                              <1> fdc_read:
  2644 0000930F 52                  <1> 	push	dx
  2645 00009310 BAF403              <1> 	mov	dx,fdc_status_reg
  2646 00009313 E8E601              <1> 	call	fdc_wait_ready
  2647 00009316 720F                <1> 	jc	.timeout
  2648 00009318 EC                  <1> 	in	al,dx
  2649 00009319 A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  2650 0000931B 740E                <1> 	jz	.failure		; jump if not ready
  2651 0000931D EB00                <1> 	jmp	short $+2		; I/O delay
  2652 0000931F EB00                <1> 	jmp	short $+2
  2653 00009321 BAF503              <1> 	mov	dx,fdc_data_reg
  2654 00009324 EC                  <1> 	in	al,dx			; read the byte
  2655                              <1> 
  2656                              <1> .exit:
  2657 00009325 5A                  <1> 	pop	dx
  2658 00009326 C3                  <1> 	ret
  2659                              <1> 
  2660                              <1> .timeout:
  2661 00009327 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  2662 00009329 EBFA                <1> 	jmp	.exit
  2663                              <1> 
  2664                              <1> .failure:
  2665 0000932B B420                <1> 	mov	ah,fdc_e_failure
  2666 0000932D F9                  <1> 	stc
  2667 0000932E EBF5                <1> 	jmp	.exit
  2668                              <1> 
  2669                              <1> ;=========================================================================
  2670                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  2671                              <1> ; Input:
  2672                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  2673                              <1> ; Output:
  2674                              <1> ;	AH = error code
  2675                              <1> ;-------------------------------------------------------------------------
  2676                              <1> 
  2677                              <1> fdc_get_error:
  2678 00009330 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2679 00009333 8B1F                <1> 	mov	bx,[bx]
  2680 00009335 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  2681 00009338 B400                <1> 	mov	ah,fdc_e_success
  2682 0000933A 7433                <1> 	jz	.exit			; jump if successful completion
  2683 0000933C F6C340              <1> 	test	bl,40h			; abnormal termination?
  2684 0000933F B420                <1> 	mov	ah,fdc_e_failure
  2685 00009341 742C                <1> 	jz	.exit
  2686 00009343 F6C701              <1> 	test	bh,1			; address mark not found?
  2687 00009346 B402                <1> 	mov	ah,fdc_e_address
  2688 00009348 7525                <1> 	jnz	.exit
  2689 0000934A F6C702              <1> 	test	bh,2			; disk write protected?
  2690 0000934D B403                <1> 	mov	ah,fdc_e_wprotect
  2691 0000934F 751E                <1> 	jnz	.exit
  2692 00009351 F6C704              <1> 	test	bh,4			; sector not found?
  2693 00009354 B404                <1> 	mov	ah,fdc_e_notfound
  2694 00009356 7517                <1> 	jnz	.exit
  2695 00009358 F6C710              <1> 	test	bh,10H			; DMA overrun?
  2696 0000935B B408                <1> 	mov	ah,fdc_e_dma
  2697 0000935D 7510                <1> 	jnz	.exit
  2698 0000935F F6C720              <1> 	test	bh,20H			; CRC error?
  2699 00009362 B410                <1> 	mov	ah,fdc_e_crc
  2700 00009364 7509                <1> 	jnz	.exit
  2701 00009366 F6C780              <1> 	test	bh,80h			; access after last sector?
  2702 00009369 B404                <1> 	mov	ah,fdc_e_notfound
  2703 0000936B 7502                <1> 	jnz	.exit
  2704 0000936D B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  2705                              <1> 
  2706                              <1> .exit:
  2707 0000936F C3                  <1> 	ret
  2708                              <1> 
  2709                              <1> ;=========================================================================
  2710                              <1> ; fdc_reset - Reset FDC
  2711                              <1> ; Input:
  2712                              <1> ;	none
  2713                              <1> ; Output:
  2714                              <1> ;	Resets FDC flags in BIOS area
  2715                              <1> ;	AX,CX,DX - trashed 
  2716                              <1> ;-------------------------------------------------------------------------
  2717                              <1> 
  2718                              <1> fdc_reset:
  2719 00009370 FA                  <1> 	cli
  2720 00009371 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  2721 00009376 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2722 0000937B A03F00              <1> 	mov	al,byte [fdc_motor_state]
  2723 0000937E D0C0                <1> 	rol	al,1			; after rol:
  2724 00009380 D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  2725 00009382 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  2726 00009384 D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  2727 00009386 24FB                <1> 	and	al,0FBh			; clear reserved bit
  2728 00009388 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  2729 0000938A BAF203              <1> 	mov	dx,fdc_dor_reg
  2730 0000938D EE                  <1> 	out	dx,al			; send it to FDC
  2731 0000938E B90300              <1> 	mov	cx,3
  2732 00009391 E829F8              <1> 	call	delay_15us		; 30-45 us delay
  2733 00009394 0C0C                <1> 	or	al,0Ch
  2734 00009396 EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  2735 00009397 FB                  <1> 	sti
  2736 00009398 E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2737 0000939B 7207                <1> 	jc	.exit
  2738 0000939D 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  2739 000093A2 30E4                <1> 	xor	ah,ah			; no errors
  2740                              <1> .exit:
  2741 000093A4 C3                  <1> 	ret
  2742                              <1> 
  2743                              <1> ;=========================================================================
  2744                              <1> ; read_cmos_type - Read drive type from CMOS
  2745                              <1> ; Input:
  2746                              <1> ;	DL = drive number (0 or 1)
  2747                              <1> ; Output:
  2748                              <1> ;	CF clear if successful
  2749                              <1> ;		AL = drive type
  2750                              <1> ;	CF set on error (invalid drive type)
  2751                              <1> ;=========================================================================
  2752                              <1> 
  2753                              <1> read_cmos_type:
  2754 000093A5 B010                <1> 	mov	al,cmos_floppy
  2755 000093A7 E800F6              <1> 	call	rtc_read		; read drive type
  2756 000093AA 08D2                <1> 	or	dl,dl			; drive 0?
  2757 000093AC 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  2758 000093AE D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  2759 000093B0 D0E8                <1> 	shr	al,1
  2760 000093B2 D0E8                <1> 	shr	al,1
  2761 000093B4 D0E8                <1> 	shr	al,1
  2762                              <1> .drive_1:
  2763 000093B6 240F                <1> 	and	al,0Fh			; mask drive bits
  2764 000093B8 3C00                <1> 	cmp	al,cmos_no_floppy
  2765 000093BA 740A                <1> 	je	.error
  2766 000093BC 3C05                <1> 	cmp	al,5			; invalid value
  2767 000093BE 7406                <1> 	je	.error
  2768 000093C0 3C06                <1> 	cmp	al,cmos_2880
  2769 000093C2 7702                <1> 	ja	.error
  2770 000093C4 F8                  <1> 	clc
  2771 000093C5 C3                  <1> 	ret
  2772                              <1> 
  2773                              <1> .error:
  2774 000093C6 F9                  <1> 	stc
  2775 000093C7 C3                  <1> 	ret
  2776                              <1> 
  2777                              <1> ;=========================================================================
  2778                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  2779                              <1> ; Input:
  2780                              <1> ;	none, expects drive number in [bp+int_13_dl]
  2781                              <1> ; Output:
  2782                              <1> ;	CF clear if successful
  2783                              <1> ;		AH = 00h
  2784                              <1> ;	CF set on error
  2785                              <1> ;		AH = 20h - invalid CMOS
  2786                              <1> ;-------------------------------------------------------------------------
  2787                              <1> fdc_detect_media:
  2788 000093C8 52                  <1> 	push	dx
  2789 000093C9 51                  <1> 	push	cx
  2790 000093CA 53                  <1> 	push	bx
  2791 000093CB 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  2792 000093CE BB9000              <1> 	mov	bx,fdc_media_state
  2793 000093D1 00D3                <1> 	add	bl,dl
  2794 000093D3 E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  2795 000093D6 B400                <1> 	mov	ah,0
  2796 000093D8 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  2797                              <1> 
  2798 000093DA 3C03                <1> 	cmp	al,cmos_720
  2799 000093DC 7410                <1> 	je	.set_720
  2800 000093DE 3C02                <1> 	cmp	al,cmos_1200
  2801 000093E0 7415                <1> 	je	.detect_1200
  2802 000093E2 3C04                <1> 	cmp	al,cmos_1440
  2803 000093E4 7427                <1> 	je	.detect_1440
  2804 000093E6 3C06                <1> 	cmp	al,cmos_2880
  2805 000093E8 7439                <1> 	je	.detect_2880
  2806                              <1> 	
  2807 000093EA B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  2808 000093EC EB02                <1> 	jmp	.set_rate
  2809                              <1> 
  2810                              <1> .set_720:
  2811 000093EE B097                <1> 	mov	al,fdc_m_720
  2812                              <1> 
  2813                              <1> .set_rate:
  2814 000093F0 50                  <1> 	push	ax
  2815 000093F1 E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  2816 000093F4 58                  <1> 	pop	ax
  2817 000093F5 EB49                <1> 	jmp	.exit_set_media
  2818                              <1> 
  2819                              <1> .detect_1200:
  2820 000093F7 B000                <1> 	mov	al,0			; try 500 Kbps
  2821 000093F9 E85300              <1> 	call	fdc_read_id
  2822 000093FC B015                <1> 	mov	al,fdc_m_1200in1200
  2823 000093FE 7340                <1> 	jnc	.exit_set_media		; jump if successful
  2824 00009400 B040                <1> 	mov	al,40h			; try 300 Kbps
  2825 00009402 E84A00              <1> 	call	fdc_read_id
  2826 00009405 B074                <1> 	mov	al,fdc_m_360in1200
  2827 00009407 7337                <1> 	jnc	.exit_set_media		; jump if successful
  2828 00009409 B002                <1> 	mov	al,fdc_m_try_1200in1200
  2829 0000940B EB33                <1> 	jmp	.exit_set_media
  2830                              <1> 
  2831                              <1> .detect_1440:
  2832 0000940D B000                <1> 	mov	al,0			; try 500 Kbps
  2833 0000940F E83D00              <1> 	call	fdc_read_id
  2834 00009412 B017                <1> 	mov	al,fdc_m_1440
  2835 00009414 732A                <1> 	jnc	.exit_set_media		; jump if successful
  2836 00009416 B080                <1> 	mov	al,80h			; try 250 Kbps
  2837 00009418 E83400              <1> 	call	fdc_read_id
  2838 0000941B B097                <1> 	mov	al,fdc_m_720
  2839 0000941D 7321                <1> 	jnc	.exit_set_media		; jump if successful
  2840 0000941F B007                <1> 	mov	al,fdc_m_try_1440
  2841 00009421 EB1D                <1> 	jmp	.exit_set_media
  2842                              <1> 
  2843                              <1> .detect_2880:
  2844 00009423 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  2845 00009425 E82700              <1> 	call	fdc_read_id
  2846 00009428 B0D7                <1> 	mov	al,fdc_m_2880
  2847 0000942A 7314                <1> 	jnc	.exit_set_media		; jump if successful
  2848 0000942C B000                <1> 	mov	al,0			; try 500 Kbps
  2849 0000942E E81E00              <1> 	call	fdc_read_id
  2850 00009431 B017                <1> 	mov	al,fdc_m_1440
  2851 00009433 730B                <1> 	jnc	.exit_set_media		; jump if successful
  2852 00009435 B080                <1> 	mov	al,80h			; try 250 Kbps
  2853 00009437 E81500              <1> 	call	fdc_read_id
  2854 0000943A B097                <1> 	mov	al,fdc_m_720
  2855 0000943C 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  2856 0000943E B0C7                <1> 	mov	al,fdc_m_try_2880
  2857                              <1> 
  2858                              <1> .exit_set_media:
  2859 00009440 8807                <1> 	mov	byte [bx],al		; set media type
  2860                              <1> 
  2861                              <1> .exit:
  2862 00009442 88264100            <1> 	mov	byte [fdc_last_error],ah
  2863 00009446 5B                  <1> 	pop	bx
  2864 00009447 59                  <1> 	pop	cx
  2865 00009448 5A                  <1> 	pop	dx
  2866 00009449 C3                  <1> 	ret
  2867                              <1> 
  2868                              <1> .invalid_cmos:
  2869 0000944A B420                <1> 	mov	ah,fdc_e_failure
  2870 0000944C F9                  <1> 	stc
  2871 0000944D EBF3                <1> 	jmp	.exit
  2872                              <1> 
  2873                              <1> ;=========================================================================
  2874                              <1> ; fdc_read_id - Read ID
  2875                              <1> ; Input:
  2876                              <1> ;	AL = data transfer rate (bits 7-6)
  2877                              <1> ; Output:
  2878                              <1> ;	CF clear if successful
  2879                              <1> ;		AH = 0 - successful completion
  2880                              <1> ;		AL = ID (bits 7-6)
  2881                              <1> ;	CF set on error
  2882                              <1> ;		AH = error code
  2883                              <1> ;-------------------------------------------------------------------------
  2884                              <1> fdc_read_id:
  2885 0000944F 53                  <1> 	push	bx
  2886 00009450 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  2887 00009455 E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  2888 00009458 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  2889 0000945B E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  2890 0000945E 7305                <1> 	jnc	.do_read_id
  2891 00009460 E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  2892 00009463 722D                <1> 	jc	.error
  2893                              <1> 
  2894                              <1> .do_read_id:
  2895 00009465 B90300              <1> 	mov	cx,3			; 3 attempts
  2896                              <1> 
  2897                              <1> .read_id_loop:
  2898 00009468 51                  <1> 	push	cx
  2899 00009469 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  2900 0000946B 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  2901 0000946D B102                <1> 	mov	cl,2			; 2 byte commands
  2902 0000946F 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2903 00009474 E8FFFD              <1> 	call	fdc_send_cmd
  2904 00009477 7218                <1> 	jc	.error_cmd
  2905 00009479 E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2906 0000947C 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  2907 0000947E B107                <1> 	mov	cl,7
  2908 00009480 E858FE              <1> 	call	fdc_get_result		; read result bytes
  2909 00009483 720C                <1> 	jc	.error_cmd
  2910 00009485 E8A8FE              <1> 	call	fdc_get_error		; get error code
  2911 00009488 59                  <1> 	pop	cx
  2912 00009489 08E4                <1> 	or	ah,ah
  2913 0000948B 7406                <1> 	jz	.exit			; if no errors
  2914 0000948D E2D9                <1> 	loop	.read_id_loop		; retry
  2915 0000948F EB01                <1> 	jmp	.error
  2916                              <1> 
  2917                              <1> .error_cmd:
  2918 00009491 59                  <1> 	pop	cx
  2919                              <1> 
  2920                              <1> .error:
  2921 00009492 F9                  <1> 	stc
  2922                              <1> 
  2923                              <1> .exit:
  2924 00009493 5B                  <1> 	pop	bx
  2925 00009494 C3                  <1> 	ret
  2926                              <1> 
  2927                              <1> ;=========================================================================
  2928                              <1> ; fdc_select_rate - Select FDC transfer rate
  2929                              <1> ; Input:
  2930                              <1> ;	AL = data transfer rate (bits 7-6)
  2931                              <1> ; Output:
  2932                              <1> ;	none
  2933                              <1> ;-------------------------------------------------------------------------
  2934                              <1> fdc_select_rate:
  2935 00009495 53                  <1> 	push	bx
  2936 00009496 BB9000              <1> 	mov	bx,fdc_media_state
  2937 00009499 00D3                <1> 	add	bl,dl			; SI -> drive media state
  2938 0000949B 8A37                <1> 	mov	dh,byte [bx]		; new media status
  2939 0000949D 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  2940 000094A1 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  2941 000094A5 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  2942 000094A7 740E                <1> 	je	.exit			; exit if rate is already selected
  2943 000094A9 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  2944 000094AE 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  2945 000094B2 88F0                <1> 	mov	al,dh
  2946 000094B4 E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  2947                              <1> 
  2948                              <1> .exit:
  2949 000094B7 5B                  <1> 	pop	bx
  2950 000094B8 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2951 000094BB C3                  <1> 	ret
  2952                              <1> 
  2953                              <1> ;=========================================================================
  2954                              <1> ; fdc_set_rate - Set transfer rate
  2955                              <1> ; Input:
  2956                              <1> ;	AL = transfer rate (bits 7 and 6)
  2957                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  2958                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  2959                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  2960                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  2961                              <1> ; Output:
  2962                              <1> ;	AL = transfer rate (bits 1 and 0)
  2963                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  2964                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  2965                              <1> ;	DX = 3F7h - FDC CCR
  2966                              <1> ;-------------------------------------------------------------------------
  2967                              <1> fdc_set_rate:
  2968 000094BC 24C0                <1> 	and	al,fdc_m_rate_bits
  2969 000094BE D0C0                <1> 	rol	al,1
  2970 000094C0 D0C0                <1> 	rol	al,1
  2971 000094C2 BAF703              <1> 	mov	dx,fdc_ccr_reg
  2972 000094C5 EE                  <1> 	out	dx,al
  2973 000094C6 C3                  <1> 	ret
  2974                              <1> 
  2975                              <1> ;=========================================================================
  2976                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  2977                              <1> ; Input:
  2978                              <1> ;	none
  2979                              <1> ; Output:
  2980                              <1> ;	CF clear if interrupt had occurred
  2981                              <1> ;		AH = 00h - successful completion
  2982                              <1> ;	CF set if no interrupt
  2983                              <1> ;		AH = 80h - timeout
  2984                              <1> ;	BX = fdc_calib_state
  2985                              <1> ;	AL,CX - trashed
  2986                              <1> ;-------------------------------------------------------------------------
  2987                              <1> fdc_wait_irq:
  2988 000094C7 FB                  <1> 	sti
  2989 000094C8 F8                  <1> 	clc
  2990 000094C9 B80190              <1> 	mov	ax,9001h
  2991 000094CC CD15                <1> 	int	15h			; call OS hook
  2992 000094CE 7221                <1> 	jc	.timeout
  2993 000094D0 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  2994 000094D3 31C9                <1> 	xor	cx,cx
  2995                              <1> 
  2996                              <1> .zero:
  2997 000094D5 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  2998 000094D8 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  2999                              <1> 
  3000                              <1> .zero_loop:
  3001 000094DA E461                <1> 	in	al,port_b_reg
  3002 000094DC A810                <1> 	test	al,refresh_flag
  3003 000094DE 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3004 000094E0 E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3005 000094E2 EB0D                <1> 	jmp	.timeout
  3006                              <1> 
  3007                              <1> .one:
  3008 000094E4 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3009 000094E7 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3010                              <1> 
  3011                              <1> .one_loop:
  3012 000094E9 E461                <1> 	in	al,port_b_reg
  3013 000094EB A810                <1> 	test	al,refresh_flag
  3014 000094ED 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3015 000094EF E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3016                              <1> 
  3017                              <1> .timeout:
  3018 000094F1 B480                <1> 	mov	ah,fdc_e_timeout
  3019 000094F3 F9                  <1> 	stc
  3020 000094F4 C3                  <1> 	ret
  3021                              <1> 
  3022                              <1> .exit:
  3023 000094F5 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3024 000094F8 B400                <1> 	mov	ah,fdc_e_success
  3025 000094FA F8                  <1> 	clc				; DEBUG - remove after debug
  3026 000094FB C3                  <1> 	ret
  3027                              <1> 
  3028                              <1> ;=========================================================================
  3029                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3030                              <1> ;		   but no more than one second
  3031                              <1> ; Input:
  3032                              <1> ; Output:
  3033                              <1> ;	CF clear if FDC is ready
  3034                              <1> ;		AL = FDC main status register
  3035                              <1> ;	CF set on timeout
  3036                              <1> ;		AL trashed
  3037                              <1> ;	DX - trashed
  3038                              <1> ;-------------------------------------------------------------------------
  3039                              <1> 
  3040                              <1> fdc_wait_ready:
  3041 000094FC 51                  <1> 	push	cx
  3042 000094FD BAF403              <1> 	mov	dx,fdc_status_reg
  3043 00009500 31C9                <1> 	xor	cx,cx
  3044                              <1> 
  3045                              <1> .zero:
  3046 00009502 EC                  <1> 	in	al,dx			; read I/O port
  3047 00009503 A880                <1> 	test	al,fdc_stat_ready
  3048 00009505 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3049                              <1> 
  3050                              <1> .zero_loop:
  3051 00009507 E461                <1> 	in	al,port_b_reg
  3052 00009509 A810                <1> 	test	al,refresh_flag
  3053 0000950B 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3054 0000950D 49                  <1> 	dec	cx
  3055 0000950E 740D                <1> 	jz	.timeout
  3056 00009510 EC                  <1> 	in	al,dx			; read I/O port again
  3057 00009511 A880                <1> 	test	al,fdc_stat_ready
  3058 00009513 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3059                              <1> 
  3060                              <1> .one_loop:
  3061 00009515 E461                <1> 	in	al,port_b_reg
  3062 00009517 A810                <1> 	test	al,refresh_flag
  3063 00009519 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3064 0000951B E2E5                <1> 	loop	.zero
  3065                              <1> 
  3066                              <1> .timeout:
  3067 0000951D F9                  <1> 	stc
  3068                              <1> 
  3069                              <1> .exit:
  3070 0000951E 59                  <1> 	pop	cx
  3071 0000951F C3                  <1> 	ret
  3072                              <1> 
  3073                              <1> ;=========================================================================
  3074                              <1> ; print_floppy - Print floppy configuration
  3075                              <1> ; Input:
  3076                              <1> ;	AL = NVRAM floppy configuration byte
  3077                              <1> ; Ouput:
  3078                              <1> ;	none
  3079                              <1> ;-------------------------------------------------------------------------
  3080                              <1> print_floppy:
  3081 00009520 50                  <1> 	push	ax
  3082 00009521 56                  <1> 	push	si
  3083 00009522 BE[D781]            <1> 	mov	si,msg_floppy
  3084 00009525 E8DD0A              <1> 	call	print
  3085 00009528 D0C8                <1> 	ror	al,1
  3086 0000952A D0C8                <1> 	ror	al,1
  3087 0000952C D0C8                <1> 	ror	al,1
  3088 0000952E D0C8                <1> 	ror	al,1
  3089 00009530 89C6                <1> 	mov	si,ax
  3090 00009532 83E607              <1> 	and	si,0007h
  3091 00009535 D1E6                <1> 	shl	si,1
  3092 00009537 2E8BB4[9A85]        <1>     cs	mov	si,word [tbl_floppy+si]
  3093 0000953C E8C60A              <1> 	call	print
  3094 0000953F BE[FD81]            <1> 	mov	si,msg_floppy_2
  3095 00009542 E8C00A              <1> 	call	print
  3096 00009545 D0C8                <1> 	ror	al,1
  3097 00009547 D0C8                <1> 	ror	al,1
  3098 00009549 D0C8                <1> 	ror	al,1
  3099 0000954B D0C8                <1> 	ror	al,1
  3100 0000954D 89C6                <1> 	mov	si,ax
  3101 0000954F 83E607              <1> 	and	si,0007h
  3102 00009552 D1E6                <1> 	shl	si,1
  3103 00009554 2E8BB4[9A85]        <1>     cs	mov	si,word [tbl_floppy+si]
  3104 00009559 E8A90A              <1> 	call	print
  3105 0000955C BE[8A80]            <1> 	mov	si,msg_crlf
  3106 0000955F E8A30A              <1> 	call	print
  3107 00009562 5E                  <1> 	pop	si
  3108 00009563 58                  <1> 	pop	ax
  3109 00009564 C3                  <1> 	ret
  3110                                  %include	"kbc.inc"		; keyboard controller functions
  3111                              <1> ;=========================================================================
  3112                              <1> ; kbc.inc - Keyboard controller support
  3113                              <1> ;-------------------------------------------------------------------------
  3114                              <1> ;
  3115                              <1> ; Compiles with NASM 2.07, might work with other versions
  3116                              <1> ;
  3117                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  3118                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  3119                              <1> ;
  3120                              <1> ; This program is free software: you can redistribute it and/or modify
  3121                              <1> ; it under the terms of the GNU General Public License as published by
  3122                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3123                              <1> ; (at your option) any later version.
  3124                              <1> ;
  3125                              <1> ; This program is distributed in the hope that it will be useful,
  3126                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3127                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3128                              <1> ; GNU General Public License for more details.
  3129                              <1> ;
  3130                              <1> ; You should have received a copy of the GNU General Public License
  3131                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3132                              <1> ;
  3133                              <1> ;=========================================================================
  3134                              <1> 
  3135                              <1> ;=========================================================================
  3136                              <1> ; Keyboard controller defines - ports, commands, and flags
  3137                              <1> ;-------------------------------------------------------------------------
  3138                              <1> kbc_data_reg	equ	60h
  3139                              <1> kbc_input_reg	equ	60h
  3140                              <1> kbc_output_reg	equ	60h
  3141                              <1> ; keyboard controller return codes
  3142                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3143                              <1> ; keyboard controller status register and its bits
  3144                              <1> kbc_status_reg	equ	64h
  3145                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3146                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3147                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3148                              <1> ; keyboard contoller command register and commands
  3149                              <1> kbc_command_reg	equ	64h
  3150                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3151                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3152                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3153                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3154                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3155                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3156                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3157                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3158                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3159                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3160                              <1> ; keyboard controller control register bits
  3161                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3162                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3163                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3164                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3165                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3166                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3167                              <1> ; keyboard controller input port bits
  3168                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3169                              <1> 
  3170                              <1> ;=========================================================================
  3171                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3172                              <1> ; Input:
  3173                              <1> ;	AL = command
  3174                              <1> ; Output:
  3175                              <1> ;	none
  3176                              <1> ;-------------------------------------------------------------------------
  3177                              <1> kbc_kb_send:
  3178 00009565 50                  <1> 	push	ax
  3179 00009566 51                  <1> 	push	cx
  3180 00009567 88C4                <1> 	mov	ah,al			; save command to AH
  3181 00009569 B90300              <1> 	mov	cx,3			; try 3 times
  3182                              <1> 
  3183                              <1> .1:
  3184 0000956C 51                  <1> 	push	cx
  3185 0000956D FA                  <1> 	cli
  3186                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3187 0000956E 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3188 00009573 31C9                <1> 	xor	cx,cx
  3189                              <1> 
  3190                              <1> .2:					; wait for KBC to empty input buffer
  3191 00009575 E464                <1> 	in	al,kbc_status_reg
  3192 00009577 A802                <1> 	test	al,kbc_stat_ibf
  3193 00009579 E0FA                <1> 	loopnz	.2
  3194                              <1> 
  3195 0000957B 88E0                <1> 	mov	al,ah
  3196 0000957D E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3197 0000957F FB                  <1> 	sti
  3198 00009580 31C9                <1> 	xor	cx,cx
  3199                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3200 00009582 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3201 00009587 E1F9                <1> 	loopz	.3
  3202 00009589 59                  <1> 	pop	cx
  3203 0000958A 7507                <1> 	jnz	.4
  3204 0000958C E2DE                <1> 	loop	.1			; try again
  3205                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3206 0000958E 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3207                              <1> .4:
  3208 00009593 59                  <1> 	pop	cx
  3209 00009594 58                  <1> 	pop	ax
  3210 00009595 C3                  <1> 	ret
  3211                              <1> 
  3212                              <1> ;=========================================================================
  3213                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3214                              <1> ; Input:
  3215                              <1> ;	AL - command byte
  3216                              <1> ;	AH = argument
  3217                              <1> ; Output:
  3218                              <1> ;	ZF == 0 - success
  3219                              <1> ;	ZF == 1 - error
  3220                              <1> ;-------------------------------------------------------------------------
  3221                              <1> kbc_send_cmd:
  3222 00009596 51                  <1> 	push	cx
  3223 00009597 88C5                <1> 	mov	ch,al			; save command byte to CH
  3224 00009599 B11E                <1> 	mov	cl,30			; 30 retries
  3225                              <1> .1:
  3226 0000959B FA                  <1> 	cli
  3227 0000959C 88E8                <1> 	mov	al,ch
  3228 0000959E E82800              <1> 	call	kbc_send_cmd_byte
  3229 000095A1 7522                <1> 	jnz	.exit			; time out
  3230 000095A3 E464                <1> 	in	al,kbc_status_reg
  3231 000095A5 A801                <1> 	test	al,kbc_stat_obf
  3232 000095A7 7414                <1> 	jz	.3			; output buffer is empty
  3233 000095A9 A820                <1> 	test	al,kbc_stat_aobf
  3234 000095AB 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3235 000095AD E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3236                              <1> %ifdef PS2_MOUSE
  3237 000095AF 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3238                              <1> %endif ; PS2_MOUSE
  3239 000095B4 EB07                <1> 	jmp	.3
  3240                              <1> .2:
  3241 000095B6 FB                  <1> 	sti
  3242 000095B7 FEC9                <1> 	dec	cl
  3243 000095B9 75E0                <1> 	jnz	.1
  3244 000095BB EB08                <1> 	jmp	.exit			; note: ZF=1
  3245                              <1> .3:
  3246 000095BD 88E0                <1> 	mov	al,ah
  3247 000095BF E660                <1> 	out	kbc_input_reg,al
  3248 000095C1 FB                  <1> 	sti
  3249 000095C2 80C901              <1> 	or	cl,1			; set ZF=0
  3250                              <1> .exit:
  3251 000095C5 88E8                <1> 	mov	al,ch			; restore AL
  3252 000095C7 59                  <1> 	pop	cx
  3253 000095C8 C3                  <1> 	ret
  3254                              <1> 
  3255                              <1> ;=========================================================================
  3256                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3257                              <1> ; Input:
  3258                              <1> ;	AL - command byte
  3259                              <1> ; Output:
  3260                              <1> ;	ZF == 1 - success
  3261                              <1> ;	ZF == 0 - time out
  3262                              <1> ; Note:
  3263                              <1> ;	XXX - function should be reused in keyboard code
  3264                              <1> ;-------------------------------------------------------------------------
  3265                              <1> kbc_send_cmd_byte:
  3266 000095C9 51                  <1> 	push	cx
  3267 000095CA 50                  <1> 	push	ax
  3268 000095CB 31C9                <1> 	xor	cx,cx
  3269                              <1> 				; wait for KBC to empty input buffer
  3270                              <1> .1:
  3271 000095CD E464                <1> 	in	al,kbc_status_reg
  3272 000095CF A802                <1> 	test	al,kbc_stat_ibf
  3273 000095D1 E0FA                <1> 	loopnz	.1
  3274 000095D3 750C                <1> 	jnz	.exit		; time out
  3275                              <1> 
  3276 000095D5 58                  <1> 	pop	ax
  3277 000095D6 E664                <1> 	out	kbc_command_reg,al
  3278                              <1> 
  3279 000095D8 50                  <1> 	push	ax
  3280 000095D9 31C9                <1> 	xor	cx,cx
  3281                              <1> 				; wait for KBC to empty input buffer
  3282                              <1> .2:
  3283 000095DB E464                <1> 	in	al,kbc_status_reg
  3284 000095DD A802                <1> 	test	al,kbc_stat_ibf
  3285 000095DF E0FA                <1> 	loopnz	.2
  3286                              <1> .exit:
  3287 000095E1 58                  <1> 	pop	ax
  3288 000095E2 59                  <1> 	pop	cx
  3289 000095E3 C3                  <1> 	ret
  3290                              <1> 
  3291                              <1> ;=========================================================================
  3292                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3293                              <1> ; Input:
  3294                              <1> ;	none
  3295                              <1> ; Output:
  3296                              <1> ;	AL = keyboard status register
  3297                              <1> ;	ZF == 0 - data is available
  3298                              <1> ;	ZF == 1 - timed out
  3299                              <1> ; Note:
  3300                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3301                              <1> ;	      be merged with kbc_wait_aux_full
  3302                              <1> ;-------------------------------------------------------------------------
  3303                              <1> kbc_wait_output_full:
  3304 000095E4 51                  <1> 	push	cx
  3305 000095E5 31C9                <1> 	xor	cx,cx
  3306                              <1> .1:
  3307 000095E7 E464                <1> 	in	al,kbc_status_reg
  3308 000095E9 A801                <1> 	test	al,kbc_stat_obf
  3309 000095EB E1FA                <1> 	loopz	.1
  3310 000095ED 09C9                <1> 	or	cx,cx
  3311 000095EF 59                  <1> 	pop	cx
  3312 000095F0 C3                  <1> 	ret
  3313                              <1> 
  3314                              <1> %ifdef PS2_MOUSE
  3315                              <1> ;=========================================================================
  3316                              <1> ; kbc_aux_read - read data from auxiliary device
  3317                              <1> ; Input:
  3318                              <1> ;	none
  3319                              <1> ; Output:
  3320                              <1> ;	AL = data
  3321                              <1> ;	CF == 0 - data is available
  3322                              <1> ;	CF == 1 - time out
  3323                              <1> ;-------------------------------------------------------------------------
  3324                              <1> kbc_aux_read:
  3325 000095F1 51                  <1> 	push	cx
  3326                              <1> ;	xor	cx,cx			; XXX too much?!
  3327 000095F2 B91400              <1> 	mov	cx,20			; retry 20 times
  3328                              <1> .1:
  3329 000095F5 E86000              <1> 	call	kbc_wait_aux_full
  3330 000095F8 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3331 000095FA E1F9                <1> 	loopz	.1
  3332 000095FC EB0B                <1> 	jmp	.error			; time out
  3333                              <1> .2:
  3334 000095FE B90100              <1> 	mov	cx,1
  3335 00009601 E8B9F5              <1> 	call	delay_15us
  3336 00009604 E460                <1> 	in	al,kbc_output_reg
  3337 00009606 F8                  <1> 	clc
  3338 00009607 EB01                <1> 	jmp	.exit
  3339                              <1> .error:
  3340 00009609 F9                  <1> 	stc
  3341                              <1> .exit:
  3342 0000960A 59                  <1> 	pop	cx
  3343 0000960B C3                  <1> 	ret
  3344                              <1> 
  3345                              <1> ;=========================================================================
  3346                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3347                              <1> ; Input:
  3348                              <1> ;	AL = command
  3349                              <1> ; Output:
  3350                              <1> ;	AH - status:
  3351                              <1> ;		00h - success
  3352                              <1> ;		03h - interface error (time out)
  3353                              <1> ;		04h - resend requested
  3354                              <1> ;	CF == 0 - no error
  3355                              <1> ;	CF == 1 - error
  3356                              <1> ;-------------------------------------------------------------------------
  3357                              <1> kbc_aux_send:
  3358 0000960C 51                  <1> 	push	cx
  3359 0000960D 88C4                <1> 	mov	ah,al			; store command to AH
  3360 0000960F B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3361 00009611 E882FF              <1> 	call	kbc_send_cmd
  3362 00009614 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3363                              <1> 
  3364                              <1> 					; wait for acknowledge
  3365 00009616 B90A00              <1> 	mov	cx,10			; retry 10 times
  3366                              <1> .1:
  3367 00009619 E83C00              <1> 	call	kbc_wait_aux_full
  3368 0000961C 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3369 0000961E E2F9                <1> 	loop	.1
  3370 00009620 EB17                <1> 	jmp	.timeout		; no reply - timeout
  3371                              <1> .2:
  3372 00009622 E460                <1> 	in	al,kbc_output_reg
  3373 00009624 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3374 00009626 740C                <1> 	je	.ok
  3375 00009628 3CFE                <1> 	cmp	al,0FEh			; resend?
  3376 0000962A 7411                <1> 	je	.resend
  3377 0000962C 3CFC                <1> 	cmp	al,0FCh			; error?
  3378 0000962E 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3379 00009630 E2E7                <1> 	loop	.1
  3380 00009632 EB05                <1> 	jmp	.timeout
  3381                              <1> 
  3382                              <1> .ok:
  3383 00009634 30C0                <1> 	xor	al,al			; success - ACK received
  3384 00009636 F8                  <1> 	clc
  3385 00009637 EB07                <1> 	jmp	.exit
  3386                              <1> 
  3387                              <1> .timeout:
  3388 00009639 B003                <1> 	mov	al,03h			; interface error
  3389 0000963B EB02                <1> 	jmp	.error
  3390                              <1> 
  3391                              <1> .resend:
  3392 0000963D B004                <1> 	mov	al,04h			; resend
  3393                              <1> 
  3394                              <1> .error:
  3395 0000963F F9                  <1> 	stc
  3396                              <1> 
  3397                              <1> .exit:
  3398 00009640 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3399 00009642 59                  <1> 	pop	cx
  3400 00009643 C3                  <1> 	ret
  3401                              <1> 
  3402                              <1> ;=========================================================================
  3403                              <1> ; kbc_aux_enable - enable auxiliary device
  3404                              <1> ; Input:
  3405                              <1> ;	none
  3406                              <1> ; Output:
  3407                              <1> ;	ZF = 0 - no error
  3408                              <1> ;	ZF = 1 - error
  3409                              <1> ;-------------------------------------------------------------------------
  3410                              <1> kbc_aux_enable:
  3411 00009644 50                  <1> 	push	ax
  3412 00009645 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3413 00009647 B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3414                              <1> 					; enable keyboard, enable aux obf
  3415                              <1> 					; interrupt, enable obf interrupt
  3416 00009649 E84AFF              <1> 	call	kbc_send_cmd
  3417 0000964C 58                  <1> 	pop	ax
  3418 0000964D C3                  <1> 	ret
  3419                              <1> 
  3420                              <1> ;=========================================================================
  3421                              <1> ; kbc_aux_disable - disable auxiliary device
  3422                              <1> ; Input:
  3423                              <1> ;	none
  3424                              <1> ; Output:
  3425                              <1> ;	ZF = 0 - no error
  3426                              <1> ;	ZF = 1 - error
  3427                              <1> ;-------------------------------------------------------------------------
  3428                              <1> kbc_aux_disable:
  3429 0000964E 50                  <1> 	push	ax
  3430 0000964F B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3431 00009651 B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3432                              <1> 					; enable keyboard, disable aux obf
  3433                              <1> 					; interrupt, enable obf interrupt
  3434 00009653 E840FF              <1> 	call	kbc_send_cmd
  3435 00009656 58                  <1> 	pop	ax
  3436 00009657 C3                  <1> 	ret
  3437                              <1> 
  3438                              <1> ;=========================================================================
  3439                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3440                              <1> ; Input:
  3441                              <1> ;	none
  3442                              <1> ; Output:
  3443                              <1> ;	AL = keyboard status register
  3444                              <1> ;	ZF == 0 - data is available
  3445                              <1> ;	ZF == 1 - timed out
  3446                              <1> ;-------------------------------------------------------------------------
  3447                              <1> kbc_wait_aux_full:
  3448 00009658 E889FF              <1> 	call	kbc_wait_output_full
  3449 0000965B 7402                <1> 	jz	.error
  3450 0000965D A820                <1> 	test	al,kbc_stat_aobf
  3451                              <1> .error:
  3452 0000965F C3                  <1> 	ret
  3453                              <1> 
  3454                              <1> %endif ; PS2_MOUSE
  3455                              <1> 
  3456                              <1> ;=========================================================================
  3457                              <1> ; kbc_flush - flush all data from i8042 buffers
  3458                              <1> ; Input:
  3459                              <1> ;	none
  3460                              <1> ; Output:
  3461                              <1> ;	CF = 0 - flushed successfully
  3462                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3463                              <1> ;-------------------------------------------------------------------------
  3464                              <1> kbc_flush:
  3465 00009660 50                  <1> 	push	ax
  3466 00009661 51                  <1> 	push	cx
  3467 00009662 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3468                              <1> .flush_next_byte:
  3469 00009665 E464                <1> 	in	al,kbc_status_reg
  3470 00009667 A801                <1> 	test	al,kbc_stat_obf
  3471 00009669 740F                <1> 	jz	.flushed
  3472 0000966B 51                  <1> 	push	cx
  3473 0000966C B90400              <1> 	mov	cx,4
  3474 0000966F E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3475 00009672 59                  <1> 	pop	cx
  3476 00009673 E460                <1> 	in	al,kbc_data_reg
  3477 00009675 E2EE                <1> 	loop	.flush_next_byte
  3478 00009677 F9                  <1> 	stc				; unable to flush it
  3479 00009678 EB01                <1> 	jmp	.exit
  3480                              <1> .flushed:
  3481 0000967A F8                  <1> 	clc
  3482                              <1> .exit:
  3483 0000967B 59                  <1> 	pop	cx
  3484 0000967C 58                  <1> 	pop	ax
  3485 0000967D C3                  <1> 	ret
  3486                              <1> 
  3487                              <1> ;=========================================================================
  3488                              <1> ; kbc_init - Initialize keyboard controller
  3489                              <1> ;-------------------------------------------------------------------------
  3490                              <1> kbc_init:
  3491 0000967E 50                  <1> 	push	ax
  3492 0000967F 51                  <1> 	push	cx
  3493 00009680 52                  <1> 	push	dx
  3494                              <1> 
  3495                              <1> ;-------------------------------------------------------------------------
  3496                              <1> ; test keyboard controller
  3497                              <1> 
  3498 00009681 E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3499                              <1> 
  3500 00009684 B90A00              <1> 	mov	cx,10			; try 10 times
  3501                              <1> 
  3502                              <1> .kbc_reset_retry:
  3503 00009687 B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3504 00009689 E83DFF              <1> 	call 	kbc_send_cmd_byte
  3505 0000968C E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3506                              <1> 
  3507 0000968F E460                <1> 	in	al,kbc_output_reg
  3508 00009691 3C55                <1> 	cmp	al,55h			; check for success
  3509 00009693 E0F2                <1> 	loopne	.kbc_reset_retry
  3510 00009695 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3511                              <1> 
  3512 0000969A B90A00              <1> 	mov	cx,10			; try 10 times
  3513                              <1> 
  3514                              <1> .kbc_test_retry:
  3515 0000969D B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3516 0000969F E827FF              <1> 	call	kbc_send_cmd_byte
  3517 000096A2 E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3518                              <1> 
  3519 000096A5 E460                <1> 	in	al,kbc_output_reg
  3520 000096A7 3C00                <1> 	cmp	al,0			; check for success
  3521 000096A9 E0F2                <1> 	loopne	.kbc_test_retry
  3522 000096AB 7403E98E00          <1> 	jne	kbd_int_fail
  3523                              <1> 
  3524                              <1> ;-------------------------------------------------------------------------
  3525                              <1> ; read display type and set equipment bits accordingly
  3526                              <1> 
  3527 000096B0 B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3528 000096B2 E814FF              <1> 	call	kbc_send_cmd_byte
  3529 000096B5 E82CFF              <1> 	call	kbc_wait_output_full
  3530                              <1> 
  3531 000096B8 E460                <1> 	in	al,kbc_output_reg
  3532 000096BA A840                <1> 	test	al,kbc_in_display
  3533 000096BC 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3534 000096BE 830E100030          <1> 	or	word [equipment_list],equip_mono
  3535 000096C3 EB05                <1> 	jmp	.get_disp_done
  3536                              <1> .get_disp_color:
  3537 000096C5 830E100020          <1> 	or	word [equipment_list],equip_color
  3538                              <1> .get_disp_done:
  3539                              <1> 
  3540                              <1> ;-------------------------------------------------------------------------
  3541                              <1> ; initialize keyboard controller
  3542                              <1> 
  3543 000096CA B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  3544 000096CC E8FAFE              <1> 	call	kbc_send_cmd_byte
  3545                              <1> 
  3546 000096CF B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  3547 000096D1 E8F5FE              <1> 	call	kbc_send_cmd_byte
  3548                              <1> 
  3549 000096D4 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  3550 000096D6 B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  3551                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  3552                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  3553                              <1> 					; Bit 4 = 0 - Enable keyboard
  3554                              <1> 					; Bit 3 = 1 - Disable inhibit
  3555                              <1> 					; Bit 2 = 0 - system flag = 0
  3556                              <1> 					; Bit 1 = 0 - reserved
  3557                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  3558 000096D8 E8BBFE              <1> 	call	kbc_send_cmd
  3559                              <1> 
  3560 000096DB B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  3561 000096DD E8E9FE              <1> 	call	kbc_send_cmd_byte
  3562                              <1> 
  3563 000096E0 B90010              <1> 	mov	cx,1000h
  3564 000096E3 E8D7F4              <1> 	call	delay_15us
  3565                              <1> 
  3566 000096E6 E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  3567 000096E9 E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  3568                              <1> 
  3569                              <1> ;-------------------------------------------------------------------------
  3570                              <1> ; check for PS/2 mouse presence
  3571                              <1> 
  3572 000096EB B90A00              <1> 	mov	cx,10			; try 10 times
  3573                              <1> .mouse_reset_retry:
  3574 000096EE B0FF                <1> 	mov	al,0FFh
  3575 000096F0 E819FF              <1> 	call	kbc_aux_send
  3576 000096F3 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  3577 000096F5 80FC03              <1> 	cmp	ah,03h			; timeout error?
  3578 000096F8 E1F4                <1> 	loopz	.mouse_reset_retry
  3579 000096FA EB13                <1> 	jmp	.no_mouse
  3580                              <1> .mouse_reset_ok:
  3581 000096FC E8F2FE              <1> 	call	kbc_aux_read
  3582 000096FF 720E                <1> 	jc	.no_mouse
  3583 00009701 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  3584 00009703 750A                <1> 	jne	.no_mouse
  3585 00009705 E8E9FE              <1> 	call	kbc_aux_read
  3586 00009708 7205                <1> 	jc	.no_mouse
  3587                              <1> ; mouse reset successful, update equipment word accordingly
  3588 0000970A 830E100004          <1> 	or      word [equipment_list],equip_mouse
  3589                              <1> .no_mouse:
  3590                              <1> 
  3591                              <1> ;-------------------------------------------------------------------------
  3592                              <1> ; setup keyboard buffer
  3593                              <1> 
  3594 0000970F B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  3595 00009712 A38000              <1>         mov     word [kbd_buffer_start],ax
  3596 00009715 A31A00              <1>         mov     word [kbd_buffer_head],ax
  3597 00009718 A31C00              <1>         mov     word [kbd_buffer_tail],ax
  3598 0000971B 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  3599 0000971E A38200              <1>         mov     word [kbd_buffer_end],ax
  3600 00009721 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  3601 00009723 A31700              <1>         mov     word [kbd_flags_1],ax
  3602 00009726 A31800              <1>         mov     word [kbd_flags_2],ax
  3603 00009729 A39600              <1>         mov     word [kbd_flags_3],ax
  3604 0000972C A39700              <1>         mov     word [kbd_flags_4],ax
  3605 0000972F B010                <1> 	mov	al,e_kbd_ok
  3606 00009731 E680                <1> 	out	post_reg,al
  3607 00009733 5A                  <1> 	pop	dx
  3608 00009734 59                  <1> 	pop	cx
  3609 00009735 58                  <1> 	pop	ax
  3610 00009736 C3                  <1> 	ret
  3611                              <1> 
  3612                              <1> kbd_ctrl_fail:
  3613 00009737 B085                <1> 	mov	al,e_kbd_ctrl_fail
  3614 00009739 E680                <1> 	out	post_reg,al
  3615                              <1> .1:
  3616 0000973B F4                  <1> 	hlt
  3617 0000973C EBFD                <1> 	jmp	.1
  3618                              <1> 
  3619                              <1> kbd_int_fail:
  3620 0000973E 240F                <1> 	and	al,0Fh
  3621 00009740 0490                <1> 	add	al,e_kbd_int_fail
  3622 00009742 E680                <1> 	out	post_reg,al
  3623                              <1> .1:
  3624 00009744 F4                  <1> 	hlt
  3625 00009745 EBFD                <1> 	jmp	.1
  3626                              <1> 
  3627                              <1> kbd_key_fail:
  3628 00009747 B086                <1> 	mov	al,e_kbd_key_fail
  3629 00009749 E680                <1> 	out	post_reg,al
  3630                              <1> .1:
  3631 0000974B F4                  <1> 	hlt
  3632 0000974C EBFD                <1> 	jmp	.1
  3633                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  3634                              <1> ;=========================================================================
  3635                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  3636                              <1> ;		 and related INT 16h functions:
  3637                              <1> ;	INT 16h - BIOS Keyboard Services
  3638                              <1> ;		- function AH=00h
  3639                              <1> ;		- function AH=01h
  3640                              <1> ;		- function AH=10h
  3641                              <1> ;		- function AH=11h
  3642                              <1> ;-------------------------------------------------------------------------
  3643                              <1> ;
  3644                              <1> ; Compiles with NASM 2.07, might work with other versions
  3645                              <1> ;
  3646                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  3647                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  3648                              <1> ;
  3649                              <1> ; This program is free software: you can redistribute it and/or modify
  3650                              <1> ; it under the terms of the GNU General Public License as published by
  3651                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3652                              <1> ; (at your option) any later version.
  3653                              <1> ;
  3654                              <1> ; This program is distributed in the hope that it will be useful,
  3655                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3656                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3657                              <1> ; GNU General Public License for more details.
  3658                              <1> ;
  3659                              <1> ; You should have received a copy of the GNU General Public License
  3660                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3661                              <1> ;
  3662                              <1> ;=========================================================================
  3663                              <1> 
  3664                              <1> ;=========================================================================
  3665                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  3666                              <1> ;                   BIOS scan code translation table
  3667                              <1> ; Note 1: Table starts with scancode == 1
  3668                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  3669                              <1> ;	00 - no flags
  3670                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  3671                              <1> ;	     x in this case equals digit value
  3672                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  3673                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  3674                              <1> ;	8x - F11, F12 BIOS scan codes
  3675                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  3676                              <1> ;-------------------------------------------------------------------------
  3677                              <1> 
  3678                              <1> scan_xlat_table:
  3679                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3680 0000974E 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  3681 00009756 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  3682 0000975E 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  3683 00009766 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  3684 0000976E 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  3685 00009776 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  3686 0000977E 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  3687 00009786 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  3688 0000978E 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  3689 00009796 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  3690 0000979E 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  3691 000097A6 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  3692 000097AE 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  3693 000097B6 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  3694 000097BE 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  3695 000097C6 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  3696                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3697 000097CE 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  3698 000097D6 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  3699 000097DE 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  3700 000097E6 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  3701 000097EE 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  3702 000097F6 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  3703 000097FE 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  3704 00009806 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  3705 0000980E 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  3706 00009816 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  3707 0000981E 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  3708 00009826 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  3709 0000982E 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  3710 00009836 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  3711 0000983E 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  3712 00009846 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  3713                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3714 0000984E 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  3715 00009856 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  3716 0000985E 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  3717 00009866 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  3718 0000986E 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  3719 00009876 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  3720 0000987E 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  3721 00009886 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  3722 0000988E 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  3723 00009896 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  3724 0000989E 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  3725 000098A6 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  3726 000098AE 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  3727 000098B6 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  3728 000098BE 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  3729 000098C6 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  3730                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3731 000098CE 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  3732 000098D6 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  3733 000098DE 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  3734 000098E6 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  3735 000098EE 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  3736 000098F6 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  3737 000098FE 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  3738 00009906 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  3739 0000990E 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  3740 00009916 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  3741 0000991E 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  3742 00009926 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  3743 0000992E 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  3744 00009936 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  3745 0000993E 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  3746 00009946 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  3747                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  3748 0000994E 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  3749 00009956 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  3750 0000995E 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  3751 00009966 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  3752 0000996E 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  3753 00009976 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  3754 0000997E 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  3755 00009986 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  3756 0000998E 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  3757 00009996 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  3758 0000999E 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  3759 000099A6 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  3760 000099AE 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  3761 000099B6 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  3762 000099BE 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  3763 000099C6 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  3764                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  3765 000099CE 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  3766 000099D6 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  3767 000099DE 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  3768 000099E6 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  3769 000099EE 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  3770 000099F6 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  3771 000099FE 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  3772 00009A06 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  3773                              <1> .end:
  3774                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  3775                              <1> 
  3776                              <1> ;=========================================================================
  3777                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  3778                              <1> ; Input:
  3779                              <1> ;	AL - scan code
  3780                              <1> ; Output:
  3781                              <1> ;	AX - ASCII character / scan code pair
  3782                              <1> ;-------------------------------------------------------------------------
  3783                              <1> scan_xlat:
  3784 00009A0E 53                  <1> 	push	bx
  3785 00009A0F FEC8                <1> 	dec	al
  3786 00009A11 3C58                <1> 	cmp	al,scan_xlat_table_size
  3787 00009A13 7205                <1> 	jb	.1
  3788 00009A15 31C0                <1> 	xor	ax,ax
  3789 00009A17 E9AB00              <1> 	jmp	.exit
  3790                              <1> 
  3791                              <1> .1:
  3792 00009A1A B700                <1> 	mov	bh,00h				; calculate offset of the key
  3793 00009A1C 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  3794 00009A1E D1E3                <1> 	shl	bx,1				; BX = AL * 8
  3795 00009A20 D1E3                <1> 	shl	bx,1
  3796 00009A22 D1E3                <1> 	shl	bx,1
  3797                              <1> 
  3798 00009A24 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  3799 00009A29 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  3800 00009A2B 2E8B87[5497]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  3801                              <1> 	; check for numeric Keypad keys
  3802 00009A30 2EF687[4F97]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  3803 00009A36 7474                <1> 	jz	.check_extended
  3804 00009A38 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  3805 00009A3D 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  3806                              <1> 						; and so it is not a keypad key
  3807                              <1> 
  3808 00009A3F 2E8A87[4F97]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  3809 00009A44 240F                <1> 	and	al,0Fh				; get the numeric value
  3810 00009A46 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  3811 00009A4A D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  3812 00009A4C A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  3813                              <1> 
  3814 00009A4F 31C0                <1> 	xor	ax,ax				; return nothing
  3815 00009A51 EB72                <1> 	jmp	.exit
  3816                              <1> 
  3817                              <1> .check_ctrl:
  3818 00009A53 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  3819 00009A58 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  3820 00009A5A 2E8B87[5297]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  3821 00009A5F EB4B                <1> 	jmp	.check_extended
  3822                              <1> 
  3823                              <1> .check_locks:
  3824 00009A61 2EF687[4F97]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  3825 00009A67 741D                <1> 	jz	.check_shift			; not affected by Locks
  3826                              <1> 
  3827 00009A69 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  3828 00009A6B 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  3829                              <1> 
  3830 00009A6D F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  3831 00009A72 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  3832 00009A74 EB07                <1> 	jmp	.lock_active
  3833                              <1> 
  3834                              <1> .check_num_lock:
  3835 00009A76 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  3836 00009A7B 7409                <1> 	jz	.check_shift			; Num Lock is not active
  3837                              <1> .lock_active:
  3838                              <1> 	; are any of Shift keys active?
  3839 00009A7D F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  3840 00009A82 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  3841 00009A84 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  3842                              <1> 
  3843                              <1> .check_shift:
  3844                              <1> 	; are any of Shift keys active?
  3845 00009A86 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  3846 00009A8B 7407                <1> 	jz	.no_shift
  3847                              <1> .shift:
  3848 00009A8D 2E8B87[5097]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  3849 00009A92 EB18                <1> 	jmp	.check_extended
  3850                              <1> 
  3851                              <1> .no_shift:
  3852 00009A94 88C4                <1> 	mov	ah,al				; Move scan code to AH
  3853 00009A96 FEC4                <1> 	inc	ah
  3854 00009A98 2E8A87[4E97]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  3855 00009A9D 2EF687[4F97]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  3856 00009AA3 7407                <1> 	jz	.check_extended			; not F11 or F12
  3857 00009AA5 2E8AA7[4F97]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  3858 00009AAA EB19                <1> 	jmp	.exit
  3859                              <1> 
  3860                              <1> .check_extended:
  3861 00009AAC 2EF687[4F97]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  3862 00009AB2 7411                <1> 	jz	.exit				; no extended key
  3863 00009AB4 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  3864 00009AB9 740A                <1> 	jz	.exit				; ... not a 0E0h
  3865 00009ABB 3C00                <1> 	cmp	al,00h
  3866 00009ABD 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  3867 00009ABF B0E0                <1> 	mov	al,0E0h				; indicate extended key
  3868 00009AC1 EB02                <1> 	jmp	.exit
  3869                              <1> 
  3870                              <1> .ascii_code:
  3871 00009AC3 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  3872                              <1> 						; key with valid ASCII code
  3873                              <1> 						; (Keypad Enter, *, and /)
  3874                              <1> 
  3875                              <1> .exit:
  3876 00009AC5 5B                  <1> 	pop	bx
  3877 00009AC6 C3                  <1> 	ret
  3878                              <1> 
  3879                              <1> ;=========================================================================
  3880                              <1> ; int_16_fn00 - get keystroke
  3881                              <1> ; Input:
  3882                              <1> ;	AH = 00h
  3883                              <1> ; Output:
  3884                              <1> ;	AH = BIOS scan code
  3885                              <1> ;	AL = ASCII character
  3886                              <1> ; Notes:
  3887                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  3888                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  3889                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  3890                              <1> ;	- Use function AH=10h for extended keystrokes handling
  3891                              <1> ;-------------------------------------------------------------------------
  3892                              <1> int_16_fn00:
  3893 00009AC7 FB                  <1> 	sti
  3894                              <1> .1:
  3895 00009AC8 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  3896 00009ACC 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  3897 00009AD0 74F6                <1> 	jz	.1			; wait or keystroke
  3898 00009AD2 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  3899 00009AD4 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  3900                              <1> 					;   location
  3901 00009AD7 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  3902 00009ADB 7504                <1> 	jne	.2
  3903 00009ADD 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  3904                              <1> .2:
  3905 00009AE1 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  3906 00009AE5 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  3907                              <1> 					;   extended key?
  3908 00009AE7 7504                <1> 	jne	.3			; not a convertible key
  3909 00009AE9 B000                <1> 	mov	al,00h			; convert to a standard key
  3910 00009AEB EB2C                <1> 	jmp	.exit
  3911                              <1> .3:
  3912 00009AED 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  3913 00009AEF 74D7                <1> 	je	.1			; an ignored extended key, get next key
  3914 00009AF1 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  3915                              <1> 					;   (scancode above 84h)
  3916 00009AF4 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  3917 00009AF6 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  3918 00009AF9 751E                <1> 	jne	.exit
  3919 00009AFB 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  3920 00009AFD 7504                <1> 	jne	.4
  3921 00009AFF B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  3922 00009B01 EB16                <1> 	jmp	.exit
  3923                              <1> .4:
  3924 00009B03 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  3925 00009B05 7504                <1> 	jne	.5
  3926 00009B07 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  3927 00009B09 EB0E                <1> 	jmp	.exit
  3928                              <1> .5:
  3929 00009B0B 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  3930 00009B0D 7504                <1> 	jne	.6
  3931 00009B0F B435                <1> 	mov	ah,35h			; standard / scancode
  3932 00009B11 EB06                <1> 	jmp	.exit
  3933                              <1> .6:
  3934 00009B13 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  3935 00009B15 7502                <1> 	jne	.exit
  3936 00009B17 B437                <1> 	mov	ah,37h			; standard * scancode
  3937                              <1> .exit:
  3938 00009B19 E94F4D              <1> 	jmp	int_16_exit
  3939                              <1> 
  3940                              <1> ;=========================================================================
  3941                              <1> ; int_16_fn01 - check for keystroke
  3942                              <1> ; Input:
  3943                              <1> ;	AH = 01h
  3944                              <1> ; Output:
  3945                              <1> ;	ZF = 1 - no keystroke available
  3946                              <1> ;	ZF = 0 = keystroke is available and put in AX
  3947                              <1> ;		AH = BIOS scan code
  3948                              <1> ;		AL = ASCII character
  3949                              <1> ; Notes:
  3950                              <1> ;	- Does not remove keystroke from keyboard buffer
  3951                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  3952                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  3953                              <1> ;	- Use function AH=11h for extended keystrokes handling
  3954                              <1> ;-------------------------------------------------------------------------
  3955                              <1> int_16_fn01:
  3956 00009B1C 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  3957 00009B20 8B07                <1> 	mov	ax,word [bx]
  3958 00009B22 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  3959 00009B26 7436                <1> 	jz	.exit			; no keystroke, exit
  3960 00009B28 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  3961                              <1> 					;   extended key?
  3962 00009B2A 7504                <1> 	jne	.1			; not a convertible key
  3963 00009B2C B000                <1> 	mov	al,00h			; convert to a standard key
  3964 00009B2E EB2C                <1> 	jmp	.clear_zf
  3965                              <1> .1:
  3966 00009B30 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  3967 00009B32 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  3968 00009B34 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  3969                              <1> 					;   (scancode above 84h)
  3970 00009B37 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  3971 00009B39 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  3972 00009B3C 751E                <1> 	jne	.clear_zf
  3973 00009B3E 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  3974 00009B40 7504                <1> 	jne	.2
  3975 00009B42 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  3976 00009B44 EB16                <1> 	jmp	.clear_zf
  3977                              <1> .2:
  3978 00009B46 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  3979 00009B48 7504                <1> 	jne	.3
  3980 00009B4A B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  3981 00009B4C EB0E                <1> 	jmp	.clear_zf
  3982                              <1> .3:
  3983 00009B4E 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  3984 00009B50 7504                <1> 	jne	.4
  3985 00009B52 B435                <1> 	mov	ah,35h			; standard / scancode
  3986 00009B54 EB06                <1> 	jmp	.clear_zf
  3987                              <1> .4:
  3988 00009B56 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  3989 00009B58 7502                <1> 	jne	.clear_zf
  3990 00009B5A B437                <1> 	mov	ah,37h			; standard * scancode
  3991                              <1> 
  3992                              <1> .clear_zf:
  3993 00009B5C 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  3994                              <1> .exit:
  3995 00009B5E E90D4D              <1> 	jmp	int_16_exitf
  3996                              <1> 
  3997                              <1> .discard_key:
  3998 00009B61 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  3999                              <1> 					;   location
  4000 00009B64 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4001 00009B68 7504                <1> 	jne	.5
  4002 00009B6A 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4003                              <1> .5:
  4004 00009B6E 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4005 00009B72 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4006                              <1> 	
  4007                              <1> 
  4008                              <1> ;=========================================================================
  4009                              <1> ; int_16_fn10 - get extended keystroke
  4010                              <1> ; Input:
  4011                              <1> ;	AH = 10h
  4012                              <1> ; Output:
  4013                              <1> ;	AH = BIOS scan code
  4014                              <1> ;	AL = ASCII character
  4015                              <1> ; Note:
  4016                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4017                              <1> ;-------------------------------------------------------------------------
  4018                              <1> int_16_fn10:
  4019 00009B74 FB                  <1> 	sti
  4020                              <1> .1:
  4021 00009B75 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4022 00009B79 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4023 00009B7D 74F6                <1> 	jz	.1			; wait or keystroke
  4024 00009B7F 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4025 00009B81 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4026                              <1> 					;   location
  4027 00009B84 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4028 00009B88 7504                <1> 	jne	.2
  4029 00009B8A 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4030                              <1> .2:
  4031 00009B8E 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4032 00009B92 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4033 00009B94 7502                <1> 	jne	.exit			; not a extended key
  4034 00009B96 B000                <1> 	mov	al,00h			; set scancode to zero
  4035                              <1> 
  4036                              <1> .exit:
  4037 00009B98 E9D04C              <1> 	jmp	int_16_exit
  4038                              <1> 
  4039                              <1> ;=========================================================================
  4040                              <1> ; int_16_fn11 - check for extended keystroke
  4041                              <1> ; Input:
  4042                              <1> ;	AH = 01h
  4043                              <1> ; Output:
  4044                              <1> ;	ZF = 1 - no keystroke available
  4045                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4046                              <1> ;		AH = BIOS scan code
  4047                              <1> ;		AL = ASCII character
  4048                              <1> ; Note:
  4049                              <1> ;	- Does not remove keystroke from keyboard buffer
  4050                              <1> ;-------------------------------------------------------------------------
  4051                              <1> int_16_fn11:
  4052 00009B9B 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4053 00009B9F 8B07                <1> 	mov	ax,word [bx]
  4054 00009BA1 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4055 00009BA5 7408                <1> 	jz	.exit			; no keystroke, exit
  4056 00009BA7 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4057 00009BA9 7502                <1> 	jne	.clear_zf		; not a extended key
  4058 00009BAB B000                <1> 	mov	al,00h			; set scancode to zero
  4059                              <1> .clear_zf:
  4060 00009BAD 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4061                              <1> .exit:
  4062 00009BAF E9BC4C              <1> 	jmp	int_16_exitf
  4063                                  %ifdef PS2_MOUSE
  4064                                  %include	"ps2aux.inc"
  4065                              <1> ;=========================================================================
  4066                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  4067                              <1> ;	INT 15h, function AH=0C2h
  4068                              <1> ;	INT 74h - IRQ12 interrupt handler
  4069                              <1> ;-------------------------------------------------------------------------
  4070                              <1> ;
  4071                              <1> ; Compiles with NASM 2.07, might work with other versions
  4072                              <1> ;
  4073                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  4074                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  4075                              <1> ;
  4076                              <1> ; This program is free software: you can redistribute it and/or modify
  4077                              <1> ; it under the terms of the GNU General Public License as published by
  4078                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4079                              <1> ; (at your option) any later version.
  4080                              <1> ;
  4081                              <1> ; This program is distributed in the hope that it will be useful,
  4082                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4083                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4084                              <1> ; GNU General Public License for more details.
  4085                              <1> ;
  4086                              <1> ; You should have received a copy of the GNU General Public License
  4087                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4088                              <1> ;
  4089                              <1> ;=========================================================================
  4090                              <1> 
  4091                              <1> ;-------------------------------------------------------------------------
  4092                              <1> ; offsets for registers on stack
  4093                              <1> int_15_fnC2_bp	equ	0
  4094                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  4095                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  4096                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  4097                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  4098                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  4099                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  4100                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  4101                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  4102                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  4103                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  4104                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  4105                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  4106                              <1> 
  4107                              <1> ;=========================================================================
  4108                              <1> ; int_15_fnC2 - mouse functions
  4109                              <1> ; Input:
  4110                              <1> ;	AH = 0C2h - mouse functions
  4111                              <1> ;	AL - function:
  4112                              <1> ;		00h - enable / disable PS/2 mouse
  4113                              <1> ;		01h - reset PS/2 mouse
  4114                              <1> ;		02h - set sample rate
  4115                              <1> ;		03h - set resolution
  4116                              <1> ;		04h - read device type
  4117                              <1> ;		05h - initialize PS/2 mouse
  4118                              <1> ;		06h - set scaling or get status
  4119                              <1> ;		07h - set PS/2 mouse driver address
  4120                              <1> ; Output:
  4121                              <1> ;	AH - exit status:
  4122                              <1> ;		00h - no error
  4123                              <1> ;		01h - invalid function call
  4124                              <1> ;		02h - invalid input value
  4125                              <1> ;		03h - interface error
  4126                              <1> ;		04h - request for resend received from 8042
  4127                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  4128                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  4129                              <1> ;-------------------------------------------------------------------------
  4130                              <1> int_15_fnC2:
  4131 00009BB2 50                  <1> 	push	ax
  4132 00009BB3 53                  <1> 	push	bx
  4133 00009BB4 51                  <1> 	push	cx
  4134 00009BB5 52                  <1> 	push	dx
  4135 00009BB6 1E                  <1> 	push	ds
  4136 00009BB7 55                  <1> 	push	bp
  4137 00009BB8 89E5                <1> 	mov	bp,sp			; establish stack addressing
  4138 00009BBA BB4000              <1> 	mov	bx,biosdseg
  4139 00009BBD 8EDB                <1> 	mov	ds,bx
  4140 00009BBF 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  4141 00009BC3 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  4142 00009BC5 3C08                <1> 	cmp	al,.num_func
  4143 00009BC7 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  4144 00009BC9 E882FA              <1> 	call	kbc_aux_disable		; disable auxiliary device
  4145 00009BCC 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  4146 00009BCE B700                <1> 	mov	bh,0
  4147 00009BD0 D1E3                <1> 	shl	bx,1			; address words
  4148 00009BD2 2EFFA7[D79B]        <1>     cs	jmp	near [.dispatch+bx]
  4149                              <1> 
  4150                              <1> .dispatch:
  4151 00009BD7 [109C]              <1> 	dw	int_15_fnC200
  4152 00009BD9 [319C]              <1> 	dw	int_15_fnC201
  4153 00009BDB [549C]              <1> 	dw	int_15_fnC202
  4154 00009BDD [7B9C]              <1> 	dw	int_15_fnC203
  4155 00009BDF [9D9C]              <1> 	dw	int_15_fnC204
  4156 00009BE1 [B59C]              <1> 	dw	int_15_fnC205
  4157 00009BE3 [F99C]              <1> 	dw	int_15_fnC206
  4158 00009BE5 [4A9D]              <1> 	dw	int_15_fnC207
  4159                              <1> .num_func	equ ($-.dispatch)/2
  4160                              <1> 
  4161                              <1> int_15_fnC2_ok:
  4162 00009BE7 B400                <1> 	mov	ah,00h			; no error
  4163 00009BE9 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  4164 00009BED EB14                <1> 	jmp	int_15_fnC2_exit
  4165                              <1> 
  4166                              <1> int_15_fnC2_err1:
  4167 00009BEF B401                <1> 	mov	ah,01h			; invalid function call
  4168 00009BF1 EB0C                <1> 	jmp	int_15_fnC2_err
  4169                              <1> 
  4170                              <1> int_15_fnC2_err2:
  4171 00009BF3 B402                <1> 	mov	ah,02h			; invalid input value
  4172 00009BF5 EB08                <1> 	jmp	int_15_fnC2_err
  4173                              <1> 
  4174                              <1> int_15_fnC2_err3:
  4175 00009BF7 B403                <1> 	mov	ah,03h			; interface error
  4176 00009BF9 EB04                <1> 	jmp	int_15_fnC2_err
  4177                              <1> 
  4178                              <1> int_15_fnC2_err5:
  4179 00009BFB B405                <1> 	mov	ah,05h			; no driver installed
  4180 00009BFD EB00                <1> 	jmp	int_15_fnC2_err
  4181                              <1> 
  4182                              <1> int_15_fnC2_err:
  4183 00009BFF 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  4184                              <1> 
  4185                              <1> int_15_fnC2_exit:
  4186 00009C03 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  4187 00009C06 E83BFA              <1> 	call	kbc_aux_enable		; enable auxiliary device
  4188 00009C09 5D                  <1> 	pop	bp
  4189 00009C0A 1F                  <1> 	pop	ds
  4190 00009C0B 5A                  <1> 	pop	dx
  4191 00009C0C 59                  <1> 	pop	cx
  4192 00009C0D 5B                  <1> 	pop	bx
  4193 00009C0E 58                  <1> 	pop	ax
  4194 00009C0F CF                  <1> 	iret
  4195                              <1> 
  4196                              <1> ;=========================================================================
  4197                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  4198                              <1> ; Input:
  4199                              <1> ;	AX = 0C200h
  4200                              <1> ;	BH - sub-function:
  4201                              <1> ;		00h - disable
  4202                              <1> ;		01h - enable
  4203                              <1> ;-------------------------------------------------------------------------
  4204                              <1> int_15_fnC200:
  4205 00009C10 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4206 00009C13 80FF01              <1> 	cmp	bh,01h
  4207 00009C16 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  4208                              <1> 
  4209 00009C18 F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  4210 00009C1D 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  4211                              <1> 
  4212 00009C1F 80FF00              <1> 	cmp	bh,00h
  4213 00009C22 7404                <1> 	je	.disable
  4214 00009C24 B0F4                <1> 	mov	al,0F4h			; device enable command
  4215 00009C26 EB02                <1> 	jmp	.send_it
  4216                              <1> .disable:
  4217 00009C28 B0F5                <1> 	mov	al,0F5h			; device disable command
  4218                              <1> 
  4219                              <1> .send_it:
  4220 00009C2A E8DFF9              <1> 	call	kbc_aux_send
  4221 00009C2D 72D0                <1> 	jc	int_15_fnC2_err		; error
  4222 00009C2F EBB6                <1> 	jmp	int_15_fnC2_ok
  4223                              <1> 
  4224                              <1> ;=========================================================================
  4225                              <1> ; int_15_fnC201 - reset PS/2 mouse
  4226                              <1> ; Input:
  4227                              <1> ;	AX = 0C201h
  4228                              <1> ; Output:
  4229                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  4230                              <1> ;	     0AAh - BAT successful XXX test!!!
  4231                              <1> ;	     0FCh - BAT error
  4232                              <1> ;	BH = device ID
  4233                              <1> ;-------------------------------------------------------------------------
  4234                              <1> int_15_fnC201:
  4235 00009C31 B90A00              <1> 	mov	cx,10			; try the reset 10 times
  4236                              <1> .1:
  4237 00009C34 B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  4238 00009C36 E8D3F9              <1> 	call	kbc_aux_send
  4239 00009C39 7307                <1> 	jnc	.2			; no error - continue
  4240 00009C3B 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4241 00009C3E E1F4                <1> 	loopz	.1			; try again
  4242 00009C40 EBBD                <1> 	jmp	int_15_fnC2_err		; error
  4243                              <1> .2:
  4244 00009C42 E8ACF9              <1> 	call	kbc_aux_read
  4245 00009C45 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  4246 00009C47 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  4247 00009C4A E8A4F9              <1> 	call	kbc_aux_read
  4248 00009C4D 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  4249 00009C4F 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  4250 00009C52 EB93                <1> 	jmp	int_15_fnC2_ok
  4251                              <1> 
  4252                              <1> ;=========================================================================
  4253                              <1> ; int_15_fnC202 - set sample rate
  4254                              <1> ; Input:
  4255                              <1> ;	AX = 0C202h
  4256                              <1> ;	BH - sample rate:
  4257                              <1> ;		00h - 10 samples per second
  4258                              <1> ;		01h - 20 samples per second
  4259                              <1> ;		02h - 40 samples per second
  4260                              <1> ;		03h - 60 samples per second
  4261                              <1> ;		04h - 80 samples per second
  4262                              <1> ;		05h - 100 samples per second
  4263                              <1> ;		06h - 200 samples per second
  4264                              <1> ;-------------------------------------------------------------------------
  4265                              <1> int_15_fnC202:
  4266 00009C54 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4267 00009C57 80FF06              <1> 	cmp	bh,06h
  4268 00009C5A 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  4269 00009C5C 88FB                <1> 	mov	bl,bh
  4270 00009C5E B700                <1> 	mov	bh,00h			; rate index in BX
  4271                              <1> 
  4272 00009C60 B0F3                <1> 	mov	al,0F3h			; set sample rate
  4273 00009C62 E8A7F9              <1> 	call	kbc_aux_send
  4274 00009C65 7298                <1> 	jc	int_15_fnC2_err		; error
  4275                              <1> 
  4276 00009C67 2E8A87[749C]        <1>     cs	mov	al,byte [.rate_table+bx]
  4277 00009C6C E89DF9              <1> 	call	kbc_aux_send
  4278 00009C6F 728E                <1> 	jc	int_15_fnC2_err		; error
  4279 00009C71 E973FF              <1> 	jmp	int_15_fnC2_ok
  4280                              <1> 
  4281 00009C74 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  4282                              <1> 	
  4283                              <1> ;=========================================================================
  4284                              <1> ; int_15_fnC203 - set resolution
  4285                              <1> ; Input:
  4286                              <1> ;	AX = 0C203h
  4287                              <1> ;	BH - resolution value:
  4288                              <1> ;		00h - 1 count per millimeter
  4289                              <1> ;		01h - 2 counts per millimeter
  4290                              <1> ;		02h - 4 counts per millimeter
  4291                              <1> ;		03h - 8 counts per millimeter
  4292                              <1> ;-------------------------------------------------------------------------
  4293                              <1> int_15_fnC203:
  4294 00009C7B 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4295 00009C7E 80FF03              <1> 	cmp	bh,03h
  4296 00009C81 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  4297                              <1> 
  4298 00009C86 B0E8                <1> 	mov	al,0E8h			; set resolution
  4299 00009C88 E881F9              <1> 	call	kbc_aux_send
  4300 00009C8B 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  4301                              <1> 
  4302 00009C90 88F8                <1> 	mov	al,bh
  4303 00009C92 E877F9              <1> 	call	kbc_aux_send
  4304 00009C95 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  4305 00009C9A E94AFF              <1> 	jmp	int_15_fnC2_ok
  4306                              <1> 
  4307                              <1> ;=========================================================================
  4308                              <1> ; int_15_fnC204 - read device type
  4309                              <1> ; Input:
  4310                              <1> ;	AX = 0C204h
  4311                              <1> ; Output:
  4312                              <1> ;	BH = device type
  4313                              <1> ;-------------------------------------------------------------------------
  4314                              <1> int_15_fnC204:
  4315 00009C9D B0F2                <1> 	mov	al,0F2h			; read device type
  4316 00009C9F E86AF9              <1> 	call	kbc_aux_send
  4317 00009CA2 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  4318 00009CA7 E847F9              <1> 	call	kbc_aux_read
  4319 00009CAA 7303E948FF          <1> 	jc	int_15_fnC2_err3
  4320 00009CAF 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  4321 00009CB2 E932FF              <1> 	jmp	int_15_fnC2_ok
  4322                              <1> 
  4323                              <1> ;=========================================================================
  4324                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  4325                              <1> ; Input:
  4326                              <1> ;	AX = 0C205h
  4327                              <1> ;	BH = data package size in bytes (03h or 04h)
  4328                              <1> ; Output:
  4329                              <1> ;	none
  4330                              <1> ;-------------------------------------------------------------------------
  4331                              <1> int_15_fnC205:
  4332 00009CB5 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4333 00009CB8 80FF03              <1> 	cmp	bh,03h
  4334 00009CBB 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  4335 00009CC0 80FF04              <1> 	cmp	bh,04h
  4336 00009CC3 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  4337 00009CC8 FECF                <1> 	dec	bh
  4338                              <1> 
  4339 00009CCA A02700              <1> 	mov	al,byte [mouse_flags_2]
  4340 00009CCD 24F8                <1> 	and	al,0F8h			; mask out package size bits
  4341 00009CCF 08F8                <1> 	or	al,bh			; add the new package size
  4342 00009CD1 A22700              <1> 	mov	byte [mouse_flags_2],al
  4343                              <1> 
  4344 00009CD4 B90500              <1> 	mov	cx,5			; try the reset 5 times
  4345                              <1> .1:
  4346 00009CD7 B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  4347 00009CD9 E830F9              <1> 	call	kbc_aux_send
  4348 00009CDC 7308                <1> 	jnc	.2			; no error - continue
  4349 00009CDE 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4350 00009CE1 E1F4                <1> 	loopz	.1			; try again
  4351 00009CE3 E919FF              <1> 	jmp	int_15_fnC2_err		; error
  4352                              <1> .2:
  4353 00009CE6 E808F9              <1> 	call	kbc_aux_read
  4354 00009CE9 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  4355 00009CEE E800F9              <1> 	call	kbc_aux_read
  4356 00009CF1 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  4357 00009CF6 E9EEFE              <1> 	jmp	int_15_fnC2_ok
  4358                              <1> 
  4359                              <1> ;=========================================================================
  4360                              <1> ; int_15_fnC206 - set scaling or get status
  4361                              <1> ; Input:
  4362                              <1> ;	AX = 0C206h
  4363                              <1> ;	BH - sub-function:
  4364                              <1> ;		00h - return status
  4365                              <1> ;		01h - set scaling factor to 1:1
  4366                              <1> ;		02h - set scaling factor to 2:1
  4367                              <1> ; Output:
  4368                              <1> ;	if BH = 00h on entry:
  4369                              <1> ;		BL - status byte 1:
  4370                              <1> ;			bit 0 = 1 - right button pressed
  4371                              <1> ;			bit 1 = 0 - reserved
  4372                              <1> ;			bit 2 = 1 - left button pressed
  4373                              <1> ;			bit 3 = 0 - reserved
  4374                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  4375                              <1> ;			bit 5 = 0 - disable, 1 - enable
  4376                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  4377                              <1> ;			bit 7 = 0 - reserved
  4378                              <1> ;		CL - status byte 2:
  4379                              <1> ;			00h - 1 count per millimeter
  4380                              <1> ;			01h - 2 counts per millimeter
  4381                              <1> ;			02h - 4 counts per millimeter
  4382                              <1> ;			03h - 8 counts per millimeter
  4383                              <1> ;		DL - status byte 3:
  4384                              <1> ;			0Ah - 10 samples per second
  4385                              <1> ;			14h - 20 samples per second
  4386                              <1> ;			3Ch - 40 samples per second
  4387                              <1> ;			3Ch - 60 samples per second
  4388                              <1> ;			50h - 80 samples per second
  4389                              <1> ;			64h - 100 samples per second
  4390                              <1> ;			0C8h - 200 samples per second
  4391                              <1> ;-------------------------------------------------------------------------
  4392                              <1> int_15_fnC206:
  4393 00009CF9 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  4394 00009CFC 80FF02              <1> 	cmp	bh,02h
  4395 00009CFF 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  4396 00009D04 7433                <1> 	je	.scale_2x1
  4397 00009D06 80FF01              <1> 	cmp	bh,01h
  4398 00009D09 7432                <1> 	je	.scale_1x1
  4399                              <1> 					; BH == 0, return status
  4400 00009D0B B0E9                <1> 	mov	al,0E9h			; request status command
  4401 00009D0D E8FCF8              <1> 	call	kbc_aux_send
  4402 00009D10 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  4403 00009D15 E8D9F8              <1> 	call	kbc_aux_read
  4404 00009D18 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  4405 00009D1D 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  4406 00009D20 E8CEF8              <1> 	call	kbc_aux_read
  4407 00009D23 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  4408 00009D28 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  4409 00009D2B E8C3F8              <1> 	call	kbc_aux_read
  4410 00009D2E 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  4411 00009D33 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  4412 00009D36 E9AEFE              <1> 	jmp	int_15_fnC2_ok
  4413                              <1> 
  4414                              <1> .scale_2x1:
  4415 00009D39 B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  4416 00009D3B EB02                <1> 	jmp	.send_it
  4417                              <1> .scale_1x1:
  4418 00009D3D B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  4419                              <1> .send_it:
  4420 00009D3F E8CAF8              <1> 	call	kbc_aux_send
  4421 00009D42 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  4422 00009D47 E99DFE              <1> 	jmp	int_15_fnC2_ok
  4423                              <1> 
  4424                              <1> ;=========================================================================
  4425                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  4426                              <1> ; Input:
  4427                              <1> ;	AX = 0C207h
  4428                              <1> ;	ES:BX - pointer to mouse driver
  4429                              <1> ;-------------------------------------------------------------------------
  4430                              <1> int_15_fnC207:
  4431 00009D4A 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  4432 00009D4D 891E2200            <1> 	mov	word [mouse_driver],bx
  4433 00009D51 8CC0                <1> 	mov	ax,es
  4434 00009D53 A32400              <1> 	mov	word [mouse_driver+2],ax
  4435 00009D56 09C0                <1> 	or	ax,ax
  4436 00009D58 750C                <1> 	jnz	.set_handler
  4437 00009D5A 09DB                <1> 	or	bx,bx
  4438 00009D5C 7508                <1> 	jnz	.set_handler
  4439                              <1> ; remove handler
  4440 00009D5E 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  4441 00009D63 E981FE              <1> 	jmp	int_15_fnC2_ok
  4442                              <1> 
  4443                              <1> .set_handler:
  4444 00009D66 800E270080          <1> 	or	byte [mouse_flags_2],80h
  4445 00009D6B E979FE              <1> 	jmp	int_15_fnC2_ok
  4446                              <1> 
  4447                              <1> ;=========================================================================
  4448                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  4449                              <1> ;-------------------------------------------------------------------------
  4450                              <1> int_74:
  4451 00009D6E FB                  <1> 	sti
  4452 00009D6F 50                  <1> 	push	ax
  4453 00009D70 53                  <1> 	push	bx
  4454 00009D71 1E                  <1> 	push	ds
  4455 00009D72 B84000              <1> 	mov	ax,biosdseg
  4456 00009D75 8ED8                <1> 	mov	ds,ax
  4457 00009D77 A10E00              <1> 	mov	ax,word [ebda_segment]
  4458 00009D7A 8ED8                <1> 	mov	ds,ax
  4459                              <1> 
  4460 00009D7C E464                <1> 	in	al,kbc_status_reg
  4461 00009D7E 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  4462 00009D80 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  4463 00009D82 7561                <1> 	jne	.exit			; no mouse data in the buffer
  4464                              <1> 
  4465 00009D84 E460                <1> 	in	al,kbc_data_reg
  4466 00009D86 88C4                <1> 	mov	ah,al			; save to AH
  4467                              <1> 
  4468 00009D88 A02700              <1> 	mov	al,byte [mouse_flags_2]
  4469 00009D8B A880                <1> 	test	al,80h
  4470 00009D8D 7456                <1> 	jz	.exit			; no mouse driver installed
  4471                              <1> 
  4472 00009D8F A02600              <1> 	mov	al,byte [mouse_flags_1]
  4473 00009D92 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  4474 00009D94 BB2800              <1> 	mov	bx,mouse_data
  4475 00009D97 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  4476 00009D99 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  4477                              <1> 
  4478 00009D9B 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  4479 00009D9F 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  4480                              <1> 
  4481 00009DA2 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  4482 00009DA4 7306                <1> 	jae	.call_driver
  4483                              <1> 
  4484 00009DA6 FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  4485 00009DAA EB39                <1> 	jmp	.exit
  4486                              <1> 
  4487                              <1> .call_driver:
  4488                              <1> 
  4489                              <1> ;-------------------------------------------------------------------------
  4490                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  4491                              <1> ; package sizes.
  4492                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  4493                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  4494                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  4495                              <1> ;-------------------------------------------------------------------------
  4496                              <1> 
  4497 00009DAC 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  4498 00009DAF 7413                <1> 	jz	.four_bytes
  4499                              <1> 					; put data in stack for 3 bytes format
  4500 00009DB1 31C0                <1> 	xor	ax,ax
  4501 00009DB3 A02800              <1> 	mov	al,byte [mouse_data]
  4502 00009DB6 50                  <1> 	push	ax
  4503 00009DB7 A02900              <1> 	mov	al,byte [mouse_data+1]
  4504 00009DBA 50                  <1> 	push	ax
  4505 00009DBB A02A00              <1> 	mov	al,byte [mouse_data+2]
  4506 00009DBE 50                  <1> 	push	ax
  4507 00009DBF B000                <1> 	mov	al,00h
  4508 00009DC1 50                  <1> 	push	ax
  4509 00009DC2 EB15                <1> 	jmp	.do_call
  4510                              <1> 
  4511                              <1> .four_bytes:				; put data in stack for 4 bytes format
  4512 00009DC4 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  4513 00009DC8 A02800              <1> 	mov	al,byte [mouse_data]
  4514 00009DCB 50                  <1> 	push	ax
  4515 00009DCC B400                <1> 	mov	ah,00h
  4516 00009DCE A02A00              <1> 	mov	al,byte [mouse_data+2]
  4517 00009DD1 50                  <1> 	push	ax
  4518 00009DD2 A02B00              <1> 	mov	al,byte [mouse_data+3]
  4519 00009DD5 50                  <1> 	push	ax
  4520 00009DD6 B000                <1> 	mov	al,00h
  4521 00009DD8 50                  <1> 	push	ax
  4522                              <1> 
  4523                              <1> .do_call:
  4524 00009DD9 FF1E2200            <1> 	call	far [mouse_driver]
  4525 00009DDD 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  4526 00009DE0 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  4527                              <1> 
  4528                              <1> .exit:
  4529 00009DE5 B020                <1> 	mov	al,20h
  4530 00009DE7 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  4531 00009DE9 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  4532 00009DEB 1F                  <1> 	pop	ds
  4533 00009DEC 5B                  <1> 	pop	bx
  4534 00009DED 58                  <1> 	pop	ax
  4535 00009DEE CF                  <1> 	iret
  4536                                  %endif
  4537                                  %include	"sound.inc"		; sound test
  4538                              <1> ;=========================================================================
  4539                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  4540                              <1> ;-------------------------------------------------------------------------
  4541                              <1> ;
  4542                              <1> ; Compiles with NASM 2.07, might work with other versions
  4543                              <1> ;
  4544                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  4545                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  4546                              <1> ;
  4547                              <1> ; This program is free software: you can redistribute it and/or modify
  4548                              <1> ; it under the terms of the GNU General Public License as published by
  4549                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4550                              <1> ; (at your option) any later version.
  4551                              <1> ;
  4552                              <1> ; This program is distributed in the hope that it will be useful,
  4553                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4554                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4555                              <1> ; GNU General Public License for more details.
  4556                              <1> ;
  4557                              <1> ; You should have received a copy of the GNU General Public License
  4558                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4559                              <1> ;
  4560                              <1> ;=========================================================================
  4561                              <1> 
  4562 00009DEF 6908                <1> notes	dw	pic_freq/554		; D flat
  4563 00009DF1 FFFF                <1> 	dw	-1			; silent
  4564 00009DF3 8814                <1> 	dw	pic_freq/227		; D flat
  4565 00009DF5 980C                <1> 	dw	pic_freq/370		; G flat
  4566 00009DF7 8814                <1> 	dw	pic_freq/227		; D flat
  4567 00009DF9 3B0B                <1> 	dw	pic_freq/415		; A flat
  4568 00009DFB 0000                <1> 	dw	0
  4569                              <1> 
  4570                              <1> ;=========================================================================
  4571                              <1> ; sound - Play power-on sound.
  4572                              <1> ; Input:
  4573                              <1> ;	none
  4574                              <1> ; Output:
  4575                              <1> ;	none, destroys some registers
  4576                              <1> ;-------------------------------------------------------------------------
  4577                              <1> sound:
  4578 00009DFD FC                  <1> 	cld
  4579 00009DFE BE[EF9D]            <1> 	mov	si,notes		; set SI to notes table
  4580                              <1> 
  4581 00009E01 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  4582 00009E03 E643                <1> 	out	pit_ctl_reg,al
  4583                              <1> 
  4584                              <1> .loop:
  4585 00009E05 2EAD                <1>     cs	lodsw				; load next note to AX
  4586 00009E07 83F800              <1> 	cmp	ax,0
  4587 00009E0A 7422                <1> 	jz	.exit
  4588 00009E0C 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  4589 00009E0E E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  4590 00009E10 88E0                <1> 	mov	al,ah
  4591 00009E12 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  4592                              <1> 
  4593 00009E14 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  4594 00009E16 0C03                <1>         or      al,03h			; turn on the speaker
  4595 00009E18 E661                <1>         out     port_b_reg,al		; write the new value
  4596                              <1> 
  4597                              <1> .silent:
  4598 00009E1A B90030              <1> 	mov	cx,3000h
  4599 00009E1D E89DED              <1> 	call	delay_15us		; delay while note is playing
  4600                              <1> 
  4601 00009E20 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  4602 00009E22 24FC                <1> 	and	al,0FCh			; turn off the speaker
  4603 00009E24 E661                <1>         out     port_b_reg,al		; write the new value
  4604                              <1> 
  4605 00009E26 B90001              <1>         mov     cx,0100h
  4606 00009E29 E891ED              <1> 	call	delay_15us		; delay after the note
  4607                              <1>         
  4608 00009E2C EBD7                <1>         jmp     .loop			; play the next note
  4609                              <1> .exit:
  4610 00009E2E C3                  <1> 	ret
  4611                              <1> 
  4612                              <1> ;=========================================================================
  4613                              <1> ; beep - Play a beep sound
  4614                              <1> ; Input:
  4615                              <1> ;	BL - duration in 0.1 second
  4616                              <1> ; Output:
  4617                              <1> ;	BL = 0
  4618                              <1> ;-------------------------------------------------------------------------
  4619                              <1> beep:
  4620 00009E2F 50                  <1> 	push	ax
  4621 00009E30 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  4622 00009E32 E643                <1> 	out	pit_ctl_reg,al
  4623 00009E34 B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  4624 00009E37 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  4625 00009E39 88E0                <1> 	mov	al,ah
  4626 00009E3B E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  4627 00009E3D E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  4628 00009E3F 0C03                <1> 	or	al,03h			; turn on the speaker
  4629 00009E41 E661                <1> 	out	port_b_reg,al		; write the new value
  4630                              <1> .loop:
  4631 00009E43 B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  4632 00009E46 E874ED              <1> 	call	delay_15us
  4633 00009E49 FECB                <1> 	dec	bl
  4634 00009E4B 75F6                <1> 	jnz	.loop
  4635 00009E4D 3403                <1> 	xor	al,03h			; turn off the speaker
  4636 00009E4F E661                <1> 	out	port_b_reg,al		; write the new value
  4637 00009E51 58                  <1> 	pop	ax
  4638 00009E52 C3                  <1> 	ret
  4639                                  %include	"cpu.inc"		; CPU and FPU detection
  4640                              <1> ;=========================================================================
  4641                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  4642                              <1> ;-------------------------------------------------------------------------
  4643                              <1> ;
  4644                              <1> ; Compiles with NASM 2.07, might work with other versions
  4645                              <1> ;
  4646                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  4647                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  4648                              <1> ;
  4649                              <1> ; This program is free software: you can redistribute it and/or modify
  4650                              <1> ; it under the terms of the GNU General Public License as published by
  4651                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4652                              <1> ; (at your option) any later version.
  4653                              <1> ;
  4654                              <1> ; This program is distributed in the hope that it will be useful,
  4655                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4656                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4657                              <1> ; GNU General Public License for more details.
  4658                              <1> ;
  4659                              <1> ; You should have received a copy of the GNU General Public License
  4660                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4661                              <1> ;
  4662                              <1> ;=========================================================================
  4663                              <1> 
  4664                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  4665                              <1> 
  4666                              <1> ;=========================================================================
  4667                              <1> ; detect_cpu - detect and print CPU type
  4668                              <1> ; Note:
  4669                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  4670                              <1> ;	  incorrect results if used on other CPU types.
  4671                              <1> ;-------------------------------------------------------------------------
  4672                              <1> detect_cpu:
  4673 00009E53 50                  <1> 	push	ax
  4674 00009E54 56                  <1> 	push	si
  4675 00009E55 BE[8D80]            <1> 	mov	si,msg_cpu
  4676 00009E58 E8AA01              <1> 	call	print
  4677                              <1> 
  4678                              <1> ; test for NEC V20
  4679 00009E5B B80101              <1> 	mov	ax,0101h
  4680 00009E5E D510                <1> 	aad	10h			; NEC V20 ignores the argument
  4681 00009E60 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  4682 00009E62 7452                <1> 	je	.nec_v20
  4683                              <1> 
  4684                              <1> ; not NEC V20, test for various 8088 versions
  4685                              <1> .i8088:					; 8088 - NMOS version of 8088
  4686 00009E64 FA                  <1> 	cli				; disable interrupts
  4687 00009E65 1E                  <1> 	push	ds
  4688 00009E66 31C0                <1> 	xor	ax,ax
  4689 00009E68 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  4690 00009E6A B8[BF9E]            <1> 	mov	ax,.int_01		; new int 01h offset
  4691 00009E6D 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  4692 00009E71 50                  <1> 	push	ax			; save to stack
  4693 00009E72 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  4694 00009E74 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  4695 00009E78 50                  <1> 	push	ax			; save to stack
  4696 00009E79 9C                  <1> 	pushf				; push flags to stack (save)
  4697 00009E7A 9C                  <1> 	pushf				; push flags to stack (modify)
  4698 00009E7B 58                  <1> 	pop	ax			; and move them to AX
  4699 00009E7C 0D0001              <1> 	or	ax,flags_tf		; set TF
  4700 00009E7F 50                  <1> 	push	ax
  4701 00009E80 31C0                <1> 	xor	ax,ax			; AX = 0
  4702 00009E82 9D                  <1> 	popf				; load modified value to FLAGS register
  4703                              <1> 					; enable single-step
  4704 00009E83 90                  <1> 	nop
  4705 00009E84 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  4706                              <1> 					; after PUSH SREG instructions
  4707                              <1> .push_sreg:				; and will not single-step to here
  4708 00009E85 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  4709                              <1> 					; after modifying segment registers
  4710                              <1> .pop_sreg:				; and will not single-step to here
  4711 00009E86 90                  <1> 	nop
  4712 00009E87 9D                  <1> 	popf				; restore original FLAGS, disable
  4713                              <1> 					; single-step
  4714                              <1> 
  4715 00009E88 5E                  <1> 	pop	si			; get original int 01h segment
  4716 00009E89 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  4717 00009E8D 5E                  <1> 	pop	si			; get original int 01h offset
  4718 00009E8E 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  4719 00009E92 1F                  <1> 	pop	ds
  4720 00009E93 FB                  <1> 	sti				; enable interrupts
  4721 00009E94 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  4722 00009E97 740D                <1> 	jz	.i8088_78
  4723                              <1> 
  4724 00009E99 83F802              <1> 	cmp	ax,0002h
  4725 00009E9C 7410                <1> 	jz	.i8088_81
  4726                              <1> 
  4727                              <1> .harris:				; Harris / Intersil 80C88
  4728 00009E9E BE[5281]            <1> 	mov	si,msg_cpu_harris
  4729 00009EA1 E86101              <1> 	call	print
  4730 00009EA4 EB16                <1> 	jmp	.exit
  4731                              <1> 
  4732                              <1> .i8088_78:
  4733 00009EA6 BE[C780]            <1> 	mov	si,msg_cpu_8088_78
  4734 00009EA9 E85901              <1> 	call	print
  4735 00009EAC EB0E                <1> 	jmp	.exit
  4736                              <1> 
  4737                              <1> .i8088_81:
  4738 00009EAE BE[2881]            <1> 	mov	si,msg_cpu_8088_81
  4739 00009EB1 E85101              <1> 	call	print
  4740 00009EB4 EB06                <1> 	jmp	.exit
  4741                              <1> 
  4742                              <1> .nec_v20:
  4743 00009EB6 BE[6C81]            <1> 	mov	si,msg_cpu_nec_v20
  4744 00009EB9 E84901              <1> 	call	print
  4745                              <1> 
  4746                              <1> .exit:
  4747 00009EBC 5E                  <1> 	pop	si
  4748 00009EBD 58                  <1> 	pop	ax
  4749 00009EBE C3                  <1> 	ret
  4750                              <1> 
  4751                              <1> ; stack frame after "push bp"
  4752                              <1> ; BP - word [BP]
  4753                              <1> ; IP - word [BP+2]
  4754                              <1> ; CS - word [BP+4]
  4755                              <1> ; FLAGS - word [BP+6]
  4756                              <1> .int_01:
  4757 00009EBF 55                  <1> 	push	bp
  4758 00009EC0 89E5                <1> 	mov	bp,sp
  4759 00009EC2 817E02[869E]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  4760 00009EC7 7504                <1> 	jne	.1
  4761 00009EC9 B001                <1> 	mov	al,01h			; (C) INTEL '79
  4762 00009ECB EB09                <1> 	jmp	.int_01_exit
  4763                              <1> .1:
  4764 00009ECD 817E02[859E]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  4765 00009ED2 7502                <1> 	jne	.int_01_exit
  4766 00009ED4 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  4767                              <1> .int_01_exit:
  4768 00009ED6 5D                  <1> 	pop	bp
  4769 00009ED7 CF                  <1> 	iret
  4770                              <1> 
  4771                              <1> ;=========================================================================
  4772                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  4773                              <1> ;-------------------------------------------------------------------------
  4774                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  4775                              <1> detect_fpu:
  4776 00009ED8 50                  <1> 	push	ax
  4777 00009ED9 51                  <1> 	push	cx
  4778 00009EDA 56                  <1> 	push	si
  4779 00009EDB BE[AA80]            <1> 	mov	si,msg_fpu
  4780 00009EDE E82401              <1> 	call	print
  4781 00009EE1 DBE3                <1> 	fninit				; initialize coprocessor
  4782 00009EE3 B90300              <1> 	mov	cx,3
  4783                              <1> .wait:
  4784 00009EE6 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  4785                              <1> 					;   (can't use fwait, since it could
  4786                              <1> 					;   be no coprocessor at all)
  4787 00009EE8 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  4788 00009EEC C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  4789 00009EF2 D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  4790 00009EF6 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  4791 00009EFC 750D                <1> 	jne	.no_fpu			;   after finit
  4792                              <1> 
  4793                              <1> .fpu:
  4794 00009EFE BE[7681]            <1> 	mov	si,msg_fpu_present
  4795 00009F01 E80101              <1> 	call	print
  4796 00009F04 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  4797 00009F09 EB06                <1> 	jmp	.exit
  4798                              <1> 
  4799                              <1> .no_fpu:
  4800                              <1> 
  4801 00009F0B BE[7A82]            <1> 	mov	si,msg_absent
  4802 00009F0E E8F400              <1> 	call	print
  4803                              <1> 
  4804                              <1> .exit:
  4805 00009F11 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  4806 00009F15 5E                  <1> 	pop	si
  4807 00009F16 59                  <1> 	pop	cx
  4808 00009F17 58                  <1> 	pop	ax
  4809 00009F18 C3                  <1> 	ret
  4810                                  
  4811                                  %ifdef AT_COMPAT
  4812                                  
  4813                                  ;=========================================================================
  4814                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  4815                                  ;-------------------------------------------------------------------------
  4816                                  int_ignore2:
  4817 00009F19 50                      	push	ax
  4818 00009F1A B020                    	mov	al,20h
  4819 00009F1C E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  4820 00009F1E E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  4821 00009F20 58                      	pop	ax
  4822 00009F21 CF                      	iret
  4823                                  
  4824                                  ;=========================================================================
  4825                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  4826                                  ;-------------------------------------------------------------------------
  4827                                  int_71:
  4828 00009F22 50                      	push	ax
  4829 00009F23 B020                    	mov	al,20h
  4830 00009F25 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  4831 00009F27 58                      	pop	ax
  4832 00009F28 CD0A                    	int	0Ah		; call IRQ2 ISR
  4833 00009F2A CF                      	iret
  4834                                  
  4835                                  ;=========================================================================
  4836                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  4837                                  ;-------------------------------------------------------------------------
  4838                                  int_75:
  4839 00009F2B 50                      	push	ax
  4840 00009F2C B020                    	mov	al,20h
  4841 00009F2E E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  4842 00009F30 E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  4843 00009F32 58                      	pop	ax
  4844 00009F33 CD02                    	int	02h		; call NMI ISR
  4845 00009F35 CF                      	iret
  4846                                  
  4847                                  %endif ; AT_COMPAT
  4848                                  
  4849                                  ;=========================================================================
  4850                                  ; extension_scan - scan for BIOS extensions
  4851                                  ; Input:
  4852                                  ;	DX - start segment
  4853                                  ;	BX - end segment
  4854                                  ; Returns:
  4855                                  ;	DX - address for the continuation of the scan
  4856                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  4857                                  ;-------------------------------------------------------------------------
  4858                                  extension_scan:
  4859 00009F36 C70667000000            	mov	word [67h],0
  4860 00009F3C C70669000000            	mov	word [69h],0
  4861                                  .scan:
  4862 00009F42 8EC2                    	mov	es,dx
  4863 00009F44 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  4864 00009F4B 752E                    	jnz	.next			; no signature, check next 2 KiB
  4865 00009F4D 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  4866 00009F51 B400                    	mov	ah,0
  4867 00009F53 B105                    	mov	cl,5
  4868 00009F55 D3E0                    	shl	ax,cl			; convert size to paragraphs
  4869 00009F57 01C2                    	add	dx,ax
  4870 00009F59 B104                    	mov	cl,4
  4871 00009F5B D3E0                    	shl	ax,cl			; convert size to bytes
  4872 00009F5D 89C1                    	mov	cx,ax
  4873 00009F5F B000                    	mov	al,0
  4874 00009F61 31F6                    	xor	si,si
  4875                                  .checksum:
  4876 00009F63 260204                      es	add	al,byte [si]
  4877 00009F66 46                      	inc	si
  4878 00009F67 E2FA                    	loop	.checksum
  4879 00009F69 E680                    	out	post_reg,al		; XXX - debug
  4880 00009F6B 08C0                    	or	al,al
  4881 00009F6D 750C                    	jnz	.next			; bad checksum
  4882 00009F6F C70667000300            	mov	word [67h],3		; extension initialization offset
  4883 00009F75 8C066900                	mov	word [69h],es		; extension segment
  4884 00009F79 EB08                    	jmp	.exit
  4885                                  .next:
  4886 00009F7B 81C28000                	add	dx,80h			; add 2 KiB
  4887 00009F7F 39DA                    	cmp	dx,bx
  4888 00009F81 72BF                    	jb	.scan
  4889                                  .exit:
  4890 00009F83 C3                      	ret
  4891                                  
  4892                                  ;=========================================================================
  4893                                  ; ipl - Initial Program Load - try to read and execute boot sector
  4894                                  ;-------------------------------------------------------------------------
  4895                                  ipl:
  4896 00009F84 FB                      	sti
  4897 00009F85 31C0                    	xor	ax,ax
  4898 00009F87 8ED8                    	mov	ds,ax
  4899 00009F89 C7067800[C7EF]          	mov	word [78h],int_1E
  4900 00009F8F 8C0E7A00                	mov	word [7Ah],cs
  4901                                  
  4902                                  .retry:
  4903 00009F93 B004                    	mov	al,4			; try booting from floppy 4 times
  4904                                  
  4905                                  .fd_loop:
  4906 00009F95 50                      	push	ax
  4907 00009F96 B400                    	mov	ah,00h			; reset disk system
  4908 00009F98 B200                    	mov	dl,00h			; drive 0
  4909 00009F9A CD13                    	int	13h
  4910 00009F9C 722C                    	jb	.fd_failed
  4911 00009F9E B408                    	mov	ah,08h			; get drive parameters
  4912 00009FA0 B200                    	mov	dl,00h			; drive 0
  4913 00009FA2 CD13                    	int	13h
  4914 00009FA4 7224                    	jc	.fd_failed
  4915 00009FA6 80FA00                  	cmp	dl,00h
  4916 00009FA9 741F                    	jz	.fd_failed		; jump if zero drives
  4917 00009FAB B80102                  	mov	ax,0201h		; read one sector
  4918 00009FAE 31D2                    	xor	dx,dx			; head 0, drive 0
  4919 00009FB0 8EC2                    	mov	es,dx			; to 0000:7C00
  4920 00009FB2 BB007C                  	mov	bx,7C00h
  4921 00009FB5 B90100                  	mov	cx,0001h		; track 0, sector 1
  4922 00009FB8 CD13                    	int	13h
  4923 00009FBA 720E                    	jc	.fd_failed
  4924 00009FBC 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  4925 00009FC3 7505                    	jnz	.fd_failed
  4926 00009FC5 EA007C0000              	jmp	0000h:7C00h
  4927                                  
  4928                                  .fd_failed:
  4929 00009FCA 58                      	pop	ax
  4930 00009FCB FEC8                    	dec	al
  4931 00009FCD 75C6                    	jnz	.fd_loop
  4932                                  
  4933                                  ; try booting from HDD
  4934                                  
  4935 00009FCF B40D                    	mov	ah,0Dh			; reset hard disks
  4936 00009FD1 B280                    	mov	dl,80h			; drive 80h
  4937 00009FD3 CD13                    	int	13h
  4938 00009FD5 7222                    	jc	.hd_failed
  4939 00009FD7 B80102                  	mov	ax,0201h		; read one sector
  4940 00009FDA BA8000                  	mov	dx,0080h		; head 0, drive 80h
  4941 00009FDD 31DB                    	xor	bx,bx
  4942 00009FDF 8EC3                    	mov	es,bx			; to 0000:7C00
  4943 00009FE1 BB007C                  	mov	bx,7C00h
  4944 00009FE4 B90100                  	mov	cx,0001h		; track 0, sector 1
  4945 00009FE7 CD13                    	int	13h
  4946 00009FE9 720E                    	jc	.hd_failed
  4947 00009FEB 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  4948 00009FF2 7505                    	jnz	.hd_failed
  4949 00009FF4 EA007C0000              	jmp	0000h:7C00h
  4950                                  
  4951                                  .hd_failed:
  4952 00009FF9 BE[2383]                	mov	si,msg_boot_failed
  4953 00009FFC E80600                  	call	print
  4954 00009FFF B400                    	mov	ah,00h
  4955 0000A001 CD16                    	int	16h
  4956 0000A003 EB8E                    	jmp	.retry
  4957                                  
  4958                                  ;=========================================================================
  4959                                  ; print - print ASCIIZ string to the console
  4960                                  ; Input:
  4961                                  ;	CS:SI - pointer to string to print
  4962                                  ; Output:
  4963                                  ;	none
  4964                                  ;-------------------------------------------------------------------------
  4965                                  print:
  4966 0000A005 9C                      	pushf
  4967 0000A006 50                      	push	ax
  4968 0000A007 53                      	push	bx
  4969 0000A008 56                      	push	si
  4970 0000A009 1E                      	push	ds
  4971 0000A00A 0E                      	push	cs
  4972 0000A00B 1F                      	pop	ds
  4973 0000A00C FC                      	cld
  4974                                  .1:
  4975 0000A00D AC                      	lodsb
  4976 0000A00E 08C0                    	or	al,al
  4977 0000A010 7408                    	jz	.exit
  4978 0000A012 B40E                    	mov	ah,0Eh
  4979 0000A014 B30F                    	mov	bl,0Fh
  4980 0000A016 CD10                    	int	10h
  4981 0000A018 EBF3                    	jmp	.1
  4982                                  .exit:
  4983 0000A01A 1F                      	pop	ds
  4984 0000A01B 5E                      	pop	si
  4985 0000A01C 5B                      	pop	bx
  4986 0000A01D 58                      	pop	ax
  4987 0000A01E 9D                      	popf
  4988 0000A01F C3                      	ret
  4989                                  
  4990                                  ;=========================================================================
  4991                                  ; print_hex - print 16-bit number in hexadecimal
  4992                                  ; Input:
  4993                                  ;	AX - number to print
  4994                                  ; Output:
  4995                                  ;	none
  4996                                  ;-------------------------------------------------------------------------
  4997                                  print_hex:
  4998 0000A020 51                      	push	cx
  4999 0000A021 50                      	push	ax
  5000 0000A022 B10C                    	mov	cl,12
  5001 0000A024 D3E8                    	shr	ax,cl
  5002 0000A026 E83B00                  	call	print_digit
  5003 0000A029 58                      	pop	ax
  5004 0000A02A 50                      	push	ax
  5005 0000A02B B108                    	mov	cl,8
  5006 0000A02D D3E8                    	shr	ax,cl
  5007 0000A02F E83200                  	call	print_digit
  5008 0000A032 58                      	pop	ax
  5009 0000A033 50                      	push	ax
  5010 0000A034 B104                    	mov	cl,4
  5011 0000A036 D3E8                    	shr	ax,cl
  5012 0000A038 E82900                  	call	print_digit
  5013 0000A03B 58                      	pop	ax
  5014 0000A03C 50                      	push	ax
  5015 0000A03D E82400                  	call	print_digit
  5016 0000A040 58                      	pop	ax
  5017 0000A041 59                      	pop	cx
  5018 0000A042 C3                      	ret
  5019                                  
  5020                                  ;=========================================================================
  5021                                  ; print_dec - print 16-bit number in decimal
  5022                                  ; Input:
  5023                                  ;	AX - number to print
  5024                                  ; Output:
  5025                                  ;	none
  5026                                  ;-------------------------------------------------------------------------
  5027                                  print_dec:
  5028 0000A043 50                      	push	ax
  5029 0000A044 51                      	push	cx
  5030 0000A045 52                      	push	dx
  5031 0000A046 B90A00                  	mov	cx,10		; base = 10
  5032 0000A049 E80400                  	call	.print_rec
  5033 0000A04C 5A                      	pop	dx
  5034 0000A04D 59                      	pop	cx
  5035 0000A04E 58                      	pop	ax
  5036 0000A04F C3                      	ret
  5037                                  
  5038                                  .print_rec:			; print all digits recursively
  5039 0000A050 52                      	push	dx
  5040 0000A051 31D2                    	xor	dx,dx		; DX = 0
  5041 0000A053 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  5042 0000A055 83F800                  	cmp	ax,0
  5043 0000A058 7403                    	je	.below10
  5044 0000A05A E8F3FF                  	call	.print_rec	; print number / 10 recursively
  5045                                  .below10:
  5046 0000A05D 89D0                    	mov	ax,dx		; reminder is in DX
  5047 0000A05F E80200                  	call	print_digit	; print reminder
  5048 0000A062 5A                      	pop	dx
  5049 0000A063 C3                      	ret
  5050                                  
  5051                                  ;=========================================================================
  5052                                  ; print_digit - print hexadecimal digit
  5053                                  ; Input:
  5054                                  ;	AL - bits 3...0 - digit to print (0...F)
  5055                                  ; Output:
  5056                                  ;	none
  5057                                  ;-------------------------------------------------------------------------
  5058                                  print_digit:
  5059 0000A064 50                      	push	ax
  5060 0000A065 53                      	push	bx
  5061 0000A066 240F                    	and	al,0Fh
  5062 0000A068 0430                    	add	al,'0'			; convert to ASCII
  5063 0000A06A 3C39                    	cmp	al,'9'			; less or equal 9?
  5064 0000A06C 7602                    	jna	.1
  5065 0000A06E 0407                    	add	al,'A'-'9'-1		; a hex digit
  5066                                  .1:
  5067 0000A070 B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  5068 0000A072 B307                    	mov	bl,07h			; just in case we're in graphic mode
  5069 0000A074 CD10                    	int	10h
  5070 0000A076 5B                      	pop	bx
  5071 0000A077 58                      	pop	ax
  5072 0000A078 C3                      	ret
  5073                                  
  5074                                  ;=========================================================================
  5075                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  5076                                  ; Input:
  5077                                  ;	AX = memory size in KiB
  5078                                  ; Notes:
  5079                                  ;	- Assumes that EBDA memory was cleaned
  5080                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  5081                                  ;-------------------------------------------------------------------------
  5082                                  reserve_ebda:
  5083                                  %ifdef PS2_MOUSE
  5084 0000A079 50                      	push	ax
  5085 0000A07A 51                      	push	cx
  5086 0000A07B F70610000400            	test	word [equipment_list],equip_mouse
  5087 0000A081 742B                    	jz	.no_mouse
  5088 0000A083 A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  5089 0000A086 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  5090 0000A089 A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  5091 0000A08C B106                    	mov	cl,6
  5092 0000A08E D3E0                    	shl	ax,cl			; convert to segment
  5093 0000A090 A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  5094 0000A093 1E                      	push	ds
  5095 0000A094 8ED8                    	mov	ds,ax
  5096 0000A096 B80100                  	mov	ax,EBDA_SIZE
  5097 0000A099 A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  5098 0000A09C 1F                      	pop	ds
  5099 0000A09D 56                      	push	si
  5100 0000A09E BE[E282]                	mov	si,msg_ebda
  5101 0000A0A1 E861FF                  	call	print
  5102 0000A0A4 E89CFF                  	call	print_dec
  5103 0000A0A7 BE[1C83]                	mov	si,msg_kib
  5104 0000A0AA E858FF                  	call	print
  5105 0000A0AD 5E                      	pop	si
  5106                                  .no_mouse:
  5107 0000A0AE 59                      	pop	cx
  5108 0000A0AF 58                      	pop	ax
  5109                                  %endif ; PS2_MOUSE
  5110 0000A0B0 C3                      	ret
  5111                                  
  5112                                  ;=========================================================================
  5113                                  ; detect_ram - Determine the size of installed RAM and test it
  5114                                  ; Input:
  5115                                  ;	none
  5116                                  ; Output:
  5117                                  ;	AX = RAM size
  5118                                  ;	CX, SI - trashed
  5119                                  ;-------------------------------------------------------------------------
  5120                                  detect_ram:
  5121 0000A0B1 1E                      	push	ds
  5122 0000A0B2 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  5123 0000A0B4 B82000                  	mov	ax,MIN_RAM_SIZE
  5124                                  
  5125                                  .fill_loop:
  5126 0000A0B7 50                      	push	ax
  5127 0000A0B8 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  5128 0000A0BA 8ED8                    	mov	ds,ax
  5129 0000A0BC A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  5130 0000A0BF 58                      	pop	ax
  5131 0000A0C0 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  5132 0000A0C3 3D8002                  	cmp	ax,MAX_RAM_SIZE
  5133 0000A0C6 75EF                    	jne	.fill_loop
  5134 0000A0C8 B82000                  	mov	ax,MIN_RAM_SIZE
  5135                                  
  5136                                  .size_loop:
  5137 0000A0CB 50                      	push	ax
  5138 0000A0CC D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  5139 0000A0CE 8ED8                    	mov	ds,ax
  5140 0000A0D0 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  5141 0000A0D4 750B                    	jne	.size_done
  5142 0000A0D6 58                      	pop	ax
  5143 0000A0D7 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  5144 0000A0DA 3D8002                  	cmp	ax,MAX_RAM_SIZE
  5145 0000A0DD 7303                    	jnb	.size_exit
  5146 0000A0DF EBEA                    	jmp	.size_loop
  5147                                  
  5148                                  .size_done:
  5149 0000A0E1 58                      	pop	ax
  5150                                  
  5151                                  .size_exit:
  5152 0000A0E2 1F                      	pop	ds
  5153 0000A0E3 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  5154                                  
  5155                                  ; AX = detected memory size, now test the RAM
  5156                                  
  5157 0000A0E6 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  5158 0000A0EC 7462                    	je	.test_done
  5159                                  
  5160 0000A0EE BE[8382]                	mov	si,msg_ram_testing
  5161 0000A0F1 E811FF                  	call	print
  5162 0000A0F4 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  5163                                  
  5164                                  .test_loop:
  5165 0000A0F7 50                      	push	ax
  5166 0000A0F8 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  5167 0000A0FA B700                    	mov	bh,00h			; page 0
  5168 0000A0FC CD10                    	int	10h			; position returned in DX
  5169 0000A0FE 58                      	pop	ax
  5170 0000A0FF E841FF                  	call	print_dec
  5171 0000A102 50                      	push	ax
  5172 0000A103 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  5173 0000A105 B700                    	mov	bh,00h			; page 0
  5174 0000A107 CD10                    	int	10h
  5175 0000A109 B401                    	mov	ah,01h
  5176 0000A10B CD16                    	int	16h
  5177 0000A10D 7412                    	jz	.test_no_key
  5178 0000A10F B400                    	mov	ah,00h
  5179 0000A111 CD16                    	int	16h			; read the keystroke
  5180 0000A113 3C1B                    	cmp	al,1Bh			; ESC?
  5181 0000A115 741B                    	je	.test_esc
  5182 0000A117 3D003B                  	cmp	ax,3B00h		; F1?
  5183 0000A11A 7505                    	jne	.test_no_key
  5184 0000A11C 800E120001              	or	byte [post_flags],post_setup
  5185                                  
  5186                                  .test_no_key:
  5187 0000A121 58                      	pop	ax
  5188 0000A122 E82C00                  	call	ram_test_block
  5189 0000A125 7211                    	jc	.test_error		; error in last test
  5190 0000A127 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  5191 0000A12A 3B061300                	cmp	ax,word [memory_size]
  5192 0000A12E 72C7                    	jb	.test_loop
  5193 0000A130 EB1E                    	jmp	.test_done
  5194                                  
  5195                                  .test_esc:
  5196 0000A132 58                      	pop	ax
  5197 0000A133 A11300                  	mov	ax,word [memory_size]
  5198 0000A136 EB18                    	jmp	.test_done
  5199                                  
  5200                                  .test_error:
  5201 0000A138 A31300                  	mov	word [memory_size],ax	; store size of good memory
  5202 0000A13B BE[A082]                	mov	si,msg_ram_error
  5203 0000A13E E8C4FE                  	call	print
  5204 0000A141 E8FFFE                  	call	print_dec
  5205 0000A144 BE[1C83]                	mov	si,msg_kib
  5206 0000A147 E8BBFE                  	call	print
  5207 0000A14A BE[8A80]                	mov	si,msg_crlf
  5208 0000A14D E8B5FE                  	call	print
  5209                                  
  5210                                  .test_done:
  5211 0000A150 C3                      	ret
  5212                                  
  5213                                  ;=========================================================================
  5214                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  5215                                  ; Input:
  5216                                  ;	AX = address of the memory to test (in KiB)
  5217                                  ; Output:
  5218                                  ;	CF = status
  5219                                  ;		0 = passed
  5220                                  ;		1 = failed
  5221                                  ;-------------------------------------------------------------------------
  5222                                  ram_test_block:
  5223 0000A151 50                      	push	ax
  5224 0000A152 53                      	push	bx
  5225 0000A153 51                      	push	cx
  5226 0000A154 56                      	push	si
  5227 0000A155 57                      	push	di
  5228 0000A156 1E                      	push	ds
  5229 0000A157 06                      	push	es
  5230 0000A158 B106                    	mov	cl,6			; convert KiB to segment address
  5231 0000A15A D3E0                    	shl	ax,cl			; (multiply by 64)
  5232 0000A15C 8ED8                    	mov	ds,ax
  5233 0000A15E 8EC0                    	mov	es,ax
  5234 0000A160 31F6                    	xor	si,si
  5235 0000A162 31FF                    	xor	di,di
  5236 0000A164 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  5237 0000A167 B8AA55                  	mov	ax,55AAh		; first test pattern
  5238 0000A16A 89D9                    	mov	cx,bx
  5239 0000A16C F3AB                        rep	stosw				; store test pattern
  5240 0000A16E 89D9                    	mov	cx,bx			; RAM test block size
  5241                                  .1:
  5242 0000A170 AD                      	lodsw
  5243 0000A171 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  5244 0000A174 7522                    	jne	.fail
  5245 0000A176 E2F8                    	loop	.1
  5246 0000A178 31F6                    	xor	si,si
  5247 0000A17A 31FF                    	xor	di,di
  5248 0000A17C B855AA                  	mov	ax,0AA55h		; second test pattern
  5249 0000A17F 89D9                    	mov	cx,bx			; RAM test block size
  5250 0000A181 F3AB                        rep stosw				; store test pattern
  5251 0000A183 89D9                    	mov	cx,bx			; RAM test block size
  5252                                  .2:
  5253 0000A185 AD                      	lodsw
  5254 0000A186 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  5255 0000A189 750D                    	jne	.fail
  5256 0000A18B E2F8                    	loop	.2
  5257 0000A18D 31FF                    	xor	di,di
  5258 0000A18F 31C0                    	xor	ax,ax			; zero
  5259 0000A191 89D9                    	mov	cx,bx			; RAM test block size
  5260 0000A193 F3AB                        rep stosw				; zero the memory
  5261 0000A195 F8                      	clc				; test passed, clear CF
  5262 0000A196 EB01                    	jmp	.exit
  5263                                  
  5264                                  .fail:
  5265 0000A198 F9                      	stc				; test failed, set CF
  5266                                  	
  5267                                  .exit:
  5268 0000A199 07                      	pop	es
  5269 0000A19A 1F                      	pop	ds
  5270 0000A19B 5F                      	pop	di
  5271 0000A19C 5E                      	pop	si
  5272 0000A19D 59                      	pop	cx
  5273 0000A19E 5B                      	pop	bx
  5274 0000A19F 58                      	pop	ax
  5275 0000A1A0 C3                      	ret
  5276                                  
  5277                                  ;=========================================================================
  5278                                  ; print display type
  5279                                  ;-------------------------------------------------------------------------
  5280                                  print_display:
  5281 0000A1A1 BE[8381]                	mov	si,msg_disp
  5282 0000A1A4 E85EFE                  	call	print
  5283 0000A1A7 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  5284 0000A1AA 2430                    	and	al,equip_video		; get video adapter type
  5285 0000A1AC BE[C581]                	mov	si,msg_disp_mda
  5286 0000A1AF 3C30                    	cmp	al,equip_mono		; monochrome?
  5287 0000A1B1 740A                    	jz	.print_disp
  5288 0000A1B3 BE[BF81]                	mov	si,msg_disp_cga
  5289 0000A1B6 3C20                    	cmp	al,equip_color		; CGA?
  5290 0000A1B8 7403                    	jz	.print_disp
  5291 0000A1BA BE[A081]                	mov	si,msg_disp_ega		; otherwise EGA or later
  5292                                  .print_disp:
  5293 0000A1BD E845FE                  	call	print
  5294 0000A1C0 C3                      	ret
  5295                                  
  5296                                  ;=========================================================================
  5297                                  ; print PS/2 mouse presence
  5298                                  ;-------------------------------------------------------------------------
  5299                                  
  5300                                  print_mouse:
  5301 0000A1C1 BE[5382]                	mov	si,msg_mouse
  5302 0000A1C4 E83EFE                  	call	print
  5303 0000A1C7 BE[7A82]                	mov	si,msg_absent
  5304 0000A1CA F606100004              	test	byte [equipment_list],equip_mouse
  5305 0000A1CF 7403                    	jz	.print_mouse
  5306 0000A1D1 BE[7082]                	mov	si,msg_present
  5307                                  .print_mouse:
  5308 0000A1D4 E82EFE                  	call	print
  5309 0000A1D7 C3                      	ret
  5310                                  
  5311                                  ;=========================================================================
  5312                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  5313                                  ;-------------------------------------------------------------------------	
  5314 0000A1D8 FF<rept>                	setloc	0E05Bh		; POST Entry Point
  5315                                  cold_start:
  5316 0000E05B B84000                  	mov	ax,biosdseg
  5317 0000E05E 8ED8                    	mov	ds,ax
  5318 0000E060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  5319                                  
  5320                                  warm_start:
  5321 0000E066 FA                      	cli				; disable interrupts
  5322 0000E067 FC                      	cld				; clear direction flag
  5323 0000E068 B001                    	mov	al,e_start
  5324 0000E06A E680                    	out	post_reg,al		; POST start code
  5325                                  
  5326                                  ;-------------------------------------------------------------------------
  5327                                  ; test CPU's FLAG register
  5328                                  
  5329 0000E06C 31C0                    	xor	ax,ax			; AX = 0
  5330 0000E06E 724A                    	jb	cpu_fail
  5331 0000E070 7048                    	jo	cpu_fail
  5332 0000E072 7846                    	js	cpu_fail
  5333 0000E074 7544                    	jnz	cpu_fail
  5334 0000E076 7B42                    	jpo	cpu_fail
  5335 0000E078 83C001                  	add	ax,1			; AX = 1
  5336 0000E07B 743D                    	jz	cpu_fail
  5337 0000E07D 7A3B                    	jpe	cpu_fail
  5338 0000E07F 2D0280                  	sub	ax,8002h
  5339 0000E082 7836                    	js	cpu_fail
  5340 0000E084 40                      	inc	ax
  5341 0000E085 7133                    	jno	cpu_fail
  5342 0000E087 D1E0                    	shl	ax,1
  5343 0000E089 732F                    	jnb	cpu_fail
  5344 0000E08B 752D                    	jnz	cpu_fail
  5345 0000E08D D1E0                    	shl	ax,1
  5346 0000E08F 7229                    	jb	cpu_fail
  5347                                  
  5348                                  ;-------------------------------------------------------------------------
  5349                                  ; Test CPU registers
  5350                                  
  5351 0000E091 B8AAAA                  	mov	ax,0AAAAh
  5352                                  .1:
  5353 0000E094 8ED8                    	mov	ds,ax
  5354 0000E096 8CDB                    	mov	bx,ds
  5355 0000E098 8EC3                    	mov	es,bx
  5356 0000E09A 8CC1                    	mov	cx,es
  5357 0000E09C 8ED1                    	mov	ss,cx
  5358 0000E09E 8CD2                    	mov	dx,ss
  5359 0000E0A0 89D5                    	mov	bp,dx
  5360 0000E0A2 89EC                    	mov	sp,bp
  5361 0000E0A4 89E6                    	mov	si,sp
  5362 0000E0A6 89F7                    	mov	di,si
  5363 0000E0A8 81FFAAAA                	cmp	di,0AAAAh
  5364 0000E0AC 7506                    	jnz	.2
  5365 0000E0AE 89F8                    	mov	ax,di
  5366 0000E0B0 F7D0                    	not	ax
  5367 0000E0B2 EBE0                    	jmp	.1
  5368                                  .2:
  5369 0000E0B4 81FF5555                	cmp	di,5555h
  5370 0000E0B8 741A                    	jz	cpu_ok
  5371                                  
  5372                                  cpu_fail:
  5373 0000E0BA B082                    	mov	al,e_cpu_fail
  5374 0000E0BC E680                    	out	post_reg,al
  5375                                  
  5376                                  ;-------------------------------------------------------------------------
  5377                                  ; CPU error: continious beep - 400 Hz
  5378                                  
  5379 0000E0BE B0B6                    	mov	al,0B6h
  5380 0000E0C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  5381 0000E0C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  5382 0000E0C5 E642                    	out	pit_ch2_reg,al
  5383 0000E0C7 88E0                    	mov	al,ah
  5384 0000E0C9 E642                    	out	pit_ch2_reg,al
  5385 0000E0CB E461                    	in	al,port_b_reg
  5386 0000E0CD 0C03                    	or	al,3			; turn speaker on and enable
  5387 0000E0CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  5388                                  
  5389                                  .1:
  5390 0000E0D1 F4                      	hlt
  5391 0000E0D2 EBFD                    	jmp	.1
  5392                                  
  5393                                  ;-------------------------------------------------------------------------
  5394                                  ; CPU test passed
  5395                                  
  5396                                  cpu_ok:
  5397 0000E0D4 B002                    	mov	al,e_cpu_ok
  5398 0000E0D6 E680                    	out	post_reg,al
  5399                                  
  5400                                  ;-------------------------------------------------------------------------
  5401                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  5402                                  
  5403 0000E0D8 B00D                    	mov	al,0Dh & nmi_disable
  5404 0000E0DA E670                    	out	rtc_addr_reg,al		; disable NMI
  5405 0000E0DC EB00                    	jmp	$+2
  5406 0000E0DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  5407                                  
  5408 0000E0E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  5409 0000E0E2 E661                    	out	port_b_reg,al
  5410 0000E0E4 B000                    	mov	al,00h			; clear turbo bit
  5411 0000E0E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  5412                                  
  5413 0000E0E8 BAD803                  	mov	dx,cga_mode_reg
  5414 0000E0EB EE                      	out	dx,al			; disable video output on CGA
  5415 0000E0EC FEC0                    	inc	al
  5416 0000E0EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  5417 0000E0F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  5418                                  
  5419                                  ;-------------------------------------------------------------------------
  5420                                  ; Initialize DMAC (8237)
  5421                                   
  5422 0000E0F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  5423 0000E0F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  5424 0000E0F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  5425 0000E0F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  5426 0000E0FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  5427 0000E0FC B042                     	mov	al,42h			; single mode, verify, channel 2
  5428 0000E0FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  5429 0000E100 B043                     	mov	al,43h			; single mode, verify, channel 3
  5430 0000E102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  5431 0000E104 B000                     	mov	al,0			; DMA Command register bits:
  5432                                   					; DACK active low, DREQ active high,
  5433                                   					; late write, fixed priority,
  5434                                   					; normal timing, controller enable
  5435                                   					; channel 0 addr hold disable
  5436                                   					; memory to memory disable
  5437 0000E106 E608                     	out	08h,al			; DMA Command register
  5438 0000E108 E681                     	out	81h,al			; DMA Page, channel 2
  5439 0000E10A E682                     	out	82h,al			; DMA Page, channel 3
  5440 0000E10C E683                     	out	83h,al			; DMA Page, channels 0,1
  5441 0000E10E B003                    	mov	al,e_dmac_ok
  5442 0000E110 E680                    	out	post_reg,al
  5443                                  
  5444                                  ;-------------------------------------------------------------------------
  5445                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  5446                                  
  5447                                  low_ram_test:
  5448 0000E112 31F6                    	xor	si,si
  5449 0000E114 31FF                    	xor	di,di
  5450 0000E116 8EDF                    	mov	ds,di
  5451 0000E118 8EC7                    	mov	es,di
  5452 0000E11A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  5453 0000E11E B8AA55                  	mov	ax,55AAh		; first test pattern
  5454 0000E121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  5455 0000E124 F3AB                        rep	stosw				; store test pattern
  5456 0000E126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  5457                                  .1:
  5458 0000E129 AD                      	lodsw
  5459 0000E12A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  5460 0000E12D 7524                    	jne	low_ram_fail
  5461 0000E12F E2F8                    	loop	.1
  5462 0000E131 31F6                    	xor	si,si
  5463 0000E133 31FF                    	xor	di,di
  5464 0000E135 B855AA                  	mov	ax,0AA55h		; second test pattern
  5465 0000E138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  5466 0000E13B F3AB                        rep stosw				; store test pattern
  5467 0000E13D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  5468                                  .2:
  5469 0000E140 AD                      	lodsw
  5470 0000E141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  5471 0000E144 750D                    	jne	low_ram_fail
  5472 0000E146 E2F8                    	loop	.2
  5473 0000E148 31FF                    	xor	di,di
  5474 0000E14A 31C0                    	xor	ax,ax			; zero
  5475 0000E14C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  5476 0000E14F F3AB                        rep stosw				; zero the memory
  5477 0000E151 EB29                    	jmp	low_ram_ok		; test passed
  5478                                  
  5479                                  low_ram_fail:
  5480 0000E153 B084                    	mov	al,e_low_ram_fail	; test failed
  5481 0000E155 E680                    	out	post_reg,al
  5482                                  
  5483                                  ;-------------------------------------------------------------------------
  5484                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  5485                                  
  5486 0000E157 B0B6                    	mov	al,0B6h
  5487 0000E159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  5488 0000E15B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  5489 0000E15E E642                    	out	pit_ch2_reg,al
  5490 0000E160 88E0                    	mov	al,ah
  5491 0000E162 E642                    	out	pit_ch2_reg,al
  5492 0000E164 E461                    	in	al,port_b_reg
  5493                                  .1:
  5494 0000E166 0C03                    	or	al,3			; turn speaker on and enable
  5495 0000E168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  5496 0000E16A B90000                  	mov	cx,0
  5497                                  .2:
  5498 0000E16D 90                      	nop
  5499 0000E16E E2FD                    	loop	.2
  5500 0000E170 24FC                    	and	al,0FCh			; turn of speaker
  5501 0000E172 E661                    	out	port_b_reg,al
  5502 0000E174 B90000                  	mov	cx,0
  5503                                  .3:
  5504 0000E177 90                      	nop
  5505 0000E178 E2FD                    	loop	.3
  5506 0000E17A EBEA                    	jmp	.1
  5507                                  
  5508                                  ;-------------------------------------------------------------------------
  5509                                  ; Low memory test passed
  5510                                  
  5511                                  low_ram_ok:
  5512 0000E17C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  5513 0000E180 B004                    	mov	al,e_low_ram_ok
  5514 0000E182 E680                    	out	post_reg,al
  5515                                  
  5516                                  ;-------------------------------------------------------------------------
  5517                                  ; Set up stack - using upper 256 bytes of interrupt table
  5518                                  
  5519 0000E184 B83000                  	mov	ax,0030h
  5520 0000E187 8ED0                    	mov	ss,ax
  5521 0000E189 BC0001                  	mov	sp,0100h
  5522                                  
  5523                                  ;-------------------------------------------------------------------------
  5524                                  ; Initialize interrupt table
  5525                                  
  5526 0000E18C 0E                      	push	cs
  5527 0000E18D 1F                      	pop	ds
  5528 0000E18E 31FF                    	xor	di,di
  5529 0000E190 8EC7                    	mov	es,di
  5530 0000E192 BE[55FF]                	mov	si,interrupt_table
  5531 0000E195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  5532 0000E198 B800F0                  	mov	ax,bioscseg
  5533                                  .1:
  5534 0000E19B A5                      	movsw				; copy ISR address (offset part)
  5535 0000E19C AB                      	stosw				; store segment part
  5536 0000E19D E2FC                    	loop	.1
  5537                                  %ifdef AT_COMPAT
  5538 0000E19F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  5539 0000E1A2 BE[95FF]                	mov	si,interrupt_table2
  5540 0000E1A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  5541                                  .2:
  5542 0000E1A8 A5                      	movsw				; copy ISR address (offset part)
  5543 0000E1A9 AB                      	stosw				; store segment part
  5544 0000E1AA E2FC                    	loop	.2
  5545                                  %endif ; AT_COMPAT
  5546 0000E1AC B005                    	mov     al,e_int_ok
  5547 0000E1AE E680                    	out	post_reg,al
  5548                                  
  5549                                  ;-------------------------------------------------------------------------
  5550                                  ; set DS to BIOS data area
  5551                                  
  5552 0000E1B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  5553 0000E1B3 8ED8                    	mov	ds,ax
  5554                                  
  5555                                  ;-------------------------------------------------------------------------
  5556                                  ; Initialize PIT (8254 timer)
  5557                                  
  5558 0000E1B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  5559 0000E1B7 E643                    	out	pit_ctl_reg,al
  5560 0000E1B9 B000                    	mov	al,0
  5561 0000E1BB E640                    	out	pit_ch0_reg,al
  5562 0000E1BD E640                    	out	pit_ch0_reg,al
  5563 0000E1BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  5564 0000E1C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  5565 0000E1C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  5566 0000E1C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  5567 0000E1C7 B040                    	mov	al,40h			; XXX timer latch
  5568 0000E1C9 E643                    	out	pit_ctl_reg,al
  5569                                  
  5570                                  ;-------------------------------------------------------------------------
  5571                                  ; Play "power on" sound - also tests PIT functionality
  5572 0000E1CB E82FBC                  	call	sound
  5573                                  
  5574 0000E1CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  5575 0000E1D0 E680                    	out	post_reg,al
  5576                                  
  5577                                  ;-------------------------------------------------------------------------
  5578                                  ; Initialize PIC (8259)
  5579                                  
  5580                                  %ifdef AT_COMPAT
  5581 0000E1D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  5582 0000E1D4 E620                    	out	pic1_reg0,al
  5583 0000E1D6 E6A0                    	out	pic2_reg0,al
  5584 0000E1D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  5585 0000E1DA E621                    	out	pic1_reg1,al
  5586 0000E1DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  5587 0000E1DE E6A1                    	out	pic2_reg1,al
  5588 0000E1E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  5589 0000E1E2 E621                    	out	pic1_reg1,al
  5590 0000E1E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  5591 0000E1E6 E6A1                    	out	pic2_reg1,al
  5592 0000E1E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  5593 0000E1EA E621                    	out	pic1_reg1,al
  5594 0000E1EC E6A1                    	out	pic2_reg1,al
  5595                                  %else
  5596                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  5597                                  	out	pic1_reg0,al
  5598                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  5599                                  	out	pic1_reg1,al
  5600                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  5601                                  	out	pic1_reg1,al
  5602                                  	mov	al,e_pic_ok
  5603                                  	out	post_reg,al
  5604                                  %endif ; AT_COMPAT
  5605                                  
  5606                                  ;-------------------------------------------------------------------------
  5607                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  5608                                  
  5609 0000E1EE E88DB4                  	call	kbc_init
  5610                                  
  5611                                  ;-------------------------------------------------------------------------
  5612                                  ; enable interrupts
  5613                                  
  5614                                  %ifdef AT_COMPAT
  5615 0000E1F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  5616 0000E1F3 E621                    	out	pic1_reg1,al
  5617                                  %ifndef PS2_MOUSE
  5618                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  5619                                  %else
  5620 0000E1F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  5621                                  %endif ; PS2_MOUSE
  5622 0000E1F7 E6A1                    	out	pic2_reg1,al
  5623                                  %else
  5624                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  5625                                  	out	pic1_reg1,al
  5626                                  %endif ; AT_COMPAT
  5627 0000E1F9 FB                      	sti
  5628                                  
  5629                                  ;-------------------------------------------------------------------------
  5630                                  ; look for video BIOS, initialize it if present
  5631                                  
  5632 0000E1FA BA00C0                  	mov	dx,0C000h
  5633 0000E1FD BB00C8                  	mov	bx,0C800h
  5634 0000E200 E833BD                  	call	extension_scan
  5635 0000E203 833E670000              	cmp	word [67h],0
  5636 0000E208 7418                    	jz	.no_video_bios
  5637 0000E20A B011                    	mov	al,e_video_bios_ok
  5638 0000E20C E680                    	out	post_reg,al
  5639 0000E20E FF1E6700                	call	far [67h]
  5640 0000E212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  5641 0000E215 8ED8                    	mov	ds,ax
  5642 0000E217 B012                    	mov	al,e_video_init_ok
  5643 0000E219 E680                    	out	post_reg,al
  5644                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  5645 0000E21B 83261000CF              	and	word [equipment_list],~equip_video
  5646 0000E220 EB14                    	jmp	.video_initialized
  5647                                  
  5648                                  .no_video_bios:
  5649 0000E222 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  5650 0000E226 80E430                  	and	ah,equip_video		; get video adapter type
  5651 0000E229 B007                    	mov	al,07h			; monochrome 80x25 mode
  5652 0000E22B 80FC30                  	cmp	ah,equip_mono		; monochrome?
  5653 0000E22E 7402                    	jz	.set_mode
  5654 0000E230 B003                    	mov	al,03h			; color 80x25 mode
  5655                                  
  5656                                  .set_mode:
  5657 0000E232 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  5658 0000E234 CD10                    	int	10h
  5659                                  
  5660                                  .video_initialized:
  5661                                  
  5662                                  ;-------------------------------------------------------------------------
  5663                                  ; print the copyright message
  5664                                  
  5665 0000E236 BE[0080]                	mov	si,msg_copyright
  5666 0000E239 E8C9BD                  	call	print
  5667                                  
  5668                                  ;-------------------------------------------------------------------------
  5669                                  ; Initialize RTC / NVRAM
  5670                                  
  5671 0000E23C E885A7                  	call	rtc_init
  5672                                  
  5673                                  ; read equipment byte from CMOS and set it in BIOS data area
  5674                                  
  5675 0000E23F BE[FB83]                	mov	si,msg_setup
  5676 0000E242 E8C0BD                  	call	print
  5677                                  
  5678                                  ;-------------------------------------------------------------------------
  5679                                  ; detect and print availability of various equipment
  5680                                  
  5681 0000E245 E80BBC                  	call	detect_cpu		; detect and print CPU type
  5682 0000E248 E88DBC                  	call	detect_fpu		; detect and print FPU presence
  5683                                  
  5684 0000E24B E853BF                  	call	print_display		; print display type
  5685 0000E24E E870BF                  	call	print_mouse		; print mouse presence
  5686                                  
  5687 0000E251 B010                    	mov	al,cmos_floppy
  5688 0000E253 E854A7                  	call	rtc_read		; floppies type to AL
  5689 0000E256 E8C7B2                  	call	print_floppy		; print floppy drive types
  5690                                  
  5691 0000E259 E855BE                  	call	detect_ram		; test RAM, get RAM size in AX
  5692                                  
  5693 0000E25C BE[C482]                	mov	si,msg_ram_total
  5694 0000E25F E8A3BD                  	call	print
  5695 0000E262 E8DEBD                  	call	print_dec
  5696 0000E265 BE[1C83]                	mov	si,msg_kib
  5697 0000E268 E89ABD                  	call	print
  5698 0000E26B E80BBE                  	call	reserve_ebda
  5699 0000E26E BE[FF82]                	mov	si,msg_ram_avail
  5700 0000E271 E891BD                  	call	print
  5701 0000E274 A11300                  	mov	ax,word [memory_size]
  5702 0000E277 E8C9BD                  	call	print_dec
  5703 0000E27A BE[1C83]                	mov	si,msg_kib
  5704 0000E27D E885BD                  	call	print
  5705                                  
  5706                                  ;-------------------------------------------------------------------------
  5707                                  ; look for BIOS extensions, initialize if found
  5708                                  
  5709 0000E280 BA00C8                  	mov	dx,0C800h
  5710 0000E283 BB00F8                  	mov	bx,0F800h
  5711                                  .ext_scan_loop:
  5712 0000E286 E8ADBC                  	call	extension_scan
  5713 0000E289 833E670000              	cmp	word [67h],0
  5714 0000E28E 7413                    	jz	.ext_scan_next
  5715 0000E290 BE[5F83]                	mov	si,msg_rom_found
  5716 0000E293 E86FBD                  	call	print
  5717 0000E296 53                      	push	bx
  5718 0000E297 52                      	push	dx
  5719 0000E298 FF1E6700                	call	far [67h]
  5720 0000E29C B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  5721 0000E29F 8ED8                    	mov	ds,ax
  5722 0000E2A1 5A                      	pop	dx
  5723 0000E2A2 5B                      	pop	bx
  5724                                  .ext_scan_next:
  5725 0000E2A3 39DA                    	cmp	dx,bx
  5726 0000E2A5 72DF                    	jb	.ext_scan_loop
  5727                                  
  5728                                  ;-------------------------------------------------------------------------
  5729                                  ; enter the setup utiltiy if F1 key was pressed
  5730                                  
  5731 0000E2A7 E8AC00                  	call	check_f1_setup
  5732                                  
  5733                                  ;-------------------------------------------------------------------------
  5734                                  ; boot the OS
  5735                                  
  5736 0000E2AA BE[8B83]                	mov	si,msg_boot
  5737 0000E2AD E855BD                  	call	print
  5738 0000E2B0 CD19                    	int	19h			; Boot the OS
  5739                                  
  5740                                  ;=========================================================================
  5741                                  ; int_02 - NMI
  5742                                  ; Note: Sergey's XT only implements IOCHK NMI, system board parity is not
  5743                                  ;	implemented
  5744                                  ;-------------------------------------------------------------------------
  5745 0000E2B2 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  5746                                  int_02:
  5747 0000E2C3 50                      	push	ax
  5748 0000E2C4 B00D                    	mov	al,0Dh & nmi_disable
  5749 0000E2C6 E8E1A6                  	call	rtc_read		; disable NMI
  5750 0000E2C9 E461                    	in	al,port_b_reg		; read Port B
  5751 0000E2CB 88C4                    	mov	ah,al
  5752 0000E2CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  5753 0000E2CF E661                    	out	port_b_reg,al
  5754 0000E2D1 A840                    	test	al,iochk_status
  5755 0000E2D3 7506                    	jnz	.iochk_nmi
  5756 0000E2D5 88E0                    	mov	al,ah
  5757 0000E2D7 E661                    	out	port_b_reg,al		; restore original bits
  5758 0000E2D9 EB24                    	jmp	.exit
  5759                                  
  5760                                  .iochk_nmi:
  5761 0000E2DB 56                      	push	si
  5762 0000E2DC BE[06E3]                	mov	si,msg_iochk_nmi
  5763 0000E2DF E823BD                  	call	print
  5764 0000E2E2 5E                      	pop	si
  5765                                  .1:
  5766 0000E2E3 B400                    	mov	ah,0h
  5767 0000E2E5 CD16                    	int	16h
  5768 0000E2E7 3C69                    	cmp	al,'i'			; exit from NMI
  5769 0000E2E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  5770 0000E2EB 3C49                    	cmp	al,'I'
  5771 0000E2ED 7410                    	je	.exit
  5772 0000E2EF 3C72                    	cmp	al,'r'
  5773 0000E2F1 7503E965FD              	je	cold_start
  5774 0000E2F6 3C52                    	cmp	al,'R'
  5775 0000E2F8 7503E95EFD              	je	cold_start
  5776 0000E2FD EBE4                    	jmp	.1
  5777                                  .exit:
  5778 0000E2FF B08D                    	mov	al,0Dh | nmi_enable
  5779 0000E301 E8A6A6                  	call	rtc_read		; enable NMI
  5780 0000E304 58                      	pop	ax
  5781 0000E305 CF                      	iret
  5782                                  
  5783                                  msg_iochk_nmi:
  5784 0000E306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  5785 0000E30F 206465746563746564-
  5786 0000E318 2E2054797065202769-
  5787 0000E321 2720746F2069676E6F-
  5788 0000E32A 726520494F43484B20-
  5789 0000E333 4E4D49732C206F7220-
  5790 0000E33C 27722720746F207265-
  5791 0000E345 626F6F742E         
  5792 0000E34A 0D0A00                  	db	0Dh, 0Ah, 00h
  5793                                  
  5794                                  ;=========================================================================
  5795                                  ; int_18 - execute ROM BASIC
  5796                                  ; Note:
  5797                                  ;	Prints an error message since we don't have ROM BASIC
  5798                                  ;-------------------------------------------------------------------------
  5799                                  int_18:
  5800 0000E34D BE[5083]                	mov	si,msg_no_basic
  5801 0000E350 E8B2BC                  	call	print
  5802                                  .1:
  5803 0000E353 F4                      	hlt
  5804 0000E354 EBFD                    	jmp	.1
  5805                                  
  5806                                  ;=========================================================================
  5807                                  ; check_f1_setup - Enters the setup utility F1 was pressed during post.
  5808                                  ;-------------------------------------------------------------------------
  5809                                  check_f1_setup:
  5810 0000E356 B401                    	mov	ah,01h
  5811 0000E358 CD16                    	int	16h
  5812 0000E35A 740E                    	jz	.no_key
  5813 0000E35C B400                    	mov	ah,00h
  5814 0000E35E CD16                    	int	16h			; read the keystroke
  5815 0000E360 3D003B                  	cmp	ax,3B00h		; F1?
  5816 0000E363 7505                    	jne	.no_key
  5817 0000E365 800E120001              	or	byte [post_flags],post_setup
  5818                                  .no_key:
  5819                                  
  5820 0000E36A F606120001              	test	byte [post_flags],post_setup
  5821 0000E36F 7403                    	jz	.no_setup
  5822 0000E371 E867A7                  	call	rtc_setup
  5823                                  
  5824                                  .no_setup:
  5825 0000E374 C3                      	ret
  5826                                  
  5827                                  ;=========================================================================
  5828                                  ; int_19 - load and execute the boot sector
  5829                                  ;-------------------------------------------------------------------------
  5830 0000E375 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  5831                                  int_19:
  5832 0000E6F2 E98FB8                  	jmp	ipl
  5833                                  
  5834                                  ;=========================================================================
  5835                                  ; configuration data table
  5836                                  ;-------------------------------------------------------------------------
  5837                                  	setloc	0E6F5h
  5838                                  config_table:
  5839 0000E6F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  5840                                  .bytes:
  5841                                  %ifdef AT_COMPAT
  5842 0000E6F7 FC                      	db	0FCh			; byte 2: model = AT
  5843 0000E6F8 00                      	db	00h			; byte 3: submodel = 0
  5844 0000E6F9 00                      	db	00h			; byte 4: release = 0
  5845 0000E6FA 70                      	db	01110000b		; byte 5: feature byte 1
  5846                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  5847                                  ;		||||||`-- bus is Micro Channel instead of ISA
  5848                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  5849                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  5850                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  5851                                  ;		||`-- real time clock installed
  5852                                  ;		|`-- 2nd interrupt controller installed
  5853                                  ;		`-- DMA channel 3 used by hard disk BIOS
  5854 0000E6FB 00                      	db	00h			; byte 6: feature byte 2
  5855 0000E6FC 00                      	db	00h			; byte 7: feature byte 3
  5856 0000E6FD 00                      	db	00h			; byte 8: feature byte 4
  5857 0000E6FE 00                      	db	00h			; byte 9: feature byte 5
  5858                                  %else
  5859                                  	db	0FEh			; byte 2: model = XT
  5860                                  	db	00h			; byte 3: submodel = 0
  5861                                  	db	00h			; byte 4: release = 0
  5862                                  	db	00000000b		; byte 5: feature byte 1
  5863                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  5864                                  ;		||||||`-- bus is Micro Channel instead of ISA
  5865                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  5866                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  5867                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  5868                                  ;		||`-- real time clock installed
  5869                                  ;		|`-- 2nd interrupt controller installed
  5870                                  ;		`-- DMA channel 3 used by hard disk BIOS
  5871                                  	db	00h			; byte 6: feature byte 2
  5872                                  	db	00h			; byte 7: feature byte 3
  5873                                  	db	00h			; byte 8: feature byte 4
  5874                                  	db	00h			; byte 9: feature byte 5
  5875                                  %endif ; AT_COMPAT
  5876                                  .size	equ	$-.bytes
  5877                                  
  5878                                  ;=========================================================================
  5879                                  ; Includes with fixed entry points (for IBM compatibility)
  5880                                  ;-------------------------------------------------------------------------
  5881                                  
  5882                                  %include	"serial.inc"		; INT 14 - BIOS Serial Communications
  5883                              <1> ;========================================================================
  5884                              <1> ; serial.inc -  BIOS Serial Port Communication Services
  5885                              <1> ;       INT 14h, functions AH=00h to AH=XXh
  5886                              <1> ;	TODO: Placeholder, needs to be implemented
  5887                              <1> ;-------------------------------------------------------------------------
  5888                              <1> ;
  5889                              <1> ; Compiles with NASM 2.07, might work with other versions
  5890                              <1> ;
  5891                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  5892                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  5893                              <1> ;
  5894                              <1> ; This program is free software: you can redistribute it and/or modify
  5895                              <1> ; it under the terms of the GNU General Public License as published by
  5896                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5897                              <1> ; (at your option) any later version.
  5898                              <1> ;
  5899                              <1> ; This program is distributed in the hope that it will be useful,
  5900                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5901                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5902                              <1> ; GNU General Public License for more details.
  5903                              <1> ;
  5904                              <1> ; You should have received a copy of the GNU General Public License
  5905                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5906                              <1> ;
  5907                              <1> ;=========================================================================
  5908                              <1> 
  5909                              <1> ;=========================================================================
  5910                              <1> ; int_14 - BIOS Serial Port Communication Services
  5911                              <1> ;-------------------------------------------------------------------------
  5912 0000E6FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  5913                              <1> int_14:
  5914 0000E729 31C0                <1> 	xor     ax,ax
  5915 0000E72B CF                  <1> 	iret
  5916                                  %include	"atkbd.inc"		; INT 16, INT 09
  5917                              <1> ;=========================================================================
  5918                              <1> ; atkbd.inc - AT keyboard support
  5919                              <1> ;       INT 16h - BIOS Keyboard Services
  5920                              <1> ;		- function AH=02h
  5921                              <1> ;		- function AH=03h
  5922                              <1> ;		- function AH=05h
  5923                              <1> ;		- function AH=12h
  5924                              <1> ;		- see scancode.inc for other (scancode related)
  5925                              <1> ;                 INT 16h functions
  5926                              <1> ;       INT 09h - IRQ1 interrupt handler
  5927                              <1> ;-------------------------------------------------------------------------
  5928                              <1> ;
  5929                              <1> ; Compiles with NASM 2.07, might work with other versions
  5930                              <1> ;
  5931                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  5932                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  5933                              <1> ;
  5934                              <1> ; This program is free software: you can redistribute it and/or modify
  5935                              <1> ; it under the terms of the GNU General Public License as published by
  5936                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5937                              <1> ; (at your option) any later version.
  5938                              <1> ;
  5939                              <1> ; This program is distributed in the hope that it will be useful,
  5940                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5941                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5942                              <1> ; GNU General Public License for more details.
  5943                              <1> ;
  5944                              <1> ; You should have received a copy of the GNU General Public License
  5945                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5946                              <1> ;
  5947                              <1> ;=========================================================================
  5948                              <1> 
  5949                              <1> ;=========================================================================
  5950                              <1> ; Scan codes and keyboard flags
  5951                              <1> ;-------------------------------------------------------------------------
  5952                              <1> 
  5953                              <1> ; scancodes for special keys
  5954                              <1> 
  5955                              <1> kbd_num_code	equ	45h
  5956                              <1> kbd_scroll_code	equ	46h
  5957                              <1> kbd_caps_code	equ	3ah
  5958                              <1> kbd_ctrl_code	equ	1dh
  5959                              <1> kbd_alt_code	equ	38h
  5960                              <1> kbd_rshift_code	equ	36h
  5961                              <1> kbd_lshift_code	equ	2ah
  5962                              <1> kbd_ins_code	equ	52h
  5963                              <1> kbd_del_code	equ	53h
  5964                              <1> 
  5965                              <1> ; Bits for the various modifier keys
  5966                              <1> 
  5967                              <1> kbd_rshft_bit	equ	1
  5968                              <1> kbd_lshft_bit	equ	2
  5969                              <1> kbd_ctrl_bit	equ	4
  5970                              <1> kbd_alt_bit	equ	8
  5971                              <1> kbd_scroll_bit	equ	10h
  5972                              <1> kbd_num_bit	equ	20h
  5973                              <1> kbd_caps_bit	equ	40h
  5974                              <1> kbd_ins_bit	equ	80h
  5975                              <1> 
  5976                              <1> ;=========================================================================
  5977                              <1> ; int_16 - BIOS keyboard functions
  5978                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  5979                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  5980                              <1> ;	conditions
  5981                              <1> ;-------------------------------------------------------------------------
  5982 0000E72C FF<rept>            <1> 	setloc	0E82Eh
  5983                              <1> int_16:
  5984 0000E82E 53                  <1> 	push	bx
  5985 0000E82F 1E                  <1> 	push	ds
  5986 0000E830 BB4000              <1> 	mov	bx,biosdseg
  5987 0000E833 8EDB                <1> 	mov	ds,bx
  5988 0000E835 80FC13              <1> 	cmp	ah,.num_func
  5989 0000E838 7331                <1> 	jae	int_16_exit
  5990 0000E83A B700                <1> 	mov	bh,0
  5991 0000E83C 88E3                <1> 	mov	bl,ah
  5992 0000E83E D1E3                <1> 	shl	bx,1
  5993 0000E840 2EFFA7[45E8]        <1>     cs	jmp	near [.dispatch+bx]
  5994                              <1> 
  5995                              <1> .dispatch:
  5996 0000E845 [C79A]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  5997 0000E847 [1C9B]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  5998 0000E849 [74E8]              <1> 	dw	int_16_fn02		; get shift status
  5999 0000E84B [79E8]              <1> 	dw	int_16_fn03		; set delays
  6000 0000E84D [6BE8]              <1> 	dw	int_16_exit		; keyclick
  6001 0000E84F [A6E8]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  6002 0000E851 [6BE8]              <1> 	dw	int_16_exit		; 06
  6003 0000E853 [6BE8]              <1> 	dw	int_16_exit		; 07
  6004 0000E855 [6BE8]              <1> 	dw	int_16_exit		; 08
  6005 0000E857 [6BE8]              <1> 	dw	int_16_exit		; 09
  6006 0000E859 [6BE8]              <1> 	dw	int_16_exit		; 0A
  6007 0000E85B [6BE8]              <1> 	dw	int_16_exit		; 0B
  6008 0000E85D [6BE8]              <1> 	dw	int_16_exit		; 0C
  6009 0000E85F [6BE8]              <1> 	dw	int_16_exit		; 0D
  6010 0000E861 [6BE8]              <1> 	dw	int_16_exit		; 0E
  6011 0000E863 [6BE8]              <1> 	dw	int_16_exit		; 0F
  6012 0000E865 [749B]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  6013 0000E867 [9B9B]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  6014 0000E869 [CFE8]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  6015                              <1> .num_func	equ	($-.dispatch)/2
  6016                              <1> 
  6017                              <1> int_16_exit:
  6018 0000E86B 1F                  <1> 	pop	ds
  6019 0000E86C 5B                  <1> 	pop	bx
  6020 0000E86D CF                  <1> 	iret
  6021                              <1> 
  6022                              <1> int_16_exitf:
  6023 0000E86E 1F                  <1> 	pop	ds
  6024 0000E86F 5B                  <1> 	pop	bx
  6025 0000E870 FB                  <1> 	sti
  6026 0000E871 CA0200              <1> 	retf	2
  6027                              <1> 
  6028                              <1> ;=========================================================================
  6029                              <1> ; int_16_fn02 - get shift flags
  6030                              <1> ; Input:
  6031                              <1> ;	AH = 02h
  6032                              <1> ; Output:
  6033                              <1> ;	AL - shift flags
  6034                              <1> ;            AL bits:
  6035                              <1> ;		7 - Insert active
  6036                              <1> ;		6 - Caps Lock active
  6037                              <1> ;		5 - Num Lock active
  6038                              <1> ;		4 - Scroll Lock active
  6039                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  6040                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  6041                              <1> ;		1 - left shift key pressed
  6042                              <1> ;		0 - right shift key pressed
  6043                              <1> ;-------------------------------------------------------------------------
  6044                              <1> int_16_fn02:
  6045 0000E874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  6046 0000E877 EBF2                <1> 	jmp	int_16_exit
  6047                              <1> 
  6048                              <1> ;=========================================================================
  6049                              <1> ; int_16_fn03 - set keyboard typematic rate
  6050                              <1> ; Input:
  6051                              <1> ;	AH = 03
  6052                              <1> ;	AL - subfunction
  6053                              <1> ;	     00 - set typematic rate to default
  6054                              <1> ;	     01 - increase initial delay
  6055                              <1> ;	     02 - slow typematic rate by 1/2
  6056                              <1> ;	     04 - turn off typematic chars
  6057                              <1> ;	     05 - set typematic rate/delay
  6058                              <1> ;	BH - repeat delay (AL=5)
  6059                              <1> ;		0 - 250ms	2 - 750ms
  6060                              <1> ;		1 - 500ms	3 - 1000ms
  6061                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  6062                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  6063                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  6064                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  6065                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  6066                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  6067                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  6068                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  6069                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  6070                              <1> ; Output:
  6071                              <1> ;	none
  6072                              <1> ;-------------------------------------------------------------------------
  6073                              <1> int_16_fn03:
  6074 0000E879 3C05                <1> 	cmp	al,05
  6075 0000E87B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  6076 0000E87D 53                  <1> 	push	bx
  6077 0000E87E 51                  <1> 	push	cx
  6078 0000E87F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  6079 0000E881 E845AD              <1> 	call	kbc_send_cmd_byte
  6080 0000E884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  6081 0000E887 B105                <1> 	mov	cl,5
  6082 0000E889 D2E7                <1> 	shl	bh,cl
  6083 0000E88B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  6084 0000E88E B0F3                <1> 	mov	al,0F3h
  6085 0000E890 E8D2AC              <1> 	call	kbc_kb_send
  6086 0000E893 88F8                <1> 	mov	al,bh
  6087 0000E895 E8CDAC              <1> 	call	kbc_kb_send
  6088 0000E898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  6089 0000E89A E82CAD              <1> 	call	kbc_send_cmd_byte
  6090 0000E89D B004                <1> 	mov	al,04h
  6091 0000E89F E8C3AC              <1> 	call	kbc_kb_send
  6092 0000E8A2 59                  <1> 	pop	cx
  6093 0000E8A3 5B                  <1> 	pop	bx
  6094                              <1> .exit:
  6095 0000E8A4 EBC5                <1> 	jmp	int_16_exit
  6096                              <1> 
  6097                              <1> ;=========================================================================
  6098                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  6099                              <1> ; Input:
  6100                              <1> ;	AH = 05h
  6101                              <1> ;	CH = BIOS scan code
  6102                              <1> ;	CL = ACII character
  6103                              <1> ; Output:
  6104                              <1> ;	AL - status
  6105                              <1> ;	     00h - success
  6106                              <1> ;	     01h - keyboard buffer full
  6107                              <1> ;-------------------------------------------------------------------------
  6108                              <1> int_16_fn05:
  6109 0000E8A6 56                  <1> 	push	si
  6110 0000E8A7 B001                <1> 	mov	al,1			; assume no space
  6111 0000E8A9 FA                  <1> 	cli				; critical section
  6112 0000E8AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  6113 0000E8AE 89DE                <1> 	mov	si,bx
  6114 0000E8B0 83C302              <1> 	add	bx,2
  6115 0000E8B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  6116 0000E8B7 7504                <1> 	jne	.1
  6117 0000E8B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  6118                              <1> .1:
  6119 0000E8BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  6120 0000E8C1 7408                <1> 	je	.no_space		; no space in buffer
  6121 0000E8C3 890C                <1> 	mov	word [si],cx
  6122 0000E8C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  6123 0000E8C9 B000                <1> 	mov	al,0			; stored successfully
  6124                              <1> .no_space:
  6125 0000E8CB FB                  <1> 	sti
  6126 0000E8CC 5E                  <1> 	pop	si
  6127 0000E8CD EB9C                <1> 	jmp	int_16_exit
  6128                              <1> 
  6129                              <1> ;=========================================================================
  6130                              <1> ; int_16_fn12 - get extended shift flags
  6131                              <1> ; Input:
  6132                              <1> ;	AH = 12h
  6133                              <1> ; Output:
  6134                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  6135                              <1> ;	AH - shift flags 2
  6136                              <1> ;            AH bits:
  6137                              <1> ;		7 - SysRq key pressed
  6138                              <1> ;		6 - Caps Lock pressed
  6139                              <1> ;		5 - Num Lock pressed
  6140                              <1> ;		4 - Scroll Lock pressed
  6141                              <1> ;		3 - right Alt key pressed
  6142                              <1> ;		2 - right Ctrl key pressed
  6143                              <1> ;		1 - left Alt key pressed
  6144                              <1> ;		0 - left Ctrl key pressed
  6145                              <1> ;-------------------------------------------------------------------------
  6146                              <1> int_16_fn12:
  6147 0000E8CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  6148 0000E8D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  6149 0000E8D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  6150 0000E8D9 7403                <1> 	je	.1
  6151 0000E8DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  6152                              <1> .1:
  6153 0000E8DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  6154 0000E8E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  6155 0000E8E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  6156 0000E8E6 08C4                <1> 	or	ah,al			; copy to AH
  6157 0000E8E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  6158 0000E8EB E97DFF              <1> 	jmp	int_16_exit
  6159                              <1> 
  6160                              <1> ;=========================================================================
  6161                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  6162                              <1> ;-------------------------------------------------------------------------
  6163 0000E8EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  6164                              <1> int_09:
  6165 0000E987 50                  <1> 	push	ax
  6166 0000E988 53                  <1> 	push	bx
  6167 0000E989 1E                  <1> 	push	ds
  6168                              <1> 
  6169 0000E98A B84000              <1> 	mov	ax,biosdseg
  6170 0000E98D 8ED8                <1> 	mov	ds,ax
  6171                              <1> 
  6172                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  6173                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  6174                              <1> 	call    kbc_send_cmd_byte
  6175                              <1> %endif
  6176 0000E98F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  6177 0000E991 FB                  <1> 	sti
  6178 0000E992 B44F                <1> 	mov	ah,4Fh
  6179 0000E994 F9                  <1> 	stc
  6180 0000E995 CD15                <1> 	int	15h			; keyboard intercept
  6181 0000E997 7203E9BC01          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  6182                              <1> 
  6183                              <1> ; check for KBC response codes
  6184                              <1> 
  6185 0000E99C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  6186 0000E99E 7503E9B501          <1> 	je      keyboard_int_exit
  6187 0000E9A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  6188 0000E9A5 7508                <1> 	jne     .2
  6189 0000E9A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  6190 0000E9AC E9A901              <1> 	jmp	keyboard_int_exit
  6191                              <1> .2:
  6192 0000E9AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  6193 0000E9B1 7508                <1> 	jne	.3
  6194 0000E9B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  6195 0000E9B8 E99D01              <1> 	jmp	keyboard_int_exit
  6196                              <1> 
  6197                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  6198                              <1> 
  6199                              <1> .3:
  6200                              <1> 
  6201                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  6202                              <1> 
  6203 0000E9BB 3CE0                <1> 	cmp	al,0e0h
  6204 0000E9BD 750D                <1> 	jne	.4
  6205 0000E9BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  6206 0000E9C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  6207 0000E9C9 E98C01              <1> 	jmp	keyboard_int_exit
  6208                              <1> .4:
  6209 0000E9CC 3CE1                <1> 	cmp	al,0e1h
  6210 0000E9CE 750D                <1> 	jne	.5
  6211 0000E9D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  6212 0000E9D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  6213 0000E9DA E97B01              <1> 	jmp	keyboard_int_exit
  6214                              <1> 
  6215                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  6216                              <1> 
  6217                              <1> .5:
  6218 0000E9DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  6219 0000E9E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  6220 0000E9E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  6221 0000E9E7 7529                <1> 	jne	.6
  6222 0000E9E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  6223 0000E9EB 750B                <1> 	jne	.check_minus
  6224 0000E9ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  6225 0000E9F3 EA[66E0]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  6226                              <1> 
  6227                              <1> .check_minus:
  6228 0000E9F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  6229 0000E9FA 7509                <1> 	jne	.check_plus
  6230                              <1> 
  6231                              <1> .turbo_off:
  6232 0000E9FC E461                <1> 	in	al,port_b_reg
  6233 0000E9FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  6234 0000EA00 E661                <1> 	out	port_b_reg,al
  6235 0000EA02 E95301              <1> 	jmp	keyboard_int_exit
  6236                              <1> 
  6237                              <1> .check_plus:
  6238 0000EA05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  6239 0000EA07 7509                <1> 	jne	.6
  6240                              <1> 
  6241                              <1> .turbo_on:
  6242 0000EA09 E461                <1> 	in	al,port_b_reg
  6243 0000EA0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  6244 0000EA0D E661                <1> 	out	port_b_reg,al
  6245 0000EA0F E94601              <1> 	jmp	keyboard_int_exit
  6246                              <1> 
  6247                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  6248                              <1> ; in the keyboard flags variables.
  6249                              <1> 
  6250                              <1> .6:
  6251 0000EA12 3C52                <1> 	cmp	al,kbd_ins_code
  6252 0000EA14 7508                <1> 	jne	.7
  6253 0000EA16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  6254 0000EA1B E9FB00              <1> 	jmp	.translate	   	; pass on INS key
  6255                              <1> 
  6256                              <1> .7:
  6257 0000EA1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  6258 0000EA20 750D                <1> 	jne     .8
  6259 0000EA22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  6260 0000EA27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  6261 0000EA2C E92401              <1> 	jmp     .no_buffer
  6262                              <1> 
  6263                              <1> ; handle the left and right Shift keys
  6264                              <1> 
  6265                              <1> .8:
  6266 0000EA2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  6267 0000EA31 7508                <1> 	jne	.9
  6268 0000EA33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  6269 0000EA38 E91801              <1> 	jmp	.no_buffer
  6270                              <1> .9:
  6271 0000EA3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  6272 0000EA3D 7508                <1> 	jne     .10
  6273 0000EA3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  6274 0000EA44 E90C01              <1> 	jmp     .no_buffer
  6275                              <1> .10:
  6276 0000EA47 3C36                <1> 	cmp	al,kbd_rshift_code
  6277 0000EA49 7508                <1> 	jne	.11
  6278 0000EA4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  6279 0000EA50 E90001              <1> 	jmp	.no_buffer
  6280                              <1> .11:
  6281 0000EA53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  6282 0000EA55 7508                <1> 	jne     .12
  6283 0000EA57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  6284 0000EA5C E9F400              <1> 	jmp	.no_buffer
  6285                              <1> 
  6286                              <1> ; handle the Alt key
  6287                              <1> 
  6288                              <1> .12:
  6289 0000EA5F 3C38                <1> 	cmp	al,kbd_alt_code
  6290 0000EA61 7508                <1> 	jne	.13
  6291 0000EA63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  6292 0000EA68 E9E800              <1> 	jmp	.no_buffer
  6293                              <1> .13:
  6294 0000EA6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  6295 0000EA6D 751C                <1> 	jne	.14
  6296 0000EA6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  6297 0000EA74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  6298 0000EA79 7503E9D500          <1> 	je	.no_buffer				; nothing there - exit
  6299 0000EA7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  6300 0000EA81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  6301 0000EA86 B400                <1> 	mov	ah,0
  6302 0000EA88 E9A700              <1> 	jmp	.put_in_buffer
  6303                              <1> 
  6304                              <1> ; handle the Ctrl key
  6305                              <1> 
  6306                              <1> .14:
  6307 0000EA8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  6308 0000EA8D 7508                <1> 	jne	.15
  6309 0000EA8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  6310 0000EA94 E9BC00              <1> 	jmp	.no_buffer
  6311                              <1> .15:
  6312 0000EA97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  6313 0000EA99 7508                <1> 	jne	.16
  6314 0000EA9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  6315 0000EAA0 E9B000              <1> 	jmp	.no_buffer
  6316                              <1> 
  6317                              <1> ; handle the Caps Lock key
  6318                              <1> 
  6319                              <1> .16:
  6320 0000EAA3 3C3A                <1> 	cmp	al,kbd_caps_code
  6321 0000EAA5 750D                <1> 	jne	.17
  6322 0000EAA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  6323 0000EAAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  6324 0000EAB1 E99F00              <1> 	jmp	.no_buffer
  6325                              <1> .17:
  6326 0000EAB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  6327 0000EAB6 7508                <1> 	jne	.18
  6328 0000EAB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  6329 0000EABD E9B400              <1> 	jmp	set_LEDs
  6330                              <1> 
  6331                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  6332                              <1> 
  6333                              <1> .18:
  6334 0000EAC0 3C46                <1> 	cmp	al,kbd_scroll_code
  6335 0000EAC2 7528                <1> 	jne	.19
  6336 0000EAC4 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  6337 0000EAC9 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  6338                              <1> 
  6339                              <1> ; handle Ctrl-Break
  6340                              <1> 
  6341 0000EACB 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  6342 0000EACF 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  6343 0000EAD3 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  6344 0000EAD7 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  6345 0000EADC CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  6346 0000EADE EB73                <1> 	jmp	.no_buffer
  6347                              <1> 
  6348                              <1> ; handle Scroll Lock
  6349                              <1> 
  6350                              <1> .scroll_lock:
  6351 0000EAE0 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  6352 0000EAE5 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  6353 0000EAEA EB67                <1> 	jmp	.no_buffer
  6354                              <1> .19:
  6355 0000EAEC 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  6356 0000EAEE 7507                <1> 	jne	.20
  6357 0000EAF0 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  6358 0000EAF5 EB7D                <1> 	jmp	set_LEDs
  6359                              <1> 
  6360                              <1> ; handle the Num Lock
  6361                              <1> 
  6362                              <1> .20:
  6363 0000EAF7 3C45                <1> 	cmp	al,kbd_num_code
  6364 0000EAF9 7513                <1> 	jne	.21
  6365 0000EAFB F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  6366 0000EB00 755E                <1> 	jnz	pause			; jump if pause
  6367 0000EB02 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  6368 0000EB07 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  6369 0000EB0C EB45                <1> 	jmp	.no_buffer
  6370                              <1> .21:
  6371 0000EB0E 3CC5                <1> 	cmp	al,kbd_num_code+80h
  6372 0000EB10 7507                <1> 	jne	.translate
  6373 0000EB12 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  6374 0000EB17 EB5B                <1> 	jmp	set_LEDs
  6375                              <1> 
  6376                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  6377                              <1> 
  6378                              <1> .translate:
  6379 0000EB19 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  6380 0000EB1E 7407                <1> 	jz	.check_release
  6381 0000EB20 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  6382 0000EB25 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  6383                              <1> .check_release:
  6384 0000EB27 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  6385 0000EB29 7528                <1> 	jnz	.no_buffer
  6386                              <1> 
  6387 0000EB2B E8E0AE              <1> 	call	scan_xlat
  6388 0000EB2E 85C0                <1> 	test	ax,ax		 	; check for bad code
  6389 0000EB30 7421                <1> 	je	.no_buffer
  6390                              <1> 
  6391                              <1> .put_in_buffer:
  6392 0000EB32 56                  <1> 	push	si			; XXX - use Int 16h/05?
  6393 0000EB33 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  6394 0000EB37 89DE                <1> 	mov	si,bx
  6395 0000EB39 83C302              <1> 	add	bx,2
  6396 0000EB3C 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  6397 0000EB40 7504                <1> 	jne	.1
  6398 0000EB42 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  6399                              <1> .1:
  6400 0000EB46 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  6401 0000EB4A 7406                <1> 	je	.no_space		; no space in buffer
  6402 0000EB4C 8904                <1> 	mov	word [si],ax
  6403 0000EB4E 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  6404                              <1> 
  6405                              <1> .no_space:
  6406 0000EB52 5E                  <1> 	pop	si
  6407                              <1> 
  6408                              <1> .no_buffer:
  6409 0000EB53 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  6410                              <1> 
  6411                              <1> keyboard_int_exit:
  6412                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  6413                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  6414                              <1> 	call	kbc_send_cmd_byte
  6415                              <1> %endif
  6416 0000EB58 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  6417 0000EB5A E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  6418                              <1> 
  6419                              <1> keyboard_int_exit1:
  6420 0000EB5C 1F                  <1> 	pop	ds
  6421 0000EB5D 5B                  <1> 	pop	bx
  6422 0000EB5E 58                  <1> 	pop	ax
  6423 0000EB5F CF                  <1> 	iret
  6424                              <1> 
  6425                              <1> pause:
  6426 0000EB60 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  6427 0000EB65 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  6428                              <1> 
  6429 0000EB67 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  6430 0000EB69 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  6431                              <1> 
  6432                              <1> .pause_loop:
  6433 0000EB6B F606180008          <1> 	test	byte [kbd_flags_2],08h
  6434 0000EB70 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  6435 0000EB72 EBE8                <1> 	jmp	keyboard_int_exit1
  6436                              <1> 
  6437                              <1> ;=========================================================================
  6438                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  6439                              <1> ; 	     variable and update LEDs on the keyboard
  6440                              <1> ;-------------------------------------------------------------------------
  6441                              <1> set_LEDs:
  6442                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  6443                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  6444                              <1> 	call	kbc_send_cmd_byte
  6445                              <1> %endif
  6446                              <1> 
  6447 0000EB74 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  6448 0000EB76 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  6449                              <1> 
  6450 0000EB78 A01700              <1> 	mov	al,byte [kbd_flags_1]
  6451 0000EB7B D0E8                <1> 	shr	al,1
  6452 0000EB7D D0E8                <1> 	shr	al,1
  6453 0000EB7F D0E8                <1> 	shr	al,1
  6454 0000EB81 D0E8                <1> 	shr	al,1
  6455 0000EB83 2407                <1> 	and	al,111b
  6456 0000EB85 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  6457 0000EB8A 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  6458 0000EB8E 88C4                <1> 	mov	ah,al			; save LED bits
  6459                              <1> 
  6460 0000EB90 B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  6461 0000EB92 E834AA              <1> 	call	kbc_send_cmd_byte
  6462                              <1> 
  6463 0000EB95 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  6464 0000EB97 E8CBA9              <1> 	call	kbc_kb_send		; send the command to the keyboard
  6465 0000EB9A 88E0                <1> 	mov	al,ah			; get parameter byte
  6466 0000EB9C E8C6A9              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  6467                              <1> 
  6468 0000EB9F B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  6469 0000EBA1 E825AA              <1> 	call	kbc_send_cmd_byte
  6470 0000EBA4 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  6471 0000EBA6 E8BCA9              <1> 	call	kbc_kb_send
  6472 0000EBA9 EBB1                <1> 	jmp	keyboard_int_exit1
  6473                              <1> 
  6474                                  %include	"floppy2.inc"		; INT 13
  6475                              <1> ;=========================================================================
  6476                              <1> ; floppy2.inc - BIOS floppy disk services
  6477                              <1> ;       INT 13h, function AH=02h
  6478                              <1> ;       INT 13h, function AH=03h
  6479                              <1> ;       INT 13h, function AH=04h
  6480                              <1> ;       INT 13h, function AH=05h
  6481                              <1> ;	- see floppy1.inc for other INT 13h functions
  6482                              <1> ;-------------------------------------------------------------------------
  6483                              <1> ;
  6484                              <1> ; Compiles with NASM 2.07, might work with other versions
  6485                              <1> ;
  6486                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  6487                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  6488                              <1> ;
  6489                              <1> ; This program is free software: you can redistribute it and/or modify
  6490                              <1> ; it under the terms of the GNU General Public License as published by
  6491                              <1> ; the Free Software Foundation, either version 3 of the License, or
  6492                              <1> ; (at your option) any later version.
  6493                              <1> ;
  6494                              <1> ; This program is distributed in the hope that it will be useful,
  6495                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6496                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6497                              <1> ; GNU General Public License for more details.
  6498                              <1> ;
  6499                              <1> ; You should have received a copy of the GNU General Public License
  6500                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  6501                              <1> ;
  6502                              <1> ;=========================================================================
  6503                              <1> 
  6504                              <1> ;-------------------------------------------------------------------------
  6505                              <1> ; offsets for registers on stack
  6506                              <1> int_13_bp	equ	0
  6507                              <1> int_13_ds	equ	int_13_bp+2
  6508                              <1> int_13_di	equ	int_13_ds+2
  6509                              <1> int_13_si	equ	int_13_di+2
  6510                              <1> int_13_dx	equ	int_13_si+2
  6511                              <1> int_13_dl	equ	int_13_dx
  6512                              <1> int_13_dh	equ	int_13_dx+1
  6513                              <1> int_13_cx	equ	int_13_dx+2
  6514                              <1> int_13_cl	equ	int_13_cx
  6515                              <1> int_13_ch	equ	int_13_cx+1
  6516                              <1> int_13_bx	equ	int_13_cx+2
  6517                              <1> int_13_bl	equ	int_13_bx
  6518                              <1> int_13_bh	equ	int_13_bx+1
  6519                              <1> int_13_ax	equ	int_13_bx+2
  6520                              <1> int_13_al	equ	int_13_ax
  6521                              <1> int_13_ah	equ	int_13_ax+1
  6522                              <1> int_13_ip	equ	int_13_ax+2
  6523                              <1> int_13_cs	equ	int_13_ip+2
  6524                              <1> int_13_flags	equ	int_13_cs+2
  6525                              <1> int_13_flags_l	equ	int_13_flags
  6526                              <1> 
  6527                              <1> ;=========================================================================
  6528                              <1> ; int_13 - BIOS floppy disk services
  6529                              <1> ; Input:
  6530                              <1> ;	AH = function
  6531                              <1> ;		00h - Reset disk system
  6532                              <1> ;		01h - Get status of last operation
  6533                              <1> ;		02h - Read disk sectors
  6534                              <1> ;		03h - Write disk sectors
  6535                              <1> ;		04h - Verify disk sectors
  6536                              <1> ;		05h - Format track
  6537                              <1> ;		08h - Get drive parameters
  6538                              <1> ;		15h - Get disk type
  6539                              <1> ;		16h - Detect disk change
  6540                              <1> ;		17h - Set disk type for format
  6541                              <1> ;		18h - Set media type for format
  6542                              <1> ; Output:
  6543                              <1> ;	- depends on function
  6544                              <1> ;	- for most functions:
  6545                              <1> ;		CF clear if successful
  6546                              <1> ;			AH = 00h - successful completion
  6547                              <1> ;		CF set on error
  6548                              <1> ;			AH = error code
  6549                              <1> ;-------------------------------------------------------------------------
  6550 0000EBAB FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  6551                              <1> int_13:
  6552 0000EC59 FB                  <1> 	sti
  6553 0000EC5A 50                  <1> 	push	ax
  6554 0000EC5B 53                  <1> 	push	bx
  6555 0000EC5C 51                  <1> 	push	cx
  6556 0000EC5D 52                  <1> 	push	dx
  6557 0000EC5E 56                  <1> 	push	si
  6558 0000EC5F 57                  <1> 	push	di
  6559 0000EC60 1E                  <1> 	push	ds
  6560 0000EC61 55                  <1> 	push	bp
  6561 0000EC62 89E5                <1> 	mov	bp,sp
  6562 0000EC64 80FC19              <1> 	cmp	ah,.num_func
  6563 0000EC67 7743                <1> 	ja	.invalid_function
  6564 0000EC69 88E0                <1> 	mov	al,ah
  6565 0000EC6B 98                  <1> 	cbw
  6566 0000EC6C 89C7                <1> 	mov	di,ax
  6567 0000EC6E D1E7                <1> 	shl	di,1
  6568 0000EC70 B84000              <1> 	mov	ax,biosdseg
  6569 0000EC73 8ED8                <1> 	mov	ds,ax
  6570 0000EC75 2EFFA5[7AEC]        <1>     cs	jmp	near [.dispatch+di]
  6571                              <1> 
  6572                              <1> .dispatch:
  6573 0000EC7A [558D]              <1> 	dw	int_13_fn00		; Reset disk system
  6574 0000EC7C [C48D]              <1> 	dw	int_13_fn01		; Get status of last operation
  6575 0000EC7E [EFEC]              <1> 	dw	int_13_fn02		; Read disk sectors
  6576 0000EC80 [EFEC]              <1> 	dw	int_13_fn03		; Write disk sectors
  6577 0000EC82 [EFEC]              <1> 	dw	int_13_fn04		; Verify disk sectors
  6578 0000EC84 [5DEE]              <1> 	dw	int_13_fn05		; Format track
  6579 0000EC86 [ACEC]              <1> 	dw	.invalid_function	; AH = 06h
  6580 0000EC88 [ACEC]              <1> 	dw	.invalid_function	; AH = 07h
  6581 0000EC8A [D08D]              <1> 	dw	int_13_fn08		; Get drive parameters
  6582 0000EC8C [ACEC]              <1> 	dw	.invalid_function	; AH = 09h
  6583 0000EC8E [ACEC]              <1> 	dw	.invalid_function	; AH = 0Ah
  6584 0000EC90 [ACEC]              <1> 	dw	.invalid_function	; AH = 0Bh
  6585 0000EC92 [ACEC]              <1> 	dw	.invalid_function	; AH = 0Ch
  6586 0000EC94 [ACEC]              <1> 	dw	.invalid_function	; AH = 0Dh
  6587 0000EC96 [ACEC]              <1> 	dw	.invalid_function	; AH = 0Eh
  6588 0000EC98 [ACEC]              <1> 	dw	.invalid_function	; AH = 0Fh
  6589 0000EC9A [ACEC]              <1> 	dw	.invalid_function	; AH = 10h
  6590 0000EC9C [ACEC]              <1> 	dw	.invalid_function	; AH = 11h
  6591 0000EC9E [ACEC]              <1> 	dw	.invalid_function	; AH = 12h
  6592 0000ECA0 [ACEC]              <1> 	dw	.invalid_function	; AH = 13h
  6593 0000ECA2 [ACEC]              <1> 	dw	.invalid_function	; AH = 14h
  6594 0000ECA4 [7D8E]              <1> 	dw	int_13_fn15		; Get disk type
  6595 0000ECA6 [9E8E]              <1> 	dw	int_13_fn16		; Detect disk change
  6596 0000ECA8 [EA8E]              <1> 	dw	int_13_fn17		; Set disk type for format
  6597 0000ECAA [558F]              <1> 	dw	int_13_fn18		; Set media type for format
  6598                              <1> .num_func	equ ($-.dispatch)/2
  6599                              <1> 
  6600                              <1> .invalid_function:
  6601 0000ECAC B401                <1> 	mov	ah,fdc_e_invalid
  6602 0000ECAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  6603 0000ECB2 F9                  <1> 	stc				; error condition
  6604 0000ECB3 EB21                <1> 	jmp	int_13_exit
  6605                              <1> 
  6606                              <1> ;-------------------------------------------------------------------------
  6607                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  6608                              <1> 
  6609                              <1> int_13_upd_exit:
  6610 0000ECB5 9C                  <1> 	pushf
  6611 0000ECB6 50                  <1> 	push	ax
  6612 0000ECB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  6613 0000ECBA 3C01                <1> 	cmp	al,1
  6614 0000ECBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  6615 0000ECBE BB9000              <1> 	mov	bx,fdc_media_state
  6616 0000ECC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  6617 0000ECC3 F60710              <1> 	test	byte [bx],fdc_m_established
  6618 0000ECC6 740C                <1> 	jz	.no_update		; skip if media type not established
  6619 0000ECC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  6620 0000ECCA 08C0                <1> 	or	al,al
  6621 0000ECCC 7402                <1> 	jz	.drive_0
  6622 0000ECCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  6623                              <1> 
  6624                              <1> .drive_0:
  6625 0000ECD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  6626                              <1> 
  6627                              <1> .no_update:
  6628 0000ECD4 58                  <1> 	pop	ax
  6629 0000ECD5 9D                  <1> 	popf
  6630                              <1> 
  6631                              <1> int_13_exit:
  6632 0000ECD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  6633 0000ECD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  6634 0000ECDC 7205                <1> 	jc	.set_error		; there is an error
  6635 0000ECDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  6636 0000ECE2 48                  <1> 	dec	ax			; clear CF in AX too
  6637                              <1> 
  6638                              <1> .set_error:
  6639 0000ECE3 094614              <1> 	or	word [bp+int_13_flags],ax
  6640 0000ECE6 5D                  <1> 	pop	bp
  6641 0000ECE7 1F                  <1> 	pop	ds
  6642 0000ECE8 5F                  <1> 	pop	di
  6643 0000ECE9 5E                  <1> 	pop	si
  6644 0000ECEA 5A                  <1> 	pop	dx
  6645 0000ECEB 59                  <1> 	pop	cx
  6646 0000ECEC 5B                  <1> 	pop	bx
  6647 0000ECED 58                  <1> 	pop	ax
  6648 0000ECEE CF                  <1> 	iret
  6649                              <1> 
  6650                              <1> ;=========================================================================
  6651                              <1> ; int_13_fn02 - Read disk sectors
  6652                              <1> ; int_13_fn03 - Write disk sectors
  6653                              <1> ; int_13_fn04 - Verify disk sectors
  6654                              <1> ; Input:
  6655                              <1> ;	AH = function
  6656                              <1> ;		02h - read
  6657                              <1> ;		03h - write
  6658                              <1> ;		04h - verify
  6659                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  6660                              <1> ;	CH = cylinder number
  6661                              <1> ;	CL = sector number
  6662                              <1> ;	DH = head number (0 or 1)
  6663                              <1> ;	DL = drive number (0 or 1)
  6664                              <1> ;	ES:BX -> data buffer
  6665                              <1> ; Output:
  6666                              <1> ;	CF clear if successful
  6667                              <1> ;		AH = 00h - successful completion
  6668                              <1> ;		AL = number of sectors transferred or verified
  6669                              <1> ;	CF set on error
  6670                              <1> ;		AH = error code
  6671                              <1> ;-------------------------------------------------------------------------
  6672                              <1> int_13_fn02:
  6673                              <1> int_13_fn03:
  6674                              <1> int_13_fn04:
  6675 0000ECEF 80FA01              <1> 	cmp	dl,1
  6676 0000ECF2 7603E94801          <1> 	ja	.invalid_drive
  6677 0000ECF7 BE9000              <1> 	mov	si,fdc_media_state
  6678 0000ECFA 52                  <1> 	push	dx
  6679 0000ECFB B600                <1> 	mov	dh,00h
  6680 0000ECFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  6681 0000ECFF 5A                  <1> 	pop	dx
  6682                              <1> 
  6683 0000ED00 E8A2A6              <1> 	call	read_cmos_type		; get drive type in AL
  6684 0000ED03 7303E93701          <1> 	jc	.invalid_drive
  6685                              <1> 
  6686 0000ED08 BF3F00              <1> 	mov	di,fdc_motor_state
  6687 0000ED0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  6688 0000ED0E 80FC03              <1> 	cmp	ah,03h			; write function
  6689 0000ED11 7503                <1> 	jne	.motor_on		; jump if not write function
  6690 0000ED13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  6691                              <1> 
  6692                              <1> .motor_on:
  6693 0000ED16 E8FDA3              <1> 	call	fdc_motor_on
  6694 0000ED19 3C01                <1> 	cmp	al,cmos_360
  6695 0000ED1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  6696 0000ED20 3C03                <1> 	cmp	al,cmos_720
  6697 0000ED22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  6698                              <1> 
  6699 0000ED27 E8A6A4              <1> 	call	fdc_disk_change
  6700 0000ED2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  6701                              <1> 
  6702 0000ED2F F60410              <1> 	test	byte [si],fdc_m_established
  6703 0000ED32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  6704                              <1> 
  6705 0000ED37 E85BA7              <1> 	call	fdc_select_rate		; select transfer rate
  6706                              <1> 	
  6707                              <1> .fdc_send_specify:
  6708 0000ED3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  6709                              <1> 					; 0BFh - specify byte 0 for 1.44M
  6710 0000ED3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  6711 0000ED40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  6712 0000ED42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  6713 0000ED44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  6714 0000ED47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  6715 0000ED49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  6716                              <1> 
  6717                              <1> .fdc_send_specify_cmd:
  6718 0000ED4B BE0200              <1> 	mov	si,2			; specify byte 1
  6719 0000ED4E B103                <1> 	mov	cl,3			; 3 bytes command
  6720 0000ED50 E823A5              <1> 	call	fdc_send_cmd
  6721 0000ED53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  6722 0000ED58 1E                  <1> 	push	ds
  6723 0000ED59 31F6                <1> 	xor	si,si
  6724 0000ED5B 8EDE                <1> 	mov	ds,si
  6725 0000ED5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  6726 0000ED61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  6727 0000ED64 B400                <1> 	mov	ah,00h
  6728 0000ED66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  6729 0000ED68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  6730 0000ED6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  6731 0000ED6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  6732 0000ED70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  6733 0000ED72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  6734                              <1> 
  6735                              <1> .calc_dma_count:
  6736 0000ED75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  6737 0000ED78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  6738 0000ED7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  6739 0000ED7D 1F                  <1> 	pop	ds
  6740 0000ED7E 48                  <1> 	dec	ax			; minus one byte
  6741 0000ED7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  6742                              <1> 
  6743 0000ED81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  6744 0000ED84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  6745 0000ED86 80FC02              <1> 	cmp	ah,02h			; read function?
  6746 0000ED89 7409                <1> 	je	.configure_dma		; jump if read function
  6747 0000ED8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  6748 0000ED8D 80FC03              <1> 	cmp	ah,03h			; write function?
  6749 0000ED90 7402                <1> 	je	.configure_dma		; jump if write function
  6750 0000ED92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  6751                              <1> 
  6752                              <1> .configure_dma:
  6753 0000ED94 E881A4              <1> 	call	fdc_configure_dma
  6754 0000ED97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  6755 0000ED9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  6756                              <1> 
  6757 0000ED9F E8BDA2              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  6758 0000EDA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  6759                              <1> 
  6760 0000EDA7 1E                  <1> 	push	ds
  6761 0000EDA8 31C0                <1> 	xor	ax,ax
  6762 0000EDAA 8ED8                <1> 	mov	ds,ax
  6763 0000EDAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  6764 0000EDB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  6765 0000EDB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  6766 0000EDB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  6767 0000EDB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  6768 0000EDBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  6769 0000EDBD 1F                  <1> 	pop	ds
  6770                              <1> 
  6771 0000EDBE BE9000              <1> 	mov	si,fdc_media_state
  6772 0000EDC1 B600                <1> 	mov	dh,00h
  6773 0000EDC3 01D6                <1> 	add	si,dx
  6774 0000EDC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  6775 0000EDC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  6776 0000EDC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  6777 0000EDCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  6778 0000EDCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  6779 0000EDD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  6780 0000EDD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  6781 0000EDD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  6782 0000EDD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  6783 0000EDDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  6784 0000EDDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  6785 0000EDDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  6786                              <1> 	
  6787                              <1> .gap_set:
  6788 0000EDE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  6789 0000EDE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  6790 0000EDE7 88F4                <1> 	mov	ah,dh			; head
  6791 0000EDE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  6792 0000EDEB D0E4                <1> 	shl	ah,1
  6793 0000EDED D0E4                <1> 	shl	ah,1
  6794 0000EDEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  6795 0000EDF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  6796 0000EDF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  6797 0000EDF7 7502                <1> 	jne	.send_command		; jump if not write 
  6798 0000EDF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  6799                              <1> 
  6800                              <1> .send_command:
  6801 0000EDFB B109                <1> 	mov	cl,9			; 9 bytes command
  6802 0000EDFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  6803 0000EE02 E871A4              <1> 	call	fdc_send_cmd
  6804 0000EE05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  6805 0000EE07 E8BDA6              <1> 	call	fdc_wait_irq
  6806 0000EE0A 7228                <1> 	jc	.error_fdc_get_result
  6807 0000EE0C B107                <1> 	mov	cl,7
  6808 0000EE0E E8CAA4              <1> 	call	fdc_get_result		; read result bytes
  6809 0000EE11 7228                <1> 	jc	.error_end_io
  6810                              <1> 
  6811 0000EE13 E81AA5              <1> 	call	fdc_get_error
  6812                              <1> 
  6813                              <1> .exit_end_io:
  6814 0000EE16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  6815                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  6816 0000EE19 E889A3              <1> 	call	fdc_end_io		; return number of last sector in BL
  6817 0000EE1C 08C0                <1> 	or	al,al
  6818 0000EE1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  6819 0000EE20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  6820 0000EE22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  6821                              <1> 
  6822                              <1> .zero_sectors:
  6823 0000EE25 08E4                <1> 	or	ah,ah
  6824 0000EE27 7401                <1> 	jz	.exit			; jump if no errors
  6825                              <1> 
  6826                              <1> .error:
  6827 0000EE29 F9                  <1> 	stc				; indicate error
  6828                              <1> 
  6829                              <1> .exit:
  6830 0000EE2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  6831 0000EE2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  6832 0000EE31 E981FE              <1> 	jmp	int_13_upd_exit
  6833                              <1> 
  6834                              <1> .error_fdc_get_result:
  6835 0000EE34 B107                <1> 	mov	cl,7
  6836 0000EE36 50                  <1> 	push	ax
  6837 0000EE37 E8A1A4              <1> 	call	fdc_get_result		; read result bytes
  6838 0000EE3A 58                  <1> 	pop	ax
  6839                              <1> 
  6840                              <1> .error_end_io:
  6841 0000EE3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  6842 0000EE3D EBD7                <1> 	jmp	.exit_end_io
  6843                              <1> 
  6844                              <1> .invalid_drive:
  6845 0000EE3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  6846 0000EE42 EBE5                <1> 	jmp	.error
  6847                              <1> 
  6848                              <1> ; 360K and 720K drives don't support change line, and only support
  6849                              <1> ; one media type - set it here
  6850                              <1> 
  6851                              <1> .set_media_360:
  6852 0000EE44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  6853 0000EE46 EB02                <1> 	jmp	.set_media
  6854                              <1> 
  6855                              <1> .set_media_720:
  6856 0000EE48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  6857                              <1> 
  6858                              <1> .set_media:
  6859 0000EE4A 8804                <1> 	mov	byte [si],al		; save media state
  6860 0000EE4C E86DA6              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  6861 0000EE4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  6862 0000EE52 E9E5FE              <1> 	jmp	.fdc_send_specify
  6863                              <1> 
  6864                              <1> ; establish media type
  6865                              <1> 
  6866                              <1> .establish_media:
  6867 0000EE55 E870A5              <1> 	call	fdc_detect_media
  6868 0000EE58 72E1                <1> 	jc	.error_end_io
  6869 0000EE5A E9DDFE              <1> 	jmp	.fdc_send_specify
  6870                              <1> 	
  6871                              <1> 
  6872                              <1> ;=========================================================================
  6873                              <1> ; int_13_fn05 - Format track
  6874                              <1> ; Input:
  6875                              <1> ;	AH = 05h
  6876                              <1> ;	CH = track number
  6877                              <1> ;	DH = head number (0 or 1)
  6878                              <1> ;	DL = drive number (0 or 1)
  6879                              <1> ;	ES:BX -> address field buffer
  6880                              <1> ; Output:
  6881                              <1> ;	CF clear if successful
  6882                              <1> ;		AH = 00h - successful completion
  6883                              <1> ;	CF set on error
  6884                              <1> ;		AH = error code 
  6885                              <1> ;-------------------------------------------------------------------------
  6886                              <1> int_13_fn05:
  6887 0000EE5D 80FA01              <1> 	cmp	dl,1
  6888 0000EE60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  6889 0000EE65 E83DA5              <1> 	call	read_cmos_type		; get drive type in AL
  6890 0000EE68 7303E99500          <1> 	jc	.invalid_drive
  6891 0000EE6D BE9000              <1> 	mov	si,fdc_media_state
  6892 0000EE70 52                  <1> 	push	dx
  6893 0000EE71 B600                <1> 	mov	dh,00h
  6894 0000EE73 01D6                <1> 	add	si,dx			; SI -> drive media state
  6895 0000EE75 5A                  <1> 	pop	dx
  6896 0000EE76 803C00              <1> 	cmp	byte [si],0
  6897 0000EE79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  6898 0000EE7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  6899 0000EE83 E890A2              <1> 	call	fdc_motor_on
  6900 0000EE86 E847A3              <1> 	call	fdc_disk_change		; read disk change line
  6901 0000EE89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  6902 0000EE8B E807A6              <1> 	call	fdc_select_rate		; select transfer rate
  6903 0000EE8E E8149F              <1> 	call	fdc_send_specify	; send FDC Specify command
  6904 0000EE91 1E                  <1> 	push	ds
  6905 0000EE92 31F6                <1> 	xor	si,si
  6906 0000EE94 8EDE                <1> 	mov	ds,si
  6907 0000EE96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  6908 0000EE9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  6909 0000EE9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  6910 0000EEA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  6911 0000EEA3 1F                  <1> 	pop	ds
  6912 0000EEA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  6913 0000EEA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  6914 0000EEA8 D1E1                <1> 	shl	cx,1
  6915 0000EEAA 49                  <1> 	dec	cx	 		; minus one byte...
  6916 0000EEAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  6917 0000EEAD E868A3              <1> 	call	fdc_configure_dma
  6918 0000EEB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  6919 0000EEB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  6920 0000EEB5 56                  <1> 	push	si
  6921 0000EEB6 E8A6A1              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  6922 0000EEB9 5E                  <1> 	pop	si
  6923 0000EEBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  6924                              <1> 
  6925 0000EEBC 88F4                <1> 	mov	ah,dh
  6926 0000EEBE D0E4                <1> 	shl	ah,1
  6927 0000EEC0 D0E4                <1> 	shl	ah,1
  6928 0000EEC2 08D4                <1> 	or	ah,dl
  6929 0000EEC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  6930                              <1> 
  6931 0000EEC6 B106                <1> 	mov	cl,6			; 6 byte command
  6932 0000EEC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  6933 0000EECD E8A6A3              <1> 	call	fdc_send_cmd
  6934 0000EED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  6935 0000EED2 E8F2A5              <1> 	call	fdc_wait_irq
  6936 0000EED5 720A                <1> 	jc	.exit_end_io
  6937 0000EED7 B107                <1> 	mov	cl,7
  6938 0000EED9 E8FFA3              <1> 	call	fdc_get_result		; read result bytes
  6939 0000EEDC 7203                <1> 	jc	.exit_end_io
  6940 0000EEDE E84FA4              <1> 	call	fdc_get_error		; get error code
  6941                              <1> 
  6942                              <1> .exit_end_io:
  6943 0000EEE1 E8C1A2              <1> 	call	fdc_end_io
  6944 0000EEE4 08E4                <1> 	or	ah,ah
  6945 0000EEE6 7401                <1> 	jz	.exit			; jump if no errors
  6946                              <1> 
  6947                              <1> .error:
  6948 0000EEE8 F9                  <1> 	stc				; indicate error
  6949                              <1> 
  6950                              <1> .exit:
  6951 0000EEE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  6952 0000EEED E9C5FD              <1> 	jmp	int_13_upd_exit
  6953                              <1> 
  6954                              <1> .error_fdc_get_result:
  6955 0000EEF0 B107                <1> 	mov	cl,7
  6956 0000EEF2 50                  <1> 	push	ax
  6957 0000EEF3 E8E5A3              <1> 	call	fdc_get_result		; read result bytes
  6958 0000EEF6 58                  <1> 	pop	ax
  6959 0000EEF7 EBE8                <1> 	jmp	.exit_end_io
  6960                              <1> 
  6961                              <1> .error_end_io:
  6962 0000EEF9 E8A9A2              <1> 	call	fdc_end_io
  6963 0000EEFC EBEA                <1> 	jmp	.error
  6964                              <1> 
  6965                              <1> .timeout:
  6966 0000EEFE B480                <1> 	mov	ah,fdc_e_timeout
  6967 0000EF00 EBE6                <1> 	jmp	.error
  6968                              <1> 
  6969                              <1> .invalid_drive:
  6970 0000EF02 B401                <1> 	mov	ah,fdc_e_invalid
  6971 0000EF04 EBE2                <1> 	jmp	.error
  6972                              <1> 
  6973                              <1> ;=========================================================================
  6974                              <1> ; int_0E - IRQ6 (FDC) service routine
  6975                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  6976                              <1> ;-------------------------------------------------------------------------
  6977 0000EF06 FF<rept>            <1> 	setloc	0EF57h
  6978                              <1> 
  6979                              <1> int_0E:
  6980 0000EF57 50                  <1> 	push	ax
  6981 0000EF58 1E                  <1> 	push	ds
  6982 0000EF59 B84000              <1> 	mov	ax,biosdseg
  6983 0000EF5C 8ED8                <1> 	mov	ds,ax
  6984 0000EF5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  6985 0000EF63 1F                  <1> 	pop	ds
  6986 0000EF64 B020                <1> 	mov	al,20h			; send EOI to PIC
  6987 0000EF66 E620                <1> 	out	pic1_reg0,al
  6988 0000EF68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  6989 0000EF6B CD15                <1> 	int	15h
  6990 0000EF6D 58                  <1> 	pop	ax
  6991 0000EF6E CF                  <1> 	iret
  6992                              <1> 
  6993                              <1> ;=========================================================================
  6994                              <1> ; Disk parameter tables in INT 1Eh format
  6995                              <1> ; Byte 0: First byte for specify command:
  6996                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  6997                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  6998                              <1> ; Byte 1: Second byte for specify command:
  6999                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  7000                              <1> ;	bit 0: non-DMA mode (always 0)
  7001                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  7002                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  7003                              <1> ; Byte 4: sectors per track
  7004                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  7005                              <1> ; Byte 6: special sector size (0FFh - not used)
  7006                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  7007                              <1> ; Byte 8: format filler byte (default 0F6h)
  7008                              <1> ; Byte 9: head settle time in milliseconds
  7009                              <1> ; Byte A: motor start time, in 1/8 seconds
  7010                              <1> ; Byte B: number of cylinders minus one
  7011                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  7012                              <1> ;-------------------------------------------------------------------------
  7013                              <1> media_360_in_360:
  7014 0000EF6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  7015 0000EF78 0F08                <1>
  7016 0000EF7A 2780                <1> 	db	27h, 80h
  7017                              <1> media_1200:
  7018 0000EF7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  7019 0000EF85 0F08                <1>
  7020 0000EF87 4F00                <1> 	db	4Fh, 00h
  7021                              <1> media_720:
  7022 0000EF89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  7023 0000EF92 0F08                <1>
  7024 0000EF94 4F80                <1> 	db	4Fh, 80h
  7025                              <1> media_1440:
  7026 0000EF96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  7027 0000EF9F 0F08                <1>
  7028 0000EFA1 4F00                <1> 	db	4Fh, 00h
  7029                              <1> media_360_in_1200:
  7030 0000EFA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  7031 0000EFAC 0F08                <1>
  7032 0000EFAE 2740                <1> 	db	27h, 40h
  7033                              <1> media_2880:
  7034 0000EFB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  7035 0000EFB9 0F08                <1>
  7036 0000EFBB 4FC0                <1> 	db	4Fh, 0C0h
  7037                              <1> 
  7038                              <1> ;=========================================================================
  7039                              <1> ; Disk parameter table for IBM compatibility
  7040                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  7041                              <1> ;-------------------------------------------------------------------------
  7042 0000EFBD FF<rept>            <1> 	setloc	0EFC7h
  7043                              <1> int_1E:
  7044 0000EFC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  7045 0000EFD0 0F08                <1>
  7046                                  %include	"printer.inc"		; INT 17
  7047                              <1> ;=========================================================================
  7048                              <1> ; printer.inc - Parallel printer support
  7049                              <1> ;       INT 17h, functions AH=00h to AH=XXh
  7050                              <1> ;	TODO: Placeholder, needs to be implemented
  7051                              <1> ;-------------------------------------------------------------------------
  7052                              <1> ;
  7053                              <1> ; Compiles with NASM 2.07, might work with other versions
  7054                              <1> ;
  7055                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  7056                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  7057                              <1> ;
  7058                              <1> ; This program is free software: you can redistribute it and/or modify
  7059                              <1> ; it under the terms of the GNU General Public License as published by
  7060                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7061                              <1> ; (at your option) any later version.
  7062                              <1> ;
  7063                              <1> ; This program is distributed in the hope that it will be useful,
  7064                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7065                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7066                              <1> ; GNU General Public License for more details.
  7067                              <1> ;
  7068                              <1> ; You should have received a copy of the GNU General Public License
  7069                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7070                              <1> ;
  7071                              <1> ;=========================================================================
  7072                              <1> 
  7073                              <1> ;=========================================================================
  7074                              <1> ; int_17  - BIOS Printer Services
  7075                              <1> ;-------------------------------------------------------------------------
  7076                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  7077                              <1> int_17:
  7078 0000EFD2 B400                <1> 	mov     ah,0
  7079 0000EFD4 CF                  <1> 	iret
  7080                                  %include	"video.inc"		; INT 10
  7081                              <1> ;=========================================================================
  7082                              <1> ; video.inc - BIOS video services
  7083                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  7084                              <1> ;-------------------------------------------------------------------------
  7085                              <1> ;
  7086                              <1> ; Compiles with NASM 2.07, might work with other versions
  7087                              <1> ;
  7088                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  7089                              <1> ;
  7090                              <1> ; This program is free software: you can redistribute it and/or modify
  7091                              <1> ; it under the terms of the GNU General Public License as published by
  7092                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7093                              <1> ; (at your option) any later version.
  7094                              <1> ;
  7095                              <1> ; This program is distributed in the hope that it will be useful,
  7096                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7097                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7098                              <1> ; GNU General Public License for more details.
  7099                              <1> ;
  7100                              <1> ; You should have received a copy of the GNU General Public License
  7101                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7102                              <1> ;
  7103                              <1> ;=========================================================================
  7104                              <1> 
  7105                              <1> ;-------------------------------------------------------------------------
  7106                              <1> ; CRTC registers
  7107                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  7108                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  7109                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  7110                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  7111                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  7112                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  7113                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  7114                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  7115                              <1> 
  7116                              <1> ;-------------------------------------------------------------------------
  7117                              <1> ; control characters
  7118                              <1> bel	equ	07h
  7119                              <1> bs	equ	08h
  7120                              <1> lf	equ	0Ah
  7121                              <1> cr	equ	0Dh
  7122                              <1> 
  7123 0000EFD5 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  7124                              <1> 
  7125                              <1> int_10_dispatch:
  7126 0000F045 [04F1]              <1> 	dw	int_10_fn00		; Set video mode
  7127 0000F047 [AFF1]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  7128 0000F049 [B9F1]              <1> 	dw	int_10_fn02		; Set cursor position
  7129 0000F04B [DCF1]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  7130 0000F04D [F0F1]              <1> 	dw	int_10_fn04		; Read light pen position
  7131 0000F04F [83F2]              <1> 	dw	int_10_fn05		; Set active display page
  7132 0000F051 [AEF2]              <1> 	dw	int_10_fn06		; Scroll up window
  7133 0000F053 [AEF2]              <1> 	dw	int_10_fn07		; Scroll down window
  7134 0000F055 [34F4]              <1> 	dw	int_10_fn08		; Read character and attribute
  7135 0000F057 [34F4]              <1> 	dw	int_10_fn09		; Write character and attribute
  7136 0000F059 [34F4]              <1> 	dw	int_10_fn0A		; Write character only
  7137 0000F05B [0FF6]              <1> 	dw	int_10_fn0B		; Set background color or palette
  7138 0000F05D [39F6]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  7139 0000F05F [71F6]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  7140 0000F061 [8FF6]              <1> 	dw	int_10_fn0E		; Teletype output
  7141 0000F063 [04F7]              <1> 	dw	int_10_fn0F		; Get current video mode
  7142                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  7143                              <1> 
  7144                              <1> 
  7145                              <1> ;-------------------------------------------------------------------------
  7146                              <1> ; offsets for registers on stack
  7147                              <1> 
  7148                              <1> int_10_ax	equ	0
  7149                              <1> int_10_al	equ	int_10_ax
  7150                              <1> int_10_ah	equ	int_10_ax+1
  7151                              <1> int_10_bx	equ	int_10_ax+2
  7152                              <1> int_10_bl	equ	int_10_bx
  7153                              <1> int_10_bh	equ	int_10_bx+1
  7154                              <1> int_10_cx	equ	int_10_bx+2
  7155                              <1> int_10_ch	equ	int_10_cx+1
  7156                              <1> int_10_dx	equ	int_10_cx+2
  7157                              <1> 
  7158                              <1> ;=========================================================================
  7159                              <1> ; int_10 - BIOS video services
  7160                              <1> ; Input:
  7161                              <1> ;	AH - Function
  7162                              <1> ;		00h - Set video mode
  7163                              <1> ;		01h - Set text mode cursor shape
  7164                              <1> ;		02h - Set cursor position
  7165                              <1> ;		03h - Get cursor position and shape
  7166                              <1> ;		04h - Read light pen position
  7167                              <1> ;		05h - Select active display page
  7168                              <1> ;		06h - Scroll up window
  7169                              <1> ;		07h - Scroll down window
  7170                              <1> ;		08h - Read character and attribute at cursor position
  7171                              <1> ;		09h - Write character and attribute at cursor position
  7172                              <1> ;		0Ah - Write character only at cursor position
  7173                              <1> ;		0Bh -
  7174                              <1> ;			BH = 00h - Set background/border color
  7175                              <1> ;			BH = 01h - Set palette
  7176                              <1> ;		0Ch - Write graphics pixel
  7177                              <1> ;		0Dh - Read graphics pixel
  7178                              <1> ;		0Eh - Teletype output
  7179                              <1> ;		0Fh - Get current video mode
  7180                              <1> ;-------------------------------------------------------------------------
  7181                              <1> 	setloc	0F065h			; int 10 Entry Point
  7182                              <1> int_10:
  7183 0000F065 FB                  <1> 	sti
  7184 0000F066 FC                  <1> 	cld				;  ...strings auto-increment
  7185 0000F067 55                  <1> 	push	bp
  7186 0000F068 06                  <1> 	push	es
  7187 0000F069 1E                  <1> 	push	ds
  7188 0000F06A 56                  <1> 	push	si
  7189 0000F06B 57                  <1> 	push	di
  7190 0000F06C 52                  <1> 	push	dx
  7191 0000F06D 51                  <1> 	push	cx
  7192 0000F06E 53                  <1> 	push	bx
  7193 0000F06F 50                  <1> 	push	ax
  7194 0000F070 BB4000              <1> 	mov	bx,biosdseg
  7195 0000F073 8EDB                <1> 	mov	ds,bx
  7196 0000F075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  7197 0000F079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  7198 0000F07C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  7199 0000F07F 7202                <1> 	jb	.color			; it is CGA
  7200 0000F081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  7201                              <1> 
  7202                              <1> .color:
  7203 0000F083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  7204 0000F085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  7205 0000F087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  7206 0000F08A 730B                <1> 	jae	.exit			; invalid function
  7207 0000F08C B700                <1> 	mov	bh,0
  7208 0000F08E 88E3                <1> 	mov	bl,ah
  7209 0000F090 D1E3                <1> 	shl	bx,1
  7210 0000F092 2EFF97[45F0]        <1>     cs	call	near [int_10_dispatch+bx]
  7211                              <1> 
  7212                              <1> .exit:
  7213 0000F097 58                  <1> 	pop	ax
  7214 0000F098 5B                  <1> 	pop	bx
  7215 0000F099 59                  <1> 	pop	cx
  7216 0000F09A 5A                  <1> 	pop	dx
  7217 0000F09B 5F                  <1> 	pop	di
  7218 0000F09C 5E                  <1> 	pop	si
  7219 0000F09D 1F                  <1> 	pop	ds
  7220 0000F09E 07                  <1> 	pop	es
  7221 0000F09F 5D                  <1> 	pop	bp
  7222 0000F0A0 CF                  <1> 	iret
  7223                              <1> 
  7224                              <1> 
  7225                              <1> ;=========================================================================
  7226                              <1> ; int_1D - Video parameters tables
  7227                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  7228                              <1> ; video mode initialization
  7229                              <1> ;-------------------------------------------------------------------------
  7230 0000F0A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  7231                              <1> int_1D:
  7232                              <1> 	; CGA test 40x25 modes
  7233 0000F0A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  7234 0000F0AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  7235                              <1> 
  7236                              <1> 	; CGA text 80x25 modes
  7237 0000F0B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  7238 0000F0BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  7239                              <1> 
  7240                              <1> 	; CGA graphics modes
  7241 0000F0C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  7242 0000F0CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  7243                              <1> 
  7244                              <1> 	; MDA text 80x25 mode
  7245 0000F0D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  7246 0000F0DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  7247                              <1> 
  7248                              <1> page_size:
  7249 0000F0E4 0008                <1> 	dw	0800h			; text 40x25 mode
  7250 0000F0E6 0010                <1> 	dw	1000h			; text 80x25 mode
  7251 0000F0E8 0040                <1> 	dw	4000h			; graphics modes
  7252 0000F0EA 0040                <1> 	dw	4000h
  7253                              <1> 
  7254                              <1> columns:
  7255 0000F0EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  7256 0000F0EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  7257 0000F0F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  7258 0000F0F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  7259                              <1> 
  7260 0000F0F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  7261                              <1> 
  7262 0000F0FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  7263                              <1> 
  7264                              <1> ;=========================================================================
  7265                              <1> ; int_10_fn00 - Set video mode
  7266                              <1> ; Input:
  7267                              <1> ;	AH = 00h
  7268                              <1> ;	AL = video mode
  7269                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  7270                              <1> ;		01h - CGA - text 40x25, 16 colors
  7271                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  7272                              <1> ;		03h - CGA - text 80x25, 16 colors
  7273                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  7274                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  7275                              <1> ;		06h - CGA - graphics 640x200, monochrome
  7276                              <1> ;		07h - MDA - text 80x25, monochrome
  7277                              <1> ;-------------------------------------------------------------------------
  7278                              <1> int_10_fn00:
  7279 0000F104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  7280 0000F107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  7281 0000F10A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  7282 0000F10D B000                <1> 	mov	al,0
  7283 0000F10F 80FB07              <1> 	cmp	bl,07h
  7284 0000F112 7206                <1> 	jb	.color			; jump if monochrome mode
  7285 0000F114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  7286 0000F116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  7287 0000F118 FEC0                <1> 	inc	al
  7288                              <1> 
  7289                              <1> .color:
  7290 0000F11A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  7291 0000F11C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  7292 0000F120 80C204              <1> 	add	dl,4
  7293 0000F123 EE                  <1> 	out	dx,al			; Reset the video
  7294 0000F124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  7295 0000F128 B700                <1> 	mov	bh,0
  7296 0000F12A 53                  <1> 	push	bx
  7297 0000F12B 06                  <1> 	push	es
  7298 0000F12C 31C0                <1> 	xor	ax,ax
  7299 0000F12E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  7300 0000F130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  7301 0000F135 2E8A9F[FCF0]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  7302 0000F13A 01DE                <1> 	add	si,bx
  7303                              <1> 
  7304 0000F13C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  7305 0000F140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  7306 0000F142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  7307                              <1> 
  7308 0000F146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  7309                              <1> 
  7310                              <1> .setup_crt_loop:
  7311 0000F149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  7312 0000F14C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  7313 0000F14F FEC4                <1> 	inc	ah			;  ...bump count
  7314 0000F151 46                  <1> 	inc	si			;  ...point to next
  7315 0000F152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  7316 0000F154 07                  <1> 	pop	es
  7317 0000F155 31FF                <1> 	xor	di,di
  7318 0000F157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  7319 0000F15A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  7320 0000F15C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  7321 0000F15F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  7322 0000F161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  7323 0000F163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  7324                              <1> 
  7325                              <1> .text_fill:
  7326 0000F166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  7327                              <1> 
  7328                              <1> .clear_screen:
  7329 0000F169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  7330                              <1> 
  7331 0000F16B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  7332 0000F16F 80C204              <1> 	add	dl,4
  7333 0000F172 5B                  <1> 	pop	bx
  7334 0000F173 2E8A87[F4F0]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  7335 0000F178 EE                  <1> 	out	dx,al			;  ...and send it
  7336 0000F179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  7337 0000F17C 42                  <1> 	inc	dx
  7338 0000F17D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  7339 0000F17F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  7340 0000F182 7502                <1> 	jnz	.set_palette
  7341 0000F184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  7342                              <1> 
  7343                              <1> .set_palette:
  7344 0000F186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  7345 0000F189 EE                  <1> 	out	dx,al			;  ...send palette
  7346                              <1> 
  7347 0000F18A 8CD8                <1> 	mov	ax,ds
  7348 0000F18C 8EC0                <1> 	mov	es,ax
  7349 0000F18E 31C0                <1> 	xor	ax,ax
  7350 0000F190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  7351 0000F193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  7352 0000F196 BF4E00              <1> 	mov	di,video_page_offt
  7353 0000F199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  7354                              <1> 
  7355 0000F19B 2E8A87[ECF0]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  7356 0000F1A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  7357 0000F1A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  7358                              <1> 					; but it means that for mode 7
  7359                              <1> 					; we'll get graphics page size?!
  7360 0000F1A6 2E8B87[E4F0]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  7361 0000F1AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  7362 0000F1AE C3                  <1> 	ret
  7363                              <1> 
  7364                              <1> ;=========================================================================
  7365                              <1> ; int_10_fn01 - Set text-mode cursor shape
  7366                              <1> ; Input:
  7367                              <1> ;	AH = 01h
  7368                              <1> ;	CH = cursor scan line start
  7369                              <1> ;	CL = cursor scan line end
  7370                              <1> ; Output:
  7371                              <1> ;	none
  7372                              <1> ;-------------------------------------------------------------------------
  7373                              <1> int_10_fn01:
  7374 0000F1AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  7375 0000F1B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  7376 0000F1B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  7377 0000F1B8 C3                  <1> 	ret
  7378                              <1> 
  7379                              <1> ;=========================================================================
  7380                              <1> ; int_10_fn02 - Set cursor position
  7381                              <1> ; Input:
  7382                              <1> ;	AH = 02h
  7383                              <1> ;	BH = page number
  7384                              <1> ;	DH = cursor row (00h is top)
  7385                              <1> ;	DL = cursor column (00h is left)
  7386                              <1> ; Output:
  7387                              <1> ;	none
  7388                              <1> ;-------------------------------------------------------------------------
  7389                              <1> int_10_fn02:
  7390 0000F1B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  7391 0000F1BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  7392 0000F1C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  7393                              <1> 
  7394                              <1> ;=========================================================================
  7395                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  7396                              <1> ;	BL = page
  7397                              <1> ;	DH = cursor row (00h is top)
  7398                              <1> ;	DL = cursor column (00h is left)
  7399                              <1> ;-------------------------------------------------------------------------
  7400                              <1> set_cur_pos:
  7401 0000F1C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  7402 0000F1C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  7403 0000F1C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  7404 0000F1CB D1E8                <1> 	shr	ax,1
  7405 0000F1CD 89C1                <1> 	mov	cx,ax
  7406 0000F1CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  7407 0000F1D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  7408                              <1> bios_set_cur_pos:
  7409 0000F1D4 B700                <1> 	mov	bh,0
  7410 0000F1D6 D0E3                <1> 	shl	bl,1			; index to words table
  7411 0000F1D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  7412 0000F1DB C3                  <1> 	ret
  7413                              <1> 
  7414                              <1> ;=========================================================================
  7415                              <1> ; int_10_fn03 - Get cursor position and shape
  7416                              <1> ; Input:
  7417                              <1> ;	AH = 03h
  7418                              <1> ;	BH = page number
  7419                              <1> ; Output:
  7420                              <1> ;	CH = cursor start scan line
  7421                              <1> ;	CL = cursor end scan line
  7422                              <1> ;	DH = cursor row (00h is top)
  7423                              <1> ;	DL = cursor column (00h is left)
  7424                              <1> ;-------------------------------------------------------------------------
  7425                              <1> int_10_fn03:
  7426 0000F1DC B700                <1> 	mov	bh,0
  7427 0000F1DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  7428 0000F1E1 D0E3                <1> 	shl	bl,1
  7429 0000F1E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  7430 0000F1E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  7431 0000F1E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  7432 0000F1EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  7433 0000F1EF C3                  <1> 	ret
  7434                              <1> 
  7435                              <1> ;=========================================================================
  7436                              <1> ; int_10_fn04 - Read light pen position
  7437                              <1> ; Input:
  7438                              <1> ;	AH = 04h
  7439                              <1> ; Output:
  7440                              <1> ;	AH - light pen trigger flag
  7441                              <1> ;		00h not down/triggered
  7442                              <1> ;		01h down/triggered
  7443                              <1> ;	If light pen is triggered:
  7444                              <1> ;		DH = character row
  7445                              <1> ;		DL = character column
  7446                              <1> ;		CH = pixel row
  7447                              <1> ;		BX = pixel column
  7448                              <1> ;-------------------------------------------------------------------------
  7449                              <1> int_10_fn04:
  7450 0000F1F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  7451 0000F1F4 8B166300            <1> 	mov	dx,word [video_port]
  7452 0000F1F8 80C206              <1> 	add	dl,6			; CRTC status register
  7453 0000F1FB EC                  <1> 	in	al,dx			; read it
  7454 0000F1FC A804                <1> 	test	al,4			; test light pen switch bit
  7455 0000F1FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  7456 0000F200 A802                <1> 	test	al,2			; test light pen tigger bit
  7457 0000F202 7501                <1> 	jnz	.read_pen		; continue if triggered
  7458 0000F204 C3                  <1> 	ret				; not triggered - return
  7459                              <1> 
  7460                              <1> .read_pen:
  7461 0000F205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  7462 0000F209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  7463 0000F20B EE                  <1> 	out	dx,al			; select it
  7464 0000F20C 42                  <1> 	inc	dx			; CRTC data register
  7465 0000F20D EC                  <1> 	in	al,dx			; read high byte of pen position
  7466 0000F20E 88C4                <1> 	mov	ah,al
  7467 0000F210 4A                  <1> 	dec	dx			; CRTC index register
  7468 0000F211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  7469 0000F213 EE                  <1> 	out	dx,al			; select it
  7470 0000F214 42                  <1> 	inc	dx			; CRTC data register
  7471 0000F215 EC                  <1> 	in	al,dx			; read low byte of pen position
  7472                              <1> 
  7473 0000F216 B700                <1> 	mov	bh,0
  7474 0000F218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  7475 0000F21C 2E8A9F[7BF2]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  7476 0000F221 29D8                <1> 	sub	ax,bx
  7477 0000F223 7902                <1> 	jns	.1
  7478 0000F225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  7479                              <1> 
  7480                              <1> .1:
  7481 0000F227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  7482 0000F22A 7325                <1> 	jnb	.text			; calculate character position if text
  7483 0000F22C B228                <1> 	mov	dl,40			; divide by 40
  7484 0000F22E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  7485 0000F230 B700                <1> 	mov	bh,0
  7486 0000F232 88E3                <1> 	mov	bl,ah
  7487 0000F234 B103                <1> 	mov	cl,3
  7488 0000F236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  7489 0000F238 88C5                <1> 	mov	ch,al
  7490 0000F23A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  7491 0000F23C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  7492 0000F23E 88C6                <1> 	mov	dh,al
  7493 0000F240 D0EE                <1> 	shr	dh,1
  7494 0000F242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  7495 0000F244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  7496 0000F249 751A                <1> 	jnz	.exit
  7497 0000F24B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  7498 0000F24D D0E2                <1> 	shl	dl,1			; same or character column
  7499 0000F24F EB14                <1> 	jmp	.exit
  7500                              <1> 
  7501                              <1> .text:
  7502 0000F251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  7503 0000F255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  7504 0000F257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  7505 0000F259 B103                <1> 	mov	cl,3
  7506 0000F25B D2E4                <1> 	shl	ah,cl
  7507 0000F25D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  7508 0000F25F B700                <1> 	mov	bh,0
  7509 0000F261 88C3                <1> 	mov	bl,al
  7510 0000F263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  7511                              <1> 
  7512                              <1> .exit:
  7513 0000F265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  7514 0000F269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  7515 0000F26C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  7516 0000F26F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  7517                              <1> 
  7518                              <1> .reset_pen:
  7519 0000F272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  7520 0000F276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  7521 0000F279 EE                  <1> 	out	dx,al			; reset it
  7522 0000F27A C3                  <1> 	ret
  7523                              <1> 
  7524                              <1> .correction:
  7525 0000F27B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  7526                              <1> 
  7527                              <1> ;=========================================================================
  7528                              <1> ; int_10_fn05 - Select active display page
  7529                              <1> ; Input:
  7530                              <1> ;	AH = 05h
  7531                              <1> ;	AL - new page number (00h is the first page)
  7532                              <1> ; Output:
  7533                              <1> ;	none
  7534                              <1> ;-------------------------------------------------------------------------
  7535                              <1> int_10_fn05:
  7536 0000F283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  7537 0000F286 88C3                <1> 	mov	bl,al			; also copy it to BL
  7538 0000F288 B400                <1> 	mov	ah,0
  7539 0000F28A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  7540 0000F28E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  7541 0000F291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  7542 0000F293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  7543 0000F295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  7544 0000F297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  7545                              <1> 
  7546 0000F29A B700                <1> 	mov	bh,0
  7547 0000F29C D1E3                <1> 	shl	bx,1
  7548 0000F29E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  7549 0000F2A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  7550 0000F2A4 D1E8                <1> 	shr	ax,1
  7551 0000F2A6 01C1                <1> 	add	cx,ax			; add to the page offset
  7552 0000F2A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  7553 0000F2AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  7554 0000F2AD C3                  <1> 	ret
  7555                              <1> 
  7556                              <1> ;=========================================================================
  7557                              <1> ; int_10_fn06 - scroll up window
  7558                              <1> ; int_10_fn07 - scroll down window
  7559                              <1> ; Input:
  7560                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  7561                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  7562                              <1> ;	BH = attribute used to write blank rows at bottom of window
  7563                              <1> ;	CH,CL = row,column of window's upper left corner
  7564                              <1> ;	DH,DL = row,column of window's lower right corner
  7565                              <1> ; Output:
  7566                              <1> ;	none
  7567                              <1> ; TODO:
  7568                              <1> ;	optimize graphics fill
  7569                              <1> ;-------------------------------------------------------------------------
  7570                              <1> int_10_fn06:
  7571                              <1> int_10_fn07:
  7572 0000F2AE E86604              <1> 	call	vid_check_mode
  7573 0000F2B1 7303E9D900          <1> 	jb	.graphics_scroll
  7574                              <1> 
  7575 0000F2B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  7576 0000F2B8 803E490002          <1> 	cmp	byte [video_mode],2
  7577 0000F2BD 720A                <1> 	jb	.no_snow
  7578 0000F2BF 803E490003          <1> 	cmp	byte [video_mode],3
  7579 0000F2C4 7703                <1> 	ja	.no_snow
  7580 0000F2C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  7581                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  7582                              <1> .no_snow:
  7583 0000F2C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  7584 0000F2CC 50                  <1> 	push	ax
  7585 0000F2CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  7586 0000F2D1 7403                <1> 	jz	.1			; jump if scroll down
  7587 0000F2D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  7588                              <1> 
  7589                              <1> .1:
  7590 0000F2D6 E89804              <1> 	call	vid_position_to_offset
  7591 0000F2D9 03064E00            <1> 	add	ax,word [video_page_offt]
  7592 0000F2DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  7593                              <1> 
  7594                              <1> ; calculate scroll window size (DX)
  7595                              <1> 
  7596 0000F2DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  7597 0000F2E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  7598 0000F2E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  7599                              <1> 
  7600                              <1> ; calculate offset between the source and the destination (AX)
  7601                              <1> 
  7602 0000F2E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  7603 0000F2EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  7604 0000F2ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  7605 0000F2F0 52                  <1> 	push    dx
  7606 0000F2F1 B400                <1>         mov     ah,0
  7607 0000F2F3 F7E3                <1>         mul     bx
  7608 0000F2F5 5A                  <1>         pop     dx
  7609                              <1> 
  7610 0000F2F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  7611 0000F2F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  7612 0000F2FA 1E                  <1> 	push	ds
  7613 0000F2FB 8CC1                <1> 	mov	cx,es
  7614 0000F2FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  7615 0000F2FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  7616 0000F303 7405                <1> 	jz	.2			; jump if scroll up
  7617 0000F305 F7D8                <1> 	neg	ax			; negate offset
  7618 0000F307 F7DB                <1> 	neg	bx			; negate distance
  7619 0000F309 FD                  <1> 	std				; copy backwards
  7620                              <1> 
  7621                              <1> .2:
  7622 0000F30A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  7623 0000F30D 08C9                <1> 	or	cl,cl
  7624 0000F30F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  7625 0000F311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  7626 0000F312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  7627 0000F314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  7628                              <1> 
  7629 0000F316 09DB                <1> 	or	bx,bx
  7630 0000F318 7434                <1> 	jz	.text_full_row_scroll
  7631                              <1> 
  7632                              <1> .text_scroll_loop:
  7633 0000F31A B500                <1> 	mov	ch,0
  7634 0000F31C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  7635                              <1> 
  7636 0000F31E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  7637 0000F320 7303                <1> 	jnc	.text_scroll_no_retrace
  7638 0000F322 E85800              <1> 	call	.retrace_wait
  7639                              <1> 
  7640                              <1> .text_scroll_no_retrace:
  7641 0000F325 F3A5                <1> 	repz	movsw			; copy one row
  7642                              <1> 
  7643                              <1> ;.text_scroll_next_row:
  7644 0000F327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  7645 0000F329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  7646 0000F32B FECE                <1> 	dec	dh			; decrement row counter
  7647 0000F32D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  7648                              <1> 
  7649                              <1> .text_fill:
  7650 0000F32F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  7651 0000F332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  7652                              <1> 
  7653                              <1> .text_fill_only:
  7654 0000F334 B500                <1> 	mov	ch,0
  7655 0000F336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  7656 0000F339 B020                <1> 	mov	al,' '			; AL = blank character
  7657                              <1> 
  7658                              <1> .text_fill_loop:
  7659 0000F33B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  7660 0000F33D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  7661 0000F33F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  7662 0000F341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  7663                              <1> 
  7664                              <1> .text_fill_no_retrace:
  7665 0000F344 F3AB                <1> 	repz	stosw			; fill one row
  7666 0000F346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  7667 0000F348 FECE                <1> 	dec	dh			; decrement row counter
  7668 0000F34A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  7669                              <1> 
  7670 0000F34C 1F                  <1> 	pop	ds
  7671 0000F34D C3                  <1> 	ret
  7672                              <1> 
  7673                              <1> .text_full_row_scroll:
  7674 0000F34E 09C0                <1> 	or	ax,ax
  7675 0000F350 741F                <1> 	jz	.text_full_row_no_snow
  7676 0000F352 50                  <1> 	push	ax
  7677 0000F353 88D0                <1> 	mov	al,dl
  7678 0000F355 F6E6                <1> 	mul	dh
  7679                              <1> 
  7680                              <1> .text_full_row_loop:
  7681 0000F357 B9F000              <1> 	mov	cx,240
  7682 0000F35A 39C8                <1> 	cmp	ax,cx
  7683 0000F35C 7705                <1> 	ja	.copy_chunk
  7684 0000F35E 91                  <1> 	xchg	ax,cx
  7685 0000F35F 31C0                <1> 	xor	ax,ax
  7686 0000F361 EB02                <1> 	jmp	.do_copy
  7687                              <1> 
  7688                              <1> .copy_chunk:
  7689 0000F363 29C8                <1> 	sub	ax,cx
  7690                              <1> 
  7691                              <1> .do_copy:
  7692 0000F365 E81500              <1> 	call	.retrace_wait
  7693 0000F368 F3A5                <1> 	rep	movsw
  7694 0000F36A 09C0                <1> 	or	ax,ax
  7695 0000F36C 75E9                <1> 	jnz	.text_full_row_loop
  7696 0000F36E 58                  <1> 	pop	ax
  7697 0000F36F EBBE                <1> 	jmp	.text_fill
  7698                              <1> 
  7699                              <1> .text_full_row_no_snow:
  7700 0000F371 50                  <1> 	push	ax
  7701 0000F372 88D0                <1> 	mov	al,dl
  7702 0000F374 F6E6                <1> 	mul	dh
  7703 0000F376 89C1                <1> 	mov	cx,ax
  7704 0000F378 F3A5                <1> 	rep	movsw
  7705 0000F37A 58                  <1> 	pop	ax
  7706 0000F37B EBB2                <1> 	jmp	.text_fill
  7707                              <1> 
  7708                              <1> ;-------------------------------------------------------------------------
  7709                              <1> ; .retrace_wait - next till the next vertical retrace
  7710                              <1> 
  7711                              <1> .retrace_wait:
  7712 0000F37D 50                  <1> 	push	ax
  7713 0000F37E 52                  <1> 	push	dx
  7714 0000F37F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  7715                              <1> 
  7716                              <1> .retrace_wait_not_set:
  7717 0000F382 EC                  <1> 	in	al,dx
  7718 0000F383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  7719 0000F385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  7720                              <1> 
  7721                              <1> .retrace_wait_set:
  7722 0000F387 EC                  <1> 	in	al,dx
  7723 0000F388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  7724 0000F38A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  7725 0000F38C 5A                  <1> 	pop	dx
  7726 0000F38D 58                  <1> 	pop	ax
  7727                              <1> 
  7728                              <1> .retrace_exit:
  7729 0000F38E C3                  <1> 	ret
  7730                              <1> 
  7731                              <1> ;-------------------------------------------------------------------------
  7732                              <1> ; .graphics_scroll - scroll for graphics modes
  7733                              <1> 
  7734                              <1> .graphics_scroll:
  7735 0000F38F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  7736 0000F392 50                  <1> 	push	ax
  7737 0000F393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  7738 0000F397 7403                <1> 	jz	.3			; jump if scroll down
  7739 0000F399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  7740                              <1> 
  7741                              <1> .3:
  7742 0000F39C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  7743 0000F39F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  7744                              <1> 
  7745                              <1> ; calculate scroll windows size (DX)
  7746                              <1> 
  7747 0000F3A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  7748 0000F3A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  7749 0000F3A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  7750 0000F3A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  7751 0000F3AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  7752 0000F3AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  7753 0000F3B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  7754 0000F3B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  7755 0000F3B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  7756 0000F3B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  7757 0000F3BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  7758 0000F3BD 7509                <1> 	jnz	.5			; jump if scroll down
  7759 0000F3BF 47                  <1> 	inc	di			; scroll up - adjust source address
  7760                              <1> 
  7761                              <1> .4:
  7762 0000F3C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  7763 0000F3C2 7504                <1> 	jnz	.5			; jump if not scroll down
  7764 0000F3C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  7765                              <1> 					;   for copying backwards
  7766                              <1> 
  7767                              <1> .5:
  7768 0000F3C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  7769 0000F3CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  7770 0000F3CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  7771 0000F3CF 53                  <1> 	push	bx
  7772 0000F3D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  7773 0000F3D2 B050                <1> 	mov	al,50h
  7774 0000F3D4 F6E3                <1> 	mul	bl
  7775 0000F3D6 BBB01F              <1> 	mov	bx,1FB0h
  7776 0000F3D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  7777 0000F3DD 7406                <1> 	jz	.6			; jump if scroll up
  7778 0000F3DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  7779 0000F3E1 BB5020              <1> 	mov	bx,2050h
  7780 0000F3E4 FD                  <1> 	std				; copy backwards
  7781                              <1> 
  7782                              <1> .6:
  7783 0000F3E5 89FE                <1> 	mov	si,di
  7784 0000F3E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  7785 0000F3E9 58                  <1> 	pop	ax
  7786 0000F3EA 8CC1                <1> 	mov	cx,es
  7787 0000F3EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  7788 0000F3EE 08C0                <1> 	or	al,al
  7789 0000F3F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  7790 0000F3F2 50                  <1> 	push	ax
  7791                              <1> 
  7792                              <1> .graphics_scroll_loop:
  7793 0000F3F3 B500                <1> 	mov	ch,0
  7794 0000F3F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  7795 0000F3F7 56                  <1> 	push	si
  7796 0000F3F8 57                  <1> 	push	di
  7797 0000F3F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  7798 0000F3FB 5F                  <1> 	pop	di
  7799 0000F3FC 5E                  <1> 	pop	si
  7800 0000F3FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  7801 0000F401 81C70020            <1> 	add	di,2000h
  7802 0000F405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  7803 0000F407 56                  <1> 	push	si
  7804 0000F408 57                  <1> 	push	di
  7805 0000F409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  7806 0000F40B 5F                  <1> 	pop	di
  7807 0000F40C 5E                  <1> 	pop	si
  7808 0000F40D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  7809 0000F40F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  7810 0000F411 FECE                <1> 	dec	dh			; decrement row counter
  7811 0000F413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  7812                              <1> 
  7813 0000F415 58                  <1> 	pop	ax
  7814 0000F416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  7815                              <1> 
  7816                              <1> .graphics_fill:
  7817 0000F418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  7818 0000F41B B500                <1> 	mov	ch,0
  7819                              <1> 
  7820                              <1> .graphics_fill_loop:
  7821 0000F41D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  7822 0000F41F 57                  <1> 	push	di
  7823 0000F420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  7824 0000F422 5F                  <1> 	pop	di
  7825 0000F423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  7826 0000F427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  7827 0000F429 57                  <1> 	push	di
  7828 0000F42A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  7829 0000F42C 5F                  <1> 	pop	di
  7830 0000F42D 29DF                <1> 	sub	di,bx
  7831 0000F42F FECE                <1> 	dec	dh			; decrement row counter
  7832 0000F431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  7833 0000F433 C3                  <1> 	ret
  7834                              <1> 
  7835                              <1> ;=========================================================================
  7836                              <1> ; int_10_fn08 - Read character and attribute
  7837                              <1> ; Input:
  7838                              <1> ;	AH = 08h
  7839                              <1> ; Output:
  7840                              <1> ;	AL - character read
  7841                              <1> ;	BH - video attribute (text modes only)
  7842                              <1> ; int_10_fn09 - Write character and attribute
  7843                              <1> ; Input:
  7844                              <1> ;	AH = 09h
  7845                              <1> ;	AL - character to write
  7846                              <1> ;	BH - page number
  7847                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  7848                              <1> ;	CX - number of times to write character
  7849                              <1> ; Output:
  7850                              <1> ;	none
  7851                              <1> ; int_10_fn0A - Write character only
  7852                              <1> ; Input:
  7853                              <1> ;	AH = 0Ah
  7854                              <1> ;	AL - character to write
  7855                              <1> ;	BH - page number
  7856                              <1> ;	CX - repeat count
  7857                              <1> ; Output:
  7858                              <1> ;	none
  7859                              <1> ;-------------------------------------------------------------------------
  7860                              <1> int_10_fn08:
  7861                              <1> int_10_fn09:
  7862                              <1> int_10_fn0A:
  7863 0000F434 E8E002              <1> 	call	vid_check_mode
  7864 0000F437 7277                <1> 	jb	.graphics		; jump if graphics mode
  7865 0000F439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  7866 0000F43C B700                <1> 	mov	bh,0
  7867 0000F43E 53                  <1> 	push	bx
  7868 0000F43F E82803              <1> 	call	vid_current_offset
  7869 0000F442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  7870 0000F444 58                  <1> 	pop	ax			; AX = page number
  7871 0000F445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  7872 0000F449 01C7                <1> 	add	di,ax			; DI = character offset
  7873 0000F44B 89FE                <1> 	mov	si,di			; SI = character offset
  7874 0000F44D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  7875 0000F451 83C206              <1> 	add	dx,6			; DX = CGA status register
  7876 0000F454 1E                  <1> 	push	ds
  7877 0000F455 8CC3                <1> 	mov	bx,es
  7878 0000F457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  7879 0000F459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  7880 0000F45C 3C08                <1> 	cmp	al,08h			; check for read character function
  7881 0000F45E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  7882                              <1> 
  7883                              <1> .read_retrace_wait:
  7884 0000F460 EC                  <1> 	in	al,dx
  7885 0000F461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  7886 0000F463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  7887 0000F465 FA                  <1> 	cli
  7888                              <1> 
  7889                              <1> .read_no_retrace_wait:
  7890 0000F466 EC                  <1> 	in	al,dx
  7891 0000F467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  7892 0000F469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  7893                              <1> 
  7894 0000F46B AD                  <1> 	lodsw				; read character and attribute
  7895 0000F46C FB                  <1> 	sti
  7896 0000F46D 1F                  <1> 	pop	ds
  7897 0000F46E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  7898 0000F471 C3                  <1> 	ret
  7899                              <1> 
  7900                              <1> .text_write:
  7901 0000F472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  7902 0000F475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  7903 0000F478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  7904 0000F47B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  7905 0000F47D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  7906                              <1> 
  7907                              <1> .write_char_retrace:
  7908 0000F47F EC                  <1> 	in	al,dx
  7909 0000F480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  7910 0000F482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  7911                              <1> 
  7912                              <1> .write_retrace_wait1:
  7913 0000F484 EC                  <1> 	in	al,dx
  7914 0000F485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  7915 0000F487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  7916 0000F489 FA                  <1> 	cli
  7917                              <1> 
  7918                              <1> .write_no_retrace_wait1:
  7919 0000F48A EC                  <1> 	in	al,dx
  7920 0000F48B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  7921 0000F48D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  7922                              <1> 
  7923                              <1> .do_write_char_attr:
  7924 0000F48F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  7925 0000F491 AB                  <1> 	stosw				; write it to video memory
  7926 0000F492 FB                  <1> 	sti
  7927 0000F493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  7928 0000F495 1F                  <1> 	pop	ds
  7929 0000F496 C3                  <1> 	ret
  7930                              <1> 
  7931                              <1> .text_write_char_only:
  7932 0000F497 EC                  <1> 	in	al,dx
  7933 0000F498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  7934 0000F49A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  7935                              <1> 
  7936                              <1> .write_retrace_wait2:
  7937 0000F49C EC                  <1> 	in	al,dx
  7938 0000F49D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  7939 0000F49F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  7940 0000F4A1 FA                  <1> 	cli
  7941                              <1> 
  7942                              <1> .write_no_retrace_wait2:
  7943 0000F4A2 EC                  <1> 	in	al,dx
  7944 0000F4A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  7945 0000F4A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  7946                              <1> 
  7947                              <1> .do_write_char_only:
  7948 0000F4A7 88D8                <1> 	mov	al,bl			; AL = character to write
  7949 0000F4A9 AA                  <1> 	stosb				; write it to video memory
  7950 0000F4AA FB                  <1> 	sti
  7951 0000F4AB 47                  <1> 	inc	di			; skip attribute
  7952 0000F4AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  7953 0000F4AE 1F                  <1> 	pop	ds
  7954 0000F4AF C3                  <1> 	ret
  7955                              <1> 
  7956                              <1> .graphics:
  7957 0000F4B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  7958 0000F4B4 7503E9B300          <1> 	jz	.graphics_read
  7959                              <1> 
  7960 0000F4B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  7961 0000F4BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  7962 0000F4BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  7963 0000F4C1 1E                  <1> 	push	ds
  7964 0000F4C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  7965 0000F4C5 B400                <1> 	mov	ah,0
  7966 0000F4C7 08C0                <1> 	or	al,al			; Is it user character set?
  7967 0000F4C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  7968 0000F4CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  7969 0000F4CD BE[6EFA]            <1> 	mov	si,gfx_font		; load graphics font offset
  7970 0000F4D0 EB0C                <1> 	jmp	.CG9_03
  7971                              <1> 
  7972                              <1> .CG9_02:
  7973 0000F4D2 247F                <1> 	and	al,7Fh			; Origin to zero
  7974 0000F4D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  7975 0000F4D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  7976 0000F4D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  7977 0000F4DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  7978                              <1> 
  7979                              <1> .CG9_03:
  7980 0000F4DE 1F                  <1> 	pop	ds			; Restore data segment
  7981 0000F4DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  7982 0000F4E1 D3E0                <1> 	shl	ax,cl
  7983 0000F4E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  7984 0000F4E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  7985 0000F4E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  7986 0000F4ED 1E                  <1> 	push	ds
  7987 0000F4EE 8EDA                <1> 	mov	ds,dx
  7988 0000F4F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  7989 0000F4F2 D1E7                <1> 	shl	di,1
  7990 0000F4F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  7991 0000F4F7 83E003              <1> 	and	ax,3
  7992 0000F4FA BB5555              <1> 	mov	bx,5555h
  7993 0000F4FD F7E3                <1> 	mul	bx
  7994 0000F4FF 89C2                <1> 	mov	dx,ax
  7995 0000F501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  7996                              <1> 
  7997                              <1> .CG9_04:
  7998 0000F504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  7999 0000F506 57                  <1> 	push	di
  8000 0000F507 56                  <1> 	push	si
  8001                              <1> 
  8002                              <1> .CG9_05:
  8003 0000F508 AC                  <1> 	lodsb				; Read the screen
  8004 0000F509 51                  <1> 	push	cx
  8005 0000F50A 53                  <1> 	push	bx
  8006 0000F50B 31DB                <1> 	xor	bx,bx
  8007 0000F50D B90800              <1> 	mov	cx,8
  8008                              <1> 
  8009                              <1> .CG9_06:
  8010 0000F510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  8011 0000F512 D1DB                <1> 	rcr	bx,1
  8012 0000F514 D1FB                <1> 	sar	bx,1
  8013 0000F516 E2F8                <1> 	loop	.CG9_06
  8014                              <1> 
  8015 0000F518 89D8                <1> 	mov	ax,bx			; Result into ax
  8016 0000F51A 5B                  <1> 	pop	bx
  8017 0000F51B 59                  <1> 	pop	cx
  8018 0000F51C 21D0                <1> 	and	ax,dx
  8019 0000F51E 86E0                <1> 	xchg	ah,al
  8020 0000F520 08DB                <1> 	or	bl,bl
  8021 0000F522 7903                <1> 	jns	.CG9_07
  8022 0000F524 263305              <1>     es	xor	ax,word [di]
  8023                              <1> 
  8024                              <1> .CG9_07:
  8025 0000F527 268905              <1>     es	mov	word [di],ax		; Write new word
  8026 0000F52A 81F70020            <1> 	xor	di,2000h
  8027 0000F52E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  8028 0000F532 7503                <1> 	jnz	.CG9_08			;  ...nope
  8029 0000F534 83C750              <1> 	add	di,50h			; Else advance character
  8030                              <1> 
  8031                              <1> .CG9_08:
  8032 0000F537 FECF                <1> 	dec	bh			; Show another char written
  8033 0000F539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  8034 0000F53B 5E                  <1> 	pop	si
  8035 0000F53C 5F                  <1> 	pop	di
  8036 0000F53D 47                  <1> 	inc	di
  8037 0000F53E 47                  <1> 	inc	di
  8038 0000F53F E2C3                <1> 	loop	.CG9_04
  8039 0000F541 1F                  <1> 	pop	ds
  8040 0000F542 C3                  <1> 	ret
  8041                              <1> 
  8042                              <1> .CG8_02:
  8043 0000F543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  8044 0000F546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  8045                              <1> 
  8046                              <1> .CG8_03:
  8047 0000F549 B708                <1> 	mov	bh,8			; Pixel count to write
  8048 0000F54B 57                  <1> 	push	di
  8049 0000F54C 56                  <1> 	push	si
  8050                              <1> 
  8051                              <1> .CG8_04:
  8052 0000F54D AC                  <1> 	lodsb				; Read from one plane
  8053 0000F54E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  8054 0000F550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  8055 0000F552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  8056                              <1> 
  8057                              <1> .CG8_05:
  8058 0000F555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  8059 0000F558 31D7                <1> 	xor	di,dx			;  ...get other plane
  8060 0000F55A 85D7                <1> 	test	di,dx			; Done both planes?
  8061 0000F55C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  8062 0000F55E 83C750              <1> 	add	di,50h			; Else position for now char
  8063                              <1> 
  8064                              <1> .CG8_06:
  8065 0000F561 FECF                <1> 	dec	bh			; Show row of pixels read
  8066 0000F563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  8067 0000F565 5E                  <1> 	pop	si
  8068 0000F566 5F                  <1> 	pop	di
  8069 0000F567 47                  <1> 	inc	di
  8070 0000F568 E2DF                <1> 	loop	.CG8_03
  8071 0000F56A 1F                  <1> 	pop	ds
  8072 0000F56B C3                  <1> 	ret
  8073                              <1> 
  8074                              <1> .graphics_read:
  8075 0000F56C FC                  <1> 	cld				; Increment upwards
  8076 0000F56D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  8077 0000F570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  8078 0000F573 89C6                <1> 	mov	si,ax			;  ...save in si
  8079 0000F575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  8080 0000F578 89E7                <1> 	mov	di,sp			;  ...save base in di
  8081 0000F57A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  8082 0000F57F 8CC0                <1> 	mov	ax,es
  8083 0000F581 1E                  <1> 	push	ds
  8084 0000F582 57                  <1> 	push	di
  8085 0000F583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  8086 0000F585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  8087 0000F587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  8088 0000F589 D1E6                <1> 	shl	si,1
  8089 0000F58B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  8090                              <1> 
  8091                              <1> CGR_02:
  8092 0000F58E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  8093 0000F590 86E0                <1> 	xchg	ah,al
  8094 0000F592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  8095 0000F595 B200                <1> 	mov	dl,0
  8096                              <1> 
  8097                              <1> CGR_03:
  8098 0000F597 85C8                <1> 	test	ax,cx			; Look for attributes
  8099 0000F599 F8                  <1> 	clc
  8100 0000F59A 7401                <1> 	jz	CGR_04			;  ...set, skip
  8101 0000F59C F9                  <1> 	stc				; Else show not set
  8102                              <1> 
  8103                              <1> CGR_04:
  8104 0000F59D D0D2                <1> 	rcl	dl,1
  8105 0000F59F D1E9                <1> 	shr	cx,1
  8106 0000F5A1 D1E9                <1> 	shr	cx,1
  8107 0000F5A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  8108 0000F5A5 368815              <1>     ss	mov	byte [di],dl
  8109 0000F5A8 47                  <1> 	inc	di
  8110 0000F5A9 31DE                <1> 	xor	si,bx			; Do other video plane
  8111 0000F5AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  8112 0000F5AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  8113 0000F5AF 83C650              <1> 	add	si,50h			; Else advance pointer
  8114                              <1> 
  8115                              <1> CGR_05:
  8116 0000F5B2 FECE                <1> 	dec	dh			; Show another pixel row done
  8117 0000F5B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  8118 0000F5B6 EB17                <1> 	jmp	short	CGR_08
  8119                              <1> 
  8120                              <1> CGR_06:
  8121 0000F5B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  8122                              <1> 
  8123                              <1> CGR_07:
  8124 0000F5BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  8125 0000F5BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  8126 0000F5BF 47                  <1> 	inc	di			;  ...advance
  8127 0000F5C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  8128 0000F5C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  8129 0000F5C7 47                  <1> 	inc	di			;  ...advance
  8130 0000F5C8 83C650              <1> 	add	si,50h			; Total pixels in char
  8131 0000F5CB FECE                <1> 	dec	dh			;  ...another row processed
  8132 0000F5CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  8133                              <1> 
  8134                              <1> CGR_08:
  8135 0000F5CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  8136 0000F5D1 BF[6EFA]            <1> 	mov	di,gfx_font		;  ...and offset
  8137 0000F5D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  8138 0000F5D6 8CD2                <1> 	mov	dx,ss
  8139 0000F5D8 8EDA                <1> 	mov	ds,dx
  8140 0000F5DA 5E                  <1> 	pop	si
  8141 0000F5DB B000                <1> 	mov	al,0
  8142                              <1> 
  8143                              <1> CGR_09:
  8144 0000F5DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  8145                              <1> 
  8146                              <1> CGR_10:
  8147 0000F5E0 56                  <1> 	push	si
  8148 0000F5E1 57                  <1> 	push	di
  8149 0000F5E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  8150 0000F5E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  8151 0000F5E7 5F                  <1> 	pop	di
  8152 0000F5E8 5E                  <1> 	pop	si
  8153 0000F5E9 741C                <1> 	jz	CGR_11			; Found graphics character
  8154 0000F5EB FEC0                <1> 	inc	al			;  ...else show another char
  8155 0000F5ED 83C708              <1> 	add	di,8			;  ...advance one row
  8156 0000F5F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  8157 0000F5F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  8158                              <1> 
  8159 0000F5F3 08C0                <1> 	or	al,al			; User graphics character set?
  8160 0000F5F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  8161 0000F5F7 31DB                <1> 	xor	bx,bx
  8162 0000F5F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  8163 0000F5FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  8164 0000F5FF 8CC3                <1> 	mov	bx,es
  8165 0000F601 09FB                <1> 	or	bx,di
  8166 0000F603 7402                <1> 	jz	CGR_11			;  ...not found
  8167 0000F605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  8168                              <1> 
  8169                              <1> CGR_11:
  8170 0000F607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  8171 0000F60A 1F                  <1> 	pop	ds
  8172 0000F60B 83C408              <1> 	add	sp,8			;  ...return temp storage
  8173 0000F60E C3                  <1> 	ret
  8174                              <1> 
  8175                              <1> ;=========================================================================
  8176                              <1> ; int_10_fn0B - Set background color or palette
  8177                              <1> ; Input:
  8178                              <1> ; 	AH - 0Bh
  8179                              <1> ;	BH = 00h - set background / border color
  8180                              <1> ;		BL - background (graphics modes) or border (text modes)
  8181                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  8182                              <1> ;		BL - palette ID:
  8183                              <1> ;			00h - background, green, red, and yellow (brown)
  8184                              <1> ;			01h - background, cyan, magenta, and white
  8185                              <1> ; Output:
  8186                              <1> ;	none
  8187                              <1> ;-------------------------------------------------------------------------
  8188                              <1> int_10_fn0B:
  8189 0000F60F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  8190 0000F612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  8191 0000F615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  8192 0000F619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  8193                              <1> 
  8194 0000F61B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  8195 0000F61D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  8196 0000F620 08E0                <1> 	or	al,ah			; apply new color
  8197 0000F622 EB09                <1> 	jmp	.write_palet_reg
  8198                              <1> 
  8199                              <1> .set_palette:
  8200 0000F624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  8201 0000F626 F6C401              <1> 	test	ah,01h
  8202 0000F629 7402                <1> 	jz	.write_palet_reg
  8203 0000F62B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  8204                              <1> 
  8205                              <1> .write_palet_reg:
  8206 0000F62D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  8207 0000F630 8B166300            <1> 	mov	dx,word [video_port]
  8208 0000F634 83C205              <1> 	add	dx,5			; CRTC color select register
  8209 0000F637 EE                  <1> 	out	dx,al			; send it to CRTC
  8210 0000F638 C3                  <1> 	ret
  8211                              <1> 
  8212                              <1> ;=========================================================================
  8213                              <1> ; int_10_fn0C - Write graphics pixel
  8214                              <1> ; Input:
  8215                              <1> ;	AH = 0Ch
  8216                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  8217                              <1> ;	CX = column
  8218                              <1> ;	DX = row
  8219                              <1> ; Output:
  8220                              <1> ;	none
  8221                              <1> ;-------------------------------------------------------------------------
  8222                              <1> int_10_fn0C:
  8223 0000F639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  8224 0000F63C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  8225 0000F63E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  8226 0000F641 88C3                <1> 	mov	bl,al			; copy color to BL
  8227 0000F643 2401                <1> 	and	al,1			; one bit per pixel
  8228 0000F645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  8229 0000F647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  8230 0000F649 EB0F                <1> 	jmp	.prepare_mask
  8231                              <1> 
  8232                              <1> .mode_320x200:
  8233 0000F64B D0E1                <1> 	shl	cl,1
  8234 0000F64D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  8235 0000F650 88C3                <1> 	mov	bl,al			; copy color to BL
  8236 0000F652 2403                <1> 	and	al,3			; two bit per pixel
  8237 0000F654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  8238 0000F656 D0C8                <1> 	ror	al,1
  8239 0000F658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  8240                              <1> 
  8241                              <1> .prepare_mask:
  8242 0000F65A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  8243 0000F65C D2E8                <1> 	shr	al,cl			; position color bits correctly
  8244 0000F65E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  8245 0000F661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  8246 0000F663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  8247 0000F665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  8248 0000F667 EB04                <1> 	jmp	.write_pixel
  8249                              <1> 
  8250                              <1> .set_color:
  8251 0000F669 20E1                <1> 	and	cl,ah			; clear existing color bits
  8252 0000F66B 08C1                <1> 	or	cl,al			; set new color bits
  8253                              <1> 
  8254                              <1> .write_pixel:
  8255 0000F66D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  8256 0000F670 C3                  <1> 	ret
  8257                              <1> 
  8258                              <1> ;=========================================================================
  8259                              <1> ; int_10_fn0D - Read graphics pixel
  8260                              <1> ; Input:
  8261                              <1> ;	AH = 0Dh
  8262                              <1> ;	CX = column
  8263                              <1> ;	DX = row
  8264                              <1> ; Output:
  8265                              <1> ;	AL = pixel color 
  8266                              <1> ;-------------------------------------------------------------------------
  8267                              <1> int_10_fn0D:
  8268 0000F671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  8269 0000F674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  8270 0000F677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  8271 0000F679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  8272 0000F67B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  8273 0000F67D 2401                <1> 	and	al,1			; one bit per pixel
  8274 0000F67F EB0A                <1> 	jmp	.exit
  8275                              <1> 
  8276                              <1> .mode_320x200:
  8277 0000F681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  8278 0000F683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  8279 0000F685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  8280 0000F687 D0C0                <1> 	rol	al,1
  8281 0000F689 2403                <1> 	and	al,3			; two bits per pixel
  8282                              <1> 
  8283                              <1> .exit:
  8284 0000F68B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  8285 0000F68E C3                  <1> 	ret
  8286                              <1> 
  8287                              <1> ;=========================================================================
  8288                              <1> ; int_10_fn0E - Teletype output
  8289                              <1> ; Input:
  8290                              <1> ;	AH = 0Eh
  8291                              <1> ;	AL = character to write
  8292                              <1> ;	BL = foreground color (graphics modes only)
  8293                              <1> ; Output:
  8294                              <1> ;	none
  8295                              <1> ; Notes:
  8296                              <1> ;	- writes character to the active video page
  8297                              <1> ;	- support following control characters: BEL, BS, LF, CR
  8298                              <1> ;-------------------------------------------------------------------------
  8299                              <1> int_10_fn0E:
  8300 0000F68F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  8301 0000F693 B700                <1> 	mov	bh,0
  8302 0000F695 D0E3                <1> 	shl	bl,1			; word index
  8303 0000F697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  8304                              <1> 
  8305 0000F69A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  8306 0000F69D 3C08                <1> 	cmp	al,bs
  8307 0000F69F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  8308 0000F6A1 3C0A                <1> 	cmp	al,lf
  8309 0000F6A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  8310 0000F6A5 3C07                <1> 	cmp	al,bel
  8311 0000F6A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  8312 0000F6A9 3C0D                <1> 	cmp	al,cr
  8313 0000F6AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  8314 0000F6AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  8315 0000F6B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  8316 0000F6B2 B90100              <1> 	mov	cx,1			; one character
  8317 0000F6B5 CD10                <1> 	int	10h			; write character
  8318 0000F6B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  8319 0000F6B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  8320 0000F6BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  8321 0000F6BF B200                <1> 	mov	dl,0			; move to the first position
  8322                              <1> 
  8323                              <1> .lf:
  8324 0000F6C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  8325 0000F6C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  8326 0000F6C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  8327 0000F6C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  8328                              <1> 
  8329                              <1> .bs:
  8330 0000F6CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  8331 0000F6CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  8332 0000F6CF FECA                <1> 	dec	dl			; move cursor to the previous position
  8333 0000F6D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  8334                              <1> 
  8335                              <1> .cr:
  8336 0000F6D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  8337                              <1> 
  8338                              <1> .set_cursor_pos:
  8339 0000F6D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  8340 0000F6D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  8341                              <1> 
  8342                              <1> .bel:
  8343 0000F6DC B302                <1> 	mov	bl,2			; 0.2 second beep
  8344 0000F6DE E84EA7              <1> 	call	beep
  8345 0000F6E1 C3                  <1> 	ret
  8346                              <1> 
  8347                              <1> .scroll:
  8348 0000F6E2 B402                <1> 	mov	ah,02h
  8349 0000F6E4 CD10                <1> 	int	10h			; set new cursor position
  8350 0000F6E6 E82E00              <1> 	call	vid_check_mode
  8351 0000F6E9 B700                <1> 	mov	bh,0
  8352 0000F6EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
  8353 0000F6ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  8354 0000F6EF CD10                <1> 	int	10h			; read attirbute at current position
  8355 0000F6F1 88E7                <1> 	mov	bh,ah
  8356                              <1> 
  8357                              <1> .do_scroll:
  8358 0000F6F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  8359 0000F6F5 B001                <1> 	mov	al,1			; scroll one line
  8360 0000F6F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  8361 0000F6F9 B618                <1> 	mov	dh,24			; bottom row is 24
  8362 0000F6FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  8363 0000F6FF FECA                <1> 	dec	dl
  8364 0000F701 CD10                <1> 	int	10h			; scroll page up
  8365 0000F703 C3                  <1> 	ret
  8366                              <1> 
  8367                              <1> ;=========================================================================
  8368                              <1> ; int_10_fn0F - Get current video mode
  8369                              <1> ; Input:
  8370                              <1> ;	AH = 0Fh
  8371                              <1> ; Output:
  8372                              <1> ;	AL = video mode
  8373                              <1> ;	AH = characters per column
  8374                              <1> ;	BH = active video page
  8375                              <1> ;-------------------------------------------------------------------------
  8376                              <1> int_10_fn0F:
  8377 0000F704 A04A00              <1> 	mov	al,byte [video_columns]
  8378 0000F707 884601              <1> 	mov	byte [bp+int_10_ah],al
  8379 0000F70A A04900              <1> 	mov	al,byte [video_mode]
  8380 0000F70D 884600              <1> 	mov	byte [bp+int_10_al],al
  8381 0000F710 A06200              <1> 	mov	al,byte [video_page]
  8382 0000F713 884603              <1> 	mov	byte [bp+int_10_bh],al
  8383 0000F716 C3                  <1> 	ret
  8384                              <1> 
  8385                              <1> ;=========================================================================
  8386                              <1> ; vid_check_mode - Check current video mode
  8387                              <1> ; Input:
  8388                              <1> ;	none
  8389                              <1> ; Output:
  8390                              <1> ;	ZF set if monochrome mode (mode 07h)
  8391                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  8392                              <1> ;-------------------------------------------------------------------------
  8393                              <1> vid_check_mode:
  8394 0000F717 50                  <1> 	push	ax
  8395 0000F718 A04900              <1> 	mov	al,byte [video_mode]
  8396 0000F71B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  8397 0000F71D 7408                <1> 	jz	.exit			; jump if monochrome
  8398 0000F71F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  8399 0000F721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  8400 0000F722 7303                <1> 	jnb	.exit			; jump if not graphics
  8401 0000F724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
  8402 0000F726 F9                  <1> 	stc				; XXX
  8403                              <1> 
  8404                              <1> .exit:
  8405 0000F727 58                  <1> 	pop	ax
  8406 0000F728 C3                  <1> 	ret
  8407                              <1> 
  8408                              <1> ;=========================================================================
  8409                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  8410                              <1> ; Input:
  8411                              <1> ;	AH = register number
  8412                              <1> ;	CX = word to write
  8413                              <1> ; Output:
  8414                              <1> ;	AX trashed
  8415                              <1> ; Note:
  8416                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  8417                              <1> ;-------------------------------------------------------------------------
  8418                              <1> vid_crtc_writew:
  8419 0000F729 88E8                <1> 	mov	al,ch
  8420 0000F72B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  8421 0000F72E FEC4                <1> 	inc	ah			; point AH to the next register
  8422 0000F730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  8423                              <1> 
  8424                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  8425                              <1> 
  8426                              <1> ;=========================================================================
  8427                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  8428                              <1> ; Input:
  8429                              <1> ;	AH = register number
  8430                              <1> ;	AL = byte to write
  8431                              <1> ; Output:
  8432                              <1> ;	none
  8433                              <1> ;-------------------------------------------------------------------------
  8434                              <1> vid_crtc_writeb:
  8435 0000F732 52                  <1> 	push	dx
  8436 0000F733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  8437 0000F737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  8438 0000F739 EE                  <1> 	out	dx,al			; write register number
  8439 0000F73A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  8440 0000F73C FEC2                <1> 	inc	dl			; DX = CRTC data port
  8441 0000F73E EE                  <1> 	out	dx,al			; write byte
  8442 0000F73F 5A                  <1> 	pop	dx
  8443 0000F740 C3                  <1> 	ret
  8444                              <1> 
  8445                              <1> ;=========================================================================
  8446                              <1> ; vid_pixel_address - calculate pixel address and mask
  8447                              <1> ; Input:
  8448                              <1> ;	CX - column
  8449                              <1> ;	DX - row
  8450                              <1> ; Output:
  8451                              <1> ;	SI - pixel address
  8452                              <1> ;	CH - pixel mask
  8453                              <1> ;	CL - pixel position in the byte
  8454                              <1> ;	ZF - mode
  8455                              <1> ;		0 = 320x200
  8456                              <1> ;		1 = 640x200
  8457                              <1> ;-------------------------------------------------------------------------
  8458                              <1> vid_pixel_address:
  8459 0000F741 31F6                <1> 	xor	si,si			; SI = 0
  8460 0000F743 D0EA                <1> 	shr	dl,1			; divide row by two
  8461 0000F745 7303                <1> 	jnb	.even			; jump if on even row 
  8462 0000F747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  8463                              <1> 
  8464                              <1> .even:
  8465 0000F74A B050                <1> 	mov	al,50h			; bytes in each row
  8466 0000F74C F6E2                <1> 	mul	dl			; AX - address of the row
  8467                              <1> 
  8468 0000F74E 01C6                <1> 	add	si,ax			; add row address to SI
  8469 0000F750 89CA                <1> 	mov	dx,cx			; DX - column
  8470 0000F752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  8471 0000F755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  8472 0000F75A 9C                  <1> 	pushf				; save ZF (and other flags
  8473 0000F75B 7503                <1> 	jnz	.1			; skip if not 640x200
  8474 0000F75D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  8475                              <1> 
  8476                              <1> .1:
  8477 0000F760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  8478 0000F762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  8479 0000F764 01D6                <1> 	add	si,dx			; add column address to SI
  8480 0000F766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  8481 0000F768 9D                  <1> 	popf
  8482 0000F769 C3                  <1> 	ret
  8483                              <1> 
  8484                              <1> ;=========================================================================
  8485                              <1> ; vid_current_offset - convert current cursor position to offset
  8486                              <1> ;		       relative to page starting address
  8487                              <1> ; Input:
  8488                              <1> ;	BL = page
  8489                              <1> ; Output:
  8490                              <1> ;	AX = offset
  8491                              <1> ;-------------------------------------------------------------------------
  8492                              <1> vid_current_offset:
  8493 0000F76A B700                <1> 	mov	bh,0
  8494 0000F76C D1E3                <1> 	shl	bx,1				; word index
  8495 0000F76E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  8496                              <1> 
  8497                              <1> ; fall through to vid_position_to_offset
  8498                              <1> 
  8499                              <1> ;=========================================================================
  8500                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  8501                              <1> ;			   relative to page starting address
  8502                              <1> ; Input:
  8503                              <1> ;	AH = row
  8504                              <1> ;	AL = column
  8505                              <1> ; Output:
  8506                              <1> ;	AX = offset
  8507                              <1> ;-------------------------------------------------------------------------
  8508                              <1> vid_position_to_offset:
  8509 0000F771 53                  <1> 	push	bx
  8510 0000F772 88C3                <1> 	mov	bl,al			; BL = column
  8511 0000F774 88E0                <1> 	mov	al,ah			; AL = row
  8512 0000F776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  8513 0000F77A B700                <1> 	mov	bh,0			;
  8514 0000F77C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  8515 0000F77E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  8516 0000F780 5B                  <1> 	pop	bx
  8517 0000F781 C3                  <1> 	ret
  8518                              <1> 
  8519                              <1> ;=========================================================================
  8520                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  8521                              <1> ; Input:
  8522                              <1> ;	AH = row
  8523                              <1> ;	AL = column
  8524                              <1> ; Output:
  8525                              <1> ;	AX = offset
  8526                              <1> ;-------------------------------------------------------------------------
  8527                              <1> vid_gfx_pos_to_offset:
  8528 0000F782 53                  <1> 	push	bx
  8529 0000F783 88C3                <1> 	mov	bl,al			; BL = column
  8530 0000F785 88E0                <1> 	mov	al,ah			; AL = row
  8531 0000F787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  8532 0000F78B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  8533 0000F78D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  8534 0000F78F B700                <1> 	mov	bh,0
  8535 0000F791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  8536 0000F793 5B                  <1> 	pop	bx
  8537 0000F794 C3                  <1> 	ret
  8538                                  
  8539                                  ;=========================================================================
  8540                                  ; int_12 - Get memory size
  8541                                  ; Input:
  8542                                  ;	none
  8543                                  ; Output:
  8544                                  ;	AX = memory size
  8545                                  ;-------------------------------------------------------------------------
  8546 0000F795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
  8547                                  int_12:
  8548 0000F841 FB                      	sti
  8549 0000F842 1E                      	push	ds
  8550 0000F843 B84000                  	mov	ax,biosdseg
  8551 0000F846 8ED8                    	mov	ds,ax
  8552 0000F848 A11300                  	mov	ax,word [memory_size]
  8553 0000F84B 1F                      	pop	ds
  8554 0000F84C CF                      	iret
  8555                                  
  8556                                  ;=========================================================================
  8557                                  ; int_11 - Get equipment list
  8558                                  ; Input:
  8559                                  ;	none
  8560                                  ; Output:
  8561                                  ;	AX = equipment list
  8562                                  ;-------------------------------------------------------------------------
  8563                                  	setloc	0F84Dh			; INT 11 Entry Point
  8564                                  int_11:
  8565 0000F84D FB                      	sti
  8566 0000F84E 1E                      	push	ds
  8567 0000F84F B84000                  	mov	ax,biosdseg
  8568 0000F852 8ED8                    	mov	ds,ax
  8569 0000F854 A11000                  	mov	ax,word [equipment_list]
  8570 0000F857 1F                      	pop	ds
  8571 0000F858 CF                      	iret
  8572                                  
  8573                                  ;=========================================================================
  8574                                  ; Includes with fixed entry points (for IBM compatibility)
  8575                                  ;-------------------------------------------------------------------------
  8576                                  
  8577                                  %include	"misc.inc"
  8578                              <1> ;=========================================================================
  8579                              <1> ; misc.inc - Miscellaneous BIOS Services
  8580                              <1> ;       INT 15h, functions:
  8581                              <1> ;       	4Fh	- OS hook keyboard intercept
  8582                              <1> ;		90h	- Device busy loop
  8583                              <1> ;		91h	- Interrupt completed
  8584                              <1> ;		0C0h	- Get system configruation
  8585                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  8586                              <1> ;		
  8587                              <1> ;-------------------------------------------------------------------------
  8588                              <1> ;
  8589                              <1> ; Compiles with NASM 2.07, might work with other versions
  8590                              <1> ;
  8591                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  8592                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  8593                              <1> ;
  8594                              <1> ; This program is free software: you can redistribute it and/or modify
  8595                              <1> ; it under the terms of the GNU General Public License as published by
  8596                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8597                              <1> ; (at your option) any later version.
  8598                              <1> ;
  8599                              <1> ; This program is distributed in the hope that it will be useful,
  8600                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8601                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8602                              <1> ; GNU General Public License for more details.
  8603                              <1> ;
  8604                              <1> ; You should have received a copy of the GNU General Public License
  8605                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8606                              <1> ;
  8607                              <1> ;=========================================================================
  8608                              <1> 
  8609                              <1> ;-------------------------------------------------------------------------
  8610                              <1> ; offsets for registers on stack
  8611                              <1> int_15_bp	equ	0
  8612                              <1> int_15_ip	equ	int_15_bp+2
  8613                              <1> int_15_cs	equ	int_15_ip+2
  8614                              <1> int_15_flags	equ	int_15_cs+2
  8615                              <1> 
  8616                              <1> ;=========================================================================
  8617                              <1> ; int_15 - Miscellaneous BIOS services
  8618                              <1> ; Input:
  8619                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  8620                              <1> ;		- Does nothing
  8621                              <1> ;	AH = 0C2h - PS/2 mouse services
  8622                              <1> ;		- Implemented in ps2aux.inc
  8623                              <1> ;-------------------------------------------------------------------------
  8624                              <1> 	setloc	0F859h			; INT 15 Entry Point
  8625                              <1> int_15:
  8626 0000F859 FB                  <1> 	sti
  8627 0000F85A 80FC4F              <1> 	cmp	ah,4Fh
  8628 0000F85D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
  8629 0000F85F 80FCC0              <1> 	cmp	ah,0C0h
  8630 0000F862 742E                <1> 	je	int_15_fnC0
  8631 0000F864 3D0190              <1> 	cmp	ax,9001h
  8632 0000F867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
  8633 0000F869 3DFD90              <1> 	cmp	ax,90FDh
  8634 0000F86C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
  8635 0000F86E 3D0191              <1> 	cmp	ax,9101h
  8636 0000F871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  8637                              <1> 
  8638                              <1> %ifdef PS2_MOUSE
  8639 0000F873 80FCC2              <1> 	cmp	ah,0C2h
  8640 0000F876 7503                <1> 	jne	.1
  8641 0000F878 E937A3              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  8642                              <1> .1:
  8643                              <1> %endif
  8644                              <1> 
  8645 0000F87B B486                <1> 	mov	ah,86h			; no cassete present
  8646                              <1> 
  8647                              <1> int_15_err:
  8648 0000F87D 55                  <1> 	push	bp
  8649 0000F87E 89E5                <1> 	mov	bp,sp
  8650 0000F880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  8651 0000F884 5D                  <1> 	pop	bp
  8652 0000F885 CF                  <1> 	iret
  8653                              <1> 
  8654                              <1> int_15_ok:
  8655 0000F886 55                  <1> 	push	bp
  8656 0000F887 89E5                <1> 	mov	bp,sp
  8657 0000F889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  8658 0000F88D 5D                  <1> 	pop	bp
  8659 0000F88E CF                  <1> 	iret
  8660                              <1> 
  8661                              <1> int_15_os_hook:
  8662 0000F88F B400                <1> 	mov	ah,00h
  8663                              <1> 
  8664                              <1> int_15_exit:
  8665 0000F891 CF                  <1> 	iret
  8666                              <1> 
  8667                              <1> ;=========================================================================
  8668                              <1> ; int_15_fnC0 - Get configuration
  8669                              <1> ; Input:
  8670                              <1> ;	AH = 0C0h - get configuration
  8671                              <1> ; Output:
  8672                              <1> ;	AH = 00h - function supported
  8673                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  8674                              <1> ;	CF = 0 (success)
  8675                              <1> ;-------------------------------------------------------------------------
  8676                              <1> int_15_fnC0:
  8677 0000F892 B400                <1> 	mov	ah,00h
  8678 0000F894 BB00F0              <1> 	mov	bx,bioscseg
  8679 0000F897 8EC3                <1> 	mov	es,bx
  8680 0000F899 BB[F5E6]            <1> 	mov	bx,config_table
  8681 0000F89C EBE8                <1> 	jmp	int_15_ok
  8682                                  %include	"fnt00-7F.inc"
  8683                              <1> ;=========================================================================
  8684                              <1> ; fnt00-7F.inc - Font for graphics modes
  8685                              <1> ;       Characters from 00h to 7Fh
  8686                              <1> ;-------------------------------------------------------------------------
  8687                              <1> ;
  8688                              <1> ; Compiles with NASM 2.07, might work with other versions
  8689                              <1> ;
  8690                              <1> ; This font is borrowed from kbd package (alt-8x8)
  8691                              <1> ;
  8692                              <1> ; This program is free software: you can redistribute it and/or modify
  8693                              <1> ; it under the terms of the GNU General Public License as published by
  8694                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8695                              <1> ; (at your option) any later version.
  8696                              <1> ;
  8697                              <1> ; This program is distributed in the hope that it will be useful,
  8698                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8699                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8700                              <1> ; GNU General Public License for more details.
  8701                              <1> ;
  8702                              <1> ; You should have received a copy of the GNU General Public License
  8703                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8704                              <1> ;
  8705                              <1> ;=========================================================================
  8706 0000F89E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
  8707                              <1> gfx_font:
  8708 0000FA6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  8709 0000FA76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  8710 0000FA7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  8711 0000FA86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  8712 0000FA8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  8713 0000FA96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  8714 0000FA9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  8715 0000FAA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  8716 0000FAAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  8717 0000FAB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  8718 0000FABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  8719 0000FAC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  8720 0000FACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  8721 0000FAD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  8722 0000FADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  8723 0000FAE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  8724 0000FAEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  8725 0000FAF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  8726 0000FAFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  8727 0000FB06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  8728 0000FB0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  8729 0000FB16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  8730 0000FB1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  8731 0000FB26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  8732 0000FB2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  8733 0000FB36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  8734 0000FB3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  8735 0000FB46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  8736 0000FB4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  8737 0000FB56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  8738 0000FB5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  8739 0000FB66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  8740 0000FB6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  8741 0000FB76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  8742 0000FB7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  8743 0000FB86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  8744 0000FB8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  8745 0000FB96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  8746 0000FB9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  8747 0000FBA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  8748 0000FBAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  8749 0000FBB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  8750 0000FBBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  8751 0000FBC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  8752 0000FBCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  8753 0000FBD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  8754 0000FBDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  8755 0000FBE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  8756 0000FBEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  8757 0000FBF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  8758 0000FBFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  8759 0000FC06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  8760 0000FC0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  8761 0000FC16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  8762 0000FC1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  8763 0000FC26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  8764 0000FC2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  8765 0000FC36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  8766 0000FC3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  8767 0000FC46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  8768 0000FC4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  8769 0000FC56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  8770 0000FC5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  8771 0000FC66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  8772 0000FC6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  8773 0000FC76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  8774 0000FC7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  8775 0000FC86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  8776 0000FC8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  8777 0000FC96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  8778 0000FC9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  8779 0000FCA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  8780 0000FCAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  8781 0000FCB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  8782 0000FCBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  8783 0000FCC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  8784 0000FCCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  8785 0000FCD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  8786 0000FCDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  8787 0000FCE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  8788 0000FCEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  8789 0000FCF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  8790 0000FCFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  8791 0000FD06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  8792 0000FD0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  8793 0000FD16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  8794 0000FD1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  8795 0000FD26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  8796 0000FD2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  8797 0000FD36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  8798 0000FD3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  8799 0000FD46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  8800 0000FD4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  8801 0000FD56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  8802 0000FD5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  8803 0000FD66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  8804 0000FD6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  8805 0000FD76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  8806 0000FD7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  8807 0000FD86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  8808 0000FD8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  8809 0000FD96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  8810 0000FD9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  8811 0000FDA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  8812 0000FDAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  8813 0000FDB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  8814 0000FDBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  8815 0000FDC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  8816 0000FDCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  8817 0000FDD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  8818 0000FDDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  8819 0000FDE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  8820 0000FDEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  8821 0000FDF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  8822 0000FDFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  8823 0000FE06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  8824 0000FE0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  8825 0000FE16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  8826 0000FE1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  8827 0000FE26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  8828 0000FE2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  8829 0000FE36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  8830 0000FE3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  8831 0000FE46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  8832 0000FE4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  8833 0000FE56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  8834 0000FE5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  8835 0000FE66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  8836                                  %include	"time2.inc"
  8837                              <1> ;=========================================================================
  8838                              <1> ; time2.int - BIOS Time Services
  8839                              <1> ;       INT 1Ah - BIOS Time Serivces
  8840                              <1> ;		dispatcher
  8841                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  8842                              <1> ;-------------------------------------------------------------------------
  8843                              <1> ;
  8844                              <1> ; Compiles with NASM 2.07, might work with other versions
  8845                              <1> ;
  8846                              <1> ; Copyright (C) 2011 Sergey Kiselev.
  8847                              <1> ; Provided for hobbyist use on the Sergey's XT board.
  8848                              <1> ;
  8849                              <1> ; This program is free software: you can redistribute it and/or modify
  8850                              <1> ; it under the terms of the GNU General Public License as published by
  8851                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8852                              <1> ; (at your option) any later version.
  8853                              <1> ;
  8854                              <1> ; This program is distributed in the hope that it will be useful,
  8855                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8856                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8857                              <1> ; GNU General Public License for more details.
  8858                              <1> ;
  8859                              <1> ; You should have received a copy of the GNU General Public License
  8860                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8861                              <1> ;
  8862                              <1> ;=========================================================================
  8863                              <1> 
  8864                              <1> ;=========================================================================
  8865                              <1> ; int_1A - BIOS Time Services
  8866                              <1> ; Note: see time1.inc for functions implementation
  8867                              <1> ;-------------------------------------------------------------------------
  8868                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  8869                              <1> int_1A:
  8870 0000FE6E 53                  <1> 	push	bx
  8871 0000FE6F 1E                  <1> 	push	ds
  8872 0000FE70 BB4000              <1> 	mov	bx,biosdseg
  8873 0000FE73 8EDB                <1> 	mov	ds,bx
  8874 0000FE75 80FC08              <1> 	cmp	ah,.max/2
  8875 0000FE78 731B                <1> 	jae	int_1A_exit
  8876 0000FE7A B700                <1> 	mov	bh,0
  8877 0000FE7C 88E3                <1> 	mov	bl,ah
  8878 0000FE7E D1E3                <1> 	shl	bx,1
  8879 0000FE80 2EFFA7[85FE]        <1>     cs	jmp	near [.dispatch+bx]
  8880                              <1> .dispatch:
  8881 0000FE85 [D48B]              <1> 	dw	int_1A_fn00
  8882 0000FE87 [E68B]              <1> 	dw	int_1A_fn01
  8883 0000FE89 [F68B]              <1> 	dw	int_1A_fn02
  8884 0000FE8B [288C]              <1> 	dw	int_1A_fn03
  8885 0000FE8D [6D8C]              <1> 	dw	int_1A_fn04
  8886 0000FE8F [9D8C]              <1> 	dw	int_1A_fn05
  8887 0000FE91 [DC8C]              <1> 	dw	int_1A_fn06
  8888 0000FE93 [2D8D]              <1> 	dw	int_1A_fn07
  8889                              <1> .max	equ	$-.dispatch
  8890                              <1> int_1A_exit:
  8891 0000FE95 1F                  <1> 	pop	ds
  8892 0000FE96 5B                  <1> 	pop	bx
  8893 0000FE97 CF                  <1> 	iret
  8894                              <1> int_1A_exitf:
  8895 0000FE98 1F                  <1> 	pop	ds
  8896 0000FE99 5B                  <1> 	pop	bx
  8897 0000FE9A CA0200              <1> 	retf	2
  8898                              <1> 
  8899                              <1> ;=========================================================================
  8900                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  8901                              <1> ;-------------------------------------------------------------------------
  8902 0000FE9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
  8903                              <1> int_08:
  8904 0000FEA5 50                  <1> 	push	ax
  8905 0000FEA6 1E                  <1> 	push	ds
  8906 0000FEA7 B84000              <1> 	mov	ax,biosdseg
  8907 0000FEAA 8ED8                <1> 	mov	ds,ax
  8908 0000FEAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  8909 0000FEB1 7413                <1> 	jz	.1
  8910 0000FEB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  8911 0000FEB7 750D                <1> 	jnz	.1
  8912 0000FEB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  8913 0000FEBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  8914 0000FEC0 52                  <1> 	push	dx
  8915 0000FEC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  8916 0000FEC4 EE                  <1> 	out	dx,al
  8917 0000FEC5 5A                  <1> 	pop	dx
  8918                              <1> .1:
  8919 0000FEC6 FF066C00            <1> 	inc	word [ticks_lo]
  8920 0000FECA 7504                <1> 	jnz	.2
  8921 0000FECC FF066E00            <1> 	inc	word [ticks_hi]
  8922                              <1> .2:
  8923 0000FED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  8924 0000FED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  8925 0000FED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  8926 0000FEDD 7512                <1> 	jnz	.3
  8927 0000FEDF C7066E000000        <1> 	mov	word [ticks_hi],0
  8928 0000FEE5 C7066C000000        <1> 	mov	word [ticks_lo],0
  8929 0000FEEB C70670000100        <1> 	mov	word [new_day],1
  8930                              <1> .3:
  8931 0000FEF1 CD1C                <1> 	int	1Ch			; User timer interrupt
  8932 0000FEF3 B020                <1> 	mov	al,20h
  8933 0000FEF5 E620                <1> 	out	pic1_reg0,al
  8934 0000FEF7 1F                  <1> 	pop	ds
  8935 0000FEF8 58                  <1> 	pop	ax
  8936 0000FEF9 CF                  <1> 	iret
  8937                                  
  8938                                  ;=========================================================================
  8939                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  8940                                  ;-------------------------------------------------------------------------
  8941 0000FEFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  8942                                  int_ignore:
  8943 0000FF23 50                      	push	ax
  8944 0000FF24 1E                      	push	ds
  8945 0000FF25 B84000                  	mov	ax,biosdseg
  8946 0000FF28 8ED8                    	mov	ds,ax
  8947 0000FF2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
  8948 0000FF2C E620                    	out	pic1_reg0,al
  8949 0000FF2E 90                      	nop
  8950 0000FF2F E420                    	in	al,pic1_reg0		; get IRQ number
  8951 0000FF31 88C4                    	mov	ah,al
  8952 0000FF33 08C0                    	or	al,al
  8953 0000FF35 7504                    	jnz	.1
  8954 0000FF37 B4FF                    	mov	ah,0FFh
  8955 0000FF39 EB0A                    	jmp	.2
  8956                                  .1:
  8957 0000FF3B E421                    	in	al,pic1_reg1		; clear the interrupt
  8958 0000FF3D 08E0                    	or	al,ah
  8959 0000FF3F E621                    	out	pic1_reg1,al
  8960 0000FF41 B020                    	mov	al,20h			; end of interrupt
  8961 0000FF43 E620                    	out	pic1_reg0,al		; signal end of interrupt
  8962                                  .2:
  8963 0000FF45 88266B00                	mov	byte [last_irq],ah
  8964 0000FF49 1F                      	pop	ds
  8965 0000FF4A 58                      	pop	ax
  8966 0000FF4B CF                      	iret
  8967                                  
  8968                                  ;=========================================================================
  8969                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
  8970                                  ;-------------------------------------------------------------------------
  8971 0000FF4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
  8972                                  int_dummy:
  8973 0000FF53 CF                      	iret
  8974                                  
  8975                                  ;=========================================================================
  8976                                  ; int_05 - BIOS Print Screen
  8977                                  ; XXX: implement
  8978                                  ;-------------------------------------------------------------------------
  8979                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
  8980                                  int_05:
  8981 0000FF54 CF                      	iret
  8982                                  
  8983                                  ;=========================================================================	
  8984                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  8985                                  ;-------------------------------------------------------------------------
  8986                                  interrupt_table:
  8987 0000FF55 [53FF]                  	dw	int_dummy		; INT 00 - Divide by zero
  8988 0000FF57 [53FF]                  	dw	int_dummy		; INT 01 - Single step
  8989 0000FF59 [C3E2]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  8990 0000FF5B [53FF]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  8991 0000FF5D [53FF]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  8992 0000FF5F [54FF]                  	dw	int_05			; INT 05 - BIOS Print Screen
  8993 0000FF61 [53FF]                  	dw	int_dummy		; INT 06
  8994 0000FF63 [53FF]                  	dw	int_dummy		; INT 07
  8995 0000FF65 [A5FE]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  8996 0000FF67 [87E9]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  8997 0000FF69 [23FF]                  	dw	int_ignore		; INT 0A - IRQ2
  8998 0000FF6B [23FF]                  	dw	int_ignore		; INT 0B - IRQ3
  8999 0000FF6D [23FF]                  	dw	int_ignore		; INT 0C - IRQ4
  9000 0000FF6F [23FF]                  	dw	int_ignore		; INT 0D - IRQ5
  9001 0000FF71 [57EF]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  9002 0000FF73 [23FF]                  	dw	int_ignore		; INT 0F - IRQ7
  9003 0000FF75 [65F0]                  	dw	int_10			; INT 10 - BIOS Video Services
  9004 0000FF77 [4DF8]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  9005 0000FF79 [41F8]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  9006 0000FF7B [59EC]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  9007 0000FF7D [29E7]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  9008 0000FF7F [59F8]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  9009 0000FF81 [2EE8]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  9010 0000FF83 [D2EF]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  9011 0000FF85 [4DE3]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  9012 0000FF87 [F2E6]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  9013 0000FF89 [6EFE]                  	dw	int_1A			; INT 1A - BIOS Time Services
  9014 0000FF8B [53FF]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  9015 0000FF8D [53FF]                  	dw	int_dummy		; INT 1C - User Timer Tick
  9016 0000FF8F [A4F0]                  	dw	int_1D			; INT 1D - Video Parameters Table
  9017 0000FF91 [C7EF]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  9018 0000FF93 [AA85]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  9019                                  
  9020                                  interrupt_table2:
  9021 0000FF95 [418D]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  9022 0000FF97 [229F]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  9023 0000FF99 [199F]                  	dw	int_ignore2		; INT 72 - IRQ10
  9024 0000FF9B [199F]                  	dw	int_ignore2		; INT 73 - IRQ11
  9025                                  %ifndef PS2_MOUSE
  9026                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  9027                                  %else
  9028 0000FF9D [6E9D]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  9029                                  %endif
  9030 0000FF9F [2B9F]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  9031 0000FFA1 [199F]                  	dw	int_ignore2		; INT 76 - IRQ14
  9032 0000FFA3 [199F]                  	dw	int_ignore2		; INT 77 - IRQ15
  9033                                  
  9034                                  ;=========================================================================
  9035                                  ; start - at power up or reset execution starts here (F000:FFF0)
  9036                                  ;-------------------------------------------------------------------------
  9037 0000FFA5 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
  9038                                  start:
  9039 0000FFF0 EA[5BE0]00F0                    jmp     bioscseg:cold_start
  9040                                  
  9041                                  	setloc	0FFF5h			; ROM Date in ASCII
  9042 0000FFF5 31312F33302F3130        	db	'11/30/10'		; BIOS release date MM/DD/YY
  9043 0000FFFD 20                      	db	20h
  9044                                  
  9045                                  	setloc	0FFFEh			; System Model
  9046                                  %ifdef AT_COMPAT
  9047 0000FFFE FC                      	db	0fch			; system is an IBM AT compatible
  9048                                  %else
  9049                                  	db	0feh			; system is an IBM PC/XT compatible
  9050                                  %endif ; AT_COMPAT
  9051 0000FFFF FF                      	db	0ffh
