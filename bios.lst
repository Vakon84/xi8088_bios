     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.07, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2011 - 2014 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 board.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.07, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 board.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
   108                                  %include "config.inc"
   109                              <1> ;=========================================================================
   110                              <1> ; config.inc - Compilation time settings and settings
   111                              <1> ;-------------------------------------------------------------------------
   112                              <1> ;
   113                              <1> ; Compiles with NASM 2.07, might work with other versions
   114                              <1> ;
   115                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   116                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   117                              <1> ;
   118                              <1> ; This program is free software: you can redistribute it and/or modify
   119                              <1> ; it under the terms of the GNU General Public License as published by
   120                              <1> ; the Free Software Foundation, either version 3 of the License, or
   121                              <1> ; (at your option) any later version.
   122                              <1> ;
   123                              <1> ; This program is distributed in the hope that it will be useful,
   124                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   125                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   126                              <1> ; GNU General Public License for more details.
   127                              <1> ;
   128                              <1> ; You should have received a copy of the GNU General Public License
   129                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   130                              <1> ;
   131                              <1> ;=========================================================================
   132                              <1> 
   133                              <1> %define DATE		'10/24/16'	; BIOS release date MM/DD/YY
   134                              <1> %define VERSION		'0.9.1'		; BIOS version
   135                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   136                              <1> 
   137                              <1> %define AT_COMPAT			; AT-compatible system, two PICs
   138                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   139                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   140                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   141                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   142                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   143                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   144                              <1> 					; EBDA is required for PS/2 aux support
   145                              <1> %define SLOW_FLOPPY			; turn off turbo during floppy I/O
   146                                  %include "errno.inc"
   147                              <1> ;=========================================================================
   148                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> ;
   151                              <1> ; Compiles with NASM 2.07, might work with other versions
   152                              <1> ;
   153                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   154                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   155                              <1> ;
   156                              <1> ; This program is free software: you can redistribute it and/or modify
   157                              <1> ; it under the terms of the GNU General Public License as published by
   158                              <1> ; the Free Software Foundation, either version 3 of the License, or
   159                              <1> ; (at your option) any later version.
   160                              <1> ;
   161                              <1> ; This program is distributed in the hope that it will be useful,
   162                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   163                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   164                              <1> ; GNU General Public License for more details.
   165                              <1> ;
   166                              <1> ; You should have received a copy of the GNU General Public License
   167                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   168                              <1> ;
   169                              <1> ;=========================================================================
   170                              <1> 
   171                              <1> e_boot		equ	00h		; Boot the OS
   172                              <1> e_start		equ	01h		; BIOS POST started
   173                              <1> e_cpu_ok	equ	02h		; CPU test passed
   174                              <1> e_dmac_ok	equ	03h		; DMAC initialized
   175                              <1> e_low_ram_ok	equ	04h		; low RAM test passed
   176                              <1> e_int_ok	equ	05h		; interrupt table initialized
   177                              <1> e_pit_ok	equ	06h		; PIT (timer) initialized
   178                              <1> e_pic_ok	equ	08h		; PIC initialized
   179                              <1> e_kbd_ok	equ	10h		; KBD test passed
   180                              <1> e_video_bios_ok	equ	11h		; Video BIOS found
   181                              <1> e_video_init_ok	equ	12h		; Video BIOS initialized
   182                              <1> e_rtc_init_ok	equ	20h		; RTC initialized
   183                              <1> e_cpu_detect_ok	equ	21h		; CPU type detected
   184                              <1> e_fpu_detect_ok	equ	22h		; FPU type detected
   185                              <1> e_serial_ok	equ	24h		; Serial port scan finished
   186                              <1> e_parallel_ok	equ	25h		; Parallel port scan finished
   187                              <1> e_ram_start	equ	30h		; RAM test start
   188                              <1> e_ram_complete	equ	31h		; RAM test completed
   189                              <1> e_ram_esc	equ	32h		; RAM test canceled
   190                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   191                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found
   192                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   193                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   194                              <1> e_cpu_fail	equ	52h		; CPU test failed
   195                              <1> e_low_ram_fail	equ	54h		; low RAM test failed
   196                              <1> e_kbd_ctrl_fail	equ	60h		; KBD test - controller selftest failed
   197                              <1> e_kbd_key_fail	equ	61h		; KBD test - echo test failed
   198                              <1> e_kbd_timeout	equ	62h		; KBD timeout
   199                              <1> e_kbd_int_fail	equ	63h		; KBD test - interface test failed
   200                              <1> e_ram_fail	equ	80h		; RAM test failed
   201                                  
   202                                  bioscseg	equ	0F000h
   203                                  biosdseg	equ	0040h
   204                                  
   205                                  pic1_reg0	equ	20h
   206                                  pic1_reg1	equ	21h
   207                                  pit_ch0_reg	equ	40h
   208                                  pit_ch1_reg	equ	41h
   209                                  pit_ch2_reg	equ	42h
   210                                  pit_ctl_reg	equ	43h
   211                                  port_b_reg	equ	61h
   212                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
   213                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
   214                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
   215                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
   216                                  post_reg	equ	80h	; POST status output port
   217                                  pic2_reg0	equ	0A0h
   218                                  pic2_reg1	equ	0A1h
   219                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   220                                  cga_mode_reg	equ	3D8h
   221                                  mda_mode_reg	equ	3B8h
   222                                  
   223                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   224                                  
   225                                  ;========================================================================
   226                                  ; BIOS data area variables
   227                                  ;------------------------------------------------------------------------
   228                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   229                                  				; or 0 if port doesn't exist
   230                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   231                                  				; or 0 if port doesn't exist
   232                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   233                                  equipment_list	equ	10h	; word - equpment list
   234                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   235                                  equip_fpu	equ	0000000000000010b	; FPU installed
   236                                  equip_mouse	equ	0000000000000100b
   237                                  equip_video	equ	0000000000110000b	; video type bit mask
   238                                  equip_color	equ	0000000000100000b	; color 80x25 (mode 3)
   239                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   240                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   241                                  		;			|||||||||||||||`-- floppy drives installed
   242                                  		;			||||||||||||||`-- FPU installed
   243                                  		;			|||||||||||||`-- PS/2 mouse installed
   244                                  		;			||||||||||||`-- reserved
   245                                  		;			||||||||||`--- initial video mode
   246                                  		;			||||||||`---- number of floppy drives - 1
   247                                  		;			|||||||`---- O = DMA installed
   248                                  		;			||||`------ number of serial ports
   249                                  		;			|||`------ game adapter installed
   250                                  		;			||`------ internal modem?!
   251                                  		;			`------- number of parallel ports
   252                                  
   253                                  post_flags	equ	12h	; byte - post flags
   254                                  post_setup	equ	01h	; run NVRAM setup
   255                                  memory_size	equ	13h	; word - memory size in KiB
   256                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   257                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   258                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   259                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   260                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   261                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   262                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   263                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   264                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   265                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   266                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   267                                  video_mode	equ	49h	; byte - active video mode number
   268                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   269                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   270                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   271                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   272                                  video_cur_shape	equ	60h	; word - cursor shape
   273                                  video_page	equ	62h	; byte - active video page
   274                                  video_port	equ	63h	; word - I/O port for the display adapter
   275                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   276                                  video_palet_reg	equ	66h	; byte - color palette
   277                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   278                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   279                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   280                                  new_day		equ	70h	; byte - 1 = new day flag
   281                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   282                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   283                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   284                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   285                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   286                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   287                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   288                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   289                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   290                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   291                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   292                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   293                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   294                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   295                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   296                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   297                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   298                                  
   299                                  ;=========================================================================
   300                                  ; Extended BIOS data area variables
   301                                  ;-------------------------------------------------------------------------
   302                                  ebda_size	equ	0h
   303                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   304                                  mouse_flags_1	equ	26h
   305                                  mouse_flags_2	equ	27h
   306                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   307                                  
   308                                  	org	START		; Use only upper 32 KiB of ROM
   309                                  
   310                                  ;=========================================================================
   311                                  ; Includes
   312                                  ;-------------------------------------------------------------------------
   313                                  %include	"messages.inc"		; POST messages
   314                              <1> ;=========================================================================
   315                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> ;
   318                              <1> ; Compiles with NASM 2.07, might work with other versions
   319                              <1> ;
   320                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   321                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   322                              <1> ;
   323                              <1> ; This program is free software: you can redistribute it and/or modify
   324                              <1> ; it under the terms of the GNU General Public License as published by
   325                              <1> ; the Free Software Foundation, either version 3 of the License, or
   326                              <1> ; (at your option) any later version.
   327                              <1> ;
   328                              <1> ; This program is distributed in the hope that it will be useful,
   329                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   330                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   331                              <1> ; GNU General Public License for more details.
   332                              <1> ;
   333                              <1> ; You should have received a copy of the GNU General Public License
   334                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   335                              <1> ;
   336                              <1> ;=========================================================================
   337                              <1> 
   338 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   339 00000002 586920383038382042- <1> 				db	"Xi 8088 BIOS, Version "
   340 0000000B 494F532C2056657273- <1>
   341 00000014 696F6E20            <1>
   342 00000018 302E392E31          <1> 				db	VERSION
   343 0000001D 2E20                <1> 				db	". "
   344 0000001F 436F70797269676874- <1> 				db	"Copyright (C) 2010 - 2014 Sergey Kiselev", 0Dh, 0Ah
   345 00000028 202843292032303130- <1>
   346 00000031 202D20323031342053- <1>
   347 0000003A 6572676579204B6973- <1>
   348 00000043 656C65760D0A        <1>
   349 00000049 446973747269627574- <1> 				db	"Distributed under the terms of the GNU General Public License", 0Dh, 0Ah
   350 00000052 656420756E64657220- <1>
   351 0000005B 746865207465726D73- <1>
   352 00000064 206F66207468652047- <1>
   353 0000006D 4E552047656E657261- <1>
   354 00000076 6C205075626C696320- <1>
   355 0000007F 4C6963656E73650D0A  <1>
   356 00000088 0D0A00              <1> msg_crlf		db      0Dh, 0Ah, 00h
   357 0000008B 6E6F6E6500          <1> msg_none		db	'none', 00h
   358 00000090 3A2000              <1> msg_colon		db	': ', 00h
   359 00000093 3B2000              <1> msg_semicolon	db	'; ', 00h
   360 00000096 50726F636573736F72- <1> msg_cpu			db      'Processor:                  ', 00h
   361 0000009F 3A2020202020202020- <1>
   362 000000A8 202020202020202020- <1>
   363 000000B1 2000                <1>
   364                              <1> ;msg_fpu		db      'Mathematics Co-processor:   ', 00h
   365                              <1> 
   366 000000B3 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78 (buggy)", 0 
   367 000000BC 382027373820286275- <1>
   368 000000C5 6767792900          <1>
   369 000000CA 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81+, or OKI 80C88", 0
   370 000000D3 38202738312B2C206F- <1>
   371 000000DC 72204F4B4920383043- <1>
   372 000000E5 383800              <1>
   373 000000E8 486172726973203830- <1> msg_cpu_harris  db      'Harris 80C88', 0
   374 000000F1 43383800            <1>
   375 000000F5 4E45432056323000    <1> msg_cpu_nec_v20 db      'NEC V20', 0
   376 000000FD 2C2038303837204650- <1> msg_fpu_present db      ', 8087 FPU', 0Dh, 0Ah, 00h
   377 00000106 550D0A00            <1>
   378 0000010A 2C204E6F204650550D- <1> msg_no_fpu		db      ', No FPU', 0Dh, 0Ah, 0
   379 00000113 0A00                <1>
   380                              <1> 
   381 00000115 2028547572626F204F- <1> msg_turbo		db      ' (Turbo O',0
   382 0000011E 00                  <1>
   383 0000011F 4E2900              <1> msg_turbo_on	db      'N)', 0
   384 00000122 46462900            <1> msg_turbo_off	db      'FF)', 0
   385                              <1> 
   386 00000126 446973706C61792041- <1> msg_disp		db      'Display Adapter Type:       ', 00h
   387 0000012F 646170746572205479- <1>
   388 00000138 70653A202020202020- <1>
   389 00000141 2000                <1>
   390 00000143 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   391 0000014C 566964656F2042494F- <1>
   392 00000155 532050726573656E74- <1>
   393 0000015E 290D0A00            <1>
   394 00000162 4347410D0A00        <1> msg_disp_cga	db      'CGA', 0Dh, 0Ah, 00h
   395 00000168 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   396 00000171 7263756C65730D0A00  <1>
   397 0000017A 52544320285265616C- <1> msg_rtc			db	'RTC (Real Time Clock) time: ', 00h
   398 00000183 2054696D6520436C6F- <1>
   399 0000018C 636B292074696D653A- <1>
   400 00000195 2000                <1>
   401 00000197 466C6F707079206469- <1> msg_floppy		db	'Floppy disk drives:         Drive 0: ', 00h
   402 000001A0 736B20647269766573- <1>
   403 000001A9 3A2020202020202020- <1>
   404 000001B2 20447269766520303A- <1>
   405 000001BB 2000                <1>
   406 000001BD 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   407 000001C6 3A2000              <1>
   408 000001C9 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   409 000001D2 2E32352200          <1>
   410 000001D7 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   411 000001E0 2E32352200          <1>
   412 000001E5 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   413 000001EE 2E352200            <1>
   414 000001F2 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   415 000001FB 332E352200          <1>
   416 00000200 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   417 00000209 332E352200          <1>
   418 0000020E 50532F322041757820- <1> msg_mouse		db      'PS/2 Aux Device (Mouse):    ', 00h
   419 00000217 44657669636520284D- <1>
   420 00000220 6F757365293A202020- <1>
   421 00000229 2000                <1>
   422 0000022B 50726573656E740D0A- <1> msg_present		db      'Present', 0Dh, 0Ah, 00h
   423 00000234 00                  <1>
   424 00000235 416273656E740D0A00  <1> msg_absent		db      'Absent', 0Dh, 0Ah, 00h
   425 0000023E 53657269616C20506F- <1> msg_serial		db	'Serial Ports:               ', 00h
   426 00000247 7274733A2020202020- <1>
   427 00000250 202020202020202020- <1>
   428 00000259 2000                <1>
   429 0000025B 434F4D00            <1> msg_serial_com	db	'COM', 00h
   430 0000025F 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   431 00000268 506F7274733A202020- <1>
   432 00000271 202020202020202020- <1>
   433 0000027A 2000                <1>
   434 0000027C 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   435 00000280 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   436 00000289 414D20284553432074- <1>
   437 00000292 6F20736B6970293A20- <1>
   438 0000029B 2000                <1>
   439 0000029D 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   440 000002A6 4661756C7479206D65- <1>
   441 000002AF 6D6F72792064657465- <1>
   442 000002B8 637465642061742000  <1>
   443                              <1> 
   444 000002C1 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   445 000002CA 6E76656E74696F6E61- <1>
   446 000002D3 6C2052414D3A202020- <1>
   447 000002DC 202000              <1>
   448 000002DF 2C20454244413A2000  <1> msg_ebda		db      ', EBDA: ', 0
   449 000002E8 2C20417661696C6162- <1> msg_ram_avail	db      ', Available: ', 00h
   450 000002F1 6C653A2000          <1>
   451 000002F6 206B6200            <1> msg_kibx		db      ' kb', 00h
   452                              <1> 
   453 000002FA 206B620D0A00        <1> msg_kib			db      ' kb', 0Dh, 0Ah, 00h
   454                              <1> 
   455 00000300 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   456 00000309 65642C207072657373- <1>
   457 00000312 20616E79206B657920- <1>
   458 0000031B 746F20747279206167- <1>
   459 00000324 61696E2E2E2E0D0A00  <1>
   460 0000032D 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   461 00000336 5349430D0A00        <1>
   462 0000033C 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   463 00000345 5320657874656E7369- <1>
   464 0000034E 6F6E20524F4D206174- <1>
   465 00000357 2000                <1>
   466 00000359 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   467 00000362 6C697A696E672E2E2E- <1>
   468 0000036B 0D0A00              <1>
   469 0000036E 426F6F74696E67204F- <1> msg_boot		db      'Booting OS...', 0Dh, 0Ah, 0
   470 00000377 532E2E2E0D0A00      <1>
   471 0000037E 4552524F523A205254- <1> msg_rtc_bad		db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   472 00000387 432062617474657279- <1>
   473 00000390 206973206261640D0A- <1>
   474 00000399 00                  <1>
   475 0000039A 4552524F523A204E56- <1> msg_rtc_sum		db	'ERROR: NVRAM checksum is invalid, '
   476 000003A3 52414D20636865636B- <1>
   477 000003AC 73756D20697320696E- <1>
   478 000003B5 76616C69642C20      <1>
   479 000003BC 6C6F6164696E672064- <1> 				db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   480 000003C5 656661756C74207661- <1>
   481 000003CE 6C75657320746F204E- <1>
   482 000003D7 5652414D0D0A00      <1>
   483 000003DE 507265737320463120- <1> msg_setup		db	'Press F1 to run NVRAM setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   484 000003E7 746F2072756E204E56- <1>
   485 000003F0 52414D207365747570- <1>
   486 000003F9 2E2E2E0D0A0D0A00    <1>
   487 00000401 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the NVRAM setup utility', 00h
   488 0000040A 20746F20746865204E- <1>
   489 00000413 5652414D2073657475- <1>
   490 0000041C 70207574696C697479- <1>
   491 00000425 00                  <1>
   492 00000426 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   493 00000428 4E5652414D20736574- <1> 				db	'NVRAM setup commands:', 0Dh, 0Ah
   494 00000431 757020636F6D6D616E- <1>
   495 0000043A 64733A0D0A          <1>
   496 0000043F 74202D205365742074- <1> 				db	't - Set time', 0Dh, 0Ah
   497 00000448 696D650D0A          <1>
   498 0000044D 64202D205365742064- <1> 				db	'd - Set date', 0Dh, 0Ah
   499 00000456 6174650D0A          <1>
   500 0000045B 66202D204368616E67- <1> 				db	'f - Change first floppy drive type', 0Dh, 0Ah
   501 00000464 652066697273742066- <1>
   502 0000046D 6C6F70707920647269- <1>
   503 00000476 766520747970650D0A  <1>
   504 0000047F 67202D204368616E67- <1> 				db	'g - Change second floppy drive type', 0Dh, 0Ah
   505 00000488 65207365636F6E6420- <1>
   506 00000491 666C6F707079206472- <1>
   507 0000049A 69766520747970650D- <1>
   508 000004A3 0A                  <1>
   509 000004A4 70202D205072696E74- <1> 				db	'p - Print current settings', 0Dh, 0Ah
   510 000004AD 2063757272656E7420- <1>
   511 000004B6 73657474696E67730D- <1>
   512 000004BF 0A                  <1>
   513 000004C0 77202D205361766520- <1> 				db	'w - Save changes and exit', 0Dh, 0Ah
   514 000004C9 6368616E6765732061- <1>
   515 000004D2 6E6420657869740D0A  <1>
   516 000004DB 71202D204578697420- <1> 				db	'q - Exit without saving changes', 0Dh, 0Ah
   517 000004E4 776974686F75742073- <1>
   518 000004ED 6176696E6720636861- <1>
   519 000004F6 6E6765730D0A        <1>
   520 000004FC 68202D2053686F7720- <1> 				db	'h - Show this help', 0Dh, 0Ah, 00h
   521 00000505 746869732068656C70- <1>
   522 0000050E 0D0A00              <1>
   523 00000511 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   524 0000051A 6F6D6D616E64202868- <1>
   525 00000523 20666F722068656C70- <1>
   526 0000052C 293A2000            <1>
   527 00000530 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   528 00000539 65202868683A6D6D3A- <1>
   529 00000542 7373293A2000        <1>
   530 00000548 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   531 00000551 652028595959592D4D- <1>
   532 0000055A 4D2D4444293A2000    <1>
   533 00000562 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   534 0000056B 76616C69642074696D- <1>
   535 00000574 652E0D0A00          <1>
   536 00000579 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   537 00000582 76616C696420646174- <1>
   538 0000058B 652E0D0A00          <1>
   539 00000590 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   540 00000592 466C6F707079206472- <1> 				db	'Floppy drive types:', 0Dh, 0Ah
   541 0000059B 697665207479706573- <1>
   542 000005A4 3A0D0A              <1>
   543 000005A7 30202D204E6F742069- <1> 				db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   544 000005B0 6E7374616C6C656420- <1>
   545 000005B9 202033202D20373230- <1>
   546 000005C2 204B422C20332E3522- <1>
   547 000005CB 0D0A                <1>
   548 000005CD 31202D20333630204B- <1> 				db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   549 000005D6 422C20352E32352220- <1>
   550 000005DF 202034202D20312E34- <1>
   551 000005E8 34204D422C20332E35- <1>
   552 000005F1 220D0A              <1>
   553 000005F4 32202D20312E32204D- <1> 				db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah
   554 000005FD 422C20352E32352220- <1>
   555 00000606 202036202D20322E38- <1>
   556 0000060F 38204D422C20332E35- <1>
   557 00000618 220D0A              <1>
   558 0000061B 536574757020636F6D- <1> 				db	'Setup commands:', 0Dh, 0Ah
   559 00000624 6D616E64733A0D0A    <1>
   560 0000062C 72202D205265747572- <1> 				db	'r - Return to the main menu', 0Dh, 0Ah
   561 00000635 6E20746F2074686520- <1>
   562 0000063E 6D61696E206D656E75- <1>
   563 00000647 0D0A                <1>
   564 00000649 68202D2053686F7720- <1> 				db	'h - Show this help', 0Dh, 0Ah, 00h
   565 00000652 746869732068656C70- <1>
   566 0000065B 0D0A00              <1>
   567 0000065E 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   568 00000667 6C6F70707920647269- <1>
   569 00000670 766520747970652028- <1>
   570 00000679 6820666F722068656C- <1>
   571 00000682 70293A20            <1>
   572 00000686 00                  <1> 		db	00h
   573 00000687 [8B00]              <1> tbl_floppy	dw	msg_none
   574 00000689 [C901]              <1> 		dw	msg_floppy_360
   575 0000068B [D701]              <1> 		dw	msg_floppy_1200
   576 0000068D [E501]              <1> 		dw	msg_floppy_720
   577 0000068F [F201]              <1> 		dw	msg_floppy_1440
   578 00000691 [8B00]              <1> 		dw	msg_none
   579 00000693 [0002]              <1> 		dw	msg_floppy_2880
   580 00000695 [8B00]              <1> 		dw	msg_none
   581                                  %include	"fnt80-FF.inc"		; font for graphics modes
   582                              <1> ;=========================================================================
   583                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   584                              <1> ;       Characters from 80h to 0FFh
   585                              <1> ;-------------------------------------------------------------------------
   586                              <1> ;
   587                              <1> ; Compiles with NASM 2.07, might work with other versions
   588                              <1> ;
   589                              <1> ; This font is borrowed from kbd package (alt-8x8)
   590                              <1> ;
   591                              <1> ; This program is free software: you can redistribute it and/or modify
   592                              <1> ; it under the terms of the GNU General Public License as published by
   593                              <1> ; the Free Software Foundation, either version 3 of the License, or
   594                              <1> ; (at your option) any later version.
   595                              <1> ;
   596                              <1> ; This program is distributed in the hope that it will be useful,
   597                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   598                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   599                              <1> ; GNU General Public License for more details.
   600                              <1> ;
   601                              <1> ; You should have received a copy of the GNU General Public License
   602                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   603                              <1> ;
   604                              <1> ;=========================================================================
   605                              <1> int_1F:
   606 00000697 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   607 0000069F 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   608 000006A7 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   609 000006AF 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   610 000006B7 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   611 000006BF 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   612 000006C7 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   613 000006CF 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   614 000006D7 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   615 000006DF 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   616 000006E7 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   617 000006EF 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   618 000006F7 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   619 000006FF 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   620 00000707 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   621 0000070F 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   622 00000717 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   623 0000071F 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   624 00000727 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   625 0000072F 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   626 00000737 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   627 0000073F 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   628 00000747 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   629 0000074F 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   630 00000757 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   631 0000075F DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   632 00000767 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   633 0000076F C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   634 00000777 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   635 0000077F 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   636 00000787 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   637 0000078F 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   638 00000797 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   639 0000079F 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   640 000007A7 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   641 000007AF 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   642 000007B7 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   643 000007BF 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   644 000007C7 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   645 000007CF 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   646 000007D7 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   647 000007DF 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   648 000007E7 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   649 000007EF 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   650 000007F7 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   651 000007FF 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   652 00000807 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   653 0000080F 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   654 00000817 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   655 0000081F 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   656 00000827 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   657 0000082F 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   658 00000837 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   659 0000083F 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   660 00000847 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   661 0000084F 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   662 00000857 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   663 0000085F 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   664 00000867 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   665 0000086F 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   666 00000877 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   667 0000087F 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   668 00000887 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   669 0000088F 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   670 00000897 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   671 0000089F 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   672 000008A7 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   673 000008AF 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   674 000008B7 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   675 000008BF 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   676 000008C7 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   677 000008CF 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   678 000008D7 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   679 000008DF 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   680 000008E7 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   681 000008EF 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   682 000008F7 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   683 000008FF 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   684 00000907 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   685 0000090F 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   686 00000917 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   687 0000091F 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   688 00000927 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   689 0000092F 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   690 00000937 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   691 0000093F 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   692 00000947 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   693 0000094F 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   694 00000957 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   695 0000095F 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   696 00000967 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   697 0000096F FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   698 00000977 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   699 0000097F F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   700 00000987 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   701 0000098F FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   702 00000997 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   703 0000099F 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   704 000009A7 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   705 000009AF 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   706 000009B7 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   707 000009BF 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   708 000009C7 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   709 000009CF 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   710 000009D7 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   711 000009DF 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   712 000009E7 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   713 000009EF 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   714 000009F7 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   715 000009FF 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   716 00000A07 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   717 00000A0F 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   718 00000A17 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   719 00000A1F 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   720 00000A27 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   721 00000A2F 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   722 00000A37 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   723 00000A3F 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   724 00000A47 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   725 00000A4F 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   726 00000A57 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   727 00000A5F 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   728 00000A67 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   729 00000A6F 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   730 00000A77 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   731 00000A7F 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   732 00000A87 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   733 00000A8F 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   734                                  ;%include	"inttrace.inc"		; XXX
   735                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   736                              <1> ;=========================================================================
   737                              <1> ; rtc.inc - RTC/CMOS read and write functions
   738                              <1> ;-------------------------------------------------------------------------
   739                              <1> ;
   740                              <1> ; Compiles with NASM 2.07, might work with other versions
   741                              <1> ;
   742                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
   743                              <1> ; Provided for hobbyist use on the Xi 8088 board.
   744                              <1> ;
   745                              <1> ; This program is free software: you can redistribute it and/or modify
   746                              <1> ; it under the terms of the GNU General Public License as published by
   747                              <1> ; the Free Software Foundation, either version 3 of the License, or
   748                              <1> ; (at your option) any later version.
   749                              <1> ;
   750                              <1> ; This program is distributed in the hope that it will be useful,
   751                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   752                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   753                              <1> ; GNU General Public License for more details.
   754                              <1> ;
   755                              <1> ; You should have received a copy of the GNU General Public License
   756                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   757                              <1> ;
   758                              <1> ;=========================================================================
   759                              <1> 
   760                              <1> ;-------------------------------------------------------------------------
   761                              <1> ; RTC ports
   762                              <1> rtc_addr_reg	equ	70h	; RTC address port
   763                              <1> rtc_data_reg	equ	71h	; RTC data port
   764                              <1> 
   765                              <1> ;-------------------------------------------------------------------------
   766                              <1> ; locations in RTC and NVRAM
   767                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   768                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   769                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   770                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   771                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   772                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   773                              <1> cmos_day	equ	06h	; day location in RTC
   774                              <1> cmos_date	equ	07h	; date location in RTC
   775                              <1> cmos_month	equ	08h	; month location in RTC
   776                              <1> cmos_year	equ	09h	; year location in RTC
   777                              <1> cmos_floppy	equ	10h	; floppy type byte
   778                              <1> cmos_equip	equ	14h	; equipment byte
   779                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   780                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   781                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   782                              <1> 
   783                              <1> ;-------------------------------------------------------------------------
   784                              <1> ; RTC control register and their bits
   785                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   786                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   787                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   788                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   789                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   790                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   791                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   792                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   793                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   794                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   795                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   796                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   797                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   798                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   799                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   800                              <1> 
   801                              <1> ;-------------------------------------------------------------------------
   802                              <1> ; NMI flag
   803                              <1> nmi_disable	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   804                              <1> nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   805                              <1> 
   806                              <1> ;=========================================================================
   807                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   808                              <1> ; Input:
   809                              <1> ;	AL - address and NMI enable bit
   810                              <1> ;		bits 6-0 - address of byte to read
   811                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   812                              <1> ; Output:
   813                              <1> ;	AL = byte from RTC
   814                              <1> ;-------------------------------------------------------------------------
   815                              <1> rtc_read:
   816 00000A97 FA                  <1> 	cli
   817 00000A98 E670                <1> 	out	rtc_addr_reg,al
   818 00000A9A EB00                <1> 	jmp	$+2
   819 00000A9C EB00                <1> 	jmp	$+2
   820                              <1> 	;; SGEO increased pause here, seems to fix my FF byte issue...
   821 00000A9E EB00                <1> 	jmp	$+2
   822 00000AA0 EB00                <1> 	jmp	$+2
   823 00000AA2 E471                <1> 	in	al,rtc_data_reg
   824 00000AA4 FB                  <1> 	sti
   825 00000AA5 C3                  <1> 	ret
   826                              <1> 
   827                              <1> ;=========================================================================
   828                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   829                              <1> ; Input:
   830                              <1> ;	AL - address and NMI enable bit
   831                              <1> ;		bits 6-0 - address of byte to read
   832                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   833                              <1> ;	AH = byte to write to RTC
   834                              <1> ;-------------------------------------------------------------------------
   835                              <1> rtc_write:
   836 00000AA6 FA                  <1> 	cli
   837 00000AA7 E670                <1> 	out	rtc_addr_reg,al
   838 00000AA9 EB00                <1> 	jmp	$+2
   839 00000AAB EB00                <1> 	jmp	$+2
   840 00000AAD 86E0                <1> 	xchg	ah,al
   841 00000AAF E671                <1> 	out	rtc_data_reg,al
   842 00000AB1 86E0                <1> 	xchg	ah,al
   843 00000AB3 FB                  <1> 	sti
   844 00000AB4 C3                  <1> 	ret
   845                              <1> 
   846                              <1> ;=========================================================================
   847                              <1> ; rtc_init - Initialize RTC
   848                              <1> ; Notes:
   849                              <1> ;	- makes sure RTC battery is OK, resets time if not
   850                              <1> ;	- disables RTC interrupts
   851                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   852                              <1> ;-------------------------------------------------------------------------
   853                              <1> rtc_init:
   854 00000AB5 50                  <1> 	push	ax
   855 00000AB6 53                  <1> 	push	bx
   856 00000AB7 51                  <1> 	push	cx
   857 00000AB8 52                  <1> 	push	dx
   858 00000AB9 56                  <1> 	push	si
   859 00000ABA 57                  <1> 	push	di
   860 00000ABB B00A                <1> 	mov	al,cmos_control_a	; select control A register
   861 00000ABD B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   862                              <1> 					; set SQW frequency to 1.024 KHz
   863 00000ABF E8E4FF              <1> 	call	rtc_write		; write control register A
   864                              <1> 
   865 00000AC2 B00B                <1> 	mov	al,cmos_control_b
   866 00000AC4 B402                <1> 	mov	ah,cmos_24hours		; 24 hours, BCD format, DSE disabled
   867                              <1> 					; interrupts disabled
   868 00000AC6 E8DDFF              <1> 	call	rtc_write		; write control register B
   869                              <1> 
   870 00000AC9 B00C                <1> 	mov	al,cmos_control_c
   871 00000ACB E8C9FF              <1> 	call	rtc_read		; read control register C - reset
   872                              <1> 					; interrupt flags
   873                              <1> 
   874 00000ACE B00D                <1> 	mov	al,cmos_control_d
   875 00000AD0 E8C4FF              <1> 	call	rtc_read		; read control register D
   876 00000AD3 A880                <1> 	test	al,cmos_vrt
   877 00000AD5 7518                <1> 	jnz	.1			; RTC battery is OK
   878 00000AD7 BE[7E03]            <1> 	mov	si,msg_rtc_bad
   879 00000ADA E8B31A              <1> 	call	print
   880                              <1> ; RTC is bad, set initial time
   881 00000ADD B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   882 00000ADF 31C9                <1> 	xor	cx,cx
   883 00000AE1 31D2                <1> 	xor	dx,dx
   884 00000AE3 CD1A                <1> 	int	1Ah
   885 00000AE5 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   886 00000AE7 B91020              <1> 	mov	cx,2010h		; year 2010
   887 00000AEA BA0101              <1> 	mov	dx,0101h		; January 1st
   888 00000AED CD1A                <1> 	int	1Ah
   889                              <1> 
   890                              <1> .1:
   891                              <1> ; set timer variables to RTC time
   892 00000AEF B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   893 00000AF1 CD1A                <1> 	int	1Ah
   894                              <1> 
   895                              <1> ; convert time to ticks * 2^11
   896                              <1> 
   897                              <1> ; ticks = seconds * 37287
   898 00000AF3 88F0                <1> 	mov	al,dh
   899 00000AF5 E8AE00              <1> 	call	bcd_to_binary		; convert seconds to binary
   900                              <1> 
   901 00000AF8 BAA791              <1> 	mov	dx,37287
   902 00000AFB F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   903                              <1> 
   904 00000AFD 89C6                <1> 	mov	si,ax
   905 00000AFF 89D7                <1> 	mov	di,dx
   906                              <1> 
   907                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   908 00000B01 88C8                <1> 	mov	al,cl
   909 00000B03 E8A000              <1> 	call	bcd_to_binary		; convert minutes to binary
   910                              <1> 
   911 00000B06 89C3                <1> 	mov	bx,ax
   912 00000B08 BA2023              <1> 	mov	dx,8992
   913 00000B0B F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   914                              <1> 
   915 00000B0D 01C6                <1> 	add	si,ax
   916 00000B0F 11D7                <1> 	adc	di,dx
   917                              <1> 
   918 00000B11 89D8                <1> 	mov	ax,bx
   919 00000B13 BA2200              <1> 	mov	dx,34
   920 00000B16 F7E2                <1> 	mul	dx
   921                              <1> 
   922 00000B18 01C7                <1> 	add	di,ax
   923                              <1> 
   924                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   925 00000B1A 88E8                <1> 	mov	al,ch
   926 00000B1C E88700              <1> 	call	bcd_to_binary		; convert hours to binary
   927                              <1> 
   928 00000B1F 89C3                <1> 	mov	bx,ax
   929 00000B21 BA6A3B              <1> 	mov	dx,15210
   930 00000B24 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   931                              <1> 
   932 00000B26 01C6                <1> 	add	si,ax
   933 00000B28 11D7                <1> 	adc	di,dx
   934                              <1> 
   935 00000B2A 89D8                <1> 	mov	ax,bx
   936 00000B2C BA0008              <1> 	mov	dx,2048
   937 00000B2F F7E2                <1> 	mul	dx			; AX = hours * 2048
   938                              <1> 
   939 00000B31 01C7                <1> 	add	di,ax
   940                              <1> 
   941                              <1> ; CX:DX = DI:SI / 2048
   942 00000B33 B10B                <1> 	mov	cl,11
   943 00000B35 D3EE                <1> 	shr	si,cl
   944 00000B37 89FA                <1> 	mov	dx,di
   945 00000B39 B105                <1> 	mov	cl,5
   946 00000B3B D3E2                <1> 	shl	dx,cl
   947 00000B3D 09F2                <1> 	or	dx,si
   948                              <1> 
   949 00000B3F B10B                <1> 	mov	cl,11
   950 00000B41 D3EF                <1> 	shr	di,cl
   951 00000B43 89F9                <1> 	mov	cx,di
   952                              <1> 
   953                              <1> 					; CX = high word of tick count
   954                              <1> 					; DX = low word of tick count
   955                              <1> 	
   956 00000B45 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   957 00000B47 CD1A                <1> 	int	1Ah	
   958                              <1> 
   959                              <1> 
   960                              <1> ; compare NVRAM checksum with stored value
   961                              <1> 
   962 00000B49 E86C00              <1> 	call	rtc_checksum
   963                              <1> 
   964 00000B4C B02E                <1> 	mov	al,cmos_sum_hi
   965 00000B4E E846FF              <1> 	call	rtc_read
   966 00000B51 88C4                <1> 	mov	ah,al
   967 00000B53 B02F                <1> 	mov	al,cmos_sum_lo
   968 00000B55 E83FFF              <1> 	call	rtc_read
   969 00000B58 39C3                <1> 	cmp	bx,ax
   970 00000B5A 742F                <1> 	je	.update_equipment
   971                              <1> 
   972 00000B5C BE[9A03]            <1> 	mov	si,msg_rtc_sum
   973 00000B5F E82E1A              <1> 	call	print
   974                              <1> 
   975                              <1> ; clear NVRAM
   976                              <1> 
   977 00000B62 B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   978                              <1> 
   979                              <1> .nvram_clear_loop:
   980 00000B65 E83EFF              <1> 	call	rtc_write
   981 00000B68 FEC0                <1> 	inc	al
   982 00000B6A 3C20                <1> 	cmp	al,20h			; last address is 20h
   983 00000B6C 76F7                <1> 	jbe	.nvram_clear_loop
   984                              <1> 
   985 00000B6E B81040              <1> 	mov	ax,4010h		; one 1.44M floppy disk
   986 00000B71 E832FF              <1> 	call	rtc_write
   987                              <1> 
   988 00000B74 B81421              <1> 	mov	ax,2114h		; color 80x25, one floppy disk
   989 00000B77 E82CFF              <1> 	call	rtc_write
   990                              <1> 
   991                              <1> ; update checksum
   992                              <1> 
   993 00000B7A E83B00              <1> 	call	rtc_checksum
   994                              <1> 
   995 00000B7D B02E                <1> 	mov	al,cmos_sum_hi
   996 00000B7F 88FC                <1> 	mov	ah,bh
   997 00000B81 E822FF              <1> 	call	rtc_write
   998                              <1> 
   999 00000B84 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1000 00000B86 88DC                <1> 	mov	ah,bl
  1001 00000B88 E81BFF              <1> 	call	rtc_write
  1002                              <1> 
  1003                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
  1004                              <1> 
  1005                              <1> .update_equipment:
  1006 00000B8B B014                <1> 	mov	al,cmos_equip
  1007 00000B8D E807FF              <1> 	call	rtc_read
  1008 00000B90 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
  1009 00000B92 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
  1010 00000B97 08061000            <1> 	or	byte [equipment_list],al
  1011                              <1> 
  1012 00000B9B B020                <1> 	mov	al,e_rtc_init_ok	; RTC initialzied successfully
  1013 00000B9D E680                <1> 	out	post_reg,al
  1014                              <1> 
  1015 00000B9F 5F                  <1> 	pop	di
  1016 00000BA0 5E                  <1> 	pop	si
  1017 00000BA1 5A                  <1> 	pop	dx
  1018 00000BA2 59                  <1> 	pop	cx
  1019 00000BA3 5B                  <1> 	pop	bx
  1020 00000BA4 58                  <1> 	pop	ax
  1021 00000BA5 C3                  <1> 	ret
  1022                              <1> 
  1023                              <1> bcd_to_binary:
  1024 00000BA6 51                  <1> 	push	cx
  1025 00000BA7 88C5                <1> 	mov	ch,al
  1026 00000BA9 80E50F              <1> 	and	ch,0Fh
  1027 00000BAC B104                <1> 	mov	cl,4
  1028 00000BAE D2E8                <1> 	shr	al,cl
  1029 00000BB0 B10A                <1> 	mov	cl,10
  1030 00000BB2 F6E1                <1> 	mul	cl
  1031 00000BB4 00E8                <1> 	add	al,ch
  1032 00000BB6 59                  <1> 	pop	cx
  1033 00000BB7 C3                  <1> 	ret
  1034                              <1> 
  1035                              <1> ;=========================================================================
  1036                              <1> ; rtc_checksum - calculate NVRAM checksum
  1037                              <1> ; Input:
  1038                              <1> ;	none
  1039                              <1> ; Output:
  1040                              <1> ;	BX = NVRAM checksum
  1041                              <1> ;-------------------------------------------------------------------------
  1042                              <1> rtc_checksum:
  1043 00000BB8 50                  <1> 	push	ax
  1044 00000BB9 31DB                <1> 	xor	bx,bx
  1045 00000BBB B410                <1> 	mov	ah,10h			; start from 10h
  1046                              <1> 
  1047                              <1> .checksum_loop:
  1048 00000BBD 88E0                <1> 	mov	al,ah
  1049 00000BBF E8D5FE              <1> 	call	rtc_read
  1050 00000BC2 00C3                <1> 	add	bl,al			; BX += AL
  1051 00000BC4 80D700              <1> 	adc	bh,0
  1052 00000BC7 FEC4                <1> 	inc	ah
  1053 00000BC9 80FC20              <1> 	cmp	ah,20h			; last address is 20h
  1054 00000BCC 76EF                <1> 	jbe	.checksum_loop
  1055 00000BCE 58                  <1> 	pop	ax
  1056 00000BCF C3                  <1> 	ret
  1057                              <1> 
  1058                              <1> ;=========================================================================
  1059                              <1> ; rtc_setup - NVRAM configuration utility
  1060                              <1> ; Input:
  1061                              <1> ;	none
  1062                              <1> ; Output:
  1063                              <1> ;	none
  1064                              <1> ;-------------------------------------------------------------------------
  1065                              <1> rtc_setup:
  1066 00000BD0 50                  <1> 	push	ax
  1067 00000BD1 53                  <1> 	push	bx
  1068 00000BD2 51                  <1> 	push	cx
  1069 00000BD3 52                  <1> 	push	dx
  1070 00000BD4 56                  <1> 	push	si
  1071                              <1> 
  1072 00000BD5 B010                <1> 	mov	al,cmos_floppy
  1073 00000BD7 E8BDFE              <1> 	call	rtc_read		; read currently configured floppies
  1074 00000BDA 88C1                <1> 	mov	cl,al			; save it to CL
  1075 00000BDC BE[0104]            <1> 	mov	si,msg_set_welcome
  1076 00000BDF E8AE19              <1> 	call	print
  1077                              <1> 
  1078                              <1> .menu_loop:
  1079 00000BE2 BE[1105]            <1> 	mov	si,msg_set_prompt
  1080 00000BE5 E8A819              <1> 	call	print
  1081                              <1> 
  1082                              <1> .menu_input:
  1083 00000BE8 B400                <1> 	mov	ah,00h
  1084 00000BEA CD16                <1> 	int	16h
  1085 00000BEC 0C20                <1> 	or	al,20h			; convert to lower case
  1086 00000BEE B200                <1> 	mov	dl,0			; floppy 0
  1087 00000BF0 3C66                <1> 	cmp	al,'f'
  1088 00000BF2 743E                <1> 	je	.set_floppy
  1089 00000BF4 FEC2                <1> 	inc	dl			; floppy 1
  1090 00000BF6 3C67                <1> 	cmp	al,'g'
  1091 00000BF8 7438                <1> 	je	.set_floppy
  1092 00000BFA 3C70                <1> 	cmp	al,'p'
  1093 00000BFC 7503E99100          <1> 	je	.print_settings
  1094 00000C01 3C74                <1> 	cmp	al,'t'
  1095 00000C03 7503E9A200          <1> 	je	.set_time
  1096 00000C08 3C64                <1> 	cmp	al,'d'
  1097 00000C0A 7503E91301          <1> 	je	.set_date
  1098 00000C0F 3C77                <1> 	cmp	al,'w'
  1099 00000C11 7503E9D401          <1> 	je	.save
  1100 00000C16 3C71                <1> 	cmp	al,'q'
  1101 00000C18 7503E90702          <1> 	je	.exit
  1102 00000C1D 3C68                <1> 	cmp	al,'h'
  1103 00000C1F 7402                <1> 	je	.help
  1104 00000C21 EBC5                <1> 	jmp	.menu_input
  1105                              <1> 
  1106                              <1> .help:
  1107 00000C23 B40E                <1> 	mov	ah,0Eh			; echo
  1108 00000C25 BB0700              <1> 	mov	bx,0007h
  1109 00000C28 CD10                <1> 	int	10h
  1110 00000C2A BE[2604]            <1> 	mov	si,msg_set_help
  1111 00000C2D E86019              <1> 	call	print
  1112 00000C30 EBB0                <1> 	jmp	.menu_loop
  1113                              <1> 
  1114                              <1> .set_floppy:
  1115 00000C32 B40E                <1> 	mov	ah,0Eh			; echo
  1116 00000C34 BB0700              <1> 	mov	bx,0007h
  1117 00000C37 CD10                <1> 	int	10h
  1118                              <1> 
  1119                              <1> .set_floppy_prompt:
  1120 00000C39 BE[5E06]            <1> 	mov	si,msg_set_fd_prmt
  1121 00000C3C E85119              <1> 	call	print
  1122                              <1> 
  1123                              <1> .floppy_input:
  1124 00000C3F B400                <1> 	mov	ah,00h
  1125 00000C41 CD16                <1> 	int	16h
  1126 00000C43 0C20                <1> 	or	al,20h			; convert to lower case
  1127 00000C45 3C72                <1> 	cmp	al,'r'
  1128 00000C47 7430                <1> 	je	.floppy_exit
  1129 00000C49 3C68                <1> 	cmp	al,'h'
  1130 00000C4B 7436                <1> 	je	.floppy_help
  1131 00000C4D 3C30                <1> 	cmp	al,'0'
  1132 00000C4F 72EE                <1> 	jb	.floppy_input
  1133 00000C51 3C36                <1> 	cmp	al,'6'
  1134 00000C53 77EA                <1> 	ja	.floppy_input
  1135 00000C55 3C35                <1> 	cmp	al,'5'
  1136 00000C57 74E6                <1> 	je	.floppy_input
  1137 00000C59 B40E                <1> 	mov	ah,0Eh			; echo
  1138 00000C5B BB0700              <1> 	mov	bx,0007h
  1139 00000C5E CD10                <1> 	int	10h
  1140 00000C60 2C30                <1> 	sub	al,'0'
  1141 00000C62 B6F0                <1> 	mov	dh,0F0h
  1142 00000C64 08D2                <1> 	or	dl,dl			; drive	0?
  1143 00000C66 750A                <1> 	jnz	.drive_1
  1144 00000C68 D0E0                <1> 	shl	al,1
  1145 00000C6A D0E0                <1> 	shl	al,1
  1146 00000C6C D0E0                <1> 	shl	al,1
  1147 00000C6E D0E0                <1> 	shl	al,1
  1148 00000C70 B60F                <1> 	mov	dh,0Fh
  1149                              <1> .drive_1:
  1150 00000C72 20F1                <1> 	and	cl,dh
  1151 00000C74 08C1                <1> 	or	cl,al
  1152 00000C76 E969FF              <1> 	jmp	.menu_loop
  1153                              <1> 
  1154                              <1> .floppy_exit:
  1155 00000C79 B40E                <1> 	mov	ah,0Eh			; echo
  1156 00000C7B BB0700              <1> 	mov	bx,0007h
  1157 00000C7E CD10                <1> 	int	10h
  1158 00000C80 E95FFF              <1> 	jmp	.menu_loop
  1159                              <1> 
  1160                              <1> .floppy_help:
  1161 00000C83 B40E                <1> 	mov	ah,0Eh			; echo
  1162 00000C85 BB0700              <1> 	mov	bx,0007h
  1163 00000C88 CD10                <1> 	int	10h
  1164 00000C8A BE[9005]            <1> 	mov	si,msg_set_fd_help
  1165 00000C8D E80019              <1> 	call	print
  1166 00000C90 EBA7                <1> 	jmp	.set_floppy_prompt
  1167                              <1> 
  1168                              <1> .print_settings:
  1169 00000C92 B40E                <1> 	mov	ah,0Eh			; echo
  1170 00000C94 BB0700              <1> 	mov	bx,0007h
  1171 00000C97 CD10                <1> 	int	10h
  1172 00000C99 BE[8800]            <1> 	mov	si,msg_crlf
  1173 00000C9C E8F118              <1> 	call	print
  1174 00000C9F E89501              <1> 	call	print_rtc		; print current RTC time
  1175 00000CA2 88C8                <1> 	mov	al,cl			; floppy bytes to AL
  1176 00000CA4 E8580B              <1> 	call	print_floppy
  1177 00000CA7 E938FF              <1> 	jmp	.menu_loop
  1178                              <1> 
  1179                              <1> .set_time:
  1180 00000CAA 51                  <1> 	push	cx
  1181 00000CAB 57                  <1> 	push	di
  1182 00000CAC 06                  <1> 	push	es
  1183 00000CAD B40E                <1> 	mov	ah,0Eh			; echo
  1184 00000CAF BB0700              <1> 	mov	bx,0007h
  1185 00000CB2 CD10                <1> 	int	10h
  1186 00000CB4 BE[8800]            <1> 	mov	si,msg_crlf
  1187 00000CB7 E8D618              <1> 	call	print
  1188                              <1> 
  1189 00000CBA BE[3005]            <1> 	mov	si,msg_set_time
  1190 00000CBD E8D018              <1> 	call	print
  1191                              <1> 
  1192 00000CC0 B402                <1> 	mov	ah,02h
  1193 00000CC2 CD1A                <1> 	int	1Ah			; get current time
  1194                              <1> 
  1195 00000CC4 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1196 00000CC7 8EC0                <1> 	mov	es,ax
  1197 00000CC9 31FF                <1> 	xor	di,di
  1198 00000CCB B80800              <1> 	mov	ax,8			; length of the time string
  1199                              <1> 
  1200 00000CCE E80718              <1> 	call	get_line
  1201                              <1> 
  1202 00000CD1 09C0                <1> 	or	ax,ax			; empty string?
  1203 00000CD3 743F                <1> 	jz	.set_time_exit
  1204                              <1> 
  1205 00000CD5 E87218              <1> 	call	atoi
  1206                              <1> 
  1207 00000CD8 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
  1208 00000CDB 773D                <1> 	ja	.set_time_invalid
  1209                              <1> 
  1210 00000CDD E88F18              <1> 	call	bin_to_bcd		; convert to BCD
  1211                              <1> 
  1212 00000CE0 88C5                <1> 	mov	ch,al			; CH = hours
  1213                              <1> 
  1214 00000CE2 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1215 00000CE6 7532                <1> 	jne	.set_time_invalid
  1216                              <1> 
  1217 00000CE8 47                  <1> 	inc	di
  1218                              <1> 
  1219 00000CE9 E85E18              <1> 	call	atoi
  1220                              <1> 
  1221 00000CEC 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
  1222 00000CEF 7729                <1> 	ja	.set_time_invalid
  1223                              <1> 
  1224 00000CF1 E87B18              <1> 	call	bin_to_bcd
  1225                              <1> 
  1226 00000CF4 88C1                <1> 	mov	cl,al			; CL = minutes
  1227                              <1> 
  1228 00000CF6 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
  1229 00000CFA 751E                <1> 	jne	.set_time_invalid
  1230                              <1> 
  1231 00000CFC 47                  <1> 	inc	di
  1232                              <1> 
  1233 00000CFD E84A18              <1> 	call	atoi
  1234                              <1> 
  1235 00000D00 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
  1236 00000D03 7715                <1> 	ja	.set_time_invalid
  1237                              <1> 
  1238 00000D05 E86718              <1> 	call	bin_to_bcd
  1239                              <1> 
  1240 00000D08 88C6                <1> 	mov	dh,al			; DH = seconds
  1241                              <1> 
  1242 00000D0A 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1243 00000D0E 750A                <1> 	jne	.set_time_invalid
  1244                              <1> 
  1245 00000D10 B403                <1> 	mov	ah,03h			; set RTC time
  1246 00000D12 CD1A                <1> 	int	1Ah
  1247                              <1> 
  1248                              <1> .set_time_exit:
  1249 00000D14 07                  <1> 	pop	es
  1250 00000D15 5F                  <1> 	pop	di
  1251 00000D16 59                  <1> 	pop	cx
  1252 00000D17 E9C8FE              <1> 	jmp	.menu_loop
  1253                              <1> 
  1254                              <1> .set_time_invalid:
  1255 00000D1A BE[6205]            <1> 	mov	si,msg_time_inval
  1256 00000D1D E87018              <1> 	call	print
  1257 00000D20 EBF2                <1> 	jmp	.set_time_exit
  1258                              <1> 
  1259                              <1> .set_date:
  1260 00000D22 51                  <1> 	push	cx
  1261 00000D23 57                  <1> 	push	di
  1262 00000D24 06                  <1> 	push	es
  1263 00000D25 B40E                <1> 	mov	ah,0Eh			; echo
  1264 00000D27 BB0700              <1> 	mov	bx,0007h
  1265 00000D2A CD10                <1> 	int	10h
  1266 00000D2C BE[8800]            <1> 	mov	si,msg_crlf
  1267 00000D2F E85E18              <1> 	call	print
  1268 00000D32 BE[4805]            <1> 	mov	si,msg_set_date
  1269 00000D35 E85818              <1> 	call	print
  1270                              <1> 
  1271 00000D38 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
  1272 00000D3B 8EC0                <1> 	mov	es,ax
  1273 00000D3D 31FF                <1> 	xor	di,di
  1274 00000D3F B80A00              <1> 	mov	ax,10			; length of the date string
  1275                              <1> 
  1276 00000D42 E89317              <1> 	call	get_line
  1277                              <1> 
  1278 00000D45 09C0                <1> 	or	ax,ax			; empty string?
  1279 00000D47 7503E99000          <1> 	jz	.set_date_exit
  1280                              <1> 
  1281 00000D4C E8FB17              <1> 	call	atoi
  1282                              <1> 
  1283 00000D4F 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
  1284 00000D52 7603E98B00          <1> 	ja	.set_date_invalid
  1285                              <1> 
  1286 00000D57 89C3                <1> 	mov	bx,ax			; store binary year in BX
  1287                              <1> 
  1288 00000D59 E81318              <1> 	call	bin_to_bcd		; convert to BCD
  1289                              <1> 
  1290 00000D5C 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
  1291                              <1> 	
  1292 00000D5E 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1293 00000D62 757E                <1> 	jne	.set_date_invalid
  1294                              <1> 
  1295 00000D64 47                  <1> 	inc	di
  1296                              <1> 
  1297 00000D65 E8E217              <1> 	call	atoi
  1298                              <1> 
  1299 00000D68 83F801              <1> 	cmp	ax,1			; month is lower than 1?
  1300 00000D6B 7275                <1> 	jb	.set_date_invalid
  1301                              <1> 
  1302 00000D6D 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
  1303 00000D70 7770                <1> 	ja	.set_date_invalid
  1304                              <1> 
  1305 00000D72 E8FA17              <1> 	call	bin_to_bcd
  1306                              <1> 
  1307 00000D75 88C6                <1> 	mov	dh,al			; DH = month
  1308                              <1> 
  1309 00000D77 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
  1310 00000D7B 7565                <1> 	jne	.set_date_invalid
  1311                              <1> 
  1312 00000D7D 47                  <1> 	inc	di
  1313                              <1> 
  1314 00000D7E E8C917              <1> 	call	atoi
  1315                              <1> 
  1316 00000D81 83F801              <1> 	cmp	ax,1			; day is lower than 1?
  1317 00000D84 725C                <1> 	jb	.set_date_invalid
  1318                              <1> 
  1319 00000D86 80FE02              <1> 	cmp	dh,02h			; February
  1320 00000D89 7430                <1> 	je	.set_date_february
  1321                              <1> 
  1322 00000D8B 80FE04              <1> 	cmp	dh,04h			; April
  1323 00000D8E 7416                <1> 	je	.set_date_30_days
  1324                              <1> 
  1325 00000D90 80FE06              <1> 	cmp	dh,06h			; July
  1326 00000D93 7411                <1> 	je	.set_date_30_days
  1327                              <1> 
  1328 00000D95 80FE09              <1> 	cmp	dh,09h			; September
  1329 00000D98 740C                <1> 	je	.set_date_30_days
  1330                              <1> 
  1331 00000D9A 80FE11              <1> 	cmp	dh,11h			; November
  1332 00000D9D 7407                <1> 	je	.set_date_30_days
  1333                              <1> 
  1334                              <1> .set_date_31_days:
  1335 00000D9F 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
  1336 00000DA2 773E                <1> 	ja	.set_date_invalid
  1337 00000DA4 EB27                <1> 	jmp	.set_date_set_day
  1338                              <1> 
  1339                              <1> .set_date_30_days:
  1340 00000DA6 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
  1341 00000DA9 7737                <1> 	ja	.set_date_invalid
  1342 00000DAB EB20                <1> 	jmp	.set_date_set_day
  1343                              <1> 
  1344                              <1> .set_date_29_days:
  1345 00000DAD 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
  1346 00000DB0 7730                <1> 	ja	.set_date_invalid
  1347 00000DB2 EB19                <1> 	jmp	.set_date_set_day
  1348                              <1> 
  1349                              <1> .set_date_28_days:
  1350 00000DB4 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
  1351 00000DB7 7729                <1> 	ja	.set_date_invalid
  1352 00000DB9 EB12                <1> 	jmp	.set_date_set_day
  1353                              <1> 
  1354                              <1> .set_date_february:
  1355 00000DBB F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
  1356 00000DBF 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
  1357                              <1> 
  1358 00000DC1 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
  1359 00000DC4 75E7                <1> 	jne	.set_date_29_days	; a leap year
  1360                              <1> 
  1361 00000DC6 F6C503              <1> 	test	ch,03h			; check if century divides by 4
  1362 00000DC9 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
  1363 00000DCB EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
  1364                              <1> 
  1365                              <1> .set_date_set_day:
  1366 00000DCD E89F17              <1> 	call	bin_to_bcd
  1367                              <1> 
  1368 00000DD0 88C2                <1> 	mov	dl,al			; DL = date (day of month)
  1369                              <1> 
  1370 00000DD2 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
  1371 00000DD6 750A                <1> 	jne	.set_date_invalid
  1372                              <1> 
  1373 00000DD8 B405                <1> 	mov	ah,05h			; set RTC date
  1374 00000DDA CD1A                <1> 	int	1Ah
  1375                              <1> 
  1376                              <1> .set_date_exit:
  1377 00000DDC 07                  <1> 	pop	es
  1378 00000DDD 5F                  <1> 	pop	di
  1379 00000DDE 59                  <1> 	pop	cx
  1380 00000DDF E900FE              <1> 	jmp	.menu_loop
  1381                              <1> 
  1382                              <1> .set_date_invalid:
  1383 00000DE2 BE[7905]            <1> 	mov	si,msg_date_inval
  1384 00000DE5 E8A817              <1> 	call	print
  1385 00000DE8 EBF2                <1> 	jmp	.set_date_exit
  1386                              <1> 
  1387                              <1> .save:
  1388 00000DEA 50                  <1> 	push	ax
  1389                              <1> 
  1390 00000DEB B010                <1> 	mov	al,cmos_floppy
  1391 00000DED 88CC                <1> 	mov	ah,cl
  1392 00000DEF E8B4FC              <1> 	call	rtc_write
  1393                              <1> 
  1394 00000DF2 8A261000            <1> 	mov	ah,byte [equipment_list]
  1395 00000DF6 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
  1396                              <1> 
  1397 00000DF9 F6C170              <1> 	test	cl,70h
  1398 00000DFC 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
  1399 00000DFE 80CC01              <1> 	or	ah,01h			; first floppy is installed
  1400                              <1> 
  1401                              <1> .second_floppy:
  1402 00000E01 F6C107              <1> 	test	cl,07h
  1403 00000E04 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
  1404 00000E06 80CC41              <1> 	or	ah,41h			; indicate two floppies
  1405                              <1> 					; (even if the first one is missing)
  1406                              <1> 
  1407                              <1> .save_equipment:
  1408 00000E09 88261000            <1> 	mov	byte [equipment_list],ah
  1409 00000E0D B014                <1> 	mov	al,cmos_equip
  1410 00000E0F E894FC              <1> 	call	rtc_write
  1411                              <1> 
  1412 00000E12 E8A3FD              <1> 	call	rtc_checksum
  1413                              <1> 
  1414 00000E15 B02E                <1> 	mov	al,cmos_sum_hi
  1415 00000E17 88FC                <1> 	mov	ah,bh
  1416 00000E19 E88AFC              <1> 	call	rtc_write
  1417                              <1> 
  1418 00000E1C FEC0                <1> 	inc	al			; AL = cmos_sum_lo
  1419 00000E1E 88DC                <1> 	mov	ah,bl
  1420 00000E20 E883FC              <1> 	call	rtc_write
  1421                              <1> 	
  1422 00000E23 58                  <1> 	pop	ax
  1423                              <1> 
  1424                              <1> .exit:
  1425 00000E24 B40E                <1> 	mov	ah,0Eh			; echo
  1426 00000E26 BB0700              <1> 	mov	bx,0007h
  1427 00000E29 CD10                <1> 	int	10h
  1428 00000E2B BE[8800]            <1> 	mov	si,msg_crlf
  1429 00000E2E E85F17              <1> 	call	print
  1430 00000E31 5E                  <1> 	pop	si
  1431 00000E32 5A                  <1> 	pop	dx
  1432 00000E33 59                  <1> 	pop	cx
  1433 00000E34 5B                  <1> 	pop	bx
  1434 00000E35 58                  <1> 	pop	ax
  1435 00000E36 C3                  <1> 	ret
  1436                              <1> 
  1437                              <1> ;=========================================================================
  1438                              <1> ; print_rtc - print current RTC date and time
  1439                              <1> ; Input:
  1440                              <1> ;	none
  1441                              <1> ; Output:
  1442                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
  1443                              <1> ; Notes:
  1444                              <1> ;	There is a slight probability of getting inconsistent printout.
  1445                              <1> ;	In case the function is called just before midnight, it could
  1446                              <1> ;	print the previos day's date and next day's time.
  1447                              <1> ;-------------------------------------------------------------------------
  1448                              <1> print_rtc:
  1449 00000E37 50                  <1> 	push	ax
  1450 00000E38 53                  <1> 	push	bx
  1451 00000E39 51                  <1> 	push	cx
  1452 00000E3A 52                  <1> 	push	dx
  1453 00000E3B 56                  <1> 	push	si
  1454 00000E3C BE[7A01]            <1> 	mov	si,msg_rtc
  1455 00000E3F E84E17              <1> 	call	print
  1456                              <1> 
  1457                              <1> ; print date
  1458 00000E42 B404                <1> 	mov	ah,04h
  1459 00000E44 CD1A                <1> 	int	1Ah			; read RTC date
  1460                              <1> 					; CH = BCD century
  1461                              <1> 					; CL = BCD year
  1462                              <1> 					; DH = BCD month
  1463                              <1> 					; DL = BCD date (day of month)
  1464 00000E46 89C8                <1> 	mov	ax,cx
  1465 00000E48 E86017              <1> 	call	print_hex		; print 4-digit year
  1466 00000E4B B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1467 00000E4E BB0700              <1> 	mov	bx,0007h
  1468 00000E51 CD10                <1> 	int	10h			; print dash (-)
  1469                              <1> 
  1470 00000E53 88F0                <1> 	mov	al,dh
  1471 00000E55 E85E17              <1> 	call	print_byte		; print 2-digit month
  1472 00000E58 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
  1473 00000E5B BB0700              <1> 	mov	bx,0007h
  1474 00000E5E CD10                <1> 	int	10h			; print dash (-)
  1475                              <1> 
  1476 00000E60 88D0                <1> 	mov	al,dl
  1477 00000E62 E85117              <1> 	call	print_byte		; print 2-digit date (day of month)
  1478                              <1> 
  1479 00000E65 B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
  1480 00000E68 BB0700              <1> 	mov	bx,0007h
  1481 00000E6B CD10                <1> 	int	10h			; print space ( )
  1482                              <1> 
  1483                              <1> ; print time
  1484 00000E6D B402                <1> 	mov	ah,02h
  1485 00000E6F CD1A                <1> 	int	1Ah			; read RTC time
  1486                              <1> 					; CH = BCD hours
  1487                              <1> 					; CL = BCD minutes
  1488                              <1> 					; DH = BCD seconds
  1489                              <1> 					; DL = daylight saving flag (ignored)
  1490 00000E71 88E8                <1> 	mov	al,ch
  1491 00000E73 E84017              <1> 	call	print_byte		; print 2-digit hours
  1492                              <1> 	
  1493 00000E76 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1494 00000E79 BB0700              <1> 	mov	bx,0007h
  1495 00000E7C CD10                <1> 	int	10h			; print colon (:)
  1496                              <1> 
  1497 00000E7E 88C8                <1> 	mov	al,cl
  1498 00000E80 E83317              <1> 	call	print_byte		; print 2-digit minutes
  1499                              <1> 	
  1500 00000E83 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
  1501 00000E86 BB0700              <1> 	mov	bx,0007h
  1502 00000E89 CD10                <1> 	int	10h			; print colon (:)
  1503                              <1> 
  1504 00000E8B 88F0                <1> 	mov	al,dh
  1505 00000E8D E82617              <1> 	call	print_byte		; print 2-digit seconds
  1506                              <1> 
  1507 00000E90 BE[8800]            <1> 	mov	si,msg_crlf
  1508 00000E93 E8FA16              <1> 	call	print
  1509 00000E96 5E                  <1> 	pop	si
  1510 00000E97 5A                  <1> 	pop	dx
  1511 00000E98 59                  <1> 	pop	cx
  1512 00000E99 5B                  <1> 	pop	bx
  1513 00000E9A 58                  <1> 	pop	ax
  1514 00000E9B C3                  <1> 	ret
  1515                              <1> 
  1516                              <1> ;=========================================================================
  1517                              <1> ; delay_15us - delay for multiplies of 15 microseconds
  1518                              <1> ; Input:
  1519                              <1> ;	CX = time to delay (in 15 microsecond units)
  1520                              <1> ; Notes:
  1521                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
  1522                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
  1523                              <1> ;	    timer channel 1. Will not function properly if timer gets
  1524                              <1> ;	    reprogrammed by an application or if it was not initialized yet
  1525                              <1> ;-------------------------------------------------------------------------
  1526                              <1> delay_15us:
  1527 00000E9C 50                  <1> 	push	ax
  1528 00000E9D 51                  <1> 	push	cx
  1529                              <1> .zero:
  1530 00000E9E E461                <1> 	in	al,port_b_reg
  1531 00000EA0 A810                <1> 	test	al,refresh_flag
  1532 00000EA2 74FA                <1> 	jz	.zero
  1533 00000EA4 49                  <1> 	dec	cx
  1534 00000EA5 7409                <1> 	jz	.exit
  1535                              <1> .one:
  1536 00000EA7 E461                <1> 	in	al,port_b_reg
  1537 00000EA9 A810                <1> 	test	al,refresh_flag
  1538 00000EAB 75FA                <1> 	jnz	.one
  1539 00000EAD 49                  <1> 	dec	cx
  1540 00000EAE 75EE                <1> 	jnz	.zero
  1541                              <1> .exit:
  1542 00000EB0 59                  <1> 	pop	cx
  1543 00000EB1 58                  <1> 	pop	ax
  1544 00000EB2 C3                  <1> 	ret
  1545                              <1> 
  1546                              <1> %if 0
  1547                              <1> ;=========================================================================
  1548                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
  1549                              <1> ; Input:
  1550                              <1> ;	DX:AX	- dividend
  1551                              <1> ;	CX	- divisor
  1552                              <1> ; Output:
  1553                              <1> ;	DX:AX	- quotient
  1554                              <1> ;-------------------------------------------------------------------------
  1555                              <1> divide_32:
  1556                              <1> 	or	dx,dx
  1557                              <1> 	jnz	.1
  1558                              <1> 	div	cx
  1559                              <1> 	xor	dx,dx
  1560                              <1> 	ret
  1561                              <1> .1:
  1562                              <1> 	push	bx
  1563                              <1> 	mov	bx,ax
  1564                              <1> 	mov	ax,dx
  1565                              <1> 	xor	dx,dx
  1566                              <1> 	div	cx
  1567                              <1> 	xchg	bx,ax
  1568                              <1> 	div	cx
  1569                              <1> 	mov	dx,bx
  1570                              <1> 	pop	bx
  1571                              <1> 	ret
  1572                              <1> %endif ; 0
  1573                                  %include	"time1.inc"		; time services
  1574                              <1> ;=========================================================================
  1575                              <1> ; time1.inc - BIOS Time Services
  1576                              <1> ;       INT 1Ah - BIOS Time Services
  1577                              <1> ;		functions AH=00h to AH=07h
  1578                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
  1579                              <1> ;-------------------------------------------------------------------------
  1580                              <1> ;
  1581                              <1> ; Compiles with NASM 2.07, might work with other versions
  1582                              <1> ;
  1583                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1584                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1585                              <1> ;
  1586                              <1> ; This program is free software: you can redistribute it and/or modify
  1587                              <1> ; it under the terms of the GNU General Public License as published by
  1588                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1589                              <1> ; (at your option) any later version.
  1590                              <1> ;
  1591                              <1> ; This program is distributed in the hope that it will be useful,
  1592                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1593                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1594                              <1> ; GNU General Public License for more details.
  1595                              <1> ;
  1596                              <1> ; You should have received a copy of the GNU General Public License
  1597                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1598                              <1> ;
  1599                              <1> ;=========================================================================
  1600                              <1> 
  1601                              <1> ;=========================================================================
  1602                              <1> ; int_1A_fn00 - Read current time
  1603                              <1> ; Input:
  1604                              <1> ;	AH = 0 - read current time
  1605                              <1> ; Output:
  1606                              <1> ;	CX = high word of tick count
  1607                              <1> ;	DX = low word of tick count
  1608                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
  1609                              <1> ;-------------------------------------------------------------------------
  1610                              <1> int_1A_fn00:
  1611 00000EB3 8B166C00            <1> 	mov	dx,word [ticks_lo]
  1612 00000EB7 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
  1613 00000EBB A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
  1614 00000EBE 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
  1615 00000EC2 E9D06F              <1> 	jmp	int_1A_exit
  1616                              <1> 
  1617                              <1> ;=========================================================================
  1618                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
  1619                              <1> ; Input:
  1620                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
  1621                              <1> ;	CX = high word of tick count
  1622                              <1> ;	DX = low word of tick count
  1623                              <1> ; Output:
  1624                              <1> ;	None
  1625                              <1> ;-------------------------------------------------------------------------
  1626                              <1> int_1A_fn01:
  1627 00000EC5 89166C00            <1> 	mov	word [ticks_lo],dx
  1628 00000EC9 890E6E00            <1> 	mov	word [ticks_hi],cx
  1629 00000ECD C606700000          <1> 	mov	byte [new_day],00h
  1630 00000ED2 E9C06F              <1> 	jmp	int_1A_exit
  1631                              <1> 
  1632                              <1> ;=========================================================================
  1633                              <1> ; int_1A_fn02 - Read real time clock (RTC)
  1634                              <1> ; Input:
  1635                              <1> ;	AH = 02h - function 02h - read RTC time
  1636                              <1> ; Output:
  1637                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1638                              <1> ;	CH = BCD hours
  1639                              <1> ;	CL = BCD minutes
  1640                              <1> ;	DH = BCD seconds
  1641                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1642                              <1> ;-------------------------------------------------------------------------
  1643                              <1> int_1A_fn02:
  1644 00000ED5 50                  <1> 	push	ax
  1645 00000ED6 B00A                <1> 	mov	al,cmos_control_a
  1646 00000ED8 E8BCFB              <1> 	call	rtc_read		; read control A register
  1647 00000EDB A880                <1> 	test	al,cmos_uip
  1648 00000EDD 7405                <1> 	jz	.1			; no update in progess
  1649 00000EDF F9                  <1> 	stc
  1650 00000EE0 58                  <1> 	pop	ax
  1651 00000EE1 E9B46F              <1> 	jmp	int_1A_exitf
  1652                              <1> .1:
  1653 00000EE4 B00B                <1> 	mov	al,cmos_control_b
  1654 00000EE6 E8AEFB              <1> 	call	rtc_read		; read control B register
  1655 00000EE9 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
  1656 00000EEB 88C2                <1> 	mov	dl,al
  1657 00000EED B000                <1> 	mov	al,cmos_seconds
  1658 00000EEF E8A5FB              <1> 	call	rtc_read		; read seconds
  1659 00000EF2 88C6                <1> 	mov	dh,al
  1660 00000EF4 B002                <1> 	mov	al,cmos_minutes
  1661 00000EF6 E89EFB              <1> 	call	rtc_read		; read minutes
  1662 00000EF9 88C1                <1> 	mov	cl,al
  1663 00000EFB B004                <1> 	mov	al,cmos_hours
  1664 00000EFD E897FB              <1> 	call	rtc_read		; read hours
  1665 00000F00 88C5                <1> 	mov	ch,al
  1666 00000F02 F8                  <1> 	clc
  1667 00000F03 58                  <1> 	pop	ax
  1668 00000F04 E9916F              <1> 	jmp	int_1A_exitf
  1669                              <1> 
  1670                              <1> ;=========================================================================
  1671                              <1> ; int_1A_fn03 - Set real time clock
  1672                              <1> ; Input:
  1673                              <1> ;	AH = 03h - function 03h - set RTC time
  1674                              <1> ;	CH = BCD hours
  1675                              <1> ;	CL = BCD minutes
  1676                              <1> ;	DH = BCD seconds
  1677                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
  1678                              <1> ; Output:
  1679                              <1> ;	None
  1680                              <1> ;-------------------------------------------------------------------------
  1681                              <1> int_1A_fn03:
  1682 00000F07 50                  <1> 	push	ax
  1683 00000F08 B00B                <1> 	mov	al,cmos_control_b
  1684 00000F0A E88AFB              <1> 	call	rtc_read		; read control B register
  1685 00000F0D 88C4                <1> 	mov	ah,al
  1686 00000F0F 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1687 00000F12 B00B                <1> 	mov	al,cmos_control_b
  1688 00000F14 E88FFB              <1> 	call	rtc_write		; write control B register
  1689                              <1> 
  1690 00000F17 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
  1691 00000F1A 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
  1692 00000F1D 08D4                <1> 	or	ah,dl			; add it from the input
  1693 00000F1F B00B                <1> 	mov	al,cmos_control_b
  1694 00000F21 E882FB              <1> 	call	rtc_write		; write control B register
  1695                              <1> 
  1696 00000F24 B000                <1> 	mov	al,cmos_seconds
  1697 00000F26 88F4                <1> 	mov	ah,dh
  1698 00000F28 E87BFB              <1> 	call	rtc_write		; write seconds
  1699 00000F2B B002                <1> 	mov	al,cmos_minutes
  1700 00000F2D 88CC                <1> 	mov	ah,cl
  1701 00000F2F E874FB              <1> 	call	rtc_write		; write minutes
  1702 00000F32 B004                <1> 	mov	al,cmos_hours
  1703 00000F34 88EC                <1> 	mov	ah,ch
  1704 00000F36 E86DFB              <1> 	call	rtc_write		; write hours
  1705                              <1> 
  1706 00000F39 B00B                <1> 	mov	al,cmos_control_b
  1707 00000F3B E859FB              <1> 	call	rtc_read		; read control B register
  1708 00000F3E 88C4                <1> 	mov	ah,al
  1709 00000F40 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1710 00000F43 B00B                <1> 	mov	al,cmos_control_b
  1711 00000F45 E85EFB              <1> 	call	rtc_write		; write control B register
  1712 00000F48 58                  <1> 	pop	ax
  1713 00000F49 E9496F              <1> 	jmp	int_1A_exit
  1714                              <1> 
  1715                              <1> ;=========================================================================
  1716                              <1> ; int_1A_fn04 - Read date from real time clock
  1717                              <1> ; Input:
  1718                              <1> ;	AH = 04h - function 04h - read RTC date
  1719                              <1> ; Output:
  1720                              <1> ;	CF set if RTC update is in progress and operation was not performed
  1721                              <1> ;	CH = BCD century
  1722                              <1> ;	CL = BCD year
  1723                              <1> ;	DH = BCD month
  1724                              <1> ;	DL = BCD date
  1725                              <1> ;-------------------------------------------------------------------------
  1726                              <1> int_1A_fn04:
  1727 00000F4C 50                  <1> 	push	ax
  1728 00000F4D B00A                <1> 	mov	al,cmos_control_a
  1729 00000F4F E845FB              <1> 	call	rtc_read		; read control A register
  1730 00000F52 A880                <1> 	test	al,cmos_uip
  1731 00000F54 7405                <1> 	jz	.1			; no update in progess
  1732 00000F56 F9                  <1> 	stc
  1733 00000F57 58                  <1> 	pop	ax
  1734 00000F58 E93D6F              <1> 	jmp	int_1A_exitf
  1735                              <1> .1:
  1736 00000F5B B007                <1> 	mov	al,cmos_date
  1737 00000F5D E837FB              <1> 	call	rtc_read		; read date
  1738 00000F60 88C2                <1> 	mov	dl,al
  1739 00000F62 B008                <1> 	mov	al,cmos_month
  1740 00000F64 E830FB              <1> 	call	rtc_read		; read month
  1741 00000F67 88C6                <1> 	mov	dh,al
  1742 00000F69 B009                <1> 	mov	al,cmos_year
  1743 00000F6B E829FB              <1> 	call	rtc_read		; read year
  1744 00000F6E 88C1                <1> 	mov	cl,al
  1745 00000F70 B032                <1> 	mov	al,cmos_century
  1746 00000F72 E822FB              <1> 	call	rtc_read		; read century
  1747 00000F75 88C5                <1> 	mov	ch,al
  1748 00000F77 F8                  <1> 	clc
  1749 00000F78 58                  <1> 	pop	ax
  1750 00000F79 E91C6F              <1> 	jmp	int_1A_exitf
  1751                              <1> 
  1752                              <1> ;=========================================================================
  1753                              <1> ; int_1A_fn05 - Set date in real time clock
  1754                              <1> ; Input:
  1755                              <1> ;	AH = 05h - function 05h - set RTC date
  1756                              <1> ;	CH = BCD century
  1757                              <1> ;	CL = BCD year
  1758                              <1> ;	DH = BCD month
  1759                              <1> ;	DL = BCD date
  1760                              <1> ; Output:
  1761                              <1> ;	None
  1762                              <1> ;-------------------------------------------------------------------------
  1763                              <1> int_1A_fn05:
  1764 00000F7C 50                  <1> 	push	ax
  1765 00000F7D B00B                <1> 	mov	al,cmos_control_b
  1766 00000F7F E815FB              <1> 	call	rtc_read		; read control B register
  1767 00000F82 88C4                <1> 	mov	ah,al
  1768 00000F84 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1769 00000F87 B00B                <1> 	mov	al,cmos_control_b
  1770 00000F89 E81AFB              <1> 	call	rtc_write		; write control B register
  1771                              <1> 
  1772 00000F8C B007                <1> 	mov	al,cmos_date
  1773 00000F8E 88D4                <1> 	mov	ah,dl
  1774 00000F90 E813FB              <1> 	call	rtc_write		; write date
  1775                              <1> 
  1776 00000F93 B008                <1> 	mov	al,cmos_month
  1777 00000F95 88F4                <1> 	mov	ah,dh
  1778 00000F97 E80CFB              <1> 	call	rtc_write		; write month
  1779 00000F9A B009                <1> 	mov	al,cmos_year
  1780 00000F9C 88CC                <1> 	mov	ah,cl
  1781 00000F9E E805FB              <1> 	call	rtc_write		; write year
  1782 00000FA1 B032                <1> 	mov	al,cmos_century
  1783 00000FA3 88EC                <1> 	mov	ah,ch
  1784 00000FA5 E8FEFA              <1> 	call	rtc_write		; write centry
  1785                              <1> 
  1786 00000FA8 B00B                <1> 	mov	al,cmos_control_b
  1787 00000FAA E8EAFA              <1> 	call	rtc_read		; read control B register
  1788 00000FAD 88C4                <1> 	mov	ah,al
  1789 00000FAF 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
  1790 00000FB2 B00B                <1> 	mov	al,cmos_control_b
  1791 00000FB4 E8EFFA              <1> 	call	rtc_write		; write control B register
  1792 00000FB7 58                  <1> 	pop	ax
  1793 00000FB8 E9DA6E              <1> 	jmp	int_1A_exit
  1794                              <1> 
  1795                              <1> ;=========================================================================
  1796                              <1> ; int_1A_fn06 - Set real time clock alarm
  1797                              <1> ; Input:
  1798                              <1> ;	AH = 06h - function 06h - set RTC alarm time
  1799                              <1> ;	CH = BCD hours
  1800                              <1> ;	CL = BCD minutes
  1801                              <1> ;	DH = BCD seconds
  1802                              <1> ; Output:
  1803                              <1> ;	CF = 1 - alarm already set
  1804                              <1> ;-------------------------------------------------------------------------
  1805                              <1> int_1A_fn06:
  1806 00000FBB 50                  <1> 	push	ax
  1807 00000FBC B00B                <1> 	mov	al,cmos_control_b
  1808 00000FBE E8D6FA              <1> 	call	rtc_read		; read control B register
  1809 00000FC1 A820                <1> 	test	al,cmos_aie
  1810 00000FC3 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
  1811 00000FC5 F9                  <1> 	stc
  1812 00000FC6 58                  <1> 	pop	ax
  1813 00000FC7 E9CE6E              <1> 	jmp	int_1A_exitf
  1814                              <1> .1:
  1815 00000FCA 88C4                <1> 	mov	ah,al
  1816 00000FCC 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
  1817 00000FCF B00B                <1> 	mov	al,cmos_control_b
  1818 00000FD1 E8D2FA              <1> 	call	rtc_write		; write control B register
  1819                              <1> 
  1820 00000FD4 B001                <1> 	mov	al,cmos_alarm_secs
  1821 00000FD6 88F4                <1> 	mov	ah,dh
  1822 00000FD8 E8CBFA              <1> 	call	rtc_write		; write alarm seconds
  1823 00000FDB B003                <1> 	mov	al,cmos_alarm_mins
  1824 00000FDD 88CC                <1> 	mov	ah,cl
  1825 00000FDF E8C4FA              <1> 	call	rtc_write		; write alarm minutes
  1826 00000FE2 B005                <1> 	mov	al,cmos_alarm_hrs
  1827 00000FE4 88EC                <1> 	mov	ah,ch
  1828 00000FE6 E8BDFA              <1> 	call	rtc_write		; write alarm hours
  1829                              <1> 
  1830 00000FE9 B00B                <1> 	mov	al,cmos_control_b
  1831 00000FEB E8A9FA              <1> 	call	rtc_read		; read control B register
  1832 00000FEE 88C4                <1> 	mov	ah,al
  1833 00000FF0 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
  1834 00000FF3 B00B                <1> 	mov	al,cmos_control_b
  1835 00000FF5 E8AEFA              <1> 	call	rtc_write		; write control B register
  1836                              <1> 
  1837 00000FF8 B00B                <1> 	mov	al,cmos_control_b
  1838 00000FFA E89AFA              <1> 	call	rtc_read		; read control B register
  1839 00000FFD 88C4                <1> 	mov	ah,al
  1840 00000FFF 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
  1841 00001002 B00B                <1> 	mov	al,cmos_control_b
  1842 00001004 E89FFA              <1> 	call	rtc_write		; write control B register with AIE set
  1843                              <1> 
  1844 00001007 58                  <1> 	pop	ax
  1845 00001008 F8                  <1> 	clc
  1846 00001009 E98C6E              <1> 	jmp	int_1A_exitf
  1847                              <1> 
  1848                              <1> ;=========================================================================
  1849                              <1> ; int_1A_fn07 - Reset real time clock alarm
  1850                              <1> ; Input:
  1851                              <1> ;	AH = 07h - function 07h - set RTC time
  1852                              <1> ; Output:
  1853                              <1> ;	None
  1854                              <1> ;-------------------------------------------------------------------------
  1855                              <1> int_1A_fn07:
  1856 0000100C 50                  <1> 	push	ax
  1857                              <1> 
  1858 0000100D B00B                <1> 	mov	al,cmos_control_b
  1859 0000100F E885FA              <1> 	call	rtc_read		; read control B register
  1860 00001012 88C4                <1> 	mov	ah,al
  1861 00001014 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
  1862 00001017 B00B                <1> 	mov	al,cmos_control_b
  1863 00001019 E88AFA              <1> 	call	rtc_write		; write control B reg. with AIE cleared
  1864                              <1> 
  1865 0000101C 58                  <1> 	pop	ax
  1866 0000101D E9756E              <1> 	jmp	int_1A_exit
  1867                              <1> 	
  1868                              <1> ;=========================================================================
  1869                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
  1870                              <1> ; Notes:
  1871                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
  1872                              <1> ;-------------------------------------------------------------------------
  1873                              <1> int_70:
  1874 00001020 50                  <1> 	push	ax
  1875 00001021 B020                <1> 	mov	al,20h
  1876 00001023 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  1877 00001025 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  1878 00001027 B00C                <1> 	mov	al,cmos_control_c
  1879 00001029 E86BFA              <1> 	call	rtc_read		; read control C register
  1880 0000102C A840                <1> 	test	al,cmos_af		; check for alarm flag
  1881 0000102E 7402                <1> 	jz	.1
  1882 00001030 CD4A                <1> 	int	4Ah			; call INT 4Ah
  1883                              <1> .1:
  1884 00001032 58                  <1> 	pop	ax
  1885 00001033 CF                  <1> 	iret
  1886                                  %include	"floppy1.inc"		; floppy services
  1887                              <1> ;=========================================================================
  1888                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
  1889                              <1> ;       INT 13h, function AH=00h
  1890                              <1> ;       INT 13h, function AH=01h
  1891                              <1> ;       INT 13h, function AH=08h
  1892                              <1> ;       INT 13h, function AH=15h
  1893                              <1> ;       INT 13h, function AH=16h
  1894                              <1> ;       INT 13h, function AH=17h
  1895                              <1> ;       INT 13h, function AH=18h
  1896                              <1> ;       INT 13h, function AH=08h
  1897                              <1> ;	- see floppy2.inc for other INT 13h functions
  1898                              <1> ;-------------------------------------------------------------------------
  1899                              <1> ;
  1900                              <1> ; Compiles with NASM 2.07, might work with other versions
  1901                              <1> ;
  1902                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  1903                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  1904                              <1> ;
  1905                              <1> ; This program is free software: you can redistribute it and/or modify
  1906                              <1> ; it under the terms of the GNU General Public License as published by
  1907                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1908                              <1> ; (at your option) any later version.
  1909                              <1> ;
  1910                              <1> ; This program is distributed in the hope that it will be useful,
  1911                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1912                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1913                              <1> ; GNU General Public License for more details.
  1914                              <1> ;
  1915                              <1> ; You should have received a copy of the GNU General Public License
  1916                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1917                              <1> ;
  1918                              <1> ;=========================================================================
  1919                              <1> 
  1920                              <1> ;-------------------------------------------------------------------------
  1921                              <1> ; FDC registers
  1922                              <1> 
  1923                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
  1924                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
  1925                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1926                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1927                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1928                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1929                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
  1930                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
  1931                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
  1932                              <1> 
  1933                              <1> ;-------------------------------------------------------------------------
  1934                              <1> ; DMAC registers
  1935                              <1> 
  1936                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
  1937                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
  1938                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
  1939                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
  1940                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
  1941                              <1> 					; first / last flip-flop
  1942                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
  1943                              <1> 
  1944                              <1> ;-------------------------------------------------------------------------
  1945                              <1> ; Floppy disk services - error codes
  1946                              <1> 
  1947                              <1> fdc_e_success	equ	00h		; successful completion
  1948                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
  1949                              <1> fdc_e_address	equ	02h		; address mark not found
  1950                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
  1951                              <1> fdc_e_notfound	equ	04h		; sector not found
  1952                              <1> fdc_e_changed	equ	06h		; disk changed
  1953                              <1> fdc_e_dma	equ	08h		; DMA overrun
  1954                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
  1955                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
  1956                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
  1957                              <1> fdc_e_failure	equ	20h		; controller failure
  1958                              <1> fdc_e_seek	equ	40h		; seek failed
  1959                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
  1960                              <1> 
  1961                              <1> ;-------------------------------------------------------------------------
  1962                              <1> ; Drive media state for fdc_media_state
  1963                              <1> 
  1964                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
  1965                              <1> 					; 00b = 500 Kbit/sec
  1966                              <1> 					; 01b = 300 Kbit/sec
  1967                              <1> 					; 10b = 250 Kbit/sec
  1968                              <1> 					; 11b = 1 Mbit/sec
  1969                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
  1970                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
  1971                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
  1972                              <1> 					; 000b = trying 360K in 360K drive
  1973                              <1> 					; 001b = trying 360K in 1.2M drive
  1974                              <1> 					; 010b = trying 1.2M in 1.2M drive
  1975                              <1> 					; 011b = known 360K in 360K drive
  1976                              <1> 					; 100b = known 360K in 1.2M drive
  1977                              <1> 					; 101b = known 1.2M in 1.2M drive
  1978                              <1> 					; 110b = not used
  1979                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
  1980                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
  1981                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
  1982                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
  1983                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
  1984                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
  1985                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
  1986                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
  1987                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
  1988                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
  1989                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
  1990                              <1> 
  1991                              <1> ;-------------------------------------------------------------------------
  1992                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
  1993                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
  1994                              <1> 
  1995                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
  1996                              <1> 
  1997                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
  1998                              <1> ;	       unset for read or verify
  1999                              <1> 
  2000                              <1> fdc_write_flag	equ	80h		; write or format operation
  2001                              <1> 
  2002                              <1> ;-------------------------------------------------------------------------
  2003                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
  2004                              <1> 
  2005                              <1> cmos_no_floppy	equ	00h
  2006                              <1> cmos_360	equ	01h
  2007                              <1> cmos_1200	equ	02h
  2008                              <1> cmos_720	equ	03h
  2009                              <1> cmos_1440	equ	04h
  2010                              <1> cmos_2880	equ	06h
  2011                              <1> 
  2012                              <1> ;=========================================================================
  2013                              <1> ; int_13_fn00: Reset disk system
  2014                              <1> ; Input:
  2015                              <1> ;	AH = 00h
  2016                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2017                              <1> ; Output:
  2018                              <1> ;	CF clear if successful
  2019                              <1> ;		AH = 00h - successful completion
  2020                              <1> ;	CF set on error
  2021                              <1> ;		AH = 20h - controller failure
  2022                              <1> ;		AH = 80h - timeout / device not ready
  2023                              <1> ; Note:
  2024                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2025                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2026                              <1> ;-------------------------------------------------------------------------
  2027                              <1> int_13_fn00:
  2028 00001034 E80700              <1> 	call	fdc_init
  2029 00001037 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2030 0000103B E9985C              <1> 	jmp	int_13_exit
  2031                              <1> 
  2032                              <1> ;=========================================================================
  2033                              <1> ; fdc_init - Initialize floppy disk controller
  2034                              <1> ; Input:
  2035                              <1> ;	none
  2036                              <1> ; Output:
  2037                              <1> ;	CF clear on success
  2038                              <1> ;		AH = 00h - successful completion
  2039                              <1> ;	CF set if error
  2040                              <1> ;		AH = 20h - controller failure
  2041                              <1> ;		AH = 80h - timeout / device not ready
  2042                              <1> ;-------------------------------------------------------------------------
  2043                              <1> fdc_init:
  2044 0000103E 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  2045 00001043 E80906              <1> 	call	fdc_reset		; reset FDC
  2046 00001046 7257                <1> 	jc	fdc_init_error
  2047 00001048 BAF403              <1> 	mov	dx,fdc_status_reg
  2048 0000104B EC                  <1> 	in	al,dx
  2049 0000104C A880                <1> 	test	al,80h
  2050 0000104E 7404                <1> 	jz	.try_again		; try again if FDC not ready
  2051 00001050 A840                <1> 	test	al,40h
  2052 00001052 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  2053                              <1> .try_again:
  2054 00001054 E8F805              <1> 	call	fdc_reset
  2055 00001057 BAF403              <1> 	mov	dx,fdc_status_reg
  2056 0000105A EC                  <1> 	in	al,dx
  2057 0000105B A880                <1> 	test	al,80h
  2058 0000105D 7440                <1> 	jz	fdc_init_error
  2059 0000105F A840                <1> 	test	al,40h
  2060 00001061 753C                <1> 	jnz	fdc_init_error
  2061                              <1> .fdc_ready:
  2062 00001063 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2063 00001065 E83905              <1> 	call	fdc_write		; send the command
  2064 00001068 7235                <1> 	jc	fdc_init_error
  2065 0000106A E88105              <1> 	call	fdc_read		; read ST0
  2066 0000106D 7230                <1> 	jc	fdc_init_error
  2067 0000106F A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  2068 00001072 88C4                <1> 	mov	ah,al			; save AL to AH
  2069 00001074 E87705              <1> 	call	fdc_read		; read current cylinder
  2070 00001077 7226                <1> 	jc	fdc_init_error
  2071 00001079 A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  2072 0000107C 80E4C0              <1> 	and	ah,0C0h
  2073 0000107F 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  2074 00001082 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  2075                              <1> 
  2076                              <1> ; fall through to fdc_send_specify
  2077                              <1> 
  2078                              <1> ;=========================================================================
  2079                              <1> ; fdc_send_specify - Send specify command to FDC
  2080                              <1> ; Input:
  2081                              <1> ;	none
  2082                              <1> ; Output:
  2083                              <1> ;	CF clear on success
  2084                              <1> ;		AH = 00 - successful completion
  2085                              <1> ;	CF set if error
  2086                              <1> ;		AH = 20h - controller failure
  2087                              <1> ;	AX,CL,SI trashed
  2088                              <1> ; Note:
  2089                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  2090                              <1> ;-------------------------------------------------------------------------
  2091                              <1> fdc_send_specify:
  2092                              <1> 
  2093 00001084 1E                  <1> 	push	ds
  2094 00001085 31C0                <1> 	xor	ax,ax
  2095 00001087 8ED8                <1> 	mov	ds,ax
  2096 00001089 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2097 0000108D B003                <1> 	mov	al,3		 	; FDC Specify command
  2098 0000108F 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  2099 00001091 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  2100 00001094 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  2101 00001096 1F                  <1> 	pop	ds
  2102 00001097 E8BB04              <1> 	call	fdc_send_cmd		; send specify command to FDC
  2103 0000109A 7203                <1> 	jc	fdc_init_error
  2104 0000109C B400                <1> 	mov	ah,fdc_e_success	; successful completion
  2105 0000109E C3                  <1> 	ret
  2106                              <1> 
  2107                              <1> fdc_init_error:
  2108 0000109F B420                <1> 	mov	ah,fdc_e_failure
  2109 000010A1 F9                  <1> 	stc
  2110 000010A2 C3                  <1> 	ret
  2111                              <1> 
  2112                              <1> ;=========================================================================
  2113                              <1> ; int_13_fn01 - Get status of last operation
  2114                              <1> ; Input:
  2115                              <1> ;	AH = 01h
  2116                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  2117                              <1> ; Output:
  2118                              <1> ;	CF clear if last operation was successful
  2119                              <1> ;		AH = 00h - successful completion
  2120                              <1> ;	CF set on error
  2121                              <1> ;		AH - error code of the last operation
  2122                              <1> ; Note:
  2123                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  2124                              <1> ;	normally will call this functions if bit 7 of DL is not set
  2125                              <1> ;-------------------------------------------------------------------------
  2126                              <1> int_13_fn01:
  2127 000010A3 8A264100            <1> 	mov	ah,byte [fdc_last_error]
  2128 000010A7 08E4                <1> 	or	ah,ah
  2129 000010A9 7401                <1> 	jz	.no_error
  2130 000010AB F9                  <1> 	stc
  2131                              <1> .no_error:
  2132 000010AC E9275C              <1> 	jmp	int_13_exit
  2133                              <1> 
  2134                              <1> ;=========================================================================
  2135                              <1> ; int_13_fn08: Get drive parameters
  2136                              <1> ; Input:
  2137                              <1> ;	AH = 08h
  2138                              <1> ;	DL = drive number (0 - 7Fh)
  2139                              <1> ; Output:
  2140                              <1> ;	CF clear if successful
  2141                              <1> ;		AX = 0000h
  2142                              <1> ;		BH = 00h
  2143                              <1> ;		BL = CMOS drive type
  2144                              <1> ;		CH = maximal cylinder number - 1
  2145                              <1> ;		CL = maximal sector number
  2146                              <1> ;		DH = maximal head number
  2147                              <1> ;		DL = number of drives
  2148                              <1> ;		ES:DI -> diskette parameter table
  2149                              <1> ;	CF set on error
  2150                              <1> ;		AH = 01h - drive number is greater than 7Fh
  2151                              <1> ; Notes:
  2152                              <1> ;	- If non-existent drive number is specified, function returns zeros in
  2153                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
  2154                              <1> ;	- If media type is not established function sets media parameters 
  2155                              <1> ;	based on CMOS drive type
  2156                              <1> ;-------------------------------------------------------------------------
  2157                              <1> int_13_fn08:
  2158 000010AF 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
  2159 000010B2 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
  2160 000010B7 A01000              <1> 	mov	al,byte [equipment_list]
  2161 000010BA 2441                <1> 	and	al,equip_floppies|equip_floppy2
  2162 000010BC B402                <1> 	mov	ah,2			; assume two floppy drives
  2163 000010BE 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
  2164 000010C0 7406                <1> 	je	.check_drive_number
  2165 000010C2 FECC                <1> 	dec	ah			; assume one floppy drive
  2166 000010C4 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
  2167 000010C6 757C                <1> 	jne	.no_drives
  2168                              <1> 
  2169                              <1> .check_drive_number:
  2170 000010C8 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
  2171 000010CB 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
  2172                              <1> 					; than number of disks?
  2173 000010CD 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
  2174 000010CF E8B205              <1> 	call	read_cmos_type		; returns drive type in AL
  2175 000010D2 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
  2176                              <1> 
  2177 000010D4 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
  2178 000010D8 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
  2179 000010DB 8CC9                <1> 	mov	cx,cs
  2180 000010DD 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
  2181                              <1> 
  2182 000010DF 3C01                <1> 	cmp	al,cmos_360
  2183 000010E1 7417                <1> 	je	.set_360
  2184 000010E3 3C03                <1> 	cmp	al,cmos_720
  2185 000010E5 741E                <1> 	je	.set_720
  2186 000010E7 3C02                <1> 	cmp	al,cmos_1200
  2187 000010E9 7425                <1> 	je	.set_1200
  2188 000010EB 3C04                <1> 	cmp	al,cmos_1440
  2189 000010ED 742C                <1> 	je	.set_1440
  2190                              <1> 
  2191                              <1> .set_2880:
  2192 000010EF B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
  2193 000010F1 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
  2194 000010F5 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
  2195 000010F8 EB2A                <1> 	jmp	.set_media_type
  2196                              <1> 
  2197                              <1> .set_360:
  2198 000010FA B093                <1> 	mov	al,fdc_m_360in360
  2199 000010FC 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2200 00001100 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
  2201 00001103 EB1F                <1> 	jmp	.set_media_type
  2202                              <1> 
  2203                              <1> .set_720:
  2204 00001105 B097                <1> 	mov	al,fdc_m_720
  2205 00001107 8D3E[896F]          <1> 	lea	di,[media_720]
  2206 0000110B B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
  2207 0000110E EB14                <1> 	jmp	.set_media_type
  2208                              <1> 
  2209                              <1> .set_1200:
  2210 00001110 B002                <1> 	mov	al,fdc_m_try_1200in1200
  2211 00001112 8D3E[7C6F]          <1> 	lea	di,[media_1200]
  2212 00001116 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
  2213 00001119 EB09                <1> 	jmp	.set_media_type
  2214                              <1> 
  2215                              <1> .set_1440:
  2216 0000111B B007                <1> 	mov	al,fdc_m_try_1440
  2217 0000111D 8D3E[966F]          <1> 	lea	di,[media_1440]
  2218 00001121 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
  2219                              <1> 
  2220                              <1> .set_media_type:
  2221 00001124 BB9000              <1> 	mov	bx,fdc_media_state
  2222 00001127 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2223 00001129 F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
  2224 0000112C 7502                <1> 	jnz	.set_parameters		; no need to update if established
  2225 0000112E 8807                <1> 	mov	[bx],al
  2226                              <1> 
  2227                              <1> .set_parameters:
  2228 00001130 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
  2229 00001132 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
  2230 00001135 A24100              <1> 	mov	byte [fdc_last_error],al
  2231 00001138 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
  2232 0000113B 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
  2233 0000113E 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
  2234 00001141 E9925B              <1> 	jmp	int_13_exit
  2235                              <1> 
  2236                              <1> .no_drives:
  2237 00001144 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
  2238                              <1> 
  2239                              <1> .non_existent_drive:
  2240 00001148 31C9                <1> 	xor	cx,cx
  2241 0000114A 31FF                <1> 	xor	di,di
  2242 0000114C 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
  2243 0000114F 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
  2244 00001152 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
  2245 00001154 EBDA                <1> 	jmp	.set_parameters
  2246                              <1> 
  2247                              <1> .invalid_drive:
  2248 00001156 B401                <1> 	mov	ah,fdc_e_invalid
  2249 00001158 F9                  <1> 	stc
  2250 00001159 E97A5B              <1> 	jmp	int_13_exit
  2251                              <1> 
  2252                              <1> ;=========================================================================
  2253                              <1> ; int_13_fn15: Get disk type
  2254                              <1> ; Input:
  2255                              <1> ;	AH = 15h
  2256                              <1> ;	DL = drive number (0 or 1)
  2257                              <1> ; Output:
  2258                              <1> ;	AH = type code:
  2259                              <1> ;		00h - no such drive (invalid drive specified)
  2260                              <1> ;		01h - floppy without change-line support
  2261                              <1> ;		02h - floppy with change-line support
  2262                              <1> ;-------------------------------------------------------------------------
  2263                              <1> int_13_fn15:
  2264 0000115C B400                <1> 	mov	ah,00h			; assume no drive
  2265 0000115E 80FA01              <1> 	cmp	dl,1
  2266 00001161 7711                <1> 	ja	.exit			; jump if invalid drive number
  2267 00001163 E81E05              <1> 	call	read_cmos_type		; returns drive type in AL
  2268 00001166 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
  2269 00001168 B401                <1> 	mov	ah,01h			; assume no change-line support
  2270 0000116A 3C01                <1> 	cmp	al,cmos_360
  2271 0000116C 7406                <1> 	je	.exit
  2272 0000116E 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
  2273 00001170 7402                <1> 	je	.exit
  2274 00001172 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
  2275                              <1> 
  2276                              <1> .exit:
  2277 00001174 F8                  <1> 	clc
  2278 00001175 C606410000          <1> 	mov	byte [fdc_last_error],0
  2279 0000117A E9595B              <1> 	jmp	int_13_exit
  2280                              <1> 
  2281                              <1> ;=========================================================================
  2282                              <1> ; int_13_fn16 - Detect disk change
  2283                              <1> ; Input:
  2284                              <1> ;	AH = 16h
  2285                              <1> ;	DL = drive number (0 or 1)
  2286                              <1> ; Output:
  2287                              <1> ;	CF clear if change line inactive
  2288                              <1> ;		AH = 00h - disk not changed
  2289                              <1> ;	CF set if change line active or error
  2290                              <1> ;		AH = 01h - invalid drive number
  2291                              <1> ;		AH = 06h - disk changed or change line not supported
  2292                              <1> ;		AH = 80h - timeout / device not ready
  2293                              <1> ;-------------------------------------------------------------------------
  2294                              <1> int_13_fn16:
  2295 0000117D 80FA01              <1> 	cmp	dl,1
  2296 00001180 7741                <1> 	ja	.invalid_drive
  2297 00001182 E8FF04              <1> 	call	read_cmos_type		; returns drive type in AL
  2298 00001185 723C                <1> 	jc	.invalid_drive
  2299                              <1> 
  2300 00001187 3C01                <1> 	cmp	al,cmos_360
  2301 00001189 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
  2302 0000118B 3C03                <1> 	cmp	al,cmos_720
  2303 0000118D 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
  2304                              <1> 
  2305 0000118F E86302              <1> 	call	fdc_motor_on		; turn motor on
  2306 00001192 30E4                <1> 	xor	ah,ah			; assume disk not changed
  2307 00001194 BAF703              <1> 	mov	dx,fdc_dir_reg
  2308 00001197 EC                  <1> 	in	al,dx			; read disk change line
  2309 00001198 D0E0                <1> 	shl	al,1			; bit 7 to CF
  2310 0000119A 7303                <1> 	jnc	.exit
  2311 0000119C B406                <1> 	mov	ah,fdc_e_changed
  2312 0000119E F9                  <1> 	stc
  2313                              <1> 
  2314                              <1> .exit:
  2315 0000119F 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  2316 000011A3 9C                  <1> 	pushf
  2317 000011A4 1E                  <1> 	push	ds
  2318 000011A5 31F6                <1> 	xor	si,si
  2319 000011A7 8EDE                <1> 	mov	ds,si
  2320 000011A9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2321 000011AD 8A4C02              <1> 	mov	cl,byte [si+2]
  2322 000011B0 1F                  <1> 	pop	ds
  2323 000011B1 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
  2324 000011B5 9D                  <1> 	popf
  2325 000011B6 E91D5B              <1> 	jmp	int_13_exit
  2326                              <1> 
  2327                              <1> 
  2328                              <1> .no_change_line:
  2329 000011B9 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
  2330 000011BB F9                  <1> 	stc
  2331 000011BC 88264100            <1> 	mov	byte [fdc_last_error],ah
  2332 000011C0 E9135B              <1> 	jmp	int_13_exit
  2333                              <1> 
  2334                              <1> .invalid_drive:
  2335 000011C3 B401                <1> 	mov	ah,fdc_e_invalid
  2336 000011C5 F9                  <1> 	stc
  2337 000011C6 E90D5B              <1> 	jmp	int_13_exit
  2338                              <1> 
  2339                              <1> ;=========================================================================
  2340                              <1> ; int_13_fn17 - Set disk type for format
  2341                              <1> ; Input:
  2342                              <1> ;	AH = 17h
  2343                              <1> ;	AL = format type
  2344                              <1> ;		01h - 320K / 360K disk in 360K drive
  2345                              <1> ;		02h - 320K / 360K disk in 1.2M drive
  2346                              <1> ;		03h - 1.2M disk in 1.2M drive
  2347                              <1> ;		04h - 720K disk in 720K or 1.2M drive
  2348                              <1> ;	DL = drive number (0 or 1)
  2349                              <1> ; Output:
  2350                              <1> ;	CF clear if successful
  2351                              <1> ;		AH = 00h - successful completion
  2352                              <1> ;	CF set on error
  2353                              <1> ;		AH = 01h - invalid drive number
  2354                              <1> ;		AH = 06h - disk changed
  2355                              <1> ;		AH = 80h - timeout / device not ready
  2356                              <1> ;-------------------------------------------------------------------------
  2357                              <1> int_13_fn17:
  2358 000011C9 80FA01              <1> 	cmp	dl,1
  2359 000011CC 7762                <1> 	ja	.invalid_parameters
  2360 000011CE E8B304              <1> 	call	read_cmos_type		; get drive type in AL
  2361 000011D1 725D                <1> 	jc	.invalid_parameters
  2362 000011D3 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
  2363 000011D6 80F900              <1> 	cmp	cl,0			; validate parameters
  2364 000011D9 7455                <1> 	je	.invalid_parameters
  2365 000011DB 80F904              <1> 	cmp	cl,4
  2366 000011DE 7750                <1> 	ja	.invalid_parameters
  2367 000011E0 BB9000              <1> 	mov	bx,fdc_media_state
  2368 000011E3 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2369 000011E5 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
  2370 000011E8 7507                <1> 	jne	.not_360in360
  2371 000011EA C60793              <1> 	mov	byte [bx],fdc_m_360in360
  2372 000011ED B400                <1> 	mov	ah,0			; no error
  2373 000011EF EB33                <1> 	jmp	.exit_check_error
  2374                              <1> 
  2375                              <1> .not_360in360:
  2376 000011F1 E80102              <1> 	call	fdc_motor_on
  2377 000011F4 89DE                <1> 	mov	si,bx
  2378 000011F6 E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
  2379 000011F9 80FC06              <1> 	cmp	ah,fdc_e_changed
  2380 000011FC 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
  2381 000011FE 80FC80              <1> 	cmp	ah,fdc_e_timeout
  2382 00001201 750A                <1> 	jne	.set_type		; floppy disk is installed
  2383 00001203 803F97              <1> 	cmp	byte [bx],fdc_m_720	; 250 Kbps and not 5.25?
  2384 00001206 741C                <1> 	je	.exit_check_error
  2385 00001208 C60761              <1> 	mov	byte [bx],fdc_m_try_360in1200 ; 300 Kpbs, try 360 in 1.2M
  2386 0000120B EB17                <1> 	jmp	.exit_check_error
  2387                              <1> 
  2388                              <1> .set_type:
  2389 0000120D 80F904              <1> 	cmp	cl,4			; 720K in 720K?
  2390 00001210 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
  2391 00001212 C60797              <1> 	mov	byte [bx],fdc_m_720
  2392 00001215 EB0D                <1> 	jmp	.exit_check_error
  2393                              <1> 
  2394                              <1> .check_360in1200:
  2395 00001217 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
  2396 0000121A 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
  2397 0000121C C60774              <1> 	mov	byte [bx],fdc_m_360in1200
  2398 0000121F EB03                <1> 	jmp	.exit_check_error
  2399                              <1> 
  2400                              <1> .set_1200in1200:
  2401 00001221 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
  2402                              <1> 
  2403                              <1> .exit_check_error:
  2404 00001224 88264100            <1> 	mov	byte [fdc_last_error],ah
  2405 00001228 08E4                <1> 	or	ah,ah
  2406 0000122A 7401                <1> 	jz	.exit			; jump if no error
  2407 0000122C F9                  <1> 	stc				; indicate error
  2408                              <1> 
  2409                              <1> .exit:
  2410 0000122D E9855A              <1> 	jmp	int_13_upd_exit
  2411                              <1> 
  2412                              <1> .invalid_parameters:
  2413 00001230 B401                <1> 	mov	ah,fdc_e_invalid
  2414 00001232 EBF9                <1> 	jmp	.exit
  2415                              <1> 
  2416                              <1> ;=========================================================================
  2417                              <1> ; int_13_fn18 - Set media type for format
  2418                              <1> ; Input:
  2419                              <1> ;	AH = 18h
  2420                              <1> ;	DL = drive number (0 or 1)
  2421                              <1> ;	CH = number of cylinders - 1
  2422                              <1> ;	CL = sectors per track
  2423                              <1> ; Output:
  2424                              <1> ;	CF = clear if successful
  2425                              <1> ;		AH = 00h - requested format is supported
  2426                              <1> ;		ES:DI -> diskette parameter table
  2427                              <1> ;	CF = set on error
  2428                              <1> ;		AH = 01h - invalid drive number specified
  2429                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
  2430                              <1> ;-------------------------------------------------------------------------
  2431                              <1> int_13_fn18:
  2432 00001234 80FA01              <1> 	cmp	dl,1
  2433 00001237 7603E99900          <1> 	ja	.invalid_drive
  2434 0000123C E84504              <1> 	call	read_cmos_type		; get drive type in AL
  2435 0000123F 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
  2436                              <1> 
  2437 00001244 BB9000              <1> 	mov	bx,fdc_media_state
  2438 00001247 00D3                <1> 	add	bl,dl			; BX -> drive media state
  2439                              <1> 
  2440 00001249 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
  2441 0000124B 7511                <1> 	jne	.try_drive_1200
  2442 0000124D 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
  2443 00001251 7403E98300          <1> 	jnz	.unsupported_format
  2444 00001256 B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
  2445 00001258 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
  2446 0000125C EB54                <1> 	jmp	.set_media
  2447                              <1> 
  2448                              <1> .try_drive_1200:
  2449 0000125E 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
  2450 00001260 751C                <1> 	jne	.try_drive_2880
  2451 00001262 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
  2452 00001266 7508                <1> 	jne	.try_media_360_in_1200
  2453 00001268 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
  2454 0000126A 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
  2455 0000126E EB42                <1> 	jmp	.set_media
  2456                              <1> 
  2457                              <1> .try_media_360_in_1200:
  2458 00001270 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
  2459 00001274 7563                <1> 	jne	.unsupported_format
  2460 00001276 B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
  2461 00001278 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
  2462 0000127C EB34                <1> 	jmp	.set_media
  2463                              <1> 
  2464                              <1> .try_drive_2880:
  2465 0000127E 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
  2466 00001280 750E                <1> 	jne	.try_drive_1440
  2467 00001282 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
  2468 00001286 750C                <1> 	jne	.try_media_1440
  2469 00001288 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
  2470 0000128A 8D3E[B06F]          <1> 	lea	di,[media_2880]
  2471 0000128E EB22                <1> 	jmp	.set_media
  2472                              <1> 
  2473                              <1> .try_drive_1440:
  2474 00001290 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
  2475 00001292 750E                <1> 	jne	.try_drive_720
  2476                              <1> 
  2477                              <1> .try_media_1440:
  2478 00001294 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
  2479 00001298 750C                <1> 	jne	.try_media_720
  2480 0000129A B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
  2481 0000129C 8D3E[966F]          <1> 	lea	di,[media_1440]
  2482 000012A0 EB10                <1> 	jmp	.set_media
  2483                              <1> 
  2484                              <1> .try_drive_720:
  2485 000012A2 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
  2486 000012A4 7533                <1> 	jne	.unsupported_format	; should never happen...
  2487                              <1> 
  2488                              <1> .try_media_720:	
  2489 000012A6 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
  2490 000012AA 752D                <1> 	jne	.unsupported_format
  2491 000012AC B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
  2492 000012AE 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
  2493                              <1> 
  2494                              <1> .set_media:
  2495 000012B2 8807                <1> 	mov	byte [bx],al		; set physical media
  2496 000012B4 E8E404              <1> 	call	fdc_set_rate		; transfer rate in AL
  2497 000012B7 D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
  2498 000012B9 D0C8                <1> 	ror	al,1
  2499 000012BB 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
  2500 000012C0 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
  2501 000012C4 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
  2502 000012C7 8CC9                <1> 	mov	cx,cs
  2503 000012C9 8EC1                <1> 	mov	es,cx			; return parameters table - segment
  2504 000012CB C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
  2505 000012D0 30E4                <1> 	xor	ah,ah
  2506 000012D2 E9E059              <1> 	jmp	int_13_upd_exit
  2507                              <1> 
  2508                              <1> .invalid_drive:
  2509 000012D5 B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
  2510 000012D7 EB02                <1> 	jmp	.error
  2511                              <1> 
  2512                              <1> .unsupported_format:
  2513 000012D9 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
  2514                              <1> 
  2515                              <1> .error:
  2516 000012DB F9                  <1> 	stc
  2517 000012DC E9D659              <1> 	jmp	int_13_upd_exit
  2518                              <1> 
  2519                              <1> ;=========================================================================
  2520                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
  2521                              <1> ; Input:
  2522                              <1> ;	DL = drive number (0 or 1)
  2523                              <1> ; Output:
  2524                              <1> ;	CF clear if successful
  2525                              <1> ;		AH = 00h - successful completion
  2526                              <1> ;	CF set on error
  2527                              <1> ;		AH = 20h - controller failure
  2528                              <1> ;		AH = 20h - timeout
  2529                              <1> ;	AH trashed
  2530                              <1> ;-------------------------------------------------------------------------
  2531                              <1> fdc_recalibrate:
  2532 000012DF 56                  <1> 	push	si
  2533 000012E0 51                  <1> 	push	cx
  2534 000012E1 52                  <1> 	push	dx
  2535 000012E2 B007                <1> 	mov	al,07h			; FDC Recalibrate command
  2536 000012E4 88D4                <1> 	mov	ah,dl			; drive number
  2537 000012E6 B102                <1> 	mov	cl,2			; 2 bytes command
  2538 000012E8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2539 000012ED E86502              <1> 	call	fdc_send_cmd
  2540 000012F0 7244                <1> 	jc	recal_end		; failure
  2541 000012F2 E8B104              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2542 000012F5 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
  2543 000012F7 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2544 000012F9 B101                <1> 	mov	cl,1			; 1 byte command
  2545 000012FB E85702              <1> 	call	fdc_send_cmd
  2546 000012FE 7236                <1> 	jc	recal_end		; failure
  2547 00001300 B90200              <1> 	mov	cx,2			; 2 bytes result
  2548 00001303 E8B402              <1> 	call	fdc_get_result		; store result
  2549 00001306 722E                <1> 	jc	recal_end		; failure
  2550 00001308 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2551 0000130B B440                <1> 	mov	ah,fdc_e_seek
  2552 0000130D 8A17                <1> 	mov	dl,[bx]			; ST0
  2553 0000130F 80E260              <1> 	and	dl,60h
  2554 00001312 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
  2555 00001315 F9                  <1> 	stc				; indicate error
  2556 00001316 741E                <1> 	je	recal_end		; failure
  2557 00001318 5A                  <1> 	pop	dx
  2558 00001319 52                  <1> 	push	dx
  2559 0000131A 30F6                <1> 	xor	dh,dh				 
  2560 0000131C BB9400              <1> 	mov	bx,fdc_cylinder
  2561 0000131F 01D3                <1> 	add	bx,dx
  2562 00001321 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
  2563 00001324 88D1                <1> 	mov	cl,dl
  2564 00001326 B201                <1> 	mov	dl,1
  2565 00001328 D2E2                <1> 	shl	dl,cl
  2566 0000132A 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
  2567 0000132E B94300              <1> 	mov	cx,43h
  2568 00001331 E868FB              <1> 	call	delay_15us		; 1 ms delay
  2569 00001334 30E4                <1> 	xor	ah,ah
  2570                              <1> 
  2571                              <1> recal_end:
  2572 00001336 88264100            <1> 	mov	byte [fdc_last_error],ah
  2573 0000133A 5A                  <1> 	pop	dx
  2574 0000133B 59                  <1> 	pop	cx
  2575 0000133C 5E                  <1> 	pop	si
  2576 0000133D C3                  <1> 	ret
  2577                              <1> 
  2578                              <1> ;=========================================================================
  2579                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
  2580                              <1> ; Input:
  2581                              <1> ;	DL = drive number
  2582                              <1> ;	DH = head number
  2583                              <1> ;	CH = cylinder
  2584                              <1> ; Output:
  2585                              <1> ;	CF clear if successful
  2586                              <1> ;		AH = 00h - successful completion
  2587                              <1> ;	CF set on error
  2588                              <1> ;		AH = 20h - controller failure
  2589                              <1> ;		AH = 40h - seek failed
  2590                              <1> ;		AH = 80h - timeout / device not ready
  2591                              <1> ;-------------------------------------------------------------------------
  2592                              <1> fdc_seek:
  2593 0000133E 53                  <1> 	push	bx
  2594 0000133F 51                  <1> 	push	cx
  2595 00001340 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
  2596 00001344 88D1                <1> 	mov	cl,dl
  2597 00001346 FEC1                <1> 	inc	cl
  2598 00001348 D2EC                <1> 	shr	ah,cl
  2599 0000134A 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
  2600 0000134C E890FF              <1> 	call	fdc_recalibrate
  2601 0000134F 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
  2602 00001351 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
  2603 00001354 727F                <1> 	jc	.exit			; no luck...
  2604                              <1> 
  2605                              <1> .skip_recalibrate:
  2606 00001356 B700                <1> 	mov	bh,00h
  2607 00001358 88D3                <1> 	mov	bl,dl			; BX = drive number
  2608 0000135A F687900020          <1> 	test	byte [fdc_media_state+bx],fdc_m_double_step ; check double
  2609                              <1> 					; steppig bit
  2610 0000135F 7402                <1> 	jz	.no_double_stepping
  2611 00001361 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
  2612                              <1> 
  2613                              <1> .no_double_stepping:
  2614 00001363 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
  2615 00001367 750B                <1> 	jne	.do_seek		; jump if seek is required
  2616 00001369 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
  2617 0000136E 7404                <1> 	je	.do_seek		; jump if it was a seek error
  2618 00001370 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
  2619 00001372 EB61                <1> 	jmp	.exit
  2620                              <1> 
  2621                              <1> .do_seek:
  2622 00001374 88E8                <1> 	mov	al,ch			; cylinder
  2623 00001376 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
  2624 00001378 B00F                <1> 	mov	al,0Fh			; FDC Seek command
  2625 0000137A 88F4                <1> 	mov	ah,dh			; head
  2626 0000137C D0E4                <1> 	shl	ah,1
  2627 0000137E D0E4                <1> 	shl	ah,1
  2628 00001380 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
  2629 00001382 B103                <1> 	mov	cl,3			; 3 bytes command
  2630 00001384 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  2631 00001389 E8C901              <1> 	call	fdc_send_cmd
  2632 0000138C 7243                <1> 	jc	.set_result		; seek error
  2633 0000138E E81504              <1> 	call	fdc_wait_irq		; wait for IRQ6
  2634 00001391 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
  2635                              <1> 
  2636 00001393 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  2637 00001395 B101                <1> 	mov	cl,1			; 1 byte command
  2638 00001397 E8BB01              <1> 	call	fdc_send_cmd
  2639 0000139A 7235                <1> 	jc	.set_result		; failure
  2640 0000139C B102                <1> 	mov	cl,2
  2641 0000139E 53                  <1> 	push	bx
  2642 0000139F E81802              <1> 	call	fdc_get_result		; read result bytes
  2643 000013A2 5B                  <1> 	pop	bx
  2644 000013A3 722C                <1> 	jc	.set_result		; error
  2645 000013A5 B440                <1> 	mov	ah,fdc_e_seek
  2646 000013A7 A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
  2647 000013AA 2460                <1> 	and	al,60h
  2648 000013AC 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  2649 000013AE F9                  <1> 	stc
  2650 000013AF 7420                <1> 	je	.set_result		; seek error
  2651 000013B1 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
  2652                              <1> 
  2653 000013B5 1E                  <1> 	push	ds
  2654 000013B6 31F6                <1> 	xor	si,si
  2655 000013B8 8EDE                <1> 	mov	ds,si
  2656 000013BA C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2657 000013BE 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  2658 000013C1 1F                  <1> 	pop	ds
  2659                              <1> 
  2660 000013C2 08C0                <1> 	or	al,al			; head settle time is zero?!
  2661 000013C4 7412                <1> 	jz	.get_settle_time
  2662                              <1> 
  2663 000013C6 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  2664 000013C8 F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  2665 000013CA 89C1                <1> 	mov	cx,ax
  2666                              <1> 
  2667                              <1> .wait:
  2668 000013CC E8CDFA              <1> 	call	delay_15us
  2669                              <1> 
  2670                              <1> .wait_end:
  2671 000013CF 30E4                <1> 	xor	ah,ah
  2672                              <1> 
  2673                              <1> .set_result:
  2674 000013D1 88264100            <1> 	mov	byte [fdc_last_error],ah
  2675                              <1> 
  2676                              <1> .exit:
  2677 000013D5 59                  <1> 	pop	cx
  2678 000013D6 5B                  <1> 	pop	bx
  2679 000013D7 C3                  <1> 	ret
  2680                              <1> 
  2681                              <1> .get_settle_time:
  2682 000013D8 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
  2683 000013DD 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
  2684                              <1> 	
  2685 000013DF 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
  2686 000013E3 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  2687 000013E6 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  2688 000013E9 74E1                <1> 	jz	.wait			; jump if 360K, media not established
  2689 000013EB 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  2690 000013EE 74DC                <1> 	je	.wait			; jump if 360K, media established
  2691 000013F0 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  2692 000013F3 EBD7                <1> 	jmp	.wait
  2693                              <1> 
  2694                              <1> ;=========================================================================
  2695                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  2696                              <1> ; Input:
  2697                              <1> ;	DL = drive number (0 or 1)
  2698                              <1> ; Output:
  2699                              <1> ;	none
  2700                              <1> ;-------------------------------------------------------------------------
  2701                              <1> fdc_motor_on:
  2702 000013F5 50                  <1> 	push	ax
  2703 000013F6 51                  <1> 	push	cx
  2704 000013F7 52                  <1> 	push	dx
  2705 000013F8 FA                  <1> 	cli				; entering critical section
  2706 000013F9 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  2707 000013FE 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
  2708 00001403 88D1                <1> 	mov	cl,dl			; CL = drive number
  2709 00001405 D0E2                <1> 	shl	dl,1
  2710 00001407 D0E2                <1> 	shl	dl,1
  2711 00001409 D0E2                <1> 	shl	dl,1
  2712 0000140B D0E2                <1> 	shl	dl,1
  2713 0000140D 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
  2714 00001411 FEC1                <1> 	inc	cl
  2715 00001413 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
  2716 00001417 D2EA                <1> 	shr	dl,cl
  2717 00001419 7255                <1> 	jc	.already_on
  2718 0000141B B201                <1> 	mov	dl,1
  2719 0000141D FEC9                <1> 	dec	cl
  2720 0000141F D2E2                <1> 	shl	dl,cl
  2721 00001421 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
  2722 00001425 FB                  <1> 	sti				; end of critical section
  2723 00001426 A03F00              <1>     	mov	al,byte [fdc_motor_state]
  2724 00001429 D0C8                <1> 	ror	al,1
  2725 0000142B D0C8                <1> 	ror	al,1
  2726 0000142D D0C8                <1> 	ror	al,1
  2727 0000142F D0C8                <1> 	ror	al,1
  2728 00001431 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2729 00001433 BAF203              <1> 	mov	dx,fdc_dor_reg
  2730 00001436 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2731 00001437 B8FD90              <1> 	mov	ax,90FDh
  2732 0000143A CD15                <1> 	int	15h			; call OS hook
  2733 0000143C 722E                <1> 	jc	.exit
  2734 0000143E 1E                  <1> 	push	ds
  2735 0000143F 56                  <1> 	push	si
  2736 00001440 31F6                <1> 	xor	si,si
  2737 00001442 8EDE                <1> 	mov	ds,si
  2738 00001444 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  2739 00001448 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  2740 0000144B 5E                  <1> 	pop	si
  2741 0000144C 1F                  <1> 	pop	ds
  2742                              <1> 
  2743 0000144D F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
  2744 00001452 7408                <1> 	jz	.read_verify		; jump if not write operation
  2745 00001454 3C08                <1> 	cmp	al,8
  2746 00001456 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  2747 00001458 B008                <1> 	mov	al,8			; wait at least 1 second for write
  2748 0000145A EB06                <1> 	jmp	.wait_loop
  2749                              <1> 
  2750                              <1> .read_verify:
  2751 0000145C 3C05                <1> 	cmp	al,5
  2752 0000145E 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  2753 00001460 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  2754                              <1> 
  2755                              <1> .wait_loop:
  2756 00001462 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  2757 00001465 E834FA              <1> 	call	delay_15us		; wait 125 ms
  2758 00001468 FEC8                <1> 	dec	al
  2759 0000146A 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  2760                              <1> 
  2761                              <1> .exit:
  2762 0000146C 59                  <1> 	pop	cx
  2763 0000146D 5A                  <1> 	pop	dx
  2764 0000146E 58                  <1> 	pop	ax
  2765 0000146F C3                  <1> 	ret
  2766                              <1> 
  2767                              <1> .already_on:
  2768 00001470 FB                  <1> 	sti
  2769 00001471 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
  2770 00001474 D0C8                <1> 	ror	al,1
  2771 00001476 D0C8                <1> 	ror	al,1
  2772 00001478 D0C8                <1> 	ror	al,1
  2773 0000147A D0C8                <1> 	ror	al,1
  2774 0000147C 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
  2775 0000147E BAF203              <1> 	mov	dx,fdc_dor_reg
  2776 00001481 EE                  <1> 	out	dx,al			; send it to FDC - start motor
  2777 00001482 EBE8                <1> 	jmp	.exit
  2778                              <1> 
  2779                              <1> ;=========================================================================
  2780                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  2781                              <1> ; Input:
  2782                              <1> ;	CH = cylinder
  2783                              <1> ;	DH = head
  2784                              <1> ; Output:
  2785                              <1> ;	BL = next sector to be transferred
  2786                              <1> ;-------------------------------------------------------------------------	
  2787                              <1> 
  2788                              <1> fdc_end_io:
  2789 00001484 50                  <1> 	push	ax
  2790 00001485 1E                  <1> 	push	ds
  2791 00001486 31DB                <1> 	xor	bx,bx
  2792 00001488 8EDB                <1> 	mov	ds,bx
  2793 0000148A C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  2794 0000148E 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
  2795 00001491 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  2796 00001494 FEC0                <1> 	inc	al
  2797 00001496 1F                  <1> 	pop	ds
  2798 00001497 BB4200              <1> 	mov	bx,fdc_ctrl_status
  2799 0000149A 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  2800 0000149D 7508                <1> 	jne	.exit
  2801 0000149F 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  2802 000014A2 7503                <1> 	jne	.exit
  2803 000014A4 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  2804                              <1> .exit:
  2805 000014A7 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  2806 000014AB 88C3                <1> 	mov	bl,al			; next sector to be transferred
  2807 000014AD 58                  <1> 	pop	ax
  2808 000014AE C3                  <1> 	ret
  2809                              <1> 
  2810                              <1> ;========================================================================
  2811                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  2812                              <1> ; Input:
  2813                              <1> ;	AL = CMOS drive type
  2814                              <1> ;	DS:SI -> drive media type
  2815                              <1> ; Output:
  2816                              <1> ;	CF clear if disk not changed
  2817                              <1> ;		AH = 00h - disk not changed
  2818                              <1> ;	CF set if disk changed or on error
  2819                              <1> ;		AH = 06h - disk changed
  2820                              <1> ;		AH = error code
  2821                              <1> ; Note:
  2822                              <1> ;	Motor needs to be turned on before calling this function
  2823                              <1> ;------------------------------------------------------------------------
  2824                              <1> fdc_disk_change:
  2825 000014AF 51                  <1> 	push	cx
  2826 000014B0 B400                <1> 	mov	ah,0
  2827 000014B2 3C01                <1> 	cmp	al,cmos_360
  2828 000014B4 743C                <1> 	je	.exit			; jump if 360K drive (no change line)
  2829 000014B6 3C03                <1> 	cmp	al,cmos_720
  2830 000014B8 7438                <1> 	je	.exit			; jump if 720K drive (no change line)
  2831                              <1> .cmos_invalid:
  2832 000014BA 8A04                <1> 	mov	al,[si]			; media type
  2833 000014BC 2407                <1> 	and	al,fdc_m_state_bits
  2834 000014BE 7432                <1> 	jz	.exit			; jump if 360K drive (no change line)
  2835 000014C0 3C03                <1> 	cmp	al,3
  2836 000014C2 742E                <1> 	je	.exit			; jump if 360K dirve (no change line)
  2837 000014C4 BAF703              <1> 	mov	dx,fdc_dir_reg
  2838 000014C7 EC                  <1> 	in	al,dx			; read disk change line
  2839 000014C8 D0E0                <1> 	shl	al,1
  2840 000014CA 7326                <1> 	jnc	.exit			; no disk change
  2841 000014CC 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  2842 000014CF E86CFB              <1> 	call	fdc_init		; full initialization
  2843 000014D2 721E                <1> 	jc	.exit
  2844 000014D4 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  2845 000014D7 B501                <1> 	mov	ch,1
  2846 000014D9 E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  2847 000014DC 7214                <1> 	jc	.exit
  2848 000014DE B500                <1> 	mov	ch,0
  2849 000014E0 E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  2850 000014E3 720D                <1> 	jc	.exit
  2851 000014E5 B406                <1> 	mov	ah,fdc_e_changed
  2852 000014E7 BAF703              <1> 	mov	dx,fdc_dir_reg
  2853 000014EA EC                  <1> 	in	al,dx			; read disk change line
  2854 000014EB D0E0                <1> 	shl	al,1
  2855 000014ED 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  2856 000014EF B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  2857                              <1> 
  2858                              <1> .changed_or_error:
  2859 000014F1 F9                  <1> 	stc
  2860                              <1> 
  2861                              <1> .exit:
  2862 000014F2 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  2863 000014F5 59                  <1> 	pop	cx
  2864 000014F6 C3                  <1> 	ret
  2865                              <1> 
  2866                              <1> ;=========================================================================
  2867                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  2868                              <1> ; Input:
  2869                              <1> ;	AL = DMA mode byte
  2870                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  2871                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  2872                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  2873                              <1> ;	CX = byte count (minus 1)
  2874                              <1> ;	ES:BX -> buffer address for DMA operation
  2875                              <1> ; Output:
  2876                              <1> ;	CF clear on success
  2877                              <1> ;	CF set if error
  2878                              <1> ;		AH = 08h - DMA overrun
  2879                              <1> ;	AX,BX trashed
  2880                              <1> ; Note:
  2881                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  2882                              <1> ;-------------------------------------------------------------------------
  2883                              <1> fdc_configure_dma:
  2884 000014F7 52                  <1> 	push	dx
  2885 000014F8 8CC2                <1> 	mov	dx,es			; user's buffer segment
  2886 000014FA D1C2                <1> 	rol	dx,1
  2887 000014FC D1C2                <1> 	rol	dx,1
  2888 000014FE D1C2                <1> 	rol	dx,1
  2889 00001500 D1C2                <1> 	rol	dx,1
  2890 00001502 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  2891 00001504 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  2892 00001507 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  2893 0000150A 01DA                <1> 	add	dx,bx			; add user's buffer offset
  2894 0000150C 80D400              <1> 	adc	ah,0			; increment page number on overflow
  2895                              <1> 
  2896 0000150F 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  2897 00001511 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  2898 00001513 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  2899                              <1> 
  2900 00001515 FA                  <1> 	cli
  2901 00001516 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  2902 00001518 EB00                <1> 	jmp	$+2
  2903 0000151A EB00                <1> 	jmp	$+2
  2904 0000151C E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  2905 0000151E EB00                <1> 	jmp	$+2
  2906 00001520 EB00                <1> 	jmp	$+2
  2907 00001522 88C8                <1> 	mov	al,cl
  2908 00001524 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  2909 00001526 EB00                <1> 	jmp	$+2
  2910 00001528 EB00                <1> 	jmp	$+2
  2911 0000152A 88E8                <1> 	mov	al,ch
  2912 0000152C E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  2913 0000152E EB00                <1> 	jmp	$+2
  2914 00001530 EB00                <1> 	jmp	$+2
  2915 00001532 88D0                <1> 	mov	al,dl
  2916 00001534 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  2917 00001536 EB00                <1> 	jmp	$+2
  2918 00001538 EB00                <1> 	jmp	$+2
  2919 0000153A 88F0                <1> 	mov	al,dh
  2920 0000153C E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  2921 0000153E EB00                <1> 	jmp	$+2
  2922 00001540 EB00                <1> 	jmp	$+2
  2923 00001542 88E0                <1> 	mov	al,ah
  2924 00001544 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  2925 00001546 EB00                <1> 	jmp	$+2
  2926 00001548 EB00                <1> 	jmp	$+2
  2927 0000154A B002                <1> 	mov	al,2
  2928 0000154C E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  2929 0000154E FB                  <1> 	sti
  2930                              <1> 
  2931                              <1> .exit:
  2932 0000154F 5A                  <1> 	pop	dx
  2933 00001550 C3                  <1> 	ret
  2934                              <1> 
  2935                              <1> .dma_boundary:				; Note: CF is already set
  2936 00001551 B409                <1> 	mov	ah,fdc_e_boundary
  2937 00001553 EBFA                <1> 	jmp	.exit
  2938                              <1> 
  2939                              <1> ;=========================================================================
  2940                              <1> ; fdc_send_cmd - Send a command to FDC
  2941                              <1> ; Input:
  2942                              <1> ;	AL = 1st byte of the command
  2943                              <1> ;	AH = 2nd byte of the command
  2944                              <1> ;	SI = 3rd and 4th bytes of the command
  2945                              <1> ;	DI = 5th and 6th bytes of the command
  2946                              <1> ;	BL = 7th byte of the command
  2947                              <1> ;	BH = 8th byte of the command
  2948                              <1> ;	CH = 9th byte of the command
  2949                              <1> ;	CL = command length (number of bytes)
  2950                              <1> ; Output:
  2951                              <1> ;	CF clear if successful
  2952                              <1> ;		AH = 00h - successful completion
  2953                              <1> ;	CF set on error
  2954                              <1> ;		AH = 20h - controller failure
  2955                              <1> ;		AH = 80h - timeout / device not ready
  2956                              <1> ;	AX trashed
  2957                              <1> ;-------------------------------------------------------------------------
  2958                              <1> fdc_send_cmd:
  2959 00001555 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  2960 00001558 FEC9                <1> 	dec	cl
  2961 0000155A 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2962 0000155C 88E0                <1> 	mov	al,ah
  2963 0000155E E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  2964 00001561 FEC9                <1> 	dec	cl
  2965 00001563 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2966 00001565 89F0                <1> 	mov	ax,si
  2967 00001567 E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  2968 0000156A FEC9                <1> 	dec	cl
  2969 0000156C 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2970 0000156E 88E0                <1> 	mov	al,ah
  2971 00001570 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  2972 00001573 FEC9                <1> 	dec	cl
  2973 00001575 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2974 00001577 89F8                <1> 	mov	ax,di
  2975 00001579 E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  2976 0000157C FEC9                <1> 	dec	cl
  2977 0000157E 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2978 00001580 88E0                <1> 	mov	al,ah
  2979 00001582 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  2980 00001585 FEC9                <1> 	dec	cl
  2981 00001587 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2982 00001589 88D8                <1> 	mov	al,bl
  2983 0000158B E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  2984 0000158E FEC9                <1> 	dec	cl
  2985 00001590 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2986 00001592 88F8                <1> 	mov	al,bh
  2987 00001594 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  2988 00001597 FEC9                <1> 	dec	cl
  2989 00001599 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  2990 0000159B 88E8                <1> 	mov	al,ch
  2991 0000159D E80100              <1> 	call	fdc_write		; send CH (9th byte)
  2992                              <1> 
  2993                              <1> .send_cmd_exit:
  2994 000015A0 C3                  <1> 	ret
  2995                              <1> 
  2996                              <1> ;=========================================================================
  2997                              <1> ; fdc_write - Send byte to FDC
  2998                              <1> ; Input:
  2999                              <1> ;	AL = byte to send
  3000                              <1> ; Output:
  3001                              <1> ;	CF clear if successful
  3002                              <1> ;	CF set if timeout
  3003                              <1> ;		AH = 80h - timeout / device not ready
  3004                              <1> ;-------------------------------------------------------------------------
  3005                              <1> fdc_write:
  3006 000015A1 52                  <1> 	push	dx
  3007 000015A2 50                  <1> 	push	ax
  3008 000015A3 E83502              <1> 	call	fdc_wait_ready
  3009 000015A6 720D                <1> 	jc	.timeout
  3010 000015A8 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  3011 000015AA 3C80                <1> 	cmp	al,fdc_stat_ready
  3012 000015AC 7507                <1> 	jne	.timeout
  3013 000015AE 58                  <1> 	pop	ax
  3014 000015AF BAF503              <1> 	mov	dx,fdc_data_reg
  3015 000015B2 EE                  <1> 	out	dx,al			; write byte
  3016                              <1> 
  3017                              <1> .exit:
  3018 000015B3 5A                  <1> 	pop	dx
  3019 000015B4 C3                  <1> 	ret
  3020                              <1> 
  3021                              <1> .timeout:
  3022 000015B5 58                  <1> 	pop	ax
  3023 000015B6 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3024 000015B8 EBF9                <1> 	jmp	.exit
  3025                              <1> 
  3026                              <1> ;=========================================================================
  3027                              <1> ; fdc_get_result - Read FDC result
  3028                              <1> ; Input:
  3029                              <1> ;	CL = number of result bytes
  3030                              <1> ; Output:
  3031                              <1> ;	CF clear if successful
  3032                              <1> ;		AH = 00h - operation successful
  3033                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  3034                              <1> ;	CF set on error
  3035                              <1> ;		AH = 20h - controller failure
  3036                              <1> ;		AH = 80h - timeout / device not ready
  3037                              <1> ;	AL,BX - trashed
  3038                              <1> ;-------------------------------------------------------------------------
  3039                              <1> fdc_get_result:
  3040 000015BA 52                  <1> 	push	dx
  3041 000015BB BB4200              <1> 	mov	bx,fdc_ctrl_status
  3042                              <1> 
  3043                              <1> .next_byte:
  3044 000015BE E81A02              <1> 	call	fdc_wait_ready
  3045 000015C1 7222                <1> 	jc	.timeout
  3046 000015C3 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  3047 000015C5 88C4                <1> 	mov	ah,al
  3048 000015C7 80E4EF              <1> 	and	ah,~fdc_stat_busy
  3049 000015CA 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  3050 000015CD 7412                <1> 	je	.done			; jump if finished
  3051 000015CF 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  3052 000015D1 7516                <1> 	jne	.failure		; jump on invalid controller status
  3053 000015D3 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  3054 000015D6 7311                <1> 	jnb	.failure		; controller error if so
  3055 000015D8 BAF503              <1> 	mov	dx,fdc_data_reg
  3056 000015DB EC                  <1> 	in	al,dx
  3057 000015DC 8807                <1> 	mov	byte [bx],al
  3058 000015DE 43                  <1> 	inc	bx
  3059 000015DF EBDD                <1> 	jmp	.next_byte
  3060                              <1> 
  3061                              <1> .done:
  3062 000015E1 30E4                <1> 	xor	ah,ah			; operation successful
  3063                              <1> 
  3064                              <1> .exit:
  3065 000015E3 5A                  <1> 	pop	dx
  3066 000015E4 C3                  <1> 	ret
  3067                              <1> 
  3068                              <1> .timeout:
  3069 000015E5 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3070 000015E7 EBFA                <1> 	jmp	.exit
  3071                              <1> 
  3072                              <1> .failure:
  3073 000015E9 B420                <1> 	mov	ah,fdc_e_failure
  3074 000015EB F9                  <1> 	stc
  3075 000015EC EBF5                <1> 	jmp	.exit
  3076                              <1> 
  3077                              <1> ;=========================================================================
  3078                              <1> ; fdc_read - Read byte from FDC
  3079                              <1> ; Input:
  3080                              <1> ;	none
  3081                              <1> ; Output:
  3082                              <1> ;	CF clear if successful
  3083                              <1> ;		AL = byte read from FDC
  3084                              <1> ;		AH - unchanged
  3085                              <1> ;	CF set on error
  3086                              <1> ;		AH = 20h - controller failure
  3087                              <1> ;		AH = 80h - timeout / device not ready
  3088                              <1> ;	CX trashed
  3089                              <1> ;-------------------------------------------------------------------------
  3090                              <1> fdc_read:
  3091 000015EE 52                  <1> 	push	dx
  3092 000015EF BAF403              <1> 	mov	dx,fdc_status_reg
  3093 000015F2 E8E601              <1> 	call	fdc_wait_ready
  3094 000015F5 720F                <1> 	jc	.timeout
  3095 000015F7 EC                  <1> 	in	al,dx
  3096 000015F8 A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  3097 000015FA 740E                <1> 	jz	.failure		; jump if not ready
  3098 000015FC EB00                <1> 	jmp	short $+2		; I/O delay
  3099 000015FE EB00                <1> 	jmp	short $+2
  3100 00001600 BAF503              <1> 	mov	dx,fdc_data_reg
  3101 00001603 EC                  <1> 	in	al,dx			; read the byte
  3102                              <1> 
  3103                              <1> .exit:
  3104 00001604 5A                  <1> 	pop	dx
  3105 00001605 C3                  <1> 	ret
  3106                              <1> 
  3107                              <1> .timeout:
  3108 00001606 B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  3109 00001608 EBFA                <1> 	jmp	.exit
  3110                              <1> 
  3111                              <1> .failure:
  3112 0000160A B420                <1> 	mov	ah,fdc_e_failure
  3113 0000160C F9                  <1> 	stc
  3114 0000160D EBF5                <1> 	jmp	.exit
  3115                              <1> 
  3116                              <1> ;=========================================================================
  3117                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  3118                              <1> ; Input:
  3119                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  3120                              <1> ; Output:
  3121                              <1> ;	AH = error code
  3122                              <1> ;-------------------------------------------------------------------------
  3123                              <1> 
  3124                              <1> fdc_get_error:
  3125 0000160F BB4200              <1> 	mov	bx,fdc_ctrl_status
  3126 00001612 8B1F                <1> 	mov	bx,[bx]
  3127 00001614 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  3128 00001617 B400                <1> 	mov	ah,fdc_e_success
  3129 00001619 7433                <1> 	jz	.exit			; jump if successful completion
  3130 0000161B F6C340              <1> 	test	bl,40h			; abnormal termination?
  3131 0000161E B420                <1> 	mov	ah,fdc_e_failure
  3132 00001620 742C                <1> 	jz	.exit
  3133 00001622 F6C701              <1> 	test	bh,1			; address mark not found?
  3134 00001625 B402                <1> 	mov	ah,fdc_e_address
  3135 00001627 7525                <1> 	jnz	.exit
  3136 00001629 F6C702              <1> 	test	bh,2			; disk write protected?
  3137 0000162C B403                <1> 	mov	ah,fdc_e_wprotect
  3138 0000162E 751E                <1> 	jnz	.exit
  3139 00001630 F6C704              <1> 	test	bh,4			; sector not found?
  3140 00001633 B404                <1> 	mov	ah,fdc_e_notfound
  3141 00001635 7517                <1> 	jnz	.exit
  3142 00001637 F6C710              <1> 	test	bh,10H			; DMA overrun?
  3143 0000163A B408                <1> 	mov	ah,fdc_e_dma
  3144 0000163C 7510                <1> 	jnz	.exit
  3145 0000163E F6C720              <1> 	test	bh,20H			; CRC error?
  3146 00001641 B410                <1> 	mov	ah,fdc_e_crc
  3147 00001643 7509                <1> 	jnz	.exit
  3148 00001645 F6C780              <1> 	test	bh,80h			; access after last sector?
  3149 00001648 B404                <1> 	mov	ah,fdc_e_notfound
  3150 0000164A 7502                <1> 	jnz	.exit
  3151 0000164C B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  3152                              <1> 
  3153                              <1> .exit:
  3154 0000164E C3                  <1> 	ret
  3155                              <1> 
  3156                              <1> ;=========================================================================
  3157                              <1> ; fdc_reset - Reset FDC
  3158                              <1> ; Input:
  3159                              <1> ;	none
  3160                              <1> ; Output:
  3161                              <1> ;	Resets FDC flags in BIOS area
  3162                              <1> ;	AX,CX,DX - trashed 
  3163                              <1> ;-------------------------------------------------------------------------
  3164                              <1> 
  3165                              <1> fdc_reset:
  3166 0000164F FA                  <1> 	cli
  3167 00001650 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  3168 00001655 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3169 0000165A A03F00              <1> 	mov	al,byte [fdc_motor_state]
  3170 0000165D D0C0                <1> 	rol	al,1			; after rol:
  3171 0000165F D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  3172 00001661 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  3173 00001663 D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  3174 00001665 24FB                <1> 	and	al,0FBh			; clear reserved bit
  3175 00001667 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  3176 00001669 BAF203              <1> 	mov	dx,fdc_dor_reg
  3177 0000166C EE                  <1> 	out	dx,al			; send it to FDC
  3178 0000166D B90300              <1> 	mov	cx,3
  3179 00001670 E829F8              <1> 	call	delay_15us		; 30-45 us delay
  3180 00001673 0C0C                <1> 	or	al,0Ch
  3181 00001675 EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  3182 00001676 FB                  <1> 	sti
  3183 00001677 E82C01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3184 0000167A 7207                <1> 	jc	.exit
  3185 0000167C 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  3186 00001681 30E4                <1> 	xor	ah,ah			; no errors
  3187                              <1> .exit:
  3188 00001683 C3                  <1> 	ret
  3189                              <1> 
  3190                              <1> ;=========================================================================
  3191                              <1> ; read_cmos_type - Read drive type from CMOS
  3192                              <1> ; Input:
  3193                              <1> ;	DL = drive number (0 or 1)
  3194                              <1> ; Output:
  3195                              <1> ;	CF clear if successful
  3196                              <1> ;		AL = drive type
  3197                              <1> ;	CF set on error (invalid drive type)
  3198                              <1> ;=========================================================================
  3199                              <1> 
  3200                              <1> read_cmos_type:
  3201 00001684 B010                <1> 	mov	al,cmos_floppy
  3202 00001686 E80EF4              <1> 	call	rtc_read		; read drive type
  3203 00001689 08D2                <1> 	or	dl,dl			; drive 0?
  3204 0000168B 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  3205 0000168D D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  3206 0000168F D0E8                <1> 	shr	al,1
  3207 00001691 D0E8                <1> 	shr	al,1
  3208 00001693 D0E8                <1> 	shr	al,1
  3209                              <1> .drive_1:
  3210 00001695 240F                <1> 	and	al,0Fh			; mask drive bits
  3211 00001697 3C00                <1> 	cmp	al,cmos_no_floppy
  3212 00001699 740A                <1> 	je	.error
  3213 0000169B 3C05                <1> 	cmp	al,5			; invalid value
  3214 0000169D 7406                <1> 	je	.error
  3215 0000169F 3C06                <1> 	cmp	al,cmos_2880
  3216 000016A1 7702                <1> 	ja	.error
  3217 000016A3 F8                  <1> 	clc
  3218 000016A4 C3                  <1> 	ret
  3219                              <1> 
  3220                              <1> .error:
  3221 000016A5 F9                  <1> 	stc
  3222 000016A6 C3                  <1> 	ret
  3223                              <1> 
  3224                              <1> ;=========================================================================
  3225                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  3226                              <1> ; Input:
  3227                              <1> ;	none, expects drive number in [bp+int_13_dl]
  3228                              <1> ; Output:
  3229                              <1> ;	CF clear if successful
  3230                              <1> ;		AH = 00h
  3231                              <1> ;	CF set on error
  3232                              <1> ;		AH = 20h - invalid CMOS
  3233                              <1> ;-------------------------------------------------------------------------
  3234                              <1> fdc_detect_media:
  3235 000016A7 52                  <1> 	push	dx
  3236 000016A8 51                  <1> 	push	cx
  3237 000016A9 53                  <1> 	push	bx
  3238 000016AA 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL - drive
  3239 000016AD BB9000              <1> 	mov	bx,fdc_media_state
  3240 000016B0 00D3                <1> 	add	bl,dl
  3241 000016B2 E8CFFF              <1> 	call	read_cmos_type		; get drive type to AL
  3242 000016B5 B400                <1> 	mov	ah,0
  3243 000016B7 7270                <1> 	jc	.invalid_cmos		; invalid drive type in CMOS
  3244                              <1> 
  3245 000016B9 3C03                <1> 	cmp	al,cmos_720
  3246 000016BB 7410                <1> 	je	.set_720
  3247 000016BD 3C02                <1> 	cmp	al,cmos_1200
  3248 000016BF 7415                <1> 	je	.detect_1200
  3249 000016C1 3C04                <1> 	cmp	al,cmos_1440
  3250 000016C3 7427                <1> 	je	.detect_1440
  3251 000016C5 3C06                <1> 	cmp	al,cmos_2880
  3252 000016C7 7439                <1> 	je	.detect_2880
  3253                              <1> 	
  3254 000016C9 B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  3255 000016CB EB02                <1> 	jmp	.set_rate
  3256                              <1> 
  3257                              <1> .set_720:
  3258 000016CD B097                <1> 	mov	al,fdc_m_720
  3259                              <1> 
  3260                              <1> .set_rate:
  3261 000016CF 50                  <1> 	push	ax
  3262 000016D0 E8C800              <1> 	call	fdc_set_rate		; transfer rate in AL
  3263 000016D3 58                  <1> 	pop	ax
  3264 000016D4 EB49                <1> 	jmp	.exit_set_media
  3265                              <1> 
  3266                              <1> .detect_1200:
  3267 000016D6 B000                <1> 	mov	al,0			; try 500 Kbps
  3268 000016D8 E85300              <1> 	call	fdc_read_id
  3269 000016DB B015                <1> 	mov	al,fdc_m_1200in1200
  3270 000016DD 7340                <1> 	jnc	.exit_set_media		; jump if successful
  3271 000016DF B040                <1> 	mov	al,40h			; try 300 Kbps
  3272 000016E1 E84A00              <1> 	call	fdc_read_id
  3273 000016E4 B074                <1> 	mov	al,fdc_m_360in1200
  3274 000016E6 7337                <1> 	jnc	.exit_set_media		; jump if successful
  3275 000016E8 B002                <1> 	mov	al,fdc_m_try_1200in1200
  3276 000016EA EB33                <1> 	jmp	.exit_set_media
  3277                              <1> 
  3278                              <1> .detect_1440:
  3279 000016EC B000                <1> 	mov	al,0			; try 500 Kbps
  3280 000016EE E83D00              <1> 	call	fdc_read_id
  3281 000016F1 B017                <1> 	mov	al,fdc_m_1440
  3282 000016F3 732A                <1> 	jnc	.exit_set_media		; jump if successful
  3283 000016F5 B080                <1> 	mov	al,80h			; try 250 Kbps
  3284 000016F7 E83400              <1> 	call	fdc_read_id
  3285 000016FA B097                <1> 	mov	al,fdc_m_720
  3286 000016FC 7321                <1> 	jnc	.exit_set_media		; jump if successful
  3287 000016FE B007                <1> 	mov	al,fdc_m_try_1440
  3288 00001700 EB1D                <1> 	jmp	.exit_set_media
  3289                              <1> 
  3290                              <1> .detect_2880:
  3291 00001702 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  3292 00001704 E82700              <1> 	call	fdc_read_id
  3293 00001707 B0D7                <1> 	mov	al,fdc_m_2880
  3294 00001709 7314                <1> 	jnc	.exit_set_media		; jump if successful
  3295 0000170B B000                <1> 	mov	al,0			; try 500 Kbps
  3296 0000170D E81E00              <1> 	call	fdc_read_id
  3297 00001710 B017                <1> 	mov	al,fdc_m_1440
  3298 00001712 730B                <1> 	jnc	.exit_set_media		; jump if successful
  3299 00001714 B080                <1> 	mov	al,80h			; try 250 Kbps
  3300 00001716 E81500              <1> 	call	fdc_read_id
  3301 00001719 B097                <1> 	mov	al,fdc_m_720
  3302 0000171B 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  3303 0000171D B0C7                <1> 	mov	al,fdc_m_try_2880
  3304                              <1> 
  3305                              <1> .exit_set_media:
  3306 0000171F 8807                <1> 	mov	byte [bx],al		; set media type
  3307                              <1> 
  3308                              <1> .exit:
  3309 00001721 88264100            <1> 	mov	byte [fdc_last_error],ah
  3310 00001725 5B                  <1> 	pop	bx
  3311 00001726 59                  <1> 	pop	cx
  3312 00001727 5A                  <1> 	pop	dx
  3313 00001728 C3                  <1> 	ret
  3314                              <1> 
  3315                              <1> .invalid_cmos:
  3316 00001729 B420                <1> 	mov	ah,fdc_e_failure
  3317 0000172B F9                  <1> 	stc
  3318 0000172C EBF3                <1> 	jmp	.exit
  3319                              <1> 
  3320                              <1> ;=========================================================================
  3321                              <1> ; fdc_read_id - Read ID
  3322                              <1> ; Input:
  3323                              <1> ;	AL = data transfer rate (bits 7-6)
  3324                              <1> ; Output:
  3325                              <1> ;	CF clear if successful
  3326                              <1> ;		AH = 0 - successful completion
  3327                              <1> ;		AL = ID (bits 7-6)
  3328                              <1> ;	CF set on error
  3329                              <1> ;		AH = error code
  3330                              <1> ;-------------------------------------------------------------------------
  3331                              <1> fdc_read_id:
  3332 0000172E 53                  <1> 	push	bx
  3333 0000172F C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  3334 00001734 E86400              <1> 	call	fdc_set_rate		; transfer rate in AL
  3335 00001737 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  3336 0000173A E8A2FB              <1> 	call	fdc_recalibrate		; recalibrate
  3337 0000173D 7305                <1> 	jnc	.do_read_id
  3338 0000173F E89DFB              <1> 	call	fdc_recalibrate		; second attempt
  3339 00001742 722D                <1> 	jc	.error
  3340                              <1> 
  3341                              <1> .do_read_id:
  3342 00001744 B90300              <1> 	mov	cx,3			; 3 attempts
  3343                              <1> 
  3344                              <1> .read_id_loop:
  3345 00001747 51                  <1> 	push	cx
  3346 00001748 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  3347 0000174A 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  3348 0000174C B102                <1> 	mov	cl,2			; 2 byte commands
  3349 0000174E 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  3350 00001753 E8FFFD              <1> 	call	fdc_send_cmd
  3351 00001756 7218                <1> 	jc	.error_cmd
  3352 00001758 E84B00              <1> 	call	fdc_wait_irq		; wait for IRQ6
  3353 0000175B 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  3354 0000175D B107                <1> 	mov	cl,7
  3355 0000175F E858FE              <1> 	call	fdc_get_result		; read result bytes
  3356 00001762 720C                <1> 	jc	.error_cmd
  3357 00001764 E8A8FE              <1> 	call	fdc_get_error		; get error code
  3358 00001767 59                  <1> 	pop	cx
  3359 00001768 08E4                <1> 	or	ah,ah
  3360 0000176A 7406                <1> 	jz	.exit			; if no errors
  3361 0000176C E2D9                <1> 	loop	.read_id_loop		; retry
  3362 0000176E EB01                <1> 	jmp	.error
  3363                              <1> 
  3364                              <1> .error_cmd:
  3365 00001770 59                  <1> 	pop	cx
  3366                              <1> 
  3367                              <1> .error:
  3368 00001771 F9                  <1> 	stc
  3369                              <1> 
  3370                              <1> .exit:
  3371 00001772 5B                  <1> 	pop	bx
  3372 00001773 C3                  <1> 	ret
  3373                              <1> 
  3374                              <1> ;=========================================================================
  3375                              <1> ; fdc_select_rate - Select FDC transfer rate
  3376                              <1> ; Input:
  3377                              <1> ;	none
  3378                              <1> ; Output:
  3379                              <1> ;	AL = data transfer rate (bits 7-6)
  3380                              <1> ;-------------------------------------------------------------------------
  3381                              <1> fdc_select_rate:
  3382 00001774 53                  <1> 	push	bx
  3383 00001775 BB9000              <1> 	mov	bx,fdc_media_state
  3384 00001778 00D3                <1> 	add	bl,dl			; SI -> drive media state
  3385 0000177A 8A37                <1> 	mov	dh,byte [bx]		; new media status
  3386 0000177C 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; last selected rate
  3387 00001780 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  3388 00001784 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  3389 00001786 740E                <1> 	je	.exit			; exit if rate is already selected
  3390 00001788 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  3391 0000178D 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  3392 00001791 88F0                <1> 	mov	al,dh
  3393 00001793 E80500              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  3394                              <1> 
  3395                              <1> .exit:
  3396 00001796 5B                  <1> 	pop	bx
  3397 00001797 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  3398 0000179A C3                  <1> 	ret
  3399                              <1> 
  3400                              <1> ;=========================================================================
  3401                              <1> ; fdc_set_rate - Set transfer rate
  3402                              <1> ; Input:
  3403                              <1> ;	AL = transfer rate (bits 7 and 6)
  3404                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  3405                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  3406                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  3407                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  3408                              <1> ; Output:
  3409                              <1> ;	AL = transfer rate (bits 1 and 0)
  3410                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  3411                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  3412                              <1> ;	DX = 3F7h - FDC CCR
  3413                              <1> ;-------------------------------------------------------------------------
  3414                              <1> fdc_set_rate:
  3415 0000179B 24C0                <1> 	and	al,fdc_m_rate_bits
  3416 0000179D D0C0                <1> 	rol	al,1
  3417 0000179F D0C0                <1> 	rol	al,1
  3418 000017A1 BAF703              <1> 	mov	dx,fdc_ccr_reg
  3419 000017A4 EE                  <1> 	out	dx,al
  3420 000017A5 C3                  <1> 	ret
  3421                              <1> 
  3422                              <1> ;=========================================================================
  3423                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  3424                              <1> ; Input:
  3425                              <1> ;	none
  3426                              <1> ; Output:
  3427                              <1> ;	CF clear if interrupt had occurred
  3428                              <1> ;		AH = 00h - successful completion
  3429                              <1> ;	CF set if no interrupt
  3430                              <1> ;		AH = 80h - timeout
  3431                              <1> ;	BX = fdc_calib_state
  3432                              <1> ;	AL,CX - trashed
  3433                              <1> ;-------------------------------------------------------------------------
  3434                              <1> fdc_wait_irq:
  3435 000017A6 FB                  <1> 	sti
  3436 000017A7 F8                  <1> 	clc
  3437 000017A8 B80190              <1> 	mov	ax,9001h
  3438 000017AB CD15                <1> 	int	15h			; call OS hook
  3439 000017AD 7221                <1> 	jc	.timeout
  3440 000017AF BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  3441 000017B2 31C9                <1> 	xor	cx,cx
  3442                              <1> 
  3443                              <1> .zero:
  3444 000017B4 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3445 000017B7 751B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3446                              <1> 
  3447                              <1> .zero_loop:
  3448 000017B9 E461                <1> 	in	al,port_b_reg
  3449 000017BB A810                <1> 	test	al,refresh_flag
  3450 000017BD 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3451 000017BF E202                <1> 	loop	.one			; DEC CX; JNZ .one
  3452 000017C1 EB0D                <1> 	jmp	.timeout
  3453                              <1> 
  3454                              <1> .one:
  3455 000017C3 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  3456 000017C6 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  3457                              <1> 
  3458                              <1> .one_loop:
  3459 000017C8 E461                <1> 	in	al,port_b_reg
  3460 000017CA A810                <1> 	test	al,refresh_flag
  3461 000017CC 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3462 000017CE E2E4                <1> 	loop	.zero			; DEC CX; JNZ .one
  3463                              <1> 
  3464                              <1> .timeout:
  3465 000017D0 B480                <1> 	mov	ah,fdc_e_timeout
  3466 000017D2 F9                  <1> 	stc
  3467 000017D3 C3                  <1> 	ret
  3468                              <1> 
  3469                              <1> .exit:
  3470 000017D4 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  3471 000017D7 B400                <1> 	mov	ah,fdc_e_success
  3472 000017D9 F8                  <1> 	clc				; DEBUG - remove after debug
  3473 000017DA C3                  <1> 	ret
  3474                              <1> 
  3475                              <1> ;=========================================================================
  3476                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  3477                              <1> ;		   but no more than one second
  3478                              <1> ; Input:
  3479                              <1> ; Output:
  3480                              <1> ;	CF clear if FDC is ready
  3481                              <1> ;		AL = FDC main status register
  3482                              <1> ;	CF set on timeout
  3483                              <1> ;		AL trashed
  3484                              <1> ;	DX - trashed
  3485                              <1> ;-------------------------------------------------------------------------
  3486                              <1> 
  3487                              <1> fdc_wait_ready:
  3488 000017DB 51                  <1> 	push	cx
  3489 000017DC BAF403              <1> 	mov	dx,fdc_status_reg
  3490 000017DF 31C9                <1> 	xor	cx,cx
  3491                              <1> 
  3492                              <1> .zero:
  3493 000017E1 EC                  <1> 	in	al,dx			; read I/O port
  3494 000017E2 A880                <1> 	test	al,fdc_stat_ready
  3495 000017E4 7517                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  3496                              <1> 
  3497                              <1> .zero_loop:
  3498 000017E6 E461                <1> 	in	al,port_b_reg
  3499 000017E8 A810                <1> 	test	al,refresh_flag
  3500 000017EA 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  3501 000017EC 49                  <1> 	dec	cx
  3502 000017ED 740D                <1> 	jz	.timeout
  3503 000017EF EC                  <1> 	in	al,dx			; read I/O port again
  3504 000017F0 A880                <1> 	test	al,fdc_stat_ready
  3505 000017F2 7509                <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  3506                              <1> 
  3507                              <1> .one_loop:
  3508 000017F4 E461                <1> 	in	al,port_b_reg
  3509 000017F6 A810                <1> 	test	al,refresh_flag
  3510 000017F8 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  3511 000017FA E2E5                <1> 	loop	.zero
  3512                              <1> 
  3513                              <1> .timeout:
  3514 000017FC F9                  <1> 	stc
  3515                              <1> 
  3516                              <1> .exit:
  3517 000017FD 59                  <1> 	pop	cx
  3518 000017FE C3                  <1> 	ret
  3519                              <1> 
  3520                              <1> ;=========================================================================
  3521                              <1> ; print_floppy - Print floppy configuration
  3522                              <1> ; Input:
  3523                              <1> ;	AL = NVRAM floppy configuration byte
  3524                              <1> ; Ouput:
  3525                              <1> ;	none
  3526                              <1> ;-------------------------------------------------------------------------
  3527                              <1> print_floppy:
  3528 000017FF 50                  <1> 	push	ax
  3529 00001800 56                  <1> 	push	si
  3530 00001801 BE[9701]            <1> 	mov	si,msg_floppy
  3531 00001804 E8890D              <1> 	call	print
  3532 00001807 D0C8                <1> 	ror	al,1
  3533 00001809 D0C8                <1> 	ror	al,1
  3534 0000180B D0C8                <1> 	ror	al,1
  3535 0000180D D0C8                <1> 	ror	al,1
  3536 0000180F 89C6                <1> 	mov	si,ax
  3537 00001811 83E607              <1> 	and	si,0007h
  3538 00001814 D1E6                <1> 	shl	si,1
  3539 00001816 2E8BB4[8706]        <1>     cs	mov	si,word [tbl_floppy+si]
  3540 0000181B E8720D              <1> 	call	print
  3541 0000181E BE[BD01]            <1> 	mov	si,msg_floppy_2
  3542 00001821 E86C0D              <1> 	call	print
  3543 00001824 D0C8                <1> 	ror	al,1
  3544 00001826 D0C8                <1> 	ror	al,1
  3545 00001828 D0C8                <1> 	ror	al,1
  3546 0000182A D0C8                <1> 	ror	al,1
  3547 0000182C 89C6                <1> 	mov	si,ax
  3548 0000182E 83E607              <1> 	and	si,0007h
  3549 00001831 D1E6                <1> 	shl	si,1
  3550 00001833 2E8BB4[8706]        <1>     cs	mov	si,word [tbl_floppy+si]
  3551 00001838 E8550D              <1> 	call	print
  3552 0000183B BE[8800]            <1> 	mov	si,msg_crlf
  3553 0000183E E84F0D              <1> 	call	print
  3554 00001841 5E                  <1> 	pop	si
  3555 00001842 58                  <1> 	pop	ax
  3556 00001843 C3                  <1> 	ret
  3557                                  %include	"kbc.inc"		; keyboard controller functions
  3558                              <1> ;=========================================================================
  3559                              <1> ; kbc.inc - Keyboard controller support
  3560                              <1> ;-------------------------------------------------------------------------
  3561                              <1> ;
  3562                              <1> ; Compiles with NASM 2.07, might work with other versions
  3563                              <1> ;
  3564                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  3565                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  3566                              <1> ;
  3567                              <1> ; This program is free software: you can redistribute it and/or modify
  3568                              <1> ; it under the terms of the GNU General Public License as published by
  3569                              <1> ; the Free Software Foundation, either version 3 of the License, or
  3570                              <1> ; (at your option) any later version.
  3571                              <1> ;
  3572                              <1> ; This program is distributed in the hope that it will be useful,
  3573                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3574                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3575                              <1> ; GNU General Public License for more details.
  3576                              <1> ;
  3577                              <1> ; You should have received a copy of the GNU General Public License
  3578                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  3579                              <1> ;
  3580                              <1> ;=========================================================================
  3581                              <1> 
  3582                              <1> ;=========================================================================
  3583                              <1> ; Keyboard controller defines - ports, commands, and flags
  3584                              <1> ;-------------------------------------------------------------------------
  3585                              <1> kbc_data_reg	equ	60h
  3586                              <1> kbc_input_reg	equ	60h
  3587                              <1> kbc_output_reg	equ	60h
  3588                              <1> ; keyboard controller return codes
  3589                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
  3590                              <1> ; keyboard controller status register and its bits
  3591                              <1> kbc_status_reg	equ	64h
  3592                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
  3593                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
  3594                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
  3595                              <1> ; keyboard contoller command register and commands
  3596                              <1> kbc_command_reg	equ	64h
  3597                              <1> kbc_cmd_wr_ctr	equ	60h	; write control register command
  3598                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
  3599                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
  3600                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
  3601                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
  3602                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
  3603                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
  3604                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
  3605                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
  3606                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
  3607                              <1> ; keyboard controller control register bits
  3608                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
  3609                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
  3610                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
  3611                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
  3612                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
  3613                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
  3614                              <1> ; keyboard controller input port bits
  3615                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
  3616                              <1> 
  3617                              <1> ;=========================================================================
  3618                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
  3619                              <1> ; Input:
  3620                              <1> ;	AL = command
  3621                              <1> ; Output:
  3622                              <1> ;	none
  3623                              <1> ;-------------------------------------------------------------------------
  3624                              <1> kbc_kb_send:
  3625 00001844 50                  <1> 	push	ax
  3626 00001845 51                  <1> 	push	cx
  3627 00001846 88C4                <1> 	mov	ah,al			; save command to AH
  3628 00001848 B90300              <1> 	mov	cx,3			; try 3 times
  3629                              <1> 
  3630                              <1> .1:
  3631 0000184B 51                  <1> 	push	cx
  3632 0000184C FA                  <1> 	cli
  3633                              <1> ; clear the Error, Acknowledge received, and resend received flags
  3634 0000184D 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
  3635 00001852 31C9                <1> 	xor	cx,cx
  3636                              <1> 
  3637                              <1> .2:					; wait for KBC to empty input buffer
  3638 00001854 E464                <1> 	in	al,kbc_status_reg
  3639 00001856 A802                <1> 	test	al,kbc_stat_ibf
  3640 00001858 E0FA                <1> 	loopnz	.2
  3641                              <1> 
  3642 0000185A 88E0                <1> 	mov	al,ah
  3643 0000185C E660                <1> 	out	kbc_output_reg,al	; send command to the keyboard
  3644 0000185E FB                  <1> 	sti
  3645 0000185F 31C9                <1> 	xor	cx,cx
  3646                              <1> .3:					; wait for acknowledge (set by IRQ1 ISR)
  3647 00001861 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
  3648 00001866 E1F9                <1> 	loopz	.3
  3649 00001868 59                  <1> 	pop	cx
  3650 00001869 7507                <1> 	jnz	.4
  3651 0000186B E2DE                <1> 	loop	.1			; try again
  3652                              <1> ; if the operation failed after 3 retries, set the error bit and quit
  3653 0000186D 800E970080          <1> 	or	byte [kbd_flags_4], 80h
  3654                              <1> .4:
  3655 00001872 59                  <1> 	pop	cx
  3656 00001873 58                  <1> 	pop	ax
  3657 00001874 C3                  <1> 	ret
  3658                              <1> 
  3659                              <1> ;=========================================================================
  3660                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
  3661                              <1> ; Input:
  3662                              <1> ;	AL - command byte
  3663                              <1> ;	AH = argument
  3664                              <1> ; Output:
  3665                              <1> ;	ZF == 0 - success
  3666                              <1> ;	ZF == 1 - error
  3667                              <1> ;-------------------------------------------------------------------------
  3668                              <1> kbc_send_cmd:
  3669 00001875 51                  <1> 	push	cx
  3670 00001876 88C5                <1> 	mov	ch,al			; save command byte to CH
  3671 00001878 B11E                <1> 	mov	cl,30			; 30 retries
  3672                              <1> .1:
  3673 0000187A FA                  <1> 	cli
  3674 0000187B 88E8                <1> 	mov	al,ch
  3675 0000187D E82800              <1> 	call	kbc_send_cmd_byte
  3676 00001880 7522                <1> 	jnz	.exit			; time out
  3677 00001882 E464                <1> 	in	al,kbc_status_reg
  3678 00001884 A801                <1> 	test	al,kbc_stat_obf
  3679 00001886 7414                <1> 	jz	.3			; output buffer is empty
  3680 00001888 A820                <1> 	test	al,kbc_stat_aobf
  3681 0000188A 7409                <1> 	jz	.2			; output buffer is full, not aux data
  3682 0000188C E460                <1> 	in	al,kbc_output_reg	; clean up auxiliary data from buffer
  3683                              <1> %ifdef PS2_MOUSE
  3684 0000188E 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset the mouse data index
  3685                              <1> %endif ; PS2_MOUSE
  3686 00001893 EB07                <1> 	jmp	.3
  3687                              <1> .2:
  3688 00001895 FB                  <1> 	sti
  3689 00001896 FEC9                <1> 	dec	cl
  3690 00001898 75E0                <1> 	jnz	.1
  3691 0000189A EB08                <1> 	jmp	.exit			; note: ZF=1
  3692                              <1> .3:
  3693 0000189C 88E0                <1> 	mov	al,ah
  3694 0000189E E660                <1> 	out	kbc_input_reg,al
  3695 000018A0 FB                  <1> 	sti
  3696 000018A1 80C901              <1> 	or	cl,1			; set ZF=0
  3697                              <1> .exit:
  3698 000018A4 88E8                <1> 	mov	al,ch			; restore AL
  3699 000018A6 59                  <1> 	pop	cx
  3700 000018A7 C3                  <1> 	ret
  3701                              <1> 
  3702                              <1> ;=========================================================================
  3703                              <1> ; kbc_send_cmd_byte - send command byte to keyboard controller
  3704                              <1> ; Input:
  3705                              <1> ;	AL - command byte
  3706                              <1> ; Output:
  3707                              <1> ;	ZF == 1 - success
  3708                              <1> ;	ZF == 0 - time out
  3709                              <1> ; Note:
  3710                              <1> ;	XXX - function should be reused in keyboard code
  3711                              <1> ;-------------------------------------------------------------------------
  3712                              <1> kbc_send_cmd_byte:
  3713 000018A8 51                  <1> 	push	cx
  3714 000018A9 50                  <1> 	push	ax
  3715 000018AA 31C9                <1> 	xor	cx,cx
  3716                              <1> 				; wait for KBC to empty input buffer
  3717                              <1> .1:
  3718 000018AC E464                <1> 	in	al,kbc_status_reg
  3719 000018AE A802                <1> 	test	al,kbc_stat_ibf
  3720 000018B0 E0FA                <1> 	loopnz	.1
  3721 000018B2 750C                <1> 	jnz	.exit		; time out
  3722                              <1> 
  3723 000018B4 58                  <1> 	pop	ax
  3724 000018B5 E664                <1> 	out	kbc_command_reg,al
  3725                              <1> 
  3726 000018B7 50                  <1> 	push	ax
  3727 000018B8 31C9                <1> 	xor	cx,cx
  3728                              <1> 				; wait for KBC to empty input buffer
  3729                              <1> .2:
  3730 000018BA E464                <1> 	in	al,kbc_status_reg
  3731 000018BC A802                <1> 	test	al,kbc_stat_ibf
  3732 000018BE E0FA                <1> 	loopnz	.2
  3733                              <1> .exit:
  3734 000018C0 58                  <1> 	pop	ax
  3735 000018C1 59                  <1> 	pop	cx
  3736 000018C2 C3                  <1> 	ret
  3737                              <1> 
  3738                              <1> ;=========================================================================
  3739                              <1> ; kbc_wait_output_full - wait for data in keyboard controller output buffer
  3740                              <1> ; Input:
  3741                              <1> ;	none
  3742                              <1> ; Output:
  3743                              <1> ;	AL = keyboard status register
  3744                              <1> ;	ZF == 0 - data is available
  3745                              <1> ;	ZF == 1 - timed out
  3746                              <1> ; Note:
  3747                              <1> ;	XXX - if this function won't be reused anywhere else, it should
  3748                              <1> ;	      be merged with kbc_wait_aux_full
  3749                              <1> ;-------------------------------------------------------------------------
  3750                              <1> kbc_wait_output_full:
  3751 000018C3 51                  <1> 	push	cx
  3752 000018C4 31C9                <1> 	xor	cx,cx
  3753                              <1> .1:
  3754 000018C6 E464                <1> 	in	al,kbc_status_reg
  3755 000018C8 A801                <1> 	test	al,kbc_stat_obf
  3756 000018CA E1FA                <1> 	loopz	.1
  3757 000018CC 09C9                <1> 	or	cx,cx
  3758 000018CE 59                  <1> 	pop	cx
  3759 000018CF C3                  <1> 	ret
  3760                              <1> 
  3761                              <1> %ifdef PS2_MOUSE
  3762                              <1> ;=========================================================================
  3763                              <1> ; kbc_aux_read - read data from auxiliary device
  3764                              <1> ; Input:
  3765                              <1> ;	none
  3766                              <1> ; Output:
  3767                              <1> ;	AL = data
  3768                              <1> ;	CF == 0 - data is available
  3769                              <1> ;	CF == 1 - time out
  3770                              <1> ;-------------------------------------------------------------------------
  3771                              <1> kbc_aux_read:
  3772 000018D0 51                  <1> 	push	cx
  3773                              <1> ;	xor	cx,cx			; XXX too much?!
  3774 000018D1 B91400              <1> 	mov	cx,20			; retry 20 times
  3775                              <1> .1:
  3776 000018D4 E86000              <1> 	call	kbc_wait_aux_full
  3777 000018D7 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3778 000018D9 E1F9                <1> 	loopz	.1
  3779 000018DB EB0B                <1> 	jmp	.error			; time out
  3780                              <1> .2:
  3781 000018DD B90100              <1> 	mov	cx,1
  3782 000018E0 E8B9F5              <1> 	call	delay_15us
  3783 000018E3 E460                <1> 	in	al,kbc_output_reg
  3784 000018E5 F8                  <1> 	clc
  3785 000018E6 EB01                <1> 	jmp	.exit
  3786                              <1> .error:
  3787 000018E8 F9                  <1> 	stc
  3788                              <1> .exit:
  3789 000018E9 59                  <1> 	pop	cx
  3790 000018EA C3                  <1> 	ret
  3791                              <1> 
  3792                              <1> ;=========================================================================
  3793                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
  3794                              <1> ; Input:
  3795                              <1> ;	AL = command
  3796                              <1> ; Output:
  3797                              <1> ;	AH - status:
  3798                              <1> ;		00h - success
  3799                              <1> ;		03h - interface error (time out)
  3800                              <1> ;		04h - resend requested
  3801                              <1> ;	CF == 0 - no error
  3802                              <1> ;	CF == 1 - error
  3803                              <1> ;-------------------------------------------------------------------------
  3804                              <1> kbc_aux_send:
  3805 000018EB 51                  <1> 	push	cx
  3806 000018EC 88C4                <1> 	mov	ah,al			; store command to AH
  3807 000018EE B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
  3808 000018F0 E882FF              <1> 	call	kbc_send_cmd
  3809 000018F3 7423                <1> 	jz	.timeout		; kbc_send_cmd timed out
  3810                              <1> 
  3811                              <1> 					; wait for acknowledge
  3812 000018F5 B90A00              <1> 	mov	cx,10			; retry 10 times
  3813                              <1> .1:
  3814 000018F8 E83C00              <1> 	call	kbc_wait_aux_full
  3815 000018FB 7504                <1> 	jnz	.2			; if ZF=0 - data is available
  3816 000018FD E2F9                <1> 	loop	.1
  3817 000018FF EB17                <1> 	jmp	.timeout		; no reply - timeout
  3818                              <1> .2:
  3819 00001901 E460                <1> 	in	al,kbc_output_reg
  3820 00001903 3CFA                <1> 	cmp	al,0FAh			; ACK?
  3821 00001905 740C                <1> 	je	.ok
  3822 00001907 3CFE                <1> 	cmp	al,0FEh			; resend?
  3823 00001909 7411                <1> 	je	.resend
  3824 0000190B 3CFC                <1> 	cmp	al,0FCh			; error?
  3825 0000190D 7409                <1> 	je	.timeout		; treat as timeout/interface error
  3826 0000190F E2E7                <1> 	loop	.1
  3827 00001911 EB05                <1> 	jmp	.timeout
  3828                              <1> 
  3829                              <1> .ok:
  3830 00001913 30C0                <1> 	xor	al,al			; success - ACK received
  3831 00001915 F8                  <1> 	clc
  3832 00001916 EB07                <1> 	jmp	.exit
  3833                              <1> 
  3834                              <1> .timeout:
  3835 00001918 B003                <1> 	mov	al,03h			; interface error
  3836 0000191A EB02                <1> 	jmp	.error
  3837                              <1> 
  3838                              <1> .resend:
  3839 0000191C B004                <1> 	mov	al,04h			; resend
  3840                              <1> 
  3841                              <1> .error:
  3842 0000191E F9                  <1> 	stc
  3843                              <1> 
  3844                              <1> .exit:
  3845 0000191F 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
  3846 00001921 59                  <1> 	pop	cx
  3847 00001922 C3                  <1> 	ret
  3848                              <1> 
  3849                              <1> ;=========================================================================
  3850                              <1> ; kbc_aux_enable - enable auxiliary device
  3851                              <1> ; Input:
  3852                              <1> ;	none
  3853                              <1> ; Output:
  3854                              <1> ;	ZF = 0 - no error
  3855                              <1> ;	ZF = 1 - error
  3856                              <1> ;-------------------------------------------------------------------------
  3857                              <1> kbc_aux_enable:
  3858 00001923 50                  <1> 	push	ax
  3859 00001924 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3860 00001926 B447                <1> 	mov	ah,01000111b		; pc compatible, enable aux
  3861                              <1> 					; enable keyboard, enable aux obf
  3862                              <1> 					; interrupt, enable obf interrupt
  3863 00001928 E84AFF              <1> 	call	kbc_send_cmd
  3864 0000192B 58                  <1> 	pop	ax
  3865 0000192C C3                  <1> 	ret
  3866                              <1> 
  3867                              <1> ;=========================================================================
  3868                              <1> ; kbc_aux_disable - disable auxiliary device
  3869                              <1> ; Input:
  3870                              <1> ;	none
  3871                              <1> ; Output:
  3872                              <1> ;	ZF = 0 - no error
  3873                              <1> ;	ZF = 1 - error
  3874                              <1> ;-------------------------------------------------------------------------
  3875                              <1> kbc_aux_disable:
  3876 0000192D 50                  <1> 	push	ax
  3877 0000192E B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller command byte
  3878 00001930 B465                <1> 	mov	ah,01100101b		; pc compatible, disable aux
  3879                              <1> 					; enable keyboard, disable aux obf
  3880                              <1> 					; interrupt, enable obf interrupt
  3881 00001932 E840FF              <1> 	call	kbc_send_cmd
  3882 00001935 58                  <1> 	pop	ax
  3883 00001936 C3                  <1> 	ret
  3884                              <1> 
  3885                              <1> ;=========================================================================
  3886                              <1> ; kbc_wait_aux_full - wait for data in keyboard controller auxiliary buffer
  3887                              <1> ; Input:
  3888                              <1> ;	none
  3889                              <1> ; Output:
  3890                              <1> ;	AL = keyboard status register
  3891                              <1> ;	ZF == 0 - data is available
  3892                              <1> ;	ZF == 1 - timed out
  3893                              <1> ;-------------------------------------------------------------------------
  3894                              <1> kbc_wait_aux_full:
  3895 00001937 E889FF              <1> 	call	kbc_wait_output_full
  3896 0000193A 7402                <1> 	jz	.error
  3897 0000193C A820                <1> 	test	al,kbc_stat_aobf
  3898                              <1> .error:
  3899 0000193E C3                  <1> 	ret
  3900                              <1> 
  3901                              <1> %endif ; PS2_MOUSE
  3902                              <1> 
  3903                              <1> ;=========================================================================
  3904                              <1> ; kbc_flush - flush all data from i8042 buffers
  3905                              <1> ; Input:
  3906                              <1> ;	none
  3907                              <1> ; Output:
  3908                              <1> ;	CF = 0 - flushed successfully
  3909                              <1> ;	CF = 1 - can't flush after 16 retries, probably no hardware
  3910                              <1> ;-------------------------------------------------------------------------
  3911                              <1> kbc_flush:
  3912 0000193F 50                  <1> 	push	ax
  3913 00001940 51                  <1> 	push	cx
  3914 00001941 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
  3915                              <1> .flush_next_byte:
  3916 00001944 E464                <1> 	in	al,kbc_status_reg
  3917 00001946 A801                <1> 	test	al,kbc_stat_obf
  3918 00001948 740F                <1> 	jz	.flushed
  3919 0000194A 51                  <1> 	push	cx
  3920 0000194B B90400              <1> 	mov	cx,4
  3921 0000194E E84BF5              <1> 	call	delay_15us		; 45-60us I/O delay
  3922 00001951 59                  <1> 	pop	cx
  3923 00001952 E460                <1> 	in	al,kbc_data_reg
  3924 00001954 E2EE                <1> 	loop	.flush_next_byte
  3925 00001956 F9                  <1> 	stc				; unable to flush it
  3926 00001957 EB01                <1> 	jmp	.exit
  3927                              <1> .flushed:
  3928 00001959 F8                  <1> 	clc
  3929                              <1> .exit:
  3930 0000195A 59                  <1> 	pop	cx
  3931 0000195B 58                  <1> 	pop	ax
  3932 0000195C C3                  <1> 	ret
  3933                              <1> 
  3934                              <1> ;=========================================================================
  3935                              <1> ; kbc_init - Initialize keyboard controller
  3936                              <1> ;-------------------------------------------------------------------------
  3937                              <1> kbc_init:
  3938 0000195D 50                  <1> 	push	ax
  3939 0000195E 51                  <1> 	push	cx
  3940 0000195F 52                  <1> 	push	dx
  3941                              <1> 
  3942                              <1> ;-------------------------------------------------------------------------
  3943                              <1> ; test keyboard controller
  3944                              <1> 
  3945 00001960 E8DCFF              <1> 	call	kbc_flush		; flush all data from KBC
  3946                              <1> 
  3947 00001963 B90A00              <1> 	mov	cx,10			; try 10 times
  3948                              <1> 
  3949                              <1> .kbc_reset_retry:
  3950 00001966 B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
  3951 00001968 E83DFF              <1> 	call 	kbc_send_cmd_byte
  3952 0000196B E855FF              <1> 	call	kbc_wait_output_full	; wait for response
  3953                              <1> 
  3954 0000196E E460                <1> 	in	al,kbc_output_reg
  3955 00001970 3C55                <1> 	cmp	al,55h			; check for success
  3956 00001972 E0F2                <1> 	loopne	.kbc_reset_retry
  3957 00001974 7403E99D00          <1> 	jne	kbd_ctrl_fail
  3958                              <1> 
  3959 00001979 B90A00              <1> 	mov	cx,10			; try 10 times
  3960                              <1> 
  3961                              <1> .kbc_test_retry:
  3962 0000197C B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
  3963 0000197E E827FF              <1> 	call	kbc_send_cmd_byte
  3964 00001981 E83FFF              <1> 	call	kbc_wait_output_full	; wait for test result
  3965                              <1> 
  3966 00001984 E460                <1> 	in	al,kbc_output_reg
  3967 00001986 3C00                <1> 	cmp	al,0			; check for success
  3968 00001988 E0F2                <1> 	loopne	.kbc_test_retry
  3969 0000198A 7403E98E00          <1> 	jne	kbd_int_fail
  3970                              <1> 
  3971                              <1> ;-------------------------------------------------------------------------
  3972                              <1> ; read display type and set equipment bits accordingly
  3973                              <1> 
  3974 0000198F B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
  3975 00001991 E814FF              <1> 	call	kbc_send_cmd_byte
  3976 00001994 E82CFF              <1> 	call	kbc_wait_output_full
  3977                              <1> 
  3978 00001997 E460                <1> 	in	al,kbc_output_reg
  3979 00001999 A840                <1> 	test	al,kbc_in_display
  3980 0000199B 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
  3981 0000199D 830E100030          <1> 	or	word [equipment_list],equip_mono
  3982 000019A2 EB05                <1> 	jmp	.get_disp_done
  3983                              <1> .get_disp_color:
  3984 000019A4 830E100020          <1> 	or	word [equipment_list],equip_color
  3985                              <1> .get_disp_done:
  3986                              <1> 
  3987                              <1> ;-------------------------------------------------------------------------
  3988                              <1> ; initialize keyboard controller
  3989                              <1> 
  3990 000019A9 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
  3991 000019AB E8FAFE              <1> 	call	kbc_send_cmd_byte
  3992                              <1> 
  3993 000019AE B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
  3994 000019B0 E8F5FE              <1> 	call	kbc_send_cmd_byte
  3995                              <1> 
  3996 000019B3 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
  3997 000019B5 B469                <1> 	mov	ah,01101001B		; Bit 7 = 0 - reserved
  3998                              <1> 					; Bit 6 = 1 - IBM PC scancodes
  3999                              <1> 					; Bit 5 = 1 - IBM PC / no party check
  4000                              <1> 					; Bit 4 = 0 - Enable keyboard
  4001                              <1> 					; Bit 3 = 1 - Disable inhibit
  4002                              <1> 					; Bit 2 = 0 - system flag = 0
  4003                              <1> 					; Bit 1 = 0 - reserved
  4004                              <1> 					; Bit 0 = 1 - enable OBF interrupt
  4005 000019B7 E8BBFE              <1> 	call	kbc_send_cmd
  4006                              <1> 
  4007 000019BA B0FF                <1> 	mov	al,0FFh			; send keyboard reset command
  4008 000019BC E8E9FE              <1> 	call	kbc_send_cmd_byte
  4009                              <1> 
  4010 000019BF B90010              <1> 	mov	cx,1000h
  4011 000019C2 E8D7F4              <1> 	call	delay_15us
  4012                              <1> 
  4013 000019C5 E8FBFE              <1> 	call	kbc_wait_output_full	; wait for response
  4014 000019C8 E460                <1> 	in	al,kbc_output_reg	; clear the output buffer
  4015                              <1> 
  4016                              <1> 
  4017                              <1> %ifdef PS2_MOUSE
  4018                              <1> ;-------------------------------------------------------------------------
  4019                              <1> ; check for PS/2 mouse presence
  4020                              <1> 
  4021 000019CA B90A00              <1> 	mov	cx,10			; try 10 times
  4022                              <1> .mouse_reset_retry:
  4023 000019CD B0FF                <1> 	mov	al,0FFh
  4024 000019CF E819FF              <1> 	call	kbc_aux_send
  4025 000019D2 7307                <1> 	jnc	.mouse_reset_ok		; no error - continue
  4026 000019D4 80FC03              <1> 	cmp	ah,03h			; timeout error?
  4027 000019D7 E1F4                <1> 	loopz	.mouse_reset_retry
  4028 000019D9 EB13                <1> 	jmp	.no_mouse
  4029                              <1> .mouse_reset_ok:
  4030 000019DB E8F2FE              <1> 	call	kbc_aux_read
  4031 000019DE 720E                <1> 	jc	.no_mouse
  4032 000019E0 3CAA                <1> 	cmp	al,0AAh			; Basic Assurance Test successful?
  4033 000019E2 750A                <1> 	jne	.no_mouse
  4034 000019E4 E8E9FE              <1> 	call	kbc_aux_read
  4035 000019E7 7205                <1> 	jc	.no_mouse
  4036                              <1> ; mouse reset successful, update equipment word accordingly
  4037 000019E9 830E100004          <1> 	or      word [equipment_list],equip_mouse
  4038                              <1> .no_mouse:
  4039                              <1> %endif ; PS2_MOUSE
  4040                              <1> 
  4041                              <1> ;-------------------------------------------------------------------------
  4042                              <1> ; setup keyboard buffer
  4043                              <1> 
  4044 000019EE B81E00              <1>         mov     ax,kbd_buffer   ; setup keyboard buffer
  4045 000019F1 A38000              <1>         mov     word [kbd_buffer_start],ax
  4046 000019F4 A31A00              <1>         mov     word [kbd_buffer_head],ax
  4047 000019F7 A31C00              <1>         mov     word [kbd_buffer_tail],ax
  4048 000019FA 83C020              <1>         add     ax,20h          ; size of the keyboard buffer
  4049 000019FD A38200              <1>         mov     word [kbd_buffer_end],ax
  4050 00001A00 31C0                <1>         xor     ax,ax           ; clear keyboard flags
  4051 00001A02 A31700              <1>         mov     word [kbd_flags_1],ax
  4052 00001A05 A31800              <1>         mov     word [kbd_flags_2],ax
  4053 00001A08 A39600              <1>         mov     word [kbd_flags_3],ax
  4054 00001A0B A39700              <1>         mov     word [kbd_flags_4],ax
  4055 00001A0E B010                <1> 	mov	al,e_kbd_ok
  4056 00001A10 E680                <1> 	out	post_reg,al
  4057 00001A12 5A                  <1> 	pop	dx
  4058 00001A13 59                  <1> 	pop	cx
  4059 00001A14 58                  <1> 	pop	ax
  4060 00001A15 C3                  <1> 	ret
  4061                              <1> 
  4062                              <1> kbd_ctrl_fail:
  4063 00001A16 B060                <1> 	mov	al,e_kbd_ctrl_fail
  4064 00001A18 E680                <1> 	out	post_reg,al
  4065                              <1> .1:
  4066 00001A1A F4                  <1> 	hlt
  4067 00001A1B EBFD                <1> 	jmp	.1
  4068                              <1> 
  4069                              <1> kbd_int_fail:
  4070 00001A1D 240F                <1> 	and	al,0Fh
  4071 00001A1F 0463                <1> 	add	al,e_kbd_int_fail
  4072 00001A21 E680                <1> 	out	post_reg,al
  4073                              <1> .1:
  4074 00001A23 F4                  <1> 	hlt
  4075 00001A24 EBFD                <1> 	jmp	.1
  4076                              <1> 
  4077                              <1> kbd_key_fail:
  4078 00001A26 B061                <1> 	mov	al,e_kbd_key_fail
  4079 00001A28 E680                <1> 	out	post_reg,al
  4080                              <1> .1:
  4081 00001A2A F4                  <1> 	hlt
  4082 00001A2B EBFD                <1> 	jmp	.1
  4083                                  %include	"scancode.inc"		; keyboard scancodes translation func.
  4084                              <1> ;=========================================================================
  4085                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
  4086                              <1> ;		 and related INT 16h functions:
  4087                              <1> ;	INT 16h - BIOS Keyboard Services
  4088                              <1> ;		- function AH=00h
  4089                              <1> ;		- function AH=01h
  4090                              <1> ;		- function AH=10h
  4091                              <1> ;		- function AH=11h
  4092                              <1> ;-------------------------------------------------------------------------
  4093                              <1> ;
  4094                              <1> ; Compiles with NASM 2.07, might work with other versions
  4095                              <1> ;
  4096                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4097                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4098                              <1> ;
  4099                              <1> ; This program is free software: you can redistribute it and/or modify
  4100                              <1> ; it under the terms of the GNU General Public License as published by
  4101                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4102                              <1> ; (at your option) any later version.
  4103                              <1> ;
  4104                              <1> ; This program is distributed in the hope that it will be useful,
  4105                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4106                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4107                              <1> ; GNU General Public License for more details.
  4108                              <1> ;
  4109                              <1> ; You should have received a copy of the GNU General Public License
  4110                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4111                              <1> ;
  4112                              <1> ;=========================================================================
  4113                              <1> 
  4114                              <1> ;=========================================================================
  4115                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
  4116                              <1> ;                   BIOS scan code translation table
  4117                              <1> ; Note 1: Table starts with scancode == 1
  4118                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
  4119                              <1> ;	00 - no flags
  4120                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
  4121                              <1> ;	     x in this case equals digit value
  4122                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
  4123                              <1> ;	40 - there is an extended key, so check for 0E0h flag
  4124                              <1> ;	8x - F11, F12 BIOS scan codes
  4125                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
  4126                              <1> ;-------------------------------------------------------------------------
  4127                              <1> 
  4128                              <1> scan_xlat_table:
  4129                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4130 00001A2D 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
  4131 00001A35 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
  4132 00001A3D 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
  4133 00001A45 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
  4134 00001A4D 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
  4135 00001A55 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
  4136 00001A5D 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
  4137 00001A65 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
  4138 00001A6D 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
  4139 00001A75 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
  4140 00001A7D 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
  4141 00001A85 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
  4142 00001A8D 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
  4143 00001A95 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
  4144 00001A9D 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
  4145 00001AA5 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
  4146                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4147 00001AAD 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
  4148 00001AB5 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
  4149 00001ABD 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
  4150 00001AC5 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
  4151 00001ACD 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
  4152 00001AD5 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
  4153 00001ADD 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
  4154 00001AE5 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
  4155 00001AED 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
  4156 00001AF5 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
  4157 00001AFD 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
  4158 00001B05 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
  4159 00001B0D 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
  4160 00001B15 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
  4161 00001B1D 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
  4162 00001B25 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
  4163                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4164 00001B2D 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
  4165 00001B35 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
  4166 00001B3D 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
  4167 00001B45 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
  4168 00001B4D 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
  4169 00001B55 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
  4170 00001B5D 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
  4171 00001B65 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
  4172 00001B6D 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
  4173 00001B75 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
  4174 00001B7D 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
  4175 00001B85 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
  4176 00001B8D 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
  4177 00001B95 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
  4178 00001B9D 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
  4179 00001BA5 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
  4180                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4181 00001BAD 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
  4182 00001BB5 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
  4183 00001BBD 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
  4184 00001BC5 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
  4185 00001BCD 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
  4186 00001BD5 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
  4187 00001BDD 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
  4188 00001BE5 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
  4189 00001BED 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
  4190 00001BF5 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
  4191 00001BFD 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
  4192 00001C05 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
  4193 00001C0D 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
  4194 00001C15 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
  4195 00001C1D 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
  4196 00001C25 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
  4197                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
  4198 00001C2D 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
  4199 00001C35 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
  4200 00001C3D 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
  4201 00001C45 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
  4202 00001C4D 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
  4203 00001C55 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
  4204 00001C5D 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
  4205 00001C65 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
  4206 00001C6D 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
  4207 00001C75 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
  4208 00001C7D 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
  4209 00001C85 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
  4210 00001C8D 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
  4211 00001C95 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +	4Eh
  4212 00001C9D 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
  4213 00001CA5 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
  4214                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
  4215 00001CAD 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
  4216 00001CB5 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
  4217 00001CBD 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
  4218 00001CC5 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
  4219 00001CCD 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
  4220 00001CD5 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
  4221 00001CDD 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
  4222 00001CE5 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
  4223                              <1> .end:
  4224                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
  4225                              <1> 
  4226                              <1> ;=========================================================================
  4227                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
  4228                              <1> ; Input:
  4229                              <1> ;	AL - scan code
  4230                              <1> ; Output:
  4231                              <1> ;	AX - ASCII character / scan code pair
  4232                              <1> ;-------------------------------------------------------------------------
  4233                              <1> scan_xlat:
  4234 00001CED 53                  <1> 	push	bx
  4235 00001CEE FEC8                <1> 	dec	al
  4236 00001CF0 3C58                <1> 	cmp	al,scan_xlat_table_size
  4237 00001CF2 7205                <1> 	jb	.1
  4238 00001CF4 31C0                <1> 	xor	ax,ax
  4239 00001CF6 E9AB00              <1> 	jmp	.exit
  4240                              <1> 
  4241                              <1> .1:
  4242 00001CF9 B700                <1> 	mov	bh,00h				; calculate offset of the key
  4243 00001CFB 88C3                <1> 	mov	bl,al				; in scan_xlat_table
  4244 00001CFD D1E3                <1> 	shl	bx,1				; BX = AL * 8
  4245 00001CFF D1E3                <1> 	shl	bx,1
  4246 00001D01 D1E3                <1> 	shl	bx,1
  4247                              <1> 
  4248 00001D03 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
  4249 00001D08 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
  4250 00001D0A 2E8B87[331A]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
  4251                              <1> 	; check for numeric Keypad keys
  4252 00001D0F 2EF687[2E1A]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
  4253 00001D15 7474                <1> 	jz	.check_extended
  4254 00001D17 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4255 00001D1C 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
  4256                              <1> 						; and so it is not a keypad key
  4257                              <1> 
  4258 00001D1E 2E8A87[2E1A]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
  4259 00001D23 240F                <1> 	and	al,0Fh				; get the numeric value
  4260 00001D25 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
  4261 00001D29 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
  4262 00001D2B A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
  4263                              <1> 
  4264 00001D2E 31C0                <1> 	xor	ax,ax				; return nothing
  4265 00001D30 EB72                <1> 	jmp	.exit
  4266                              <1> 
  4267                              <1> .check_ctrl:
  4268 00001D32 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
  4269 00001D37 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
  4270 00001D39 2E8B87[311A]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
  4271 00001D3E EB4B                <1> 	jmp	.check_extended
  4272                              <1> 
  4273                              <1> .check_locks:
  4274 00001D40 2EF687[2E1A]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
  4275 00001D46 741D                <1> 	jz	.check_shift			; not affected by Locks
  4276                              <1> 
  4277 00001D48 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
  4278 00001D4A 7309                <1> 	jae	.check_num_lock			; above or equal 47h
  4279                              <1> 
  4280 00001D4C F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
  4281 00001D51 7412                <1> 	jz	.check_shift			; Caps Lock is not active
  4282 00001D53 EB07                <1> 	jmp	.lock_active
  4283                              <1> 
  4284                              <1> .check_num_lock:
  4285 00001D55 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
  4286 00001D5A 7409                <1> 	jz	.check_shift			; Num Lock is not active
  4287                              <1> .lock_active:
  4288                              <1> 	; are any of Shift keys active?
  4289 00001D5C F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4290 00001D61 7409                <1> 	jz	.shift				; Lock active, Shift inactive
  4291 00001D63 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
  4292                              <1> 
  4293                              <1> .check_shift:
  4294                              <1> 	; are any of Shift keys active?
  4295 00001D65 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
  4296 00001D6A 7407                <1> 	jz	.no_shift
  4297                              <1> .shift:
  4298 00001D6C 2E8B87[2F1A]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
  4299 00001D71 EB18                <1> 	jmp	.check_extended
  4300                              <1> 
  4301                              <1> .no_shift:
  4302 00001D73 88C4                <1> 	mov	ah,al				; Move scan code to AH
  4303 00001D75 FEC4                <1> 	inc	ah
  4304 00001D77 2E8A87[2D1A]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
  4305 00001D7C 2EF687[2E1A]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
  4306 00001D82 7407                <1> 	jz	.check_extended			; not F11 or F12
  4307 00001D84 2E8AA7[2E1A]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
  4308 00001D89 EB19                <1> 	jmp	.exit
  4309                              <1> 
  4310                              <1> .check_extended:
  4311 00001D8B 2EF687[2E1A]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
  4312 00001D91 7411                <1> 	jz	.exit				; no extended key
  4313 00001D93 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
  4314 00001D98 740A                <1> 	jz	.exit				; ... not a 0E0h
  4315 00001D9A 3C00                <1> 	cmp	al,00h
  4316 00001D9C 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
  4317 00001D9E B0E0                <1> 	mov	al,0E0h				; indicate extended key
  4318 00001DA0 EB02                <1> 	jmp	.exit
  4319                              <1> 
  4320                              <1> .ascii_code:
  4321 00001DA2 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
  4322                              <1> 						; key with valid ASCII code
  4323                              <1> 						; (Keypad Enter, *, and /)
  4324                              <1> 
  4325                              <1> .exit:
  4326 00001DA4 5B                  <1> 	pop	bx
  4327 00001DA5 C3                  <1> 	ret
  4328                              <1> 
  4329                              <1> ;=========================================================================
  4330                              <1> ; int_16_fn00 - get keystroke
  4331                              <1> ; Input:
  4332                              <1> ;	AH = 00h
  4333                              <1> ; Output:
  4334                              <1> ;	AH = BIOS scan code
  4335                              <1> ;	AL = ASCII character
  4336                              <1> ; Notes:
  4337                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4338                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4339                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4340                              <1> ;	- Use function AH=10h for extended keystrokes handling
  4341                              <1> ;-------------------------------------------------------------------------
  4342                              <1> int_16_fn00:
  4343 00001DA6 FB                  <1> 	sti
  4344                              <1> .1:
  4345 00001DA7 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4346 00001DAB 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4347 00001DAF 74F6                <1> 	jz	.1			; wait or keystroke
  4348 00001DB1 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4349 00001DB3 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4350                              <1> 					;   location
  4351 00001DB6 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4352 00001DBA 7504                <1> 	jne	.2
  4353 00001DBC 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4354                              <1> .2:
  4355 00001DC0 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4356 00001DC4 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4357                              <1> 					;   extended key?
  4358 00001DC6 7504                <1> 	jne	.3			; not a convertible key
  4359 00001DC8 B000                <1> 	mov	al,00h			; convert to a standard key
  4360 00001DCA EB2C                <1> 	jmp	.exit
  4361                              <1> .3:
  4362 00001DCC 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4363 00001DCE 74D7                <1> 	je	.1			; an ignored extended key, get next key
  4364 00001DD0 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4365                              <1> 					;   (scancode above 84h)
  4366 00001DD3 77D2                <1> 	ja	.1			; an ignored extended key, get next key
  4367 00001DD5 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4368 00001DD8 751E                <1> 	jne	.exit
  4369 00001DDA 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4370 00001DDC 7504                <1> 	jne	.4
  4371 00001DDE B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4372 00001DE0 EB16                <1> 	jmp	.exit
  4373                              <1> .4:
  4374 00001DE2 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4375 00001DE4 7504                <1> 	jne	.5
  4376 00001DE6 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4377 00001DE8 EB0E                <1> 	jmp	.exit
  4378                              <1> .5:
  4379 00001DEA 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4380 00001DEC 7504                <1> 	jne	.6
  4381 00001DEE B435                <1> 	mov	ah,35h			; standard / scancode
  4382 00001DF0 EB06                <1> 	jmp	.exit
  4383                              <1> .6:
  4384 00001DF2 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4385 00001DF4 7502                <1> 	jne	.exit
  4386 00001DF6 B437                <1> 	mov	ah,37h			; standard * scancode
  4387                              <1> .exit:
  4388 00001DF8 E9704A              <1> 	jmp	int_16_exit
  4389                              <1> 
  4390                              <1> ;=========================================================================
  4391                              <1> ; int_16_fn01 - check for keystroke
  4392                              <1> ; Input:
  4393                              <1> ;	AH = 01h
  4394                              <1> ; Output:
  4395                              <1> ;	ZF = 1 - no keystroke available
  4396                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4397                              <1> ;		AH = BIOS scan code
  4398                              <1> ;		AL = ASCII character
  4399                              <1> ; Notes:
  4400                              <1> ;	- Does not remove keystroke from keyboard buffer
  4401                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
  4402                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
  4403                              <1> ;	- Use function AH=11h for extended keystrokes handling
  4404                              <1> ;-------------------------------------------------------------------------
  4405                              <1> int_16_fn01:
  4406 00001DFB 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4407 00001DFF 8B07                <1> 	mov	ax,word [bx]
  4408 00001E01 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4409 00001E05 7436                <1> 	jz	.exit			; no keystroke, exit
  4410 00001E07 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
  4411                              <1> 					;   extended key?
  4412 00001E09 7504                <1> 	jne	.1			; not a convertible key
  4413 00001E0B B000                <1> 	mov	al,00h			; convert to a standard key
  4414 00001E0D EB2C                <1> 	jmp	.clear_zf
  4415                              <1> .1:
  4416 00001E0F 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
  4417 00001E11 742D                <1> 	je	.discard_key		; an ignored extended key, discard
  4418 00001E13 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
  4419                              <1> 					;   (scancode above 84h)
  4420 00001E16 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
  4421 00001E18 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
  4422 00001E1B 751E                <1> 	jne	.clear_zf
  4423 00001E1D 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
  4424 00001E1F 7504                <1> 	jne	.2
  4425 00001E21 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4426 00001E23 EB16                <1> 	jmp	.clear_zf
  4427                              <1> .2:
  4428 00001E25 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
  4429 00001E27 7504                <1> 	jne	.3
  4430 00001E29 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
  4431 00001E2B EB0E                <1> 	jmp	.clear_zf
  4432                              <1> .3:
  4433 00001E2D 3C2F                <1> 	cmp	al,2Fh			; Keypad /
  4434 00001E2F 7504                <1> 	jne	.4
  4435 00001E31 B435                <1> 	mov	ah,35h			; standard / scancode
  4436 00001E33 EB06                <1> 	jmp	.clear_zf
  4437                              <1> .4:
  4438 00001E35 3C2A                <1> 	cmp	al,2Ah			; Keypad *
  4439 00001E37 7502                <1> 	jne	.clear_zf
  4440 00001E39 B437                <1> 	mov	ah,37h			; standard * scancode
  4441                              <1> 
  4442                              <1> .clear_zf:
  4443 00001E3B 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4444                              <1> .exit:
  4445 00001E3D E92E4A              <1> 	jmp	int_16_exitf
  4446                              <1> 
  4447                              <1> .discard_key:
  4448 00001E40 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4449                              <1> 					;   location
  4450 00001E43 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4451 00001E47 7504                <1> 	jne	.5
  4452 00001E49 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4453                              <1> .5:
  4454 00001E4D 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4455 00001E51 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
  4456                              <1> 	
  4457                              <1> 
  4458                              <1> ;=========================================================================
  4459                              <1> ; int_16_fn10 - get extended keystroke
  4460                              <1> ; Input:
  4461                              <1> ;	AH = 10h
  4462                              <1> ; Output:
  4463                              <1> ;	AH = BIOS scan code
  4464                              <1> ;	AL = ASCII character
  4465                              <1> ; Note:
  4466                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
  4467                              <1> ;-------------------------------------------------------------------------
  4468                              <1> int_16_fn10:
  4469 00001E53 FB                  <1> 	sti
  4470                              <1> .1:
  4471 00001E54 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4472 00001E58 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
  4473 00001E5C 74F6                <1> 	jz	.1			; wait or keystroke
  4474 00001E5E 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
  4475 00001E60 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
  4476                              <1> 					;   location
  4477 00001E63 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  4478 00001E67 7504                <1> 	jne	.2
  4479 00001E69 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  4480                              <1> .2:
  4481 00001E6D 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  4482 00001E71 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4483 00001E73 7502                <1> 	jne	.exit			; not a extended key
  4484 00001E75 B000                <1> 	mov	al,00h			; set scancode to zero
  4485                              <1> 
  4486                              <1> .exit:
  4487 00001E77 E9F149              <1> 	jmp	int_16_exit
  4488                              <1> 
  4489                              <1> ;=========================================================================
  4490                              <1> ; int_16_fn11 - check for extended keystroke
  4491                              <1> ; Input:
  4492                              <1> ;	AH = 01h
  4493                              <1> ; Output:
  4494                              <1> ;	ZF = 1 - no keystroke available
  4495                              <1> ;	ZF = 0 = keystroke is available and put in AX
  4496                              <1> ;		AH = BIOS scan code
  4497                              <1> ;		AL = ASCII character
  4498                              <1> ; Note:
  4499                              <1> ;	- Does not remove keystroke from keyboard buffer
  4500                              <1> ;-------------------------------------------------------------------------
  4501                              <1> int_16_fn11:
  4502 00001E7A 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
  4503 00001E7E 8B07                <1> 	mov	ax,word [bx]
  4504 00001E80 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
  4505 00001E84 7408                <1> 	jz	.exit			; no keystroke, exit
  4506 00001E86 3CF0                <1> 	cmp	al,0F0h			; an extended key?
  4507 00001E88 7502                <1> 	jne	.clear_zf		; not a extended key
  4508 00001E8A B000                <1> 	mov	al,00h			; set scancode to zero
  4509                              <1> .clear_zf:
  4510 00001E8C 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
  4511                              <1> .exit:
  4512 00001E8E E9DD49              <1> 	jmp	int_16_exitf
  4513                                  %include	"serial1.inc"		; serial port services & detection
  4514                              <1> ;========================================================================
  4515                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
  4516                              <1> ;       INT 14h, function AH=01h
  4517                              <1> ;	INT 14h, function AH=02h
  4518                              <1> ;	detect_serial
  4519                              <1> ;	serial port related definitions and tables
  4520                              <1> ;	- see serial2.inc for other INT 14h functions
  4521                              <1> ;-------------------------------------------------------------------------
  4522                              <1> ;
  4523                              <1> ; Compiles with NASM 2.07, might work with other versions
  4524                              <1> ;
  4525                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4526                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4527                              <1> ;
  4528                              <1> ; This program is free software: you can redistribute it and/or modify
  4529                              <1> ; it under the terms of the GNU General Public License as published by
  4530                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4531                              <1> ; (at your option) any later version.
  4532                              <1> ;
  4533                              <1> ; This program is distributed in the hope that it will be useful,
  4534                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4535                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4536                              <1> ; GNU General Public License for more details.
  4537                              <1> ;
  4538                              <1> ; You should have received a copy of the GNU General Public License
  4539                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4540                              <1> ;
  4541                              <1> ;=========================================================================
  4542                              <1> 
  4543                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
  4544                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
  4545                              <1> 
  4546                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
  4547                              <1> 
  4548                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
  4549                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
  4550                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
  4551                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
  4552                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
  4553                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
  4554                              <1> 
  4555                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
  4556                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
  4557                              <1> uart_mcr_rts	equ	3		; MCR - request to send (RTS)
  4558                              <1> 
  4559                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
  4560                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
  4561                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
  4562                              <1> 
  4563                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
  4564                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
  4565                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
  4566                              <1> 
  4567                              <1> uart_err_timeout equ	80h		; timeout error
  4568                              <1> 
  4569                              <1> num_serial	equ	4		; number of serial ports
  4570                              <1> 
  4571                              <1> ;=========================================================================
  4572                              <1> ; int_14_fn01 - Send character
  4573                              <1> ; Input:
  4574                              <1> ;	AH = 01h - function 01h - send character
  4575                              <1> ;	AL = character to send
  4576                              <1> ;	DX = serial port number (0-3)
  4577                              <1> ; Output:
  4578                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4579                              <1> ;-------------------------------------------------------------------------
  4580                              <1> int_14_fn01:
  4581 00001E91 50                  <1> 	push	ax
  4582 00001E92 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4583 00001E94 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR
  4584 00001E96 B320                <1> 	mov	bl,uart_lsr_thre	; and for THR empty in LSR
  4585 00001E98 E82200              <1> 	call	uart_wait_status
  4586 00001E9B 59                  <1> 	pop	cx
  4587 00001E9C 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
  4588 00001E9E 88C8                <1> 	mov	al,cl
  4589 00001EA0 EE                  <1> 	out	dx,al			; sent the character
  4590 00001EA1 E9C248              <1> 	jmp	int_14_exit
  4591                              <1> 
  4592                              <1> int_14_timeout:
  4593 00001EA4 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
  4594 00001EA6 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
  4595 00001EA9 E9BA48              <1> 	jmp	int_14_exit
  4596                              <1> 
  4597                              <1> ;=========================================================================
  4598                              <1> ; int_14_fn02 - Receive character
  4599                              <1> ; Input:
  4600                              <1> ;	AH = 02h - function 02h - receive character
  4601                              <1> ;	DX = serial port number (0-3)
  4602                              <1> ; Output:
  4603                              <1> ;	AL = character received
  4604                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  4605                              <1> ;-------------------------------------------------------------------------
  4606                              <1> int_14_fn02:
  4607 00001EAC 50                  <1> 	push	ax
  4608 00001EAD B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; indicate DTR and RTS
  4609 00001EAF B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR
  4610 00001EB1 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR
  4611 00001EB3 E80700              <1> 	call	uart_wait_status
  4612 00001EB6 59                  <1> 	pop	cx
  4613 00001EB7 75EB                <1> 	jnz	int_14_timeout
  4614 00001EB9 EC                  <1> 	in	al,dx			; receive the character
  4615 00001EBA E9A948              <1> 	jmp	int_14_exit
  4616                              <1> 
  4617                              <1> ;=========================================================================
  4618                              <1> ; uart_wait_status - wait for modem and line status
  4619                              <1> ; Input:
  4620                              <1> ;	AL = value to write to MCR (Modem Control Register)
  4621                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
  4622                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
  4623                              <1> ;	DX = UART base address
  4624                              <1> ;	SI = serial port number
  4625                              <1> ; Output:
  4626                              <1> ;	AH = line status
  4627                              <1> ;	ZF = 0 - timeout
  4628                              <1> ;	CX,BX - destroyed
  4629                              <1> ;-------------------------------------------------------------------------
  4630                              <1> uart_wait_status:
  4631 00001EBD 52                  <1> 	push	dx
  4632 00001EBE 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
  4633 00001EC1 EE                  <1> 	out	dx,al			; output MCR value
  4634 00001EC2 42                  <1> 	inc	dx
  4635 00001EC3 42                  <1> 	inc	dx			; DX = UART MSR address
  4636                              <1> 					; OPTIMIZATION:
  4637                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
  4638 00001EC4 E80A00              <1> 	call	wait_for_port		; wait for MSR status
  4639 00001EC7 7506                <1> 	jnz	.wait_exit
  4640 00001EC9 4A                  <1> 	dec	dx			; DX = UART LSR address
  4641                              <1> 					; OPTIMIZATION:
  4642                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
  4643 00001ECA 88DF                <1> 	mov	bh,bl			; BH = LSR mask
  4644 00001ECC E80200              <1> 	call	wait_for_port		; wait for LSR status
  4645                              <1> .wait_exit:
  4646 00001ECF 5A                  <1> 	pop	dx
  4647 00001ED0 C3                  <1> 	ret
  4648                              <1> 
  4649                              <1> ;=========================================================================
  4650                              <1> ; wait_for_port - wait for set bits in a register
  4651                              <1> ;
  4652                              <1> ; Input:
  4653                              <1> ;	BH = mask to wait for (bits that need to be 1)
  4654                              <1> ;	DX = register address
  4655                              <1> ;	SI = address of the timeout value (in seconds)
  4656                              <1> ; Output:
  4657                              <1> ;	AH = last port reading
  4658                              <1> ;	ZF clear on timeout
  4659                              <1> ;	ZF set on success
  4660                              <1> ;	AL - trashed
  4661                              <1> ;	CX - trashed
  4662                              <1> ;-------------------------------------------------------------------------
  4663                              <1> wait_for_port:
  4664 00001ED1 53                  <1> 	push	bx
  4665 00001ED2 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
  4666                              <1> 
  4667                              <1> .loop_outer:
  4668 00001ED4 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
  4669                              <1> 
  4670                              <1> .loop_inner:
  4671 00001ED7 EC                  <1> 	in	al,dx			; read the register
  4672 00001ED8 88C4                <1> 	mov	ah,al			; save register in AH
  4673 00001EDA 20F8                <1> 	and	al,bh
  4674 00001EDC 38F8                <1> 	cmp	al,bh			; required bits are set?
  4675 00001EDE 7414                <1> 	je	.exit
  4676                              <1> 
  4677                              <1> .zero_loop:
  4678 00001EE0 E461                <1> 	in	al,port_b_reg
  4679 00001EE2 A810                <1> 	test	al,refresh_flag
  4680 00001EE4 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
  4681                              <1> 
  4682                              <1> .one_loop:
  4683 00001EE6 E461                <1> 	in	al,port_b_reg
  4684 00001EE8 A810                <1> 	test	al,refresh_flag
  4685 00001EEA 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
  4686 00001EEC E2E9                <1> 	loop	.loop_inner
  4687                              <1> 
  4688 00001EEE FECB                <1> 	dec	bl
  4689 00001EF0 75E2                <1> 	jnz	.loop_outer
  4690 00001EF2 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
  4691                              <1> 
  4692                              <1> .exit:
  4693 00001EF4 5B                  <1> 	pop	bx
  4694 00001EF5 C3                  <1> 	ret
  4695                              <1> 
  4696                              <1> ;=========================================================================
  4697                              <1> ; detect_serial - detect and print serial ports
  4698                              <1> ; Input:
  4699                              <1> ;	none
  4700                              <1> ; Output:
  4701                              <1> ;	none (updates BIOS data area)
  4702                              <1> ;-------------------------------------------------------------------------
  4703                              <1> detect_serial:
  4704 00001EF6 50                  <1> 	push	ax
  4705 00001EF7 53                  <1> 	push	bx
  4706 00001EF8 52                  <1> 	push	dx
  4707 00001EF9 56                  <1> 	push	si
  4708 00001EFA BE[3E02]            <1> 	mov	si,msg_serial
  4709 00001EFD E89006              <1> 	call	print
  4710 00001F00 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
  4711 00001F03 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
  4712 00001F07 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
  4713 00001F0B 31DB                <1> 	xor	bx,bx			; BX = 0
  4714                              <1> .detect_loop:
  4715 00001F0D BE[5B02]            <1> 	mov	si,msg_serial_com
  4716 00001F10 E87D06              <1> 	call	print
  4717 00001F13 88D8                <1> 	mov	al,bl
  4718 00001F15 D0E8                <1> 	shr	al,1
  4719 00001F17 FEC0                <1> 	inc	al			; AL = COM port number (1..4)
  4720 00001F19 E8D206              <1> 	call	print_digit
  4721 00001F1C BE[9000]            <1> 	mov	si,msg_colon
  4722 00001F1F E86E06              <1> 	call	print
  4723 00001F22 2E8B97[8C1F]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
  4724 00001F27 EC                  <1> 	in	al,dx
  4725 00001F28 B00F                <1> 	mov	al,0Fh
  4726 00001F2A EE                  <1> 	out	dx,al			; enable interrupts
  4727 00001F2B B000                <1> 	mov	al,00h
  4728 00001F2D E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
  4729 00001F2F EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4730 00001F30 3C0F                <1> 	cmp	al,0Fh
  4731 00001F32 7530                <1> 	jne	.no_port		; no port at this address
  4732 00001F34 B000                <1> 	mov	al,00h
  4733 00001F36 EE                  <1> 	out	dx,al			; disable interrupts
  4734 00001F37 B0FF                <1> 	mov	al,0FFh
  4735 00001F39 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4736 00001F3B EC                  <1> 	in	al,dx			; get interrupt enable register to AL
  4737 00001F3C 3C00                <1> 	cmp	al,00h
  4738 00001F3E 7524                <1> 	jne	.no_port		; no port at this address
  4739 00001F40 4A                  <1> 	dec	dx			; DX = UART base address
  4740                              <1> 					; OPTIMIZATION:
  4741                              <1> 					; uart_base = uart_ier_reg - 1
  4742 00001F41 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
  4743                              <1> 					; data area
  4744                              <1> 					
  4745                              <1> 	;; SGEO serial port fix
  4746 00001F43 50                  <1> 	push ax
  4747 00001F44 51                  <1> 	push cx
  4748                              <1> 	
  4749 00001F45 A11000              <1> 	mov ax,[equipment_list]
  4750 00001F48 B109                <1> 	mov cl,9
  4751 00001F4A D3E8                <1> 	shr ax,cl
  4752 00001F4C 2407                <1> 	and al,0x7
  4753 00001F4E 40                  <1> 	inc ax
  4754 00001F4F D3E0                <1> 	shl ax,cl	
  4755 00001F51 81261000FFF1        <1> 	and word [equipment_list],0xF1FF
  4756 00001F57 09061000            <1> 	or [equipment_list],ax
  4757                              <1> 	
  4758 00001F5B 59                  <1> 	pop cx
  4759 00001F5C 58                  <1> 	pop ax
  4760                              <1> 					
  4761 00001F5D 89D0                <1> 	mov	ax,dx
  4762 00001F5F E84906              <1> 	call	print_hex
  4763 00001F62 EB0A                <1> 	jmp	.next
  4764                              <1> 
  4765                              <1> .no_port:
  4766 00001F64 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
  4767 00001F68 BE[8B00]            <1> 	mov	si,msg_none
  4768 00001F6B E82206              <1> 	call	print
  4769                              <1> 	
  4770                              <1> .next:
  4771 00001F6E 43                  <1> 	inc	bx
  4772 00001F6F 43                  <1> 	inc	bx
  4773 00001F70 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
  4774 00001F73 7408                <1> 	je	.done
  4775 00001F75 BE[9300]            <1> 	mov	si,msg_semicolon
  4776 00001F78 E81506              <1> 	call	print
  4777 00001F7B EB90                <1> 	jmp	.detect_loop
  4778                              <1> 
  4779                              <1> .done:
  4780 00001F7D BE[8800]            <1> 	mov	si,msg_crlf
  4781 00001F80 E80D06              <1> 	call	print
  4782                              <1> 
  4783 00001F83 B024                <1> 	mov	al,e_serial_ok		; serial port detection complete
  4784 00001F85 E680                <1> 	out	post_reg,al
  4785                              <1> 
  4786 00001F87 5E                  <1> 	pop	si
  4787 00001F88 5A                  <1> 	pop	dx
  4788 00001F89 5B                  <1> 	pop	bx
  4789 00001F8A 58                  <1> 	pop	ax
  4790 00001F8B C3                  <1> 	ret
  4791                              <1> 
  4792                              <1> ;-------------------------------------------------------------------------
  4793                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
  4794 00001F8C F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
  4795 00001F90 E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
  4796                              <1> 
  4797                              <1> ;-------------------------------------------------------------------------
  4798                              <1> ; UART divisor values table
  4799 00001F94 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
  4800 00001F96 0003                <1> 		dw	uart_osc/16/150		; 150 bps
  4801 00001F98 8001                <1> 		dw	uart_osc/16/300		; 300 bps
  4802 00001F9A C000                <1> 		dw	uart_osc/16/600		; 600 bps
  4803 00001F9C 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
  4804 00001F9E 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
  4805 00001FA0 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
  4806 00001FA2 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
  4807 00001FA4 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
  4808 00001FA6 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
  4809 00001FA8 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
  4810 00001FAA 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
  4811                              <1> num_divisors	equ ($-uart_divisors)/2
  4812                                  %include	"printer1.inc"		; parallel printer services & detection
  4813                              <1> ;========================================================================
  4814                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
  4815                              <1> ;	INT 17h, function AH=01h 
  4816                              <1> ;	detect_parallel
  4817                              <1> ;	- see printer2.inc for other INT 17h functions
  4818                              <1> ;-------------------------------------------------------------------------
  4819                              <1> ;
  4820                              <1> ; Compiles with NASM 2.07, might work with other versions
  4821                              <1> ;
  4822                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  4823                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  4824                              <1> ;
  4825                              <1> ; This program is free software: you can redistribute it and/or modify
  4826                              <1> ; it under the terms of the GNU General Public License as published by
  4827                              <1> ; the Free Software Foundation, either version 3 of the License, or
  4828                              <1> ; (at your option) any later version.
  4829                              <1> ;
  4830                              <1> ; This program is distributed in the hope that it will be useful,
  4831                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4832                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4833                              <1> ; GNU General Public License for more details.
  4834                              <1> ;
  4835                              <1> ; You should have received a copy of the GNU General Public License
  4836                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  4837                              <1> ;
  4838                              <1> ;=========================================================================
  4839                              <1> 
  4840                              <1> num_parallel	equ	3		; number of parallel ports
  4841                              <1> 
  4842                              <1> prn_data_reg	equ	0		; printer data register (out)
  4843                              <1> 
  4844                              <1> prn_stat_reg	equ	1		; printer status register (in)
  4845                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
  4846                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
  4847                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
  4848                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
  4849                              <1> 
  4850                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
  4851                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
  4852                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
  4853                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
  4854                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
  4855                              <1> 
  4856                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
  4857                              <1> 
  4858                              <1> ;=========================================================================
  4859                              <1> ; int_17_fn01 - Initialize printer port
  4860                              <1> ; Input:
  4861                              <1> ;	AH = 1 - function 01h - initialize printer port
  4862                              <1> ;	DX = printer port number (0-2)
  4863                              <1> ; Output:
  4864                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  4865                              <1> ;-------------------------------------------------------------------------
  4866                              <1> int_17_fn01:
  4867 00001FAC 42                  <1> 	inc	dx
  4868 00001FAD 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  4869                              <1> 					; OPTIMIZATION:
  4870                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
  4871 00001FAE B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
  4872 00001FB0 EE                  <1> 	out	dx,al
  4873 00001FB1 51                  <1> 	push	cx
  4874 00001FB2 B9B509              <1> 	mov	cx,prn_init_delay
  4875 00001FB5 E8E4EE              <1> 	call	delay_15us
  4876 00001FB8 59                  <1> 	pop	cx
  4877 00001FB9 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  4878 00001FBB EE                  <1> 	out	dx,al			; deactivate init bit
  4879 00001FBC 4A                  <1> 	dec	dx			; OPTIMIZATION:
  4880                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
  4881 00001FBD E97950              <1> 	jmp	int_17_status		; exit returning status
  4882                              <1> 
  4883                              <1> ;=========================================================================
  4884                              <1> ; detect_parallel - detect and print parallel ports
  4885                              <1> ; Input:
  4886                              <1> ;	none
  4887                              <1> ; Output:
  4888                              <1> ;	none (updates BIOS data area)
  4889                              <1> ; Notes:
  4890                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
  4891                              <1> ;	  enumeration is used:
  4892                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
  4893                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
  4894                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
  4895                              <1> ;-------------------------------------------------------------------------
  4896                              <1> detect_parallel:
  4897 00001FC0 50                  <1> 	push	ax
  4898 00001FC1 53                  <1> 	push	bx
  4899 00001FC2 52                  <1> 	push	dx
  4900 00001FC3 56                  <1> 	push	si
  4901 00001FC4 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
  4902 00001FC7 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
  4903 00001FCB 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
  4904 00001FCF 31DB                <1> 	xor	bx,bx			; BX = 0
  4905 00001FD1 31FF                <1> 	xor	di,di			; DI = 0
  4906                              <1> .detect_loop:
  4907 00001FD3 2E8B95[6420]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
  4908 00001FD8 B05A                <1> 	mov	al,05Ah			; just some test value
  4909 00001FDA EE                  <1> 	out	dx,al			; write it to the printer data register
  4910 00001FDB B0FF                <1> 	mov	al,0FFh
  4911 00001FDD E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
  4912 00001FDF EC                  <1> 	in	al,dx
  4913 00001FE0 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
  4914 00001FE2 751F                <1> 	jne	.no_port		; no port at this address
  4915 00001FE4 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
  4916                              <1> 					; data area
  4917                              <1> 					
  4918                              <1> 	;; SGEO parallel port fix
  4919 00001FE7 50                  <1> 	push ax
  4920 00001FE8 51                  <1> 	push cx
  4921 00001FE9 A11000              <1> 	mov ax,[equipment_list]
  4922 00001FEC B10E                <1> 	mov cl,14
  4923 00001FEE D3E8                <1> 	shr ax,cl
  4924 00001FF0 2403                <1> 	and al,0x3
  4925 00001FF2 40                  <1> 	inc ax
  4926 00001FF3 D3E0                <1> 	shl ax,cl
  4927 00001FF5 81261000FF3F        <1> 	and word [equipment_list],0x3FFF
  4928 00001FFB 09061000            <1> 	or [equipment_list],ax
  4929 00001FFF 59                  <1> 	pop cx
  4930 00002000 58                  <1> 	pop ax
  4931 00002001 EB09                <1> 	jmp	.next
  4932                              <1> 
  4933                              <1> .no_port:
  4934 00002003 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
  4935 00002008 09FF                <1> 	or	di,di			; no printer port at 3BCh?
  4936 0000200A 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
  4937                              <1> .next:
  4938 0000200C 43                  <1> 	inc	bx
  4939 0000200D 43                  <1> 	inc	bx
  4940                              <1> 
  4941                              <1> .next_skip_3BC:
  4942 0000200E 47                  <1> 	inc	di
  4943 0000200F 47                  <1> 	inc	di
  4944 00002010 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
  4945 00002013 7402                <1> 	je	.print			; done with detection, print findings
  4946 00002015 EBBC                <1> 	jmp	.detect_loop
  4947                              <1> 
  4948                              <1> .print:
  4949 00002017 BE[5F02]            <1> 	mov	si,msg_parallel
  4950 0000201A E87305              <1> 	call	print
  4951 0000201D 31DB                <1> 	xor	bx,bx
  4952                              <1> 
  4953                              <1> .print_loop:
  4954 0000201F BE[7C02]            <1> 	mov	si,msg_parallel_lpt
  4955 00002022 E86B05              <1> 	call	print
  4956 00002025 88D8                <1> 	mov	al,bl
  4957 00002027 D0E8                <1> 	shr	al,1
  4958 00002029 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
  4959 0000202B E8C005              <1> 	call	print_digit
  4960 0000202E BE[9000]            <1> 	mov	si,msg_colon
  4961 00002031 E85C05              <1> 	call	print
  4962 00002034 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
  4963 00002037 09C0                <1> 	or	ax,ax			; parallel interface installed?
  4964 00002039 7405                <1> 	jz	.print_no_port
  4965 0000203B E86D05              <1> 	call	print_hex
  4966 0000203E EB06                <1> 	jmp	.print_next
  4967                              <1> 
  4968                              <1> .print_no_port:
  4969 00002040 BE[8B00]            <1> 	mov	si,msg_none
  4970 00002043 E84A05              <1> 	call	print
  4971                              <1> 
  4972                              <1> .print_next:
  4973 00002046 43                  <1> 	inc	bx
  4974 00002047 43                  <1> 	inc	bx
  4975 00002048 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
  4976 0000204B 7408                <1> 	je	.done
  4977 0000204D BE[9300]            <1> 	mov	si,msg_semicolon
  4978 00002050 E83D05              <1> 	call	print
  4979 00002053 EBCA                <1> 	jmp	.print_loop
  4980                              <1> 
  4981                              <1> .done:
  4982 00002055 BE[8800]            <1> 	mov	si,msg_crlf
  4983 00002058 E83505              <1> 	call	print
  4984                              <1> 
  4985 0000205B B025                <1> 	mov	al,e_parallel_ok	; parallel port detection complete
  4986 0000205D E680                <1> 	out	post_reg,al
  4987                              <1> 
  4988 0000205F 5E                  <1> 	pop	si
  4989 00002060 5A                  <1> 	pop	dx
  4990 00002061 5B                  <1> 	pop	bx
  4991 00002062 58                  <1> 	pop	ax
  4992 00002063 C3                  <1> 	ret
  4993                              <1> 
  4994                              <1> ;-------------------------------------------------------------------------
  4995                              <1> ; parallel port base addresses - used for port detection
  4996 00002064 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
  4997                                  %ifdef PS2_MOUSE
  4998                                  %ifndef AT_COMPAT
  4999                                  %error "PS2_MOUSE depends on AT_COMPAT. Please fix config.inc."
  5000                                  %endif ; AT_COMPAT
  5001                                  %include	"ps2aux.inc"
  5002                              <1> ;=========================================================================
  5003                              <1> ; ps2aux.inc - PS/2 mouse support functions:
  5004                              <1> ;	INT 15h, function AH=0C2h
  5005                              <1> ;	INT 74h - IRQ12 interrupt handler
  5006                              <1> ;-------------------------------------------------------------------------
  5007                              <1> ;
  5008                              <1> ; Compiles with NASM 2.07, might work with other versions
  5009                              <1> ;
  5010                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5011                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5012                              <1> ;
  5013                              <1> ; This program is free software: you can redistribute it and/or modify
  5014                              <1> ; it under the terms of the GNU General Public License as published by
  5015                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5016                              <1> ; (at your option) any later version.
  5017                              <1> ;
  5018                              <1> ; This program is distributed in the hope that it will be useful,
  5019                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5020                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5021                              <1> ; GNU General Public License for more details.
  5022                              <1> ;
  5023                              <1> ; You should have received a copy of the GNU General Public License
  5024                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5025                              <1> ;
  5026                              <1> ;=========================================================================
  5027                              <1> 
  5028                              <1> ;-------------------------------------------------------------------------
  5029                              <1> ; offsets for registers on stack
  5030                              <1> int_15_fnC2_bp	equ	0
  5031                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
  5032                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
  5033                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
  5034                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
  5035                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
  5036                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
  5037                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
  5038                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
  5039                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
  5040                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
  5041                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
  5042                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
  5043                              <1> 
  5044                              <1> ;=========================================================================
  5045                              <1> ; int_15_fnC2 - mouse functions
  5046                              <1> ; Input:
  5047                              <1> ;	AH = 0C2h - mouse functions
  5048                              <1> ;	AL - function:
  5049                              <1> ;		00h - enable / disable PS/2 mouse
  5050                              <1> ;		01h - reset PS/2 mouse
  5051                              <1> ;		02h - set sample rate
  5052                              <1> ;		03h - set resolution
  5053                              <1> ;		04h - read device type
  5054                              <1> ;		05h - initialize PS/2 mouse
  5055                              <1> ;		06h - set scaling or get status
  5056                              <1> ;		07h - set PS/2 mouse driver address
  5057                              <1> ; Output:
  5058                              <1> ;	AH - exit status:
  5059                              <1> ;		00h - no error
  5060                              <1> ;		01h - invalid function call
  5061                              <1> ;		02h - invalid input value
  5062                              <1> ;		03h - interface error
  5063                              <1> ;		04h - request for resend received from 8042
  5064                              <1> ;		05h - no driver installed (function 0C207h has not been called)
  5065                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
  5066                              <1> ;-------------------------------------------------------------------------
  5067                              <1> int_15_fnC2:
  5068 0000206A 50                  <1> 	push	ax
  5069 0000206B 53                  <1> 	push	bx
  5070 0000206C 51                  <1> 	push	cx
  5071 0000206D 52                  <1> 	push	dx
  5072 0000206E 1E                  <1> 	push	ds
  5073 0000206F 55                  <1> 	push	bp
  5074 00002070 89E5                <1> 	mov	bp,sp			; establish stack addressing
  5075 00002072 BB4000              <1> 	mov	bx,biosdseg
  5076 00002075 8EDB                <1> 	mov	ds,bx
  5077 00002077 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
  5078 0000207B 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
  5079 0000207D 3C08                <1> 	cmp	al,.num_func
  5080 0000207F 7326                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
  5081 00002081 E8A9F8              <1> 	call	kbc_aux_disable		; disable auxiliary device
  5082 00002084 88C3                <1> 	mov	bl,al			; set to index into dispatch table
  5083 00002086 B700                <1> 	mov	bh,0
  5084 00002088 D1E3                <1> 	shl	bx,1			; address words
  5085 0000208A 2EFFA7[8F20]        <1>     cs	jmp	near [.dispatch+bx]
  5086                              <1> 
  5087                              <1> .dispatch:
  5088 0000208F [C820]              <1> 	dw	int_15_fnC200
  5089 00002091 [E920]              <1> 	dw	int_15_fnC201
  5090 00002093 [0C21]              <1> 	dw	int_15_fnC202
  5091 00002095 [3321]              <1> 	dw	int_15_fnC203
  5092 00002097 [5521]              <1> 	dw	int_15_fnC204
  5093 00002099 [6D21]              <1> 	dw	int_15_fnC205
  5094 0000209B [B121]              <1> 	dw	int_15_fnC206
  5095 0000209D [0222]              <1> 	dw	int_15_fnC207
  5096                              <1> .num_func	equ ($-.dispatch)/2
  5097                              <1> 
  5098                              <1> int_15_fnC2_ok:
  5099 0000209F B400                <1> 	mov	ah,00h			; no error
  5100 000020A1 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
  5101 000020A5 EB14                <1> 	jmp	int_15_fnC2_exit
  5102                              <1> 
  5103                              <1> int_15_fnC2_err1:
  5104 000020A7 B401                <1> 	mov	ah,01h			; invalid function call
  5105 000020A9 EB0C                <1> 	jmp	int_15_fnC2_err
  5106                              <1> 
  5107                              <1> int_15_fnC2_err2:
  5108 000020AB B402                <1> 	mov	ah,02h			; invalid input value
  5109 000020AD EB08                <1> 	jmp	int_15_fnC2_err
  5110                              <1> 
  5111                              <1> int_15_fnC2_err3:
  5112 000020AF B403                <1> 	mov	ah,03h			; interface error
  5113 000020B1 EB04                <1> 	jmp	int_15_fnC2_err
  5114                              <1> 
  5115                              <1> int_15_fnC2_err5:
  5116 000020B3 B405                <1> 	mov	ah,05h			; no driver installed
  5117 000020B5 EB00                <1> 	jmp	int_15_fnC2_err
  5118                              <1> 
  5119                              <1> int_15_fnC2_err:
  5120 000020B7 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
  5121                              <1> 
  5122                              <1> int_15_fnC2_exit:
  5123 000020BB 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
  5124 000020BE E862F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
  5125 000020C1 5D                  <1> 	pop	bp
  5126 000020C2 1F                  <1> 	pop	ds
  5127 000020C3 5A                  <1> 	pop	dx
  5128 000020C4 59                  <1> 	pop	cx
  5129 000020C5 5B                  <1> 	pop	bx
  5130 000020C6 58                  <1> 	pop	ax
  5131 000020C7 CF                  <1> 	iret
  5132                              <1> 
  5133                              <1> ;=========================================================================
  5134                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
  5135                              <1> ; Input:
  5136                              <1> ;	AX = 0C200h
  5137                              <1> ;	BH - sub-function:
  5138                              <1> ;		00h - disable
  5139                              <1> ;		01h - enable
  5140                              <1> ;-------------------------------------------------------------------------
  5141                              <1> int_15_fnC200:
  5142 000020C8 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5143 000020CB 80FF01              <1> 	cmp	bh,01h
  5144 000020CE 77D7                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5145                              <1> 
  5146 000020D0 F606270080          <1> 	test	byte [mouse_flags_2],80h ; driver installed?
  5147 000020D5 74DC                <1> 	jz	int_15_fnC2_err5	; no driver installed
  5148                              <1> 
  5149 000020D7 80FF00              <1> 	cmp	bh,00h
  5150 000020DA 7404                <1> 	je	.disable
  5151 000020DC B0F4                <1> 	mov	al,0F4h			; device enable command
  5152 000020DE EB02                <1> 	jmp	.send_it
  5153                              <1> .disable:
  5154 000020E0 B0F5                <1> 	mov	al,0F5h			; device disable command
  5155                              <1> 
  5156                              <1> .send_it:
  5157 000020E2 E806F8              <1> 	call	kbc_aux_send
  5158 000020E5 72D0                <1> 	jc	int_15_fnC2_err		; error
  5159 000020E7 EBB6                <1> 	jmp	int_15_fnC2_ok
  5160                              <1> 
  5161                              <1> ;=========================================================================
  5162                              <1> ; int_15_fnC201 - reset PS/2 mouse
  5163                              <1> ; Input:
  5164                              <1> ;	AX = 0C201h
  5165                              <1> ; Output:
  5166                              <1> ;	BL - Basic Assurance Test (BAT) completion status
  5167                              <1> ;	     0AAh - BAT successful XXX test!!!
  5168                              <1> ;	     0FCh - BAT error
  5169                              <1> ;	BH = device ID
  5170                              <1> ;-------------------------------------------------------------------------
  5171                              <1> int_15_fnC201:
  5172 000020E9 B90A00              <1> 	mov	cx,10			; try the reset 10 times
  5173                              <1> .1:
  5174 000020EC B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5175 000020EE E8FAF7              <1> 	call	kbc_aux_send
  5176 000020F1 7307                <1> 	jnc	.2			; no error - continue
  5177 000020F3 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5178 000020F6 E1F4                <1> 	loopz	.1			; try again
  5179 000020F8 EBBD                <1> 	jmp	int_15_fnC2_err		; error
  5180                              <1> .2:
  5181 000020FA E8D3F7              <1> 	call	kbc_aux_read
  5182 000020FD 72B0                <1> 	jc	int_15_fnC2_err3	; interface error
  5183 000020FF 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5184 00002102 E8CBF7              <1> 	call	kbc_aux_read
  5185 00002105 72A8                <1> 	jc	int_15_fnC2_err3	; interface error
  5186 00002107 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5187 0000210A EB93                <1> 	jmp	int_15_fnC2_ok
  5188                              <1> 
  5189                              <1> ;=========================================================================
  5190                              <1> ; int_15_fnC202 - set sample rate
  5191                              <1> ; Input:
  5192                              <1> ;	AX = 0C202h
  5193                              <1> ;	BH - sample rate:
  5194                              <1> ;		00h - 10 samples per second
  5195                              <1> ;		01h - 20 samples per second
  5196                              <1> ;		02h - 40 samples per second
  5197                              <1> ;		03h - 60 samples per second
  5198                              <1> ;		04h - 80 samples per second
  5199                              <1> ;		05h - 100 samples per second
  5200                              <1> ;		06h - 200 samples per second
  5201                              <1> ;-------------------------------------------------------------------------
  5202                              <1> int_15_fnC202:
  5203 0000210C 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5204 0000210F 80FF06              <1> 	cmp	bh,06h
  5205 00002112 7797                <1> 	ja	int_15_fnC2_err2	; invalid input value
  5206 00002114 88FB                <1> 	mov	bl,bh
  5207 00002116 B700                <1> 	mov	bh,00h			; rate index in BX
  5208                              <1> 
  5209 00002118 B0F3                <1> 	mov	al,0F3h			; set sample rate
  5210 0000211A E8CEF7              <1> 	call	kbc_aux_send
  5211 0000211D 7298                <1> 	jc	int_15_fnC2_err		; error
  5212                              <1> 
  5213 0000211F 2E8A87[2C21]        <1>     cs	mov	al,byte [.rate_table+bx]
  5214 00002124 E8C4F7              <1> 	call	kbc_aux_send
  5215 00002127 728E                <1> 	jc	int_15_fnC2_err		; error
  5216 00002129 E973FF              <1> 	jmp	int_15_fnC2_ok
  5217                              <1> 
  5218 0000212C 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
  5219                              <1> 	
  5220                              <1> ;=========================================================================
  5221                              <1> ; int_15_fnC203 - set resolution
  5222                              <1> ; Input:
  5223                              <1> ;	AX = 0C203h
  5224                              <1> ;	BH - resolution value:
  5225                              <1> ;		00h - 1 count per millimeter
  5226                              <1> ;		01h - 2 counts per millimeter
  5227                              <1> ;		02h - 4 counts per millimeter
  5228                              <1> ;		03h - 8 counts per millimeter
  5229                              <1> ;-------------------------------------------------------------------------
  5230                              <1> int_15_fnC203:
  5231 00002133 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5232 00002136 80FF03              <1> 	cmp	bh,03h
  5233 00002139 7603E96DFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5234                              <1> 
  5235 0000213E B0E8                <1> 	mov	al,0E8h			; set resolution
  5236 00002140 E8A8F7              <1> 	call	kbc_aux_send
  5237 00002143 7303E96FFF          <1> 	jc	int_15_fnC2_err		; error
  5238                              <1> 
  5239 00002148 88F8                <1> 	mov	al,bh
  5240 0000214A E89EF7              <1> 	call	kbc_aux_send
  5241 0000214D 7303E965FF          <1> 	jc	int_15_fnC2_err		; error
  5242 00002152 E94AFF              <1> 	jmp	int_15_fnC2_ok
  5243                              <1> 
  5244                              <1> ;=========================================================================
  5245                              <1> ; int_15_fnC204 - read device type
  5246                              <1> ; Input:
  5247                              <1> ;	AX = 0C204h
  5248                              <1> ; Output:
  5249                              <1> ;	BH = device type
  5250                              <1> ;-------------------------------------------------------------------------
  5251                              <1> int_15_fnC204:
  5252 00002155 B0F2                <1> 	mov	al,0F2h			; read device type
  5253 00002157 E891F7              <1> 	call	kbc_aux_send
  5254 0000215A 7303E958FF          <1> 	jc	int_15_fnC2_err		; error
  5255 0000215F E86EF7              <1> 	call	kbc_aux_read
  5256 00002162 7303E948FF          <1> 	jc	int_15_fnC2_err3
  5257 00002167 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
  5258 0000216A E932FF              <1> 	jmp	int_15_fnC2_ok
  5259                              <1> 
  5260                              <1> ;=========================================================================
  5261                              <1> ; int_15_fnC205 - initialize PS/2 mouse
  5262                              <1> ; Input:
  5263                              <1> ;	AX = 0C205h
  5264                              <1> ;	BH = data package size in bytes (03h or 04h)
  5265                              <1> ; Output:
  5266                              <1> ;	none
  5267                              <1> ;-------------------------------------------------------------------------
  5268                              <1> int_15_fnC205:
  5269 0000216D 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5270 00002170 80FF03              <1> 	cmp	bh,03h
  5271 00002173 7303E933FF          <1> 	jb	int_15_fnC2_err2	; invalid input value
  5272 00002178 80FF04              <1> 	cmp	bh,04h
  5273 0000217B 7603E92BFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
  5274 00002180 FECF                <1> 	dec	bh
  5275                              <1> 
  5276 00002182 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5277 00002185 24F8                <1> 	and	al,0F8h			; mask out package size bits
  5278 00002187 08F8                <1> 	or	al,bh			; add the new package size
  5279 00002189 A22700              <1> 	mov	byte [mouse_flags_2],al
  5280                              <1> 
  5281 0000218C B90500              <1> 	mov	cx,5			; try the reset 5 times
  5282                              <1> .1:
  5283 0000218F B0FF                <1> 	mov	al,0FFh			; reset auxiliary device, set defaults
  5284 00002191 E857F7              <1> 	call	kbc_aux_send
  5285 00002194 7308                <1> 	jnc	.2			; no error - continue
  5286 00002196 80FC03              <1> 	cmp	ah,03h			; timeout error?
  5287 00002199 E1F4                <1> 	loopz	.1			; try again
  5288 0000219B E919FF              <1> 	jmp	int_15_fnC2_err		; error
  5289                              <1> .2:
  5290 0000219E E82FF7              <1> 	call	kbc_aux_read
  5291 000021A1 7303E909FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5292 000021A6 E827F7              <1> 	call	kbc_aux_read
  5293 000021A9 7303E901FF          <1> 	jc	int_15_fnC2_err3	; interface error
  5294 000021AE E9EEFE              <1> 	jmp	int_15_fnC2_ok
  5295                              <1> 
  5296                              <1> ;=========================================================================
  5297                              <1> ; int_15_fnC206 - set scaling or get status
  5298                              <1> ; Input:
  5299                              <1> ;	AX = 0C206h
  5300                              <1> ;	BH - sub-function:
  5301                              <1> ;		00h - return status
  5302                              <1> ;		01h - set scaling factor to 1:1
  5303                              <1> ;		02h - set scaling factor to 2:1
  5304                              <1> ; Output:
  5305                              <1> ;	if BH = 00h on entry:
  5306                              <1> ;		BL - status byte 1:
  5307                              <1> ;			bit 0 = 1 - right button pressed
  5308                              <1> ;			bit 1 = 0 - reserved
  5309                              <1> ;			bit 2 = 1 - left button pressed
  5310                              <1> ;			bit 3 = 0 - reserved
  5311                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
  5312                              <1> ;			bit 5 = 0 - disable, 1 - enable
  5313                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
  5314                              <1> ;			bit 7 = 0 - reserved
  5315                              <1> ;		CL - status byte 2:
  5316                              <1> ;			00h - 1 count per millimeter
  5317                              <1> ;			01h - 2 counts per millimeter
  5318                              <1> ;			02h - 4 counts per millimeter
  5319                              <1> ;			03h - 8 counts per millimeter
  5320                              <1> ;		DL - status byte 3:
  5321                              <1> ;			0Ah - 10 samples per second
  5322                              <1> ;			14h - 20 samples per second
  5323                              <1> ;			3Ch - 40 samples per second
  5324                              <1> ;			3Ch - 60 samples per second
  5325                              <1> ;			50h - 80 samples per second
  5326                              <1> ;			64h - 100 samples per second
  5327                              <1> ;			0C8h - 200 samples per second
  5328                              <1> ;-------------------------------------------------------------------------
  5329                              <1> int_15_fnC206:
  5330 000021B1 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
  5331 000021B4 80FF02              <1> 	cmp	bh,02h
  5332 000021B7 7603E9EBFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
  5333 000021BC 7433                <1> 	je	.scale_2x1
  5334 000021BE 80FF01              <1> 	cmp	bh,01h
  5335 000021C1 7432                <1> 	je	.scale_1x1
  5336                              <1> 					; BH == 0, return status
  5337 000021C3 B0E9                <1> 	mov	al,0E9h			; request status command
  5338 000021C5 E823F7              <1> 	call	kbc_aux_send
  5339 000021C8 7303E9EAFE          <1> 	jc	int_15_fnC2_err		; error
  5340 000021CD E800F7              <1> 	call	kbc_aux_read
  5341 000021D0 7303E9DAFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5342 000021D5 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
  5343 000021D8 E8F5F6              <1> 	call	kbc_aux_read
  5344 000021DB 7303E9CFFE          <1> 	jc	int_15_fnC2_err3	; interface error
  5345 000021E0 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
  5346 000021E3 E8EAF6              <1> 	call	kbc_aux_read
  5347 000021E6 7303E9C4FE          <1> 	jc	int_15_fnC2_err3	; interface error
  5348 000021EB 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
  5349 000021EE E9AEFE              <1> 	jmp	int_15_fnC2_ok
  5350                              <1> 
  5351                              <1> .scale_2x1:
  5352 000021F1 B0E7                <1> 	mov	al,0E7h			; set 2:1 scaling factor command
  5353 000021F3 EB02                <1> 	jmp	.send_it
  5354                              <1> .scale_1x1:
  5355 000021F5 B4E6                <1> 	mov	ah,0E6h			; set 1:1 scaling factor command
  5356                              <1> .send_it:
  5357 000021F7 E8F1F6              <1> 	call	kbc_aux_send
  5358 000021FA 7303E9B8FE          <1> 	jc	int_15_fnC2_err		; error
  5359 000021FF E99DFE              <1> 	jmp	int_15_fnC2_ok
  5360                              <1> 
  5361                              <1> ;=========================================================================
  5362                              <1> ; int_15_fnC207 - set PS/2 mouse driver
  5363                              <1> ; Input:
  5364                              <1> ;	AX = 0C207h
  5365                              <1> ;	ES:BX - pointer to mouse driver
  5366                              <1> ;-------------------------------------------------------------------------
  5367                              <1> int_15_fnC207:
  5368 00002202 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
  5369 00002205 891E2200            <1> 	mov	word [mouse_driver],bx
  5370 00002209 8CC0                <1> 	mov	ax,es
  5371 0000220B A32400              <1> 	mov	word [mouse_driver+2],ax
  5372 0000220E 09C0                <1> 	or	ax,ax
  5373 00002210 750C                <1> 	jnz	.set_handler
  5374 00002212 09DB                <1> 	or	bx,bx
  5375 00002214 7508                <1> 	jnz	.set_handler
  5376                              <1> ; remove handler
  5377 00002216 802627007F          <1> 	and	byte [mouse_flags_2],~80h
  5378 0000221B E981FE              <1> 	jmp	int_15_fnC2_ok
  5379                              <1> 
  5380                              <1> .set_handler:
  5381 0000221E 800E270080          <1> 	or	byte [mouse_flags_2],80h
  5382 00002223 E979FE              <1> 	jmp	int_15_fnC2_ok
  5383                              <1> 
  5384                              <1> ;=========================================================================
  5385                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
  5386                              <1> ;-------------------------------------------------------------------------
  5387                              <1> int_74:
  5388 00002226 FB                  <1> 	sti
  5389 00002227 50                  <1> 	push	ax
  5390 00002228 53                  <1> 	push	bx
  5391 00002229 1E                  <1> 	push	ds
  5392 0000222A B84000              <1> 	mov	ax,biosdseg
  5393 0000222D 8ED8                <1> 	mov	ds,ax
  5394 0000222F A10E00              <1> 	mov	ax,word [ebda_segment]
  5395 00002232 8ED8                <1> 	mov	ds,ax
  5396                              <1> 
  5397 00002234 E464                <1> 	in	al,kbc_status_reg
  5398 00002236 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
  5399 00002238 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
  5400 0000223A 7561                <1> 	jne	.exit			; no mouse data in the buffer
  5401                              <1> 
  5402 0000223C E460                <1> 	in	al,kbc_data_reg
  5403 0000223E 88C4                <1> 	mov	ah,al			; save to AH
  5404                              <1> 
  5405 00002240 A02700              <1> 	mov	al,byte [mouse_flags_2]
  5406 00002243 A880                <1> 	test	al,80h
  5407 00002245 7456                <1> 	jz	.exit			; no mouse driver installed
  5408                              <1> 
  5409 00002247 A02600              <1> 	mov	al,byte [mouse_flags_1]
  5410 0000224A 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
  5411 0000224C BB2800              <1> 	mov	bx,mouse_data
  5412 0000224F 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
  5413 00002251 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
  5414                              <1> 
  5415 00002253 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
  5416 00002257 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
  5417                              <1> 
  5418 0000225A 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
  5419 0000225C 7306                <1> 	jae	.call_driver
  5420                              <1> 
  5421 0000225E FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
  5422 00002262 EB39                <1> 	jmp	.exit
  5423                              <1> 
  5424                              <1> .call_driver:
  5425                              <1> 
  5426                              <1> ;-------------------------------------------------------------------------
  5427                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
  5428                              <1> ; package sizes.
  5429                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
  5430                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
  5431                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
  5432                              <1> ;-------------------------------------------------------------------------
  5433                              <1> 
  5434 00002264 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
  5435 00002267 7413                <1> 	jz	.four_bytes
  5436                              <1> 					; put data in stack for 3 bytes format
  5437 00002269 31C0                <1> 	xor	ax,ax
  5438 0000226B A02800              <1> 	mov	al,byte [mouse_data]
  5439 0000226E 50                  <1> 	push	ax
  5440 0000226F A02900              <1> 	mov	al,byte [mouse_data+1]
  5441 00002272 50                  <1> 	push	ax
  5442 00002273 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5443 00002276 50                  <1> 	push	ax
  5444 00002277 B000                <1> 	mov	al,00h
  5445 00002279 50                  <1> 	push	ax
  5446 0000227A EB15                <1> 	jmp	.do_call
  5447                              <1> 
  5448                              <1> .four_bytes:				; put data in stack for 4 bytes format
  5449 0000227C 8A262900            <1> 	mov	ah,byte [mouse_data+1]
  5450 00002280 A02800              <1> 	mov	al,byte [mouse_data]
  5451 00002283 50                  <1> 	push	ax
  5452 00002284 B400                <1> 	mov	ah,00h
  5453 00002286 A02A00              <1> 	mov	al,byte [mouse_data+2]
  5454 00002289 50                  <1> 	push	ax
  5455 0000228A A02B00              <1> 	mov	al,byte [mouse_data+3]
  5456 0000228D 50                  <1> 	push	ax
  5457 0000228E B000                <1> 	mov	al,00h
  5458 00002290 50                  <1> 	push	ax
  5459                              <1> 
  5460                              <1> .do_call:
  5461 00002291 FF1E2200            <1> 	call	far [mouse_driver]
  5462 00002295 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
  5463 00002298 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
  5464                              <1> 
  5465                              <1> .exit:
  5466 0000229D B020                <1> 	mov	al,20h
  5467 0000229F E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
  5468 000022A1 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
  5469 000022A3 1F                  <1> 	pop	ds
  5470 000022A4 5B                  <1> 	pop	bx
  5471 000022A5 58                  <1> 	pop	ax
  5472 000022A6 CF                  <1> 	iret
  5473                                  %endif
  5474                                  %include	"sound.inc"		; sound test
  5475                              <1> ;=========================================================================
  5476                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
  5477                              <1> ;-------------------------------------------------------------------------
  5478                              <1> ;
  5479                              <1> ; Compiles with NASM 2.07, might work with other versions
  5480                              <1> ;
  5481                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5482                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5483                              <1> ;
  5484                              <1> ; This program is free software: you can redistribute it and/or modify
  5485                              <1> ; it under the terms of the GNU General Public License as published by
  5486                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5487                              <1> ; (at your option) any later version.
  5488                              <1> ;
  5489                              <1> ; This program is distributed in the hope that it will be useful,
  5490                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5491                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5492                              <1> ; GNU General Public License for more details.
  5493                              <1> ;
  5494                              <1> ; You should have received a copy of the GNU General Public License
  5495                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5496                              <1> ;
  5497                              <1> ;=========================================================================
  5498                              <1> 
  5499 000022A7 6908                <1> notes	dw	pic_freq/554		; D flat
  5500 000022A9 FFFF                <1> 	dw	-1			; silent
  5501 000022AB 8814                <1> 	dw	pic_freq/227		; D flat
  5502 000022AD 980C                <1> 	dw	pic_freq/370		; G flat
  5503 000022AF 8814                <1> 	dw	pic_freq/227		; D flat
  5504 000022B1 3B0B                <1> 	dw	pic_freq/415		; A flat
  5505 000022B3 0000                <1> 	dw	0
  5506                              <1> 
  5507                              <1> ;=========================================================================
  5508                              <1> ; sound - Play power-on sound.
  5509                              <1> ; Input:
  5510                              <1> ;	none
  5511                              <1> ; Output:
  5512                              <1> ;	none, destroys some registers
  5513                              <1> ;-------------------------------------------------------------------------
  5514                              <1> sound:
  5515 000022B5 FC                  <1> 	cld
  5516 000022B6 BE[A722]            <1> 	mov	si,notes		; set SI to notes table
  5517                              <1> 
  5518 000022B9 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5519 000022BB E643                <1> 	out	pit_ctl_reg,al
  5520                              <1> 
  5521                              <1> .loop:
  5522 000022BD 2EAD                <1>     cs	lodsw				; load next note to AX
  5523 000022BF 83F800              <1> 	cmp	ax,0
  5524 000022C2 7422                <1> 	jz	.exit
  5525 000022C4 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
  5526 000022C6 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5527 000022C8 88E0                <1> 	mov	al,ah
  5528 000022CA E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5529                              <1> 
  5530 000022CC E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5531 000022CE 0C03                <1>         or      al,03h			; turn on the speaker
  5532 000022D0 E661                <1>         out     port_b_reg,al		; write the new value
  5533                              <1> 
  5534                              <1> .silent:
  5535 000022D2 B90030              <1> 	mov	cx,3000h
  5536 000022D5 E8C4EB              <1> 	call	delay_15us		; delay while note is playing
  5537                              <1> 
  5538 000022D8 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5539 000022DA 24FC                <1> 	and	al,0FCh			; turn off the speaker
  5540 000022DC E661                <1>         out     port_b_reg,al		; write the new value
  5541                              <1> 
  5542 000022DE B90001              <1>         mov     cx,0100h
  5543 000022E1 E8B8EB              <1> 	call	delay_15us		; delay after the note
  5544                              <1>         
  5545 000022E4 EBD7                <1>         jmp     .loop			; play the next note
  5546                              <1> .exit:
  5547 000022E6 C3                  <1> 	ret
  5548                              <1> 
  5549                              <1> ;=========================================================================
  5550                              <1> ; beep - Play a beep sound
  5551                              <1> ; Input:
  5552                              <1> ;	BL - duration in 0.1 second
  5553                              <1> ; Output:
  5554                              <1> ;	BL = 0
  5555                              <1> ;-------------------------------------------------------------------------
  5556                              <1> beep:
  5557 000022E7 50                  <1> 	push	ax
  5558 000022E8 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
  5559 000022EA E643                <1> 	out	pit_ctl_reg,al
  5560 000022EC B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
  5561 000022EF E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
  5562 000022F1 88E0                <1> 	mov	al,ah
  5563 000022F3 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
  5564 000022F5 E461                <1> 	in	al,port_b_reg		; read current value of PORT B
  5565 000022F7 0C03                <1> 	or	al,03h			; turn on the speaker
  5566 000022F9 E661                <1> 	out	port_b_reg,al		; write the new value
  5567                              <1> .loop:
  5568 000022FB B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
  5569 000022FE E89BEB              <1> 	call	delay_15us
  5570 00002301 FECB                <1> 	dec	bl
  5571 00002303 75F6                <1> 	jnz	.loop
  5572 00002305 3403                <1> 	xor	al,03h			; turn off the speaker
  5573 00002307 E661                <1> 	out	port_b_reg,al		; write the new value
  5574 00002309 58                  <1> 	pop	ax
  5575 0000230A C3                  <1> 	ret
  5576                                  %include	"cpu.inc"		; CPU and FPU detection
  5577                              <1> ;=========================================================================
  5578                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
  5579                              <1> ;-------------------------------------------------------------------------
  5580                              <1> ;
  5581                              <1> ; Compiles with NASM 2.07, might work with other versions
  5582                              <1> ;
  5583                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  5584                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  5585                              <1> ;
  5586                              <1> ; This program is free software: you can redistribute it and/or modify
  5587                              <1> ; it under the terms of the GNU General Public License as published by
  5588                              <1> ; the Free Software Foundation, either version 3 of the License, or
  5589                              <1> ; (at your option) any later version.
  5590                              <1> ;
  5591                              <1> ; This program is distributed in the hope that it will be useful,
  5592                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5593                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5594                              <1> ; GNU General Public License for more details.
  5595                              <1> ;
  5596                              <1> ; You should have received a copy of the GNU General Public License
  5597                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  5598                              <1> ;
  5599                              <1> ;=========================================================================
  5600                              <1> 
  5601                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
  5602                              <1> 
  5603                              <1> ;=========================================================================
  5604                              <1> ; detect_cpu - detect and print CPU type
  5605                              <1> ; Note:
  5606                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
  5607                              <1> ;	  incorrect results if used on other CPU types.
  5608                              <1> ;-------------------------------------------------------------------------
  5609                              <1> detect_cpu:
  5610 0000230B 50                  <1> 	push	ax
  5611 0000230C 56                  <1> 	push	si
  5612 0000230D BE[9600]            <1> 	mov	si,msg_cpu
  5613 00002310 E87D02              <1> 	call	print
  5614                              <1> 
  5615                              <1> ; test for NEC V20
  5616 00002313 B80101              <1> 	mov	ax,0101h
  5617 00002316 D510                <1> 	aad	10h			; NEC V20 ignores the argument
  5618 00002318 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
  5619 0000231A 7452                <1> 	je	.nec_v20
  5620                              <1> 
  5621                              <1> ; not NEC V20, test for various 8088 versions
  5622                              <1> .i8088:					; 8088 - NMOS version of 8088
  5623 0000231C FA                  <1> 	cli				; disable interrupts
  5624 0000231D 1E                  <1> 	push	ds
  5625 0000231E 31C0                <1> 	xor	ax,ax
  5626 00002320 8ED8                <1> 	mov	ds,ax			; interrupt table segment
  5627 00002322 B8[9023]            <1> 	mov	ax,.int_01		; new int 01h offset
  5628 00002325 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
  5629 00002329 50                  <1> 	push	ax			; save to stack
  5630 0000232A 8CC8                <1> 	mov	ax,cs			; new int 01h segment
  5631 0000232C 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
  5632 00002330 50                  <1> 	push	ax			; save to stack
  5633 00002331 9C                  <1> 	pushf				; push flags to stack (save)
  5634 00002332 9C                  <1> 	pushf				; push flags to stack (modify)
  5635 00002333 58                  <1> 	pop	ax			; and move them to AX
  5636 00002334 0D0001              <1> 	or	ax,flags_tf		; set TF
  5637 00002337 50                  <1> 	push	ax
  5638 00002338 31C0                <1> 	xor	ax,ax			; AX = 0
  5639 0000233A 9D                  <1> 	popf				; load modified value to FLAGS register
  5640                              <1> 					; enable single-step
  5641 0000233B 90                  <1> 	nop
  5642 0000233C 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
  5643                              <1> 					; after PUSH SREG instructions
  5644                              <1> .push_sreg:				; and will not single-step to here
  5645 0000233D 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
  5646                              <1> 					; after modifying segment registers
  5647                              <1> .pop_sreg:				; and will not single-step to here
  5648 0000233E 90                  <1> 	nop
  5649 0000233F 9D                  <1> 	popf				; restore original FLAGS, disable
  5650                              <1> 					; single-step
  5651                              <1> 
  5652 00002340 5E                  <1> 	pop	si			; get original int 01h segment
  5653 00002341 89360600            <1> 	mov	word [6],si		; save it to interrupt table
  5654 00002345 5E                  <1> 	pop	si			; get original int 01h offset
  5655 00002346 89360400            <1> 	mov	word [4],si		; save it to interrupt table
  5656 0000234A 1F                  <1> 	pop	ds
  5657 0000234B FB                  <1> 	sti				; enable interrupts
  5658 0000234C 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
  5659 0000234F 740D                <1> 	jz	.i8088_78
  5660                              <1> 
  5661 00002351 83F802              <1> 	cmp	ax,0002h
  5662 00002354 7410                <1> 	jz	.i8088_81
  5663                              <1> 
  5664                              <1> .harris:				; Harris / Intersil 80C88
  5665 00002356 BE[E800]            <1> 	mov	si,msg_cpu_harris
  5666 00002359 E83402              <1> 	call	print
  5667 0000235C EB16                <1> 	jmp	.exit
  5668                              <1> 
  5669                              <1> .i8088_78:
  5670 0000235E BE[B300]            <1> 	mov	si,msg_cpu_8088_78
  5671 00002361 E82C02              <1> 	call	print
  5672 00002364 EB0E                <1> 	jmp	.exit
  5673                              <1> 
  5674                              <1> .i8088_81:
  5675 00002366 BE[CA00]            <1> 	mov	si,msg_cpu_8088_81
  5676 00002369 E82402              <1> 	call	print
  5677 0000236C EB06                <1> 	jmp	.exit
  5678                              <1> 
  5679                              <1> .nec_v20:
  5680 0000236E BE[F500]            <1> 	mov	si,msg_cpu_nec_v20
  5681 00002371 E81C02              <1> 	call	print
  5682                              <1> 
  5683                              <1> .exit:
  5684                              <1> 	;; SGEO do turbo test.
  5685 00002374 BE[1501]            <1> 	mov si, msg_turbo
  5686 00002377 E81602              <1> 	call print
  5687                              <1> 	
  5688 0000237A BE[1F01]            <1> 	mov si, msg_turbo_on
  5689                              <1> 	
  5690 0000237D E461                <1> 	in al, 0x61
  5691 0000237F A804                <1> 	test al,0x4
  5692 00002381 7503                <1> 	jnz .exit1
  5693 00002383 BE[2201]            <1> 	mov si, msg_turbo_off
  5694                              <1> .exit1:
  5695 00002386 E80702              <1> 	call print
  5696                              <1> 	
  5697 00002389 B021                <1> 	mov	al,e_cpu_detect_ok	; CPU detection finished
  5698 0000238B E680                <1> 	out	post_reg,al
  5699                              <1> 
  5700 0000238D 5E                  <1> 	pop	si
  5701 0000238E 58                  <1> 	pop	ax
  5702 0000238F C3                  <1> 	ret
  5703                              <1> 
  5704                              <1> ; stack frame after "push bp"
  5705                              <1> ; BP - word [BP]
  5706                              <1> ; IP - word [BP+2]
  5707                              <1> ; CS - word [BP+4]
  5708                              <1> ; FLAGS - word [BP+6]
  5709                              <1> .int_01:
  5710 00002390 55                  <1> 	push	bp
  5711 00002391 89E5                <1> 	mov	bp,sp
  5712 00002393 817E02[3E23]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
  5713 00002398 7504                <1> 	jne	.1
  5714 0000239A B001                <1> 	mov	al,01h			; (C) INTEL '79
  5715 0000239C EB09                <1> 	jmp	.int_01_exit
  5716                              <1> .1:
  5717 0000239E 817E02[3D23]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
  5718 000023A3 7502                <1> 	jne	.int_01_exit
  5719 000023A5 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
  5720                              <1> .int_01_exit:
  5721 000023A7 5D                  <1> 	pop	bp
  5722 000023A8 CF                  <1> 	iret
  5723                              <1> 
  5724                              <1> ;=========================================================================
  5725                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
  5726                              <1> ;-------------------------------------------------------------------------
  5727                              <1> test_word	equ	03FEh		; right at the end of interrupt table
  5728                              <1> detect_fpu:
  5729 000023A9 50                  <1> 	push	ax
  5730 000023AA 51                  <1> 	push	cx
  5731 000023AB 56                  <1> 	push	si
  5732                              <1> 		
  5733 000023AC DBE3                <1> 	fninit				; initialize coprocessor
  5734 000023AE B90300              <1> 	mov	cx,3
  5735                              <1> .wait:
  5736 000023B1 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
  5737                              <1> 					;   (can't use fwait, since it could
  5738                              <1> 					;   be no coprocessor at all)
  5739 000023B3 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
  5740 000023B7 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
  5741 000023BD D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
  5742 000023C1 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
  5743 000023C7 750D                <1> 	jne	.no_fpu			;   after finit
  5744                              <1> 
  5745                              <1> .fpu:
  5746 000023C9 BE[FD00]            <1> 	mov	si, msg_fpu_present
  5747 000023CC E8C101              <1> 	call	print
  5748 000023CF 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
  5749 000023D4 EB06                <1> 	jmp	.exit
  5750                              <1> 
  5751                              <1> .no_fpu:
  5752 000023D6 BE[0A01]            <1> 	mov si, msg_no_fpu
  5753 000023D9 E8B401              <1> 	call	print
  5754                              <1> 
  5755                              <1> .exit:
  5756 000023DC 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
  5757                              <1> 
  5758 000023E0 B022                <1> 	mov	al,e_fpu_detect_ok	; FPU detection finished
  5759 000023E2 E680                <1> 	out	post_reg,al
  5760                              <1> 
  5761 000023E4 5E                  <1> 	pop	si
  5762 000023E5 59                  <1> 	pop	cx
  5763 000023E6 58                  <1> 	pop	ax
  5764 000023E7 C3                  <1> 	ret
  5765                                  
  5766                                  %ifdef AT_COMPAT
  5767                                  
  5768                                  ;=========================================================================
  5769                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
  5770                                  ;-------------------------------------------------------------------------
  5771                                  int_ignore2:
  5772 000023E8 50                      	push	ax
  5773 000023E9 B020                    	mov	al,20h
  5774 000023EB E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5775 000023ED E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5776 000023EF 58                      	pop	ax
  5777 000023F0 CF                      	iret
  5778                                  
  5779                                  ;=========================================================================
  5780                                  ; int_71 - IRQ9 ISR, emulate IRQ2
  5781                                  ;-------------------------------------------------------------------------
  5782                                  int_71:
  5783 000023F1 50                      	push	ax
  5784 000023F2 B020                    	mov	al,20h
  5785 000023F4 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5786 000023F6 58                      	pop	ax
  5787 000023F7 CD0A                    	int	0Ah		; call IRQ2 ISR
  5788 000023F9 CF                      	iret
  5789                                  
  5790                                  ;=========================================================================
  5791                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
  5792                                  ;-------------------------------------------------------------------------
  5793                                  int_75:
  5794 000023FA 50                      	push	ax
  5795 000023FB B020                    	mov	al,20h
  5796 000023FD E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
  5797 000023FF E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
  5798 00002401 58                      	pop	ax
  5799 00002402 CD02                    	int	02h		; call NMI ISR
  5800 00002404 CF                      	iret
  5801                                  
  5802                                  %endif ; AT_COMPAT
  5803                                  
  5804                                  ;=========================================================================
  5805                                  ; extension_scan - scan for BIOS extensions
  5806                                  ; Input:
  5807                                  ;	DX - start segment
  5808                                  ;	BX - end segment
  5809                                  ; Returns:
  5810                                  ;	DX - address for the continuation of the scan
  5811                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  5812                                  ;-------------------------------------------------------------------------
  5813                                  extension_scan:
  5814 00002405 C70667000000            	mov	word [67h],0
  5815 0000240B C70669000000            	mov	word [69h],0
  5816                                  .scan:
  5817 00002411 8EC2                    	mov	es,dx
  5818 00002413 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  5819 0000241A 7532                    	jnz	.next			; no signature, check next 2 KiB
  5820 0000241C 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  5821 00002420 B400                    	mov	ah,0
  5822 00002422 B105                    	mov	cl,5
  5823 00002424 D3E0                    	shl	ax,cl			; convert size to paragraphs
  5824 00002426 01C2                    	add	dx,ax
  5825 00002428 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  5826 0000242B 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  5827 0000242E B104                    	mov	cl,4
  5828 00002430 D3E0                    	shl	ax,cl			; convert size to bytes
  5829 00002432 89C1                    	mov	cx,ax
  5830 00002434 B000                    	mov	al,0
  5831 00002436 31F6                    	xor	si,si
  5832                                  .checksum:
  5833 00002438 260204                      es	add	al,byte [si]
  5834 0000243B 46                      	inc	si
  5835 0000243C E2FA                    	loop	.checksum
  5836 0000243E 08C0                    	or	al,al			; AL == 0?
  5837 00002440 750C                    	jnz	.next			; AL not zero - bad checksum
  5838 00002442 C70667000300            	mov	word [67h],3		; extension initialization offset
  5839 00002448 8C066900                	mov	word [69h],es		; extension segment
  5840 0000244C EB08                    	jmp	.exit
  5841                                  .next:
  5842 0000244E 81C28000                	add	dx,80h			; add 2 KiB
  5843 00002452 39DA                    	cmp	dx,bx
  5844 00002454 72BB                    	jb	.scan
  5845                                  .exit:
  5846 00002456 C3                      	ret
  5847                                  
  5848                                  ;=========================================================================
  5849                                  ; ipl - Initial Program Load - try to read and execute boot sector
  5850                                  ;-------------------------------------------------------------------------
  5851                                  ipl:
  5852 00002457 FB                      	sti
  5853 00002458 31C0                    	xor	ax,ax
  5854 0000245A 8ED8                    	mov	ds,ax
  5855 0000245C C7067800[C76F]          	mov	word [78h],int_1E
  5856 00002462 8C0E7A00                	mov	word [7Ah],cs
  5857                                  
  5858                                  .retry:
  5859 00002466 B004                    	mov	al,4			; try booting from floppy 4 times
  5860                                  
  5861                                  .fd_loop:
  5862 00002468 50                      	push	ax
  5863 00002469 B400                    	mov	ah,00h			; reset disk system
  5864 0000246B B200                    	mov	dl,00h			; drive 0
  5865 0000246D CD13                    	int	13h
  5866 0000246F 722C                    	jb	.fd_failed
  5867 00002471 B408                    	mov	ah,08h			; get drive parameters
  5868 00002473 B200                    	mov	dl,00h			; drive 0
  5869 00002475 CD13                    	int	13h
  5870 00002477 7224                    	jc	.fd_failed
  5871 00002479 80FA00                  	cmp	dl,00h
  5872 0000247C 741F                    	jz	.fd_failed		; jump if zero drives
  5873 0000247E B80102                  	mov	ax,0201h		; read one sector
  5874 00002481 31D2                    	xor	dx,dx			; head 0, drive 0
  5875 00002483 8EC2                    	mov	es,dx			; to 0000:7C00
  5876 00002485 BB007C                  	mov	bx,7C00h
  5877 00002488 B90100                  	mov	cx,0001h		; track 0, sector 1
  5878 0000248B CD13                    	int	13h
  5879 0000248D 720E                    	jc	.fd_failed
  5880 0000248F 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5881 00002496 7505                    	jnz	.fd_failed
  5882 00002498 EA007C0000              	jmp	0000h:7C00h
  5883                                  
  5884                                  .fd_failed:
  5885 0000249D 58                      	pop	ax
  5886 0000249E FEC8                    	dec	al
  5887 000024A0 75C6                    	jnz	.fd_loop
  5888                                  
  5889                                  ; try booting from HDD
  5890                                  
  5891 000024A2 B40D                    	mov	ah,0Dh			; reset hard disks
  5892 000024A4 B280                    	mov	dl,80h			; drive 80h
  5893 000024A6 CD13                    	int	13h
  5894 000024A8 7222                    	jc	.hd_failed
  5895 000024AA B80102                  	mov	ax,0201h		; read one sector
  5896 000024AD BA8000                  	mov	dx,0080h		; head 0, drive 80h
  5897 000024B0 31DB                    	xor	bx,bx
  5898 000024B2 8EC3                    	mov	es,bx			; to 0000:7C00
  5899 000024B4 BB007C                  	mov	bx,7C00h
  5900 000024B7 B90100                  	mov	cx,0001h		; track 0, sector 1
  5901 000024BA CD13                    	int	13h
  5902 000024BC 720E                    	jc	.hd_failed
  5903 000024BE 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  5904 000024C5 7505                    	jnz	.hd_failed
  5905 000024C7 EA007C0000              	jmp	0000h:7C00h
  5906                                  
  5907                                  .hd_failed:
  5908 000024CC BE[0003]                	mov	si,msg_boot_failed
  5909 000024CF E8BE00                  	call	print
  5910 000024D2 B400                    	mov	ah,00h
  5911 000024D4 CD16                    	int	16h
  5912 000024D6 EB8E                    	jmp	.retry
  5913                                  
  5914                                  ;=========================================================================
  5915                                  ; get_line - read an ASCIIZ string from the console
  5916                                  ; Input:
  5917                                  ;	ES:DI - pointer to the buffer
  5918                                  ;	AX - max string length
  5919                                  ; Output:
  5920                                  ;	AX - string length
  5921                                  ; Notes:
  5922                                  ;	Buffer must have size of max string length + 1 to accomodate 00h
  5923                                  ;-------------------------------------------------------------------------
  5924                                  get_line:
  5925 000024D8 53                      	push	bx
  5926 000024D9 52                      	push	dx
  5927 000024DA 56                      	push	si
  5928 000024DB 57                      	push	di
  5929                                  
  5930 000024DC FC                      	cld
  5931 000024DD 89FE                    	mov	si,di
  5932 000024DF 01C6                    	add	si,ax			; SI = last character position
  5933 000024E1 31D2                    	xor	dx,dx			; DX = 0 - string length
  5934                                  
  5935                                  .read_char_loop:
  5936 000024E3 B400                    	mov	ah,00h			; read character from keyboard
  5937 000024E5 CD16                    	int	16h
  5938                                  
  5939 000024E7 3C08                    	cmp	al,08h			; <Backspace> key
  5940 000024E9 741B                    	jz	.backspace
  5941                                  
  5942 000024EB 3C0D                    	cmp	al,0Dh			; <Enter> key
  5943 000024ED 7441                    	jz	.enter
  5944                                  
  5945 000024EF 3C20                    	cmp	al,20h			; below printable ASCII code?
  5946 000024F1 7233                    	jb	.error_input
  5947                                  
  5948 000024F3 3C7E                    	cmp	al,7Eh			; above printable ASCII code?
  5949 000024F5 772F                    	ja	.error_input
  5950                                  
  5951 000024F7 39F7                    	cmp	di,si			; end of buffer reached?
  5952 000024F9 732B                    	jae	.error_input
  5953                                  
  5954 000024FB AA                      	stosb				; store character in the buffer
  5955 000024FC 42                      	inc	dx			; increment strng length
  5956                                  
  5957 000024FD B40E                    	mov	ah,0Eh			; teletype output (echo)
  5958 000024FF BB0700                  	mov	bx,0007h
  5959 00002502 CD10                    	int	10h
  5960                                  
  5961 00002504 EBDD                    	jmp	.read_char_loop
  5962                                  
  5963                                  .backspace:
  5964 00002506 09D2                    	or	dx,dx			; empty string?
  5965 00002508 741C                    	jz	.error_input
  5966                                  
  5967 0000250A 4F                      	dec	di			; move pointer back
  5968 0000250B 4A                      	dec	dx			; decrement string size
  5969                                  
  5970 0000250C B8080E                  	mov	ax,0E08h		; move the cursor back
  5971 0000250F BB0700                  	mov	bx,0007h
  5972 00002512 CD10                    	int	10h
  5973                                  
  5974 00002514 B8200E                  	mov	ax,0E20h		; erase the character under the cursor
  5975 00002517 BB0700                  	mov	bx,0007h
  5976 0000251A CD10                    	int	10h
  5977                                  
  5978 0000251C B8080E                  	mov	ax,0E08h		; move the cursor back again
  5979 0000251F BB0700                  	mov	bx,0007h
  5980 00002522 CD10                    	int	10h
  5981                                  
  5982 00002524 EBBD                    	jmp	.read_char_loop
  5983                                  
  5984                                  .error_input:
  5985 00002526 B8070E                  	mov	ax,0E07h		; beep
  5986 00002529 BB0700                  	mov	bx,0007h
  5987 0000252C CD10                    	int	10h
  5988                                  
  5989 0000252E EBB3                    	jmp	.read_char_loop
  5990                                  
  5991                                  .enter:
  5992 00002530 B000                    	mov	al,00h			; store 00h at the end of the string
  5993 00002532 AA                      	stosb
  5994                                  
  5995 00002533 B80D0E                  	mov	ax,0E0Dh		; CR
  5996 00002536 BB0700                  	mov	bx,0007h
  5997 00002539 CD10                    	int	10h
  5998                                  
  5999 0000253B B80A0E                  	mov	ax,0E0Ah		; LF
  6000 0000253E BB0700                  	mov	bx,0007h
  6001 00002541 CD10                    	int	10h
  6002                                  
  6003 00002543 89D0                    	mov	ax,dx			; string length to AX
  6004                                  
  6005 00002545 5F                      	pop	di
  6006 00002546 5E                      	pop	si
  6007 00002547 5A                      	pop	dx
  6008 00002548 5B                      	pop	bx
  6009 00002549 C3                      	ret
  6010                                  
  6011                                  ;=========================================================================
  6012                                  ; atoi - convert ASCIIZ string to an 16-bit integer number
  6013                                  ; Input:
  6014                                  ;	ES:DI - pointer to string
  6015                                  ; Output:
  6016                                  ;	AX - number
  6017                                  ; 	ES:DI - pointer moved to the position following the number
  6018                                  ;-------------------------------------------------------------------------
  6019                                  atoi:
  6020 0000254A 53                      	push	bx
  6021 0000254B 51                      	push	cx
  6022 0000254C 52                      	push	dx
  6023                                  
  6024 0000254D 31C0                    	xor	ax,ax			; zero the result
  6025 0000254F BB0A00                  	mov	bx,10			; multiplier
  6026                                  
  6027                                  .atoi_loop:
  6028 00002552 268A0D                      es	mov	cl,byte [di]
  6029                                  
  6030 00002555 80F930                  	cmp	cl,'0'			; ASCII code below '0'
  6031 00002558 7211                    	jb	.exit
  6032                                  
  6033 0000255A 80F939                  	cmp	cl,'9'			; ASCII code above '9'
  6034 0000255D 770C                    	ja	.exit
  6035                                  
  6036 0000255F 47                      	inc	di			; move to the next character
  6037                                  
  6038 00002560 80E930                  	sub	cl,'0'			; convert to ASCII to binary
  6039                                  
  6040 00002563 F7E3                    	mul	bx			; DX:AX = AX * 10
  6041 00002565 B500                    	mov	ch,0
  6042 00002567 01C8                    	add	ax,cx			; AX = AX + CX
  6043                                  	
  6044 00002569 EBE7                    	jmp	.atoi_loop
  6045                                  
  6046                                  .exit:
  6047 0000256B 5A                      	pop	dx
  6048 0000256C 59                      	pop	cx
  6049 0000256D 5B                      	pop	bx
  6050 0000256E C3                      	ret
  6051                                  
  6052                                  ;=========================================================================
  6053                                  ; bin_to_bcd - convert binary number to a packed BCD
  6054                                  ; Input:
  6055                                  ;	AX - binary number
  6056                                  ; Output:
  6057                                  ;	AX - packed BCD number
  6058                                  ;-------------------------------------------------------------------------
  6059                                  bin_to_bcd:
  6060 0000256F 53                      	push	bx
  6061 00002570 51                      	push	cx
  6062 00002571 52                      	push	dx
  6063 00002572 56                      	push	si
  6064                                  
  6065 00002573 B100                    	mov	cl,0			; shift amount
  6066 00002575 31F6                    	xor	si,si			; zero result
  6067 00002577 BB0A00                  	mov	bx,10			; BX - divisor
  6068                                  
  6069                                  .bin_to_bcd_loop:
  6070 0000257A 31D2                    	xor	dx,dx			; DX - zero for 32-bit div operand
  6071 0000257C F7F3                    	div	bx
  6072                                  
  6073 0000257E D3E2                    	shl	dx,cl			; shift digit to the required position
  6074 00002580 80C104                  	add	cl,4			; calculate next position
  6075                                  
  6076 00002583 01D6                    	add	si,dx			; add reminder to the result
  6077 00002585 09C0                    	or	ax,ax			; quotient is zero?
  6078 00002587 75F1                    	jnz	.bin_to_bcd_loop
  6079                                  
  6080 00002589 89F0                    	mov	ax,si			; result to AX
  6081                                  
  6082 0000258B 5E                      	pop	si
  6083 0000258C 5A                      	pop	dx
  6084 0000258D 59                      	pop	cx
  6085 0000258E 5B                      	pop	bx
  6086 0000258F C3                      	ret
  6087                                  
  6088                                  
  6089                                  ;=========================================================================
  6090                                  ; print - print ASCIIZ string to the console
  6091                                  ; Input:
  6092                                  ;	CS:SI - pointer to string to print
  6093                                  ; Output:
  6094                                  ;	none
  6095                                  ;-------------------------------------------------------------------------
  6096                                  print:
  6097 00002590 9C                      	pushf
  6098 00002591 50                      	push	ax
  6099 00002592 53                      	push	bx
  6100 00002593 56                      	push	si
  6101 00002594 1E                      	push	ds
  6102 00002595 0E                      	push	cs
  6103 00002596 1F                      	pop	ds
  6104 00002597 FC                      	cld
  6105                                  .1:
  6106 00002598 AC                      	lodsb
  6107 00002599 08C0                    	or	al,al
  6108 0000259B 7408                    	jz	.exit
  6109 0000259D B40E                    	mov	ah,0Eh
  6110 0000259F B30F                    	mov	bl,0Fh
  6111 000025A1 CD10                    	int	10h
  6112 000025A3 EBF3                    	jmp	.1
  6113                                  .exit:
  6114 000025A5 1F                      	pop	ds
  6115 000025A6 5E                      	pop	si
  6116 000025A7 5B                      	pop	bx
  6117 000025A8 58                      	pop	ax
  6118 000025A9 9D                      	popf
  6119 000025AA C3                      	ret
  6120                                  
  6121                                  ;=========================================================================
  6122                                  ; print_hex - print 16-bit number in hexadecimal
  6123                                  ; Input:
  6124                                  ;	AX - number to print
  6125                                  ; Output:
  6126                                  ;	none
  6127                                  ;-------------------------------------------------------------------------
  6128                                  print_hex:
  6129 000025AB 86C4                    	xchg	al,ah
  6130 000025AD E80600                  	call	print_byte		; print the upper byte
  6131 000025B0 86C4                    	xchg	al,ah
  6132 000025B2 E80100                  	call	print_byte		; print the lower byte
  6133 000025B5 C3                      	ret
  6134                                  
  6135                                  ;=========================================================================
  6136                                  ; print_byte - print a byte in hexadecimal
  6137                                  ; Input:
  6138                                  ;	AL - byte to print
  6139                                  ; Output:
  6140                                  ;	none
  6141                                  ;-------------------------------------------------------------------------
  6142                                  print_byte:
  6143 000025B6 D0C0                    	rol	al,1
  6144 000025B8 D0C0                    	rol	al,1
  6145 000025BA D0C0                    	rol	al,1
  6146 000025BC D0C0                    	rol	al,1
  6147 000025BE E82D00                  	call	print_digit
  6148 000025C1 D0C0                    	rol	al,1
  6149 000025C3 D0C0                    	rol	al,1
  6150 000025C5 D0C0                    	rol	al,1
  6151 000025C7 D0C0                    	rol	al,1
  6152 000025C9 E82200                  	call	print_digit
  6153 000025CC C3                      	ret
  6154                                  
  6155                                  ;=========================================================================
  6156                                  ; print_dec - print 16-bit number in decimal
  6157                                  ; Input:
  6158                                  ;	AX - number to print
  6159                                  ; Output:
  6160                                  ;	none
  6161                                  ;-------------------------------------------------------------------------
  6162                                  print_dec:
  6163 000025CD 50                      	push	ax
  6164 000025CE 51                      	push	cx
  6165 000025CF 52                      	push	dx
  6166 000025D0 B90A00                  	mov	cx,10		; base = 10
  6167 000025D3 E80400                  	call	.print_rec
  6168 000025D6 5A                      	pop	dx
  6169 000025D7 59                      	pop	cx
  6170 000025D8 58                      	pop	ax
  6171 000025D9 C3                      	ret
  6172                                  
  6173                                  .print_rec:			; print all digits recursively
  6174 000025DA 52                      	push	dx
  6175 000025DB 31D2                    	xor	dx,dx		; DX = 0
  6176 000025DD F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
  6177 000025DF 83F800                  	cmp	ax,0
  6178 000025E2 7403                    	je	.below10
  6179 000025E4 E8F3FF                  	call	.print_rec	; print number / 10 recursively
  6180                                  .below10:
  6181 000025E7 89D0                    	mov	ax,dx		; reminder is in DX
  6182 000025E9 E80200                  	call	print_digit	; print reminder
  6183 000025EC 5A                      	pop	dx
  6184 000025ED C3                      	ret
  6185                                  
  6186                                  ;=========================================================================
  6187                                  ; print_digit - print hexadecimal digit
  6188                                  ; Input:
  6189                                  ;	AL - bits 3...0 - digit to print (0...F)
  6190                                  ; Output:
  6191                                  ;	none
  6192                                  ;-------------------------------------------------------------------------
  6193                                  print_digit:
  6194 000025EE 50                      	push	ax
  6195 000025EF 53                      	push	bx
  6196 000025F0 240F                    	and	al,0Fh
  6197 000025F2 0430                    	add	al,'0'			; convert to ASCII
  6198 000025F4 3C39                    	cmp	al,'9'			; less or equal 9?
  6199 000025F6 7602                    	jna	.1
  6200 000025F8 0407                    	add	al,'A'-'9'-1		; a hex digit
  6201                                  .1:
  6202 000025FA B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
  6203 000025FC B307                    	mov	bl,07h			; just in case we're in graphic mode
  6204 000025FE CD10                    	int	10h
  6205 00002600 5B                      	pop	bx
  6206 00002601 58                      	pop	ax
  6207 00002602 C3                      	ret
  6208                                  
  6209                                  ;=========================================================================
  6210                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
  6211                                  ; Input:
  6212                                  ;	AX = memory size in KiB
  6213                                  ; Notes:
  6214                                  ;	- Assumes that EBDA memory was cleaned
  6215                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
  6216                                  ;-------------------------------------------------------------------------
  6217                                  reserve_ebda:
  6218                                  %ifdef PS2_MOUSE
  6219 00002603 50                      	push	ax
  6220 00002604 51                      	push	cx
  6221 00002605 F70610000400            	test	word [equipment_list],equip_mouse
  6222 0000260B 742B                    	jz	.no_mouse
  6223 0000260D A11300                  	mov	ax,word [memory_size]	; get conventional memory size
  6224 00002610 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
  6225 00002613 A31300                  	mov	word [memory_size],ax	; store new conventional memory size
  6226 00002616 B106                    	mov	cl,6
  6227 00002618 D3E0                    	shl	ax,cl			; convert to segment
  6228 0000261A A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
  6229 0000261D 1E                      	push	ds
  6230 0000261E 8ED8                    	mov	ds,ax
  6231 00002620 B80100                  	mov	ax,EBDA_SIZE
  6232 00002623 A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
  6233 00002626 1F                      	pop	ds
  6234 00002627 56                      	push	si
  6235 00002628 BE[DF02]                	mov	si,msg_ebda
  6236 0000262B E862FF                  	call	print
  6237 0000262E E89CFF                  	call	print_dec
  6238 00002631 BE[F602]                	mov	si,msg_kibx
  6239 00002634 E859FF                  	call	print
  6240 00002637 5E                      	pop	si
  6241                                  .no_mouse:
  6242 00002638 59                      	pop	cx
  6243 00002639 58                      	pop	ax
  6244                                  %endif ; PS2_MOUSE
  6245 0000263A C3                      	ret
  6246                                  
  6247                                  ;=========================================================================
  6248                                  ; detect_ram - Determine the size of installed RAM and test it
  6249                                  ; Input:
  6250                                  ;	none
  6251                                  ; Output:
  6252                                  ;	AX = RAM size
  6253                                  ;	CX, SI - trashed
  6254                                  ;-------------------------------------------------------------------------
  6255                                  detect_ram:
  6256 0000263B B030                    	mov	al,e_ram_start		; RAM scan start
  6257 0000263D E680                    	out	post_reg,al
  6258                                  
  6259 0000263F 1E                      	push	ds
  6260 00002640 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  6261 00002642 B82000                  	mov	ax,MIN_RAM_SIZE
  6262                                  
  6263                                  .fill_loop:
  6264 00002645 50                      	push	ax
  6265 00002646 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6266 00002648 8ED8                    	mov	ds,ax
  6267 0000264A A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  6268 0000264D 58                      	pop	ax
  6269 0000264E 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6270 00002651 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6271 00002654 75EF                    	jne	.fill_loop
  6272 00002656 B82000                  	mov	ax,MIN_RAM_SIZE
  6273                                  
  6274                                  .size_loop:
  6275 00002659 50                      	push	ax
  6276 0000265A D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  6277 0000265C 8ED8                    	mov	ds,ax
  6278 0000265E 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  6279 00002662 750B                    	jne	.size_done
  6280 00002664 58                      	pop	ax
  6281 00002665 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  6282 00002668 3D8002                  	cmp	ax,MAX_RAM_SIZE
  6283 0000266B 7303                    	jnb	.size_exit
  6284 0000266D EBEA                    	jmp	.size_loop
  6285                                  
  6286                                  .size_done:
  6287 0000266F 58                      	pop	ax
  6288                                  
  6289                                  .size_exit:
  6290 00002670 1F                      	pop	ds
  6291 00002671 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  6292                                  
  6293                                  ; AX = detected memory size, now test the RAM
  6294                                  
  6295 00002674 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  6296 0000267A 7474                    	je	.test_done
  6297                                  
  6298 0000267C BE[8002]                	mov	si,msg_ram_testing
  6299 0000267F E80EFF                  	call	print
  6300 00002682 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  6301                                  
  6302                                  .test_loop:
  6303 00002685 50                      	push	ax
  6304 00002686 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  6305 00002688 B700                    	mov	bh,00h			; page 0
  6306 0000268A CD10                    	int	10h			; position returned in DX
  6307 0000268C 58                      	pop	ax
  6308 0000268D E83DFF                  	call	print_dec
  6309 00002690 50                      	push	ax
  6310 00002691 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  6311 00002693 B700                    	mov	bh,00h			; page 0
  6312 00002695 CD10                    	int	10h
  6313 00002697 B401                    	mov	ah,01h
  6314 00002699 CD16                    	int	16h
  6315 0000269B 7412                    	jz	.test_no_key
  6316 0000269D B400                    	mov	ah,00h
  6317 0000269F CD16                    	int	16h			; read the keystroke
  6318 000026A1 3C1B                    	cmp	al,1Bh			; ESC?
  6319 000026A3 7421                    	je	.test_esc
  6320 000026A5 3D003B                  	cmp	ax,3B00h		; F1?
  6321 000026A8 7505                    	jne	.test_no_key
  6322 000026AA 800E120001              	or	byte [post_flags],post_setup
  6323                                  
  6324                                  .test_no_key:
  6325 000026AF 58                      	pop	ax
  6326 000026B0 E83E00                  	call	ram_test_block
  6327 000026B3 721D                    	jc	.test_error		; error in last test
  6328 000026B5 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  6329 000026B8 3B061300                	cmp	ax,word [memory_size]
  6330 000026BC 72C7                    	jb	.test_loop
  6331                                  
  6332 000026BE 50                      	push	ax
  6333 000026BF B031                    	mov	al,e_ram_complete	; RAM scan complete
  6334 000026C1 E680                    	out	post_reg,al
  6335 000026C3 58                      	pop	ax
  6336                                  
  6337 000026C4 EB2A                    	jmp	.test_done
  6338                                  
  6339                                  .test_esc:
  6340 000026C6 58                      	pop	ax
  6341 000026C7 A11300                  	mov	ax,word [memory_size]
  6342                                  
  6343 000026CA 50                      	push	ax
  6344 000026CB B032                    	mov	al,e_ram_esc		; RAM scan canceled
  6345 000026CD E680                    	out	post_reg,al
  6346 000026CF 58                      	pop	ax
  6347                                  
  6348 000026D0 EB1E                    	jmp	.test_done
  6349                                  
  6350                                  .test_error:
  6351 000026D2 A31300                  	mov	word [memory_size],ax	; store size of good memory
  6352 000026D5 BE[9D02]                	mov	si,msg_ram_error
  6353 000026D8 E8B5FE                  	call	print
  6354 000026DB E8EFFE                  	call	print_dec
  6355 000026DE BE[FA02]                	mov	si,msg_kib
  6356 000026E1 E8ACFE                  	call	print
  6357 000026E4 BE[8800]                	mov	si,msg_crlf
  6358 000026E7 E8A6FE                  	call	print
  6359                                  
  6360 000026EA 50                      	push	ax
  6361 000026EB B080                    	mov	al,e_ram_fail		; RAM scan failed
  6362 000026ED E680                    	out	post_reg,al
  6363 000026EF 58                      	pop	ax
  6364                                  
  6365                                  .test_done:
  6366 000026F0 C3                      	ret
  6367                                  
  6368                                  ;=========================================================================
  6369                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  6370                                  ; Input:
  6371                                  ;	AX = address of the memory to test (in KiB)
  6372                                  ; Output:
  6373                                  ;	CF = status
  6374                                  ;		0 = passed
  6375                                  ;		1 = failed
  6376                                  ;-------------------------------------------------------------------------
  6377                                  ram_test_block:
  6378 000026F1 50                      	push	ax
  6379 000026F2 53                      	push	bx
  6380 000026F3 51                      	push	cx
  6381 000026F4 56                      	push	si
  6382 000026F5 57                      	push	di
  6383 000026F6 1E                      	push	ds
  6384 000026F7 06                      	push	es
  6385 000026F8 B106                    	mov	cl,6			; convert KiB to segment address
  6386 000026FA D3E0                    	shl	ax,cl			; (multiply by 64)
  6387 000026FC 8ED8                    	mov	ds,ax
  6388 000026FE 8EC0                    	mov	es,ax
  6389 00002700 31F6                    	xor	si,si
  6390 00002702 31FF                    	xor	di,di
  6391 00002704 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  6392 00002707 B8AA55                  	mov	ax,55AAh		; first test pattern
  6393 0000270A 89D9                    	mov	cx,bx
  6394 0000270C F3AB                        rep	stosw				; store test pattern
  6395 0000270E 89D9                    	mov	cx,bx			; RAM test block size
  6396                                  .1:
  6397 00002710 AD                      	lodsw
  6398 00002711 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6399 00002714 7522                    	jne	.fail
  6400 00002716 E2F8                    	loop	.1
  6401 00002718 31F6                    	xor	si,si
  6402 0000271A 31FF                    	xor	di,di
  6403 0000271C B855AA                  	mov	ax,0AA55h		; second test pattern
  6404 0000271F 89D9                    	mov	cx,bx			; RAM test block size
  6405 00002721 F3AB                        rep stosw				; store test pattern
  6406 00002723 89D9                    	mov	cx,bx			; RAM test block size
  6407                                  .2:
  6408 00002725 AD                      	lodsw
  6409 00002726 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6410 00002729 750D                    	jne	.fail
  6411 0000272B E2F8                    	loop	.2
  6412 0000272D 31FF                    	xor	di,di
  6413 0000272F 31C0                    	xor	ax,ax			; zero
  6414 00002731 89D9                    	mov	cx,bx			; RAM test block size
  6415 00002733 F3AB                        rep stosw				; zero the memory
  6416 00002735 F8                      	clc				; test passed, clear CF
  6417 00002736 EB01                    	jmp	.exit
  6418                                  
  6419                                  .fail:
  6420 00002738 F9                      	stc				; test failed, set CF
  6421                                  	
  6422                                  .exit:
  6423 00002739 07                      	pop	es
  6424 0000273A 1F                      	pop	ds
  6425 0000273B 5F                      	pop	di
  6426 0000273C 5E                      	pop	si
  6427 0000273D 59                      	pop	cx
  6428 0000273E 5B                      	pop	bx
  6429 0000273F 58                      	pop	ax
  6430 00002740 C3                      	ret
  6431                                  
  6432                                  ;=========================================================================
  6433                                  ; print display type
  6434                                  ;-------------------------------------------------------------------------
  6435                                  print_display:
  6436 00002741 BE[2601]                	mov	si,msg_disp
  6437 00002744 E849FE                  	call	print
  6438 00002747 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
  6439 0000274A 2430                    	and	al,equip_video		; get video adapter type
  6440 0000274C BE[6801]                	mov	si,msg_disp_mda
  6441 0000274F 3C30                    	cmp	al,equip_mono		; monochrome?
  6442 00002751 740A                    	jz	.print_disp
  6443 00002753 BE[6201]                	mov	si,msg_disp_cga
  6444 00002756 3C20                    	cmp	al,equip_color		; CGA?
  6445 00002758 7403                    	jz	.print_disp
  6446 0000275A BE[4301]                	mov	si,msg_disp_ega		; otherwise EGA or later
  6447                                  .print_disp:
  6448 0000275D E830FE                  	call	print
  6449 00002760 C3                      	ret
  6450                                  
  6451                                  ;=========================================================================
  6452                                  ; print PS/2 mouse presence
  6453                                  ;-------------------------------------------------------------------------
  6454                                  
  6455                                  print_mouse:
  6456 00002761 BE[0E02]                	mov	si,msg_mouse
  6457 00002764 E829FE                  	call	print
  6458 00002767 BE[3502]                	mov	si,msg_absent
  6459 0000276A F606100004              	test	byte [equipment_list],equip_mouse
  6460 0000276F 7403                    	jz	.print_mouse
  6461 00002771 BE[2B02]                	mov	si,msg_present
  6462                                  .print_mouse:
  6463 00002774 E819FE                  	call	print
  6464 00002777 C3                      	ret
  6465                                  
  6466                                  ;=========================================================================
  6467                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  6468                                  ;-------------------------------------------------------------------------
  6469                                  
  6470                                  detect_rom_ext:
  6471 00002778 B040                    	mov	al,e_ext_start		; ROM extension scan start
  6472 0000277A E680                    	out	post_reg,al
  6473                                  
  6474 0000277C BA00C8                  	mov	dx,0C800h
  6475 0000277F BB00F8                  	mov	bx,0F800h
  6476                                  
  6477                                  .ext_scan_loop:
  6478 00002782 E880FC                  	call	extension_scan
  6479 00002785 833E670000              	cmp	word [67h],0
  6480 0000278A 7429                    	jz	.ext_scan_done		; No ROM extension found
  6481 0000278C B041                    	mov	al,e_ext_detect		; ROM extension found
  6482 0000278E E680                    	out	post_reg,al
  6483 00002790 BE[3C03]                	mov	si,msg_rom_found
  6484 00002793 E8FAFD                  	call	print
  6485 00002796 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  6486 00002799 E80FFE                  	call	print_hex
  6487 0000279C BE[5903]                	mov	si,msg_rom_init
  6488 0000279F E8EEFD                  	call	print
  6489 000027A2 53                      	push	bx
  6490 000027A3 52                      	push	dx
  6491 000027A4 FF1E6700                	call	far [67h]
  6492 000027A8 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6493 000027AB 8ED8                    	mov	ds,ax
  6494 000027AD B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  6495 000027AF E680                    	out	post_reg,al
  6496 000027B1 5A                      	pop	dx
  6497 000027B2 5B                      	pop	bx
  6498 000027B3 EBCD                    	jmp	.ext_scan_loop
  6499                                  
  6500                                  .ext_scan_done:
  6501 000027B5 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  6502 000027B7 E680                    	out	post_reg,al
  6503                                  
  6504 000027B9 C3                      	ret
  6505                                  
  6506                                  ;=========================================================================	
  6507                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
  6508                                  ;-------------------------------------------------------------------------
  6509                                  interrupt_table:
  6510 000027BA [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
  6511 000027BC [537F]                  	dw	int_dummy		; INT 01 - Single step
  6512 000027BE [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
  6513 000027C0 [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
  6514 000027C2 [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
  6515 000027C4 [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
  6516 000027C6 [537F]                  	dw	int_dummy		; INT 06
  6517 000027C8 [537F]                  	dw	int_dummy		; INT 07
  6518 000027CA [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
  6519 000027CC [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
  6520 000027CE [237F]                  	dw	int_ignore		; INT 0A - IRQ2
  6521 000027D0 [237F]                  	dw	int_ignore		; INT 0B - IRQ3
  6522 000027D2 [237F]                  	dw	int_ignore		; INT 0C - IRQ4
  6523 000027D4 [237F]                  	dw	int_ignore		; INT 0D - IRQ5
  6524 000027D6 [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
  6525 000027D8 [237F]                  	dw	int_ignore		; INT 0F - IRQ7
  6526 000027DA [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
  6527 000027DC [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
  6528 000027DE [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
  6529 000027E0 [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
  6530 000027E2 [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
  6531 000027E4 [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
  6532 000027E6 [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
  6533 000027E8 [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
  6534 000027EA [4D63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
  6535 000027EC [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
  6536 000027EE [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
  6537 000027F0 [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
  6538 000027F2 [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
  6539 000027F4 [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
  6540 000027F6 [C76F]                  	dw	int_1E			; INT 1E - Floppy Paameters Table
  6541 000027F8 [9706]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
  6542                                  
  6543                                  %ifdef AT_COMPAT
  6544                                  interrupt_table2:
  6545 000027FA [2010]                  	dw	int_70			; INT 70 - IRQ8 - RTC
  6546 000027FC [F123]                  	dw	int_71			; INT 71 - IRQ9 - redirection
  6547 000027FE [E823]                  	dw	int_ignore2		; INT 72 - IRQ10
  6548 00002800 [E823]                  	dw	int_ignore2		; INT 73 - IRQ11
  6549                                  %ifndef PS2_MOUSE
  6550                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
  6551                                  %else
  6552 00002802 [2622]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
  6553                                  %endif
  6554 00002804 [FA23]                  	dw	int_75			; INT 75 - IRQ13 - FPU
  6555 00002806 [E823]                  	dw	int_ignore2		; INT 76 - IRQ14
  6556 00002808 [E823]                  	dw	int_ignore2		; INT 77 - IRQ15
  6557                                  %endif ; AT_COMPAT
  6558                                  
  6559                                  ;=========================================================================
  6560                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
  6561                                  ;-------------------------------------------------------------------------	
  6562 0000280A FF<rept>                	setloc	0E05Bh		; POST Entry Point
  6563          ******************       warning: (setloc:7) Inserting 14417 bytes
  6564                                  cold_start:
  6565 0000605B B84000                  	mov	ax,biosdseg
  6566 0000605E 8ED8                    	mov	ds,ax
  6567 00006060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
  6568                                  
  6569                                  warm_start:
  6570 00006066 FA                      	cli				; disable interrupts
  6571 00006067 FC                      	cld				; clear direction flag
  6572 00006068 B001                    	mov	al,e_start
  6573 0000606A E680                    	out	post_reg,al		; POST start code
  6574                                  
  6575                                  ;-------------------------------------------------------------------------
  6576                                  ; test CPU's FLAG register
  6577                                  
  6578 0000606C 31C0                    	xor	ax,ax			; AX = 0
  6579 0000606E 724A                    	jb	cpu_fail
  6580 00006070 7048                    	jo	cpu_fail
  6581 00006072 7846                    	js	cpu_fail
  6582 00006074 7544                    	jnz	cpu_fail
  6583 00006076 7B42                    	jpo	cpu_fail
  6584 00006078 83C001                  	add	ax,1			; AX = 1
  6585 0000607B 743D                    	jz	cpu_fail
  6586 0000607D 7A3B                    	jpe	cpu_fail
  6587 0000607F 2D0280                  	sub	ax,8002h
  6588 00006082 7836                    	js	cpu_fail
  6589 00006084 40                      	inc	ax
  6590 00006085 7133                    	jno	cpu_fail
  6591 00006087 D1E0                    	shl	ax,1
  6592 00006089 732F                    	jnb	cpu_fail
  6593 0000608B 752D                    	jnz	cpu_fail
  6594 0000608D D1E0                    	shl	ax,1
  6595 0000608F 7229                    	jb	cpu_fail
  6596                                  
  6597                                  ;-------------------------------------------------------------------------
  6598                                  ; Test CPU registers
  6599                                  
  6600 00006091 B8AAAA                  	mov	ax,0AAAAh
  6601                                  .1:
  6602 00006094 8ED8                    	mov	ds,ax
  6603 00006096 8CDB                    	mov	bx,ds
  6604 00006098 8EC3                    	mov	es,bx
  6605 0000609A 8CC1                    	mov	cx,es
  6606 0000609C 8ED1                    	mov	ss,cx
  6607 0000609E 8CD2                    	mov	dx,ss
  6608 000060A0 89D5                    	mov	bp,dx
  6609 000060A2 89EC                    	mov	sp,bp
  6610 000060A4 89E6                    	mov	si,sp
  6611 000060A6 89F7                    	mov	di,si
  6612 000060A8 81FFAAAA                	cmp	di,0AAAAh
  6613 000060AC 7506                    	jnz	.2
  6614 000060AE 89F8                    	mov	ax,di
  6615 000060B0 F7D0                    	not	ax
  6616 000060B2 EBE0                    	jmp	.1
  6617                                  .2:
  6618 000060B4 81FF5555                	cmp	di,5555h
  6619 000060B8 741A                    	jz	cpu_ok
  6620                                  
  6621                                  cpu_fail:
  6622 000060BA B052                    	mov	al,e_cpu_fail
  6623 000060BC E680                    	out	post_reg,al
  6624                                  
  6625                                  ;-------------------------------------------------------------------------
  6626                                  ; CPU error: continious beep - 400 Hz
  6627                                  
  6628 000060BE B0B6                    	mov	al,0B6h
  6629 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6630 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6631 000060C5 E642                    	out	pit_ch2_reg,al
  6632 000060C7 88E0                    	mov	al,ah
  6633 000060C9 E642                    	out	pit_ch2_reg,al
  6634 000060CB E461                    	in	al,port_b_reg
  6635 000060CD 0C03                    	or	al,3			; turn speaker on and enable
  6636 000060CF E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6637                                  
  6638                                  .1:
  6639 000060D1 F4                      	hlt
  6640 000060D2 EBFD                    	jmp	.1
  6641                                  
  6642                                  ;-------------------------------------------------------------------------
  6643                                  ; CPU test passed
  6644                                  
  6645                                  cpu_ok:
  6646 000060D4 B002                    	mov	al,e_cpu_ok
  6647 000060D6 E680                    	out	post_reg,al
  6648                                  
  6649                                  ;-------------------------------------------------------------------------
  6650                                  ; disable NMI, turbo mode, and video output on CGA and MDA
  6651                                  
  6652 000060D8 B00D                    	mov	al,0Dh & nmi_disable
  6653 000060DA E670                    	out	rtc_addr_reg,al		; disable NMI
  6654 000060DC EB00                    	jmp	$+2
  6655 000060DE E471                    	in	al,rtc_data_reg		; dummy read to keep RTC happy
  6656                                  
  6657 000060E0 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  6658 000060E2 E661                    	out	port_b_reg,al
  6659 000060E4 B000                    	mov	al,00h			; clear turbo bit
  6660 000060E6 E661                    	out	port_b_reg,al		; and also turn off the speaker
  6661                                  
  6662 000060E8 BAD803                  	mov	dx,cga_mode_reg
  6663 000060EB EE                      	out	dx,al			; disable video output on CGA
  6664 000060EC FEC0                    	inc	al
  6665 000060EE BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
  6666 000060F1 EE                      	out	dx,al			; and set MDA high-resolution mode bit
  6667                                  
  6668                                  ;-------------------------------------------------------------------------
  6669                                  ; Initialize DMAC (8237)
  6670                                   
  6671 000060F2 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
  6672 000060F4 B040                     	mov	al,40h			; single mode, verify, channel 0
  6673 000060F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6674 000060F8 B041                     	mov	al,41h			; single mode, verify, channel 1
  6675 000060FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6676 000060FC B042                     	mov	al,42h			; single mode, verify, channel 2
  6677 000060FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6678 00006100 B043                     	mov	al,43h			; single mode, verify, channel 3
  6679 00006102 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
  6680 00006104 B000                     	mov	al,0			; DMA Command register bits:
  6681                                   					; DACK active low, DREQ active high,
  6682                                   					; late write, fixed priority,
  6683                                   					; normal timing, controller enable
  6684                                   					; channel 0 addr hold disable
  6685                                   					; memory to memory disable
  6686 00006106 E608                     	out	08h,al			; DMA Command register
  6687 00006108 E681                     	out	81h,al			; DMA Page, channel 2
  6688 0000610A E682                     	out	82h,al			; DMA Page, channel 3
  6689 0000610C E683                     	out	83h,al			; DMA Page, channels 0,1
  6690 0000610E B003                    	mov	al,e_dmac_ok
  6691 00006110 E680                    	out	post_reg,al
  6692                                  
  6693                                  ;-------------------------------------------------------------------------
  6694                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
  6695                                  
  6696                                  low_ram_test:
  6697 00006112 31F6                    	xor	si,si
  6698 00006114 31FF                    	xor	di,di
  6699 00006116 8EDF                    	mov	ds,di
  6700 00006118 8EC7                    	mov	es,di
  6701 0000611A 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
  6702 0000611E B8AA55                  	mov	ax,55AAh		; first test pattern
  6703 00006121 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6704 00006124 F3AB                        rep	stosw				; store test pattern
  6705 00006126 B90040                  	mov	cx,4000h		; 32 KiB = 16384 words
  6706                                  .1:
  6707 00006129 AD                      	lodsw
  6708 0000612A 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  6709 0000612D 7524                    	jne	low_ram_fail
  6710 0000612F E2F8                    	loop	.1
  6711 00006131 31F6                    	xor	si,si
  6712 00006133 31FF                    	xor	di,di
  6713 00006135 B855AA                  	mov	ax,0AA55h		; second test pattern
  6714 00006138 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6715 0000613B F3AB                        rep stosw				; store test pattern
  6716 0000613D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6717                                  .2:
  6718 00006140 AD                      	lodsw
  6719 00006141 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  6720 00006144 750D                    	jne	low_ram_fail
  6721 00006146 E2F8                    	loop	.2
  6722 00006148 31FF                    	xor	di,di
  6723 0000614A 31C0                    	xor	ax,ax			; zero
  6724 0000614C B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
  6725 0000614F F3AB                        rep stosw				; zero the memory
  6726 00006151 EB29                    	jmp	low_ram_ok		; test passed
  6727                                  
  6728                                  low_ram_fail:
  6729 00006153 B054                    	mov	al,e_low_ram_fail	; test failed
  6730 00006155 E680                    	out	post_reg,al
  6731                                  
  6732                                  ;-------------------------------------------------------------------------
  6733                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
  6734                                  
  6735 00006157 B0B6                    	mov	al,0B6h
  6736 00006159 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
  6737 0000615B B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
  6738 0000615E E642                    	out	pit_ch2_reg,al
  6739 00006160 88E0                    	mov	al,ah
  6740 00006162 E642                    	out	pit_ch2_reg,al
  6741 00006164 E461                    	in	al,port_b_reg
  6742                                  .1:
  6743 00006166 0C03                    	or	al,3			; turn speaker on and enable
  6744 00006168 E661                    	out	port_b_reg,al		; PIT channel 2 to speaker
  6745 0000616A B90000                  	mov	cx,0
  6746                                  .2:
  6747 0000616D 90                      	nop
  6748 0000616E E2FD                    	loop	.2
  6749 00006170 24FC                    	and	al,0FCh			; turn of speaker
  6750 00006172 E661                    	out	port_b_reg,al
  6751 00006174 B90000                  	mov	cx,0
  6752                                  .3:
  6753 00006177 90                      	nop
  6754 00006178 E2FD                    	loop	.3
  6755 0000617A EBEA                    	jmp	.1
  6756                                  
  6757                                  ;-------------------------------------------------------------------------
  6758                                  ; Low memory test passed
  6759                                  
  6760                                  low_ram_ok:
  6761 0000617C 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
  6762 00006180 B004                    	mov	al,e_low_ram_ok
  6763 00006182 E680                    	out	post_reg,al
  6764                                  
  6765                                  ;-------------------------------------------------------------------------
  6766                                  ; Set up stack - using upper 256 bytes of interrupt table
  6767                                  
  6768 00006184 B83000                  	mov	ax,0030h
  6769 00006187 8ED0                    	mov	ss,ax
  6770 00006189 BC0001                  	mov	sp,0100h
  6771                                  
  6772                                  ;-------------------------------------------------------------------------
  6773                                  ; Initialize interrupt table
  6774                                  
  6775 0000618C 0E                      	push	cs
  6776 0000618D 1F                      	pop	ds
  6777 0000618E 31FF                    	xor	di,di
  6778 00006190 8EC7                    	mov	es,di
  6779 00006192 BE[BA27]                	mov	si,interrupt_table
  6780 00006195 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
  6781 00006198 B800F0                  	mov	ax,bioscseg
  6782                                  .1:
  6783 0000619B A5                      	movsw				; copy ISR address (offset part)
  6784 0000619C AB                      	stosw				; store segment part
  6785 0000619D E2FC                    	loop	.1
  6786                                  %ifdef AT_COMPAT
  6787 0000619F BFC001                  	mov	di,70h*4		; starting from IRQ 70
  6788 000061A2 BE[FA27]                	mov	si,interrupt_table2
  6789 000061A5 B90800                  	mov	cx,8			; 8 Interrupt vectors
  6790                                  .2:
  6791 000061A8 A5                      	movsw				; copy ISR address (offset part)
  6792 000061A9 AB                      	stosw				; store segment part
  6793 000061AA E2FC                    	loop	.2
  6794                                  %endif ; AT_COMPAT
  6795 000061AC B005                    	mov     al,e_int_ok
  6796 000061AE E680                    	out	post_reg,al
  6797                                  
  6798                                  ;-------------------------------------------------------------------------
  6799                                  ; set DS to BIOS data area
  6800                                  
  6801 000061B0 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6802 000061B3 8ED8                    	mov	ds,ax
  6803                                  
  6804                                  ;-------------------------------------------------------------------------
  6805                                  ; Initialize PIT (8254 timer)
  6806                                  
  6807 000061B5 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  6808 000061B7 E643                    	out	pit_ctl_reg,al
  6809 000061B9 B000                    	mov	al,0
  6810 000061BB E640                    	out	pit_ch0_reg,al
  6811 000061BD E640                    	out	pit_ch0_reg,al
  6812 000061BF B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  6813 000061C1 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  6814 000061C3 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  6815 000061C5 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  6816 000061C7 B040                    	mov	al,40h			; XXX timer latch
  6817 000061C9 E643                    	out	pit_ctl_reg,al
  6818                                  
  6819                                  ;-------------------------------------------------------------------------
  6820                                  ; Play "power on" sound - also tests PIT functionality
  6821 000061CB E8E7C0                  	call	sound
  6822                                  
  6823 000061CE B006                    	mov     al,e_pit_ok		; PIT initialization successful
  6824 000061D0 E680                    	out	post_reg,al
  6825                                  
  6826                                  ;-------------------------------------------------------------------------
  6827                                  ; Initialize PIC (8259)
  6828                                  
  6829                                  %ifdef AT_COMPAT
  6830 000061D2 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  6831 000061D4 E620                    	out	pic1_reg0,al
  6832 000061D6 E6A0                    	out	pic2_reg0,al
  6833 000061D8 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  6834 000061DA E621                    	out	pic1_reg1,al
  6835 000061DC B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  6836 000061DE E6A1                    	out	pic2_reg1,al
  6837 000061E0 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  6838 000061E2 E621                    	out	pic1_reg1,al
  6839 000061E4 B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  6840 000061E6 E6A1                    	out	pic2_reg1,al
  6841 000061E8 B001                    	mov	al,1			; ICW4 - 8086/8088
  6842 000061EA E621                    	out	pic1_reg1,al
  6843 000061EC E6A1                    	out	pic2_reg1,al
  6844                                  %else
  6845                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  6846                                  	out	pic1_reg0,al
  6847                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  6848                                  	out	pic1_reg1,al
  6849                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  6850                                  	out	pic1_reg1,al
  6851                                  	mov	al,e_pic_ok
  6852                                  	out	post_reg,al
  6853                                  %endif ; AT_COMPAT
  6854                                  
  6855                                  ;-------------------------------------------------------------------------
  6856                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  6857                                  
  6858 000061EE E86CB7                  	call	kbc_init
  6859                                  
  6860                                  ;-------------------------------------------------------------------------
  6861                                  ; enable interrupts
  6862                                  
  6863                                  %ifdef AT_COMPAT
  6864 000061F1 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  6865 000061F3 E621                    	out	pic1_reg1,al
  6866                                  %ifndef PS2_MOUSE
  6867                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  6868                                  %else
  6869 000061F5 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  6870                                  %endif ; PS2_MOUSE
  6871 000061F7 E6A1                    	out	pic2_reg1,al
  6872                                  %else
  6873                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  6874                                  	out	pic1_reg1,al
  6875                                  %endif ; AT_COMPAT
  6876 000061F9 FB                      	sti
  6877                                  
  6878                                  ;-------------------------------------------------------------------------
  6879                                  ; look for video BIOS, initialize it if present
  6880                                  	
  6881 000061FA BA00C0                  	mov	dx,0C000h
  6882 000061FD BB00C8                  	mov	bx,0C800h
  6883 00006200 E802C2                  	call	extension_scan
  6884 00006203 833E670000              	cmp	word [67h],0
  6885 00006208 7418                    	jz	.no_video_bios
  6886 0000620A B011                    	mov	al,e_video_bios_ok
  6887 0000620C E680                    	out	post_reg,al
  6888 0000620E FF1E6700                	call	far [67h]
  6889 00006212 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  6890 00006215 8ED8                    	mov	ds,ax
  6891 00006217 B012                    	mov	al,e_video_init_ok
  6892 00006219 E680                    	out	post_reg,al
  6893                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  6894 0000621B 83261000CF              	and	word [equipment_list],~equip_video
  6895 00006220 EB1E                    	jmp	.video_initialized
  6896                                  
  6897                                  .no_video_bios:
  6898 00006222 8A261000                	mov	ah,byte [equipment_list] 	; get equipment - low byte
  6899 00006226 80E430                  	and	ah,equip_video				; get video adapter type
  6900                                  	
  6901 00006229 B007                    	mov	al,07h						; monochrome 80x25 mode
  6902 0000622B 80FC30                  	cmp	ah,equip_mono				; monochrome?
  6903 0000622E 7402                    	jz	.set_mode
  6904                                  	
  6905 00006230 B003                    	mov	al,03h						; color 80x25 mode
  6906                                  
  6907                                  .set_mode:
  6908 00006232 B400                    	mov	ah,00h						; INT 10, AH=00 - Set video mode
  6909                                  
  6910                                  	;; SGEO - try and do a video fix..
  6911 00006234 50                      	push ax
  6912 00006235 CD10                    	int	10h
  6913                                  	;; 100ms
  6914 00006237 B92C1A                  	mov cx, 0x43 * 100
  6915 0000623A E85FAC                  	call delay_15us
  6916 0000623D 58                      	pop ax
  6917 0000623E CD10                    	int 0x10
  6918                                  
  6919                                  .video_initialized:
  6920                                  
  6921                                  ;-------------------------------------------------------------------------
  6922                                  ; print the copyright message
  6923                                  
  6924 00006240 BE[0000]                	mov	si,msg_copyright
  6925 00006243 E84AC3                  	call	print
  6926                                  
  6927                                  ;-------------------------------------------------------------------------
  6928                                  ; Initialize RTC / NVRAM
  6929                                  
  6930 00006246 E86CA8                  	call	rtc_init
  6931                                  
  6932                                  ; read equipment byte from CMOS and set it in BIOS data area
  6933                                  
  6934 00006249 BE[DE03]                	mov	si,msg_setup
  6935 0000624C E841C3                  	call	print
  6936                                  
  6937                                  ;-------------------------------------------------------------------------
  6938                                  ; detect and print availability of various equipment
  6939                                  
  6940 0000624F E8B9C0                  	call	detect_cpu		; detect and print CPU type
  6941 00006252 E854C1                  	call	detect_fpu		; detect and print FPU presence
  6942                                  
  6943 00006255 E8DFAB                  	call	print_rtc		; print current RTC time
  6944                                  
  6945 00006258 E8E6C4                  	call	print_display		; print display type
  6946 0000625B E803C5                  	call	print_mouse		; print mouse presence
  6947                                  
  6948 0000625E E895BC                  	call	detect_serial		; detect serial ports and print findings
  6949 00006261 E85CBD                  	call	detect_parallel		; detect parallel ports and print
  6950                                  					; findings
  6951                                  
  6952 00006264 B010                    	mov	al,cmos_floppy
  6953 00006266 E82EA8                  	call	rtc_read		; floppies type to AL
  6954 00006269 E893B5                  	call	print_floppy		; print floppy drive types
  6955                                  
  6956 0000626C E8CCC3                  	call	detect_ram		; test RAM, get RAM size in AX
  6957                                  
  6958 0000626F BE[C102]                	mov	si,msg_ram_total
  6959 00006272 E81BC3                  	call	print
  6960 00006275 E855C3                  	call	print_dec		; print RAM size
  6961 00006278 BE[F602]                	mov	si,msg_kibx
  6962 0000627B E812C3                  	call	print
  6963                                  
  6964 0000627E E882C3                  	call	reserve_ebda		; reserve EBDA if needed
  6965                                  
  6966 00006281 BE[E802]                	mov	si,msg_ram_avail
  6967 00006284 E809C3                  	call	print
  6968 00006287 A11300                  	mov	ax,word [memory_size]
  6969 0000628A E840C3                  	call	print_dec		; print remaining RAM size
  6970 0000628D BE[FA02]                	mov	si,msg_kib
  6971 00006290 E8FDC2                  	call	print
  6972                                  
  6973 00006293 E8E2C4                  	call	detect_rom_ext		; detect and initialize extension ROMs
  6974                                  
  6975                                  ;-------------------------------------------------------------------------
  6976                                  ; Check for F1 (setup key), run setup utility if pressed
  6977                                  
  6978 00006296 B401                    	mov	ah,01h
  6979 00006298 CD16                    	int	16h
  6980 0000629A 740E                    	jz	.no_key
  6981 0000629C B400                    	mov	ah,00h
  6982 0000629E CD16                    	int	16h			; read the keystroke
  6983 000062A0 3D003B                  	cmp	ax,3B00h		; F1?
  6984 000062A3 7505                    	jne	.no_key
  6985 000062A5 800E120001              	or	byte [post_flags],post_setup
  6986                                  .no_key:
  6987                                  
  6988 000062AA F606120001              	test	byte [post_flags],post_setup
  6989 000062AF 7403                    	jz	.no_setup
  6990 000062B1 E81CA9                  	call	rtc_setup
  6991                                  
  6992                                  .no_setup:
  6993                                  
  6994                                  ;-------------------------------------------------------------------------
  6995                                  ; boot the OS
  6996                                  
  6997 000062B4 B000                    	mov	al,e_boot		; boot the OS POST code
  6998 000062B6 E680                    	out	post_reg,al
  6999                                  
  7000 000062B8 BE[6E03]                	mov	si,msg_boot
  7001 000062BB E8D2C2                  	call	print
  7002 000062BE CD19                    	int	19h			; boot the OS
  7003                                  
  7004                                  ;=========================================================================
  7005                                  ; int_02 - NMI
  7006                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  7007                                  ;	implemented
  7008                                  ;-------------------------------------------------------------------------
  7009 000062C0 FF<rept>                	setloc	0E2C3h			; NMI Entry Point
  7010          ******************       warning: (setloc:7) Inserting 3 bytes
  7011                                  int_02:
  7012 000062C3 50                      	push	ax
  7013 000062C4 B00D                    	mov	al,0Dh & nmi_disable
  7014 000062C6 E8CEA7                  	call	rtc_read		; disable NMI
  7015 000062C9 E461                    	in	al,port_b_reg		; read Port B
  7016 000062CB 88C4                    	mov	ah,al
  7017 000062CD 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  7018 000062CF E661                    	out	port_b_reg,al
  7019 000062D1 A840                    	test	al,iochk_status
  7020 000062D3 7506                    	jnz	.iochk_nmi
  7021 000062D5 88E0                    	mov	al,ah
  7022 000062D7 E661                    	out	port_b_reg,al		; restore original bits
  7023 000062D9 EB24                    	jmp	.exit
  7024                                  
  7025                                  .iochk_nmi:
  7026 000062DB 56                      	push	si
  7027 000062DC BE[0663]                	mov	si,msg_iochk_nmi
  7028 000062DF E8AEC2                  	call	print
  7029 000062E2 5E                      	pop	si
  7030                                  .1:
  7031 000062E3 B400                    	mov	ah,0h
  7032 000062E5 CD16                    	int	16h
  7033 000062E7 3C69                    	cmp	al,'i'			; exit from NMI
  7034 000062E9 7414                    	je	.exit			;  ~IOCHK remains disabled
  7035 000062EB 3C49                    	cmp	al,'I'
  7036 000062ED 7410                    	je	.exit
  7037 000062EF 3C72                    	cmp	al,'r'
  7038 000062F1 7503E965FD              	je	cold_start
  7039 000062F6 3C52                    	cmp	al,'R'
  7040 000062F8 7503E95EFD              	je	cold_start
  7041 000062FD EBE4                    	jmp	.1
  7042                                  .exit:
  7043 000062FF B08D                    	mov	al,0Dh | nmi_enable
  7044 00006301 E893A7                  	call	rtc_read		; enable NMI
  7045 00006304 58                      	pop	ax
  7046 00006305 CF                      	iret
  7047                                  
  7048                                  msg_iochk_nmi:
  7049 00006306 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore IOCHK NMIs, or 'r' to reboot."
  7050 0000630F 206465746563746564-
  7051 00006318 2E2054797065202769-
  7052 00006321 2720746F2069676E6F-
  7053 0000632A 726520494F43484B20-
  7054 00006333 4E4D49732C206F7220-
  7055 0000633C 27722720746F207265-
  7056 00006345 626F6F742E         
  7057 0000634A 0D0A00                  	db	0Dh, 0Ah, 00h
  7058                                  
  7059                                  ;=========================================================================
  7060                                  ; int_18 - execute ROM BASIC
  7061                                  ; Note:
  7062                                  ;	Prints an error message since we don't have ROM BASIC
  7063                                  ;-------------------------------------------------------------------------
  7064                                  int_18:
  7065 0000634D BE[2D03]                	mov	si,msg_no_basic
  7066 00006350 E83DC2                  	call	print
  7067                                  .1:
  7068 00006353 F4                      	hlt
  7069 00006354 EBFD                    	jmp	.1
  7070                                  
  7071                                  ;=========================================================================
  7072                                  ; int_19 - load and execute the boot sector
  7073                                  ;-------------------------------------------------------------------------
  7074 00006356 FF<rept>                	setloc	0E6F2h			; INT 19 Entry Point
  7075          ******************       warning: (setloc:7) Inserting 924 bytes
  7076                                  int_19:
  7077 000066F2 E962BD                  	jmp	ipl
  7078                                  
  7079                                  ;=========================================================================
  7080                                  ; configuration data table
  7081                                  ;-------------------------------------------------------------------------
  7082                                  	setloc	0E6F5h
  7083                                  config_table:
  7084 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  7085                                  .bytes:
  7086                                  %ifdef AT_COMPAT
  7087 000066F7 FC                      	db	0FCh			; byte 2: model = AT
  7088 000066F8 00                      	db	00h			; byte 3: submodel = 0
  7089 000066F9 00                      	db	00h			; byte 4: release = 0
  7090 000066FA 70                      	db	01110000b		; byte 5: feature byte 1
  7091                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7092                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7093                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7094                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7095                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7096                                  ;		||`-- real time clock installed
  7097                                  ;		|`-- 2nd interrupt controller installed
  7098                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7099 000066FB 00                      	db	00h			; byte 6: feature byte 2
  7100 000066FC 00                      	db	00h			; byte 7: feature byte 3
  7101 000066FD 00                      	db	00h			; byte 8: feature byte 4
  7102 000066FE 00                      	db	00h			; byte 9: feature byte 5
  7103                                  %else
  7104                                  	db	0FEh			; byte 2: model = XT
  7105                                  	db	00h			; byte 3: submodel = 0
  7106                                  	db	00h			; byte 4: release = 0
  7107                                  	db	00000000b		; byte 5: feature byte 1
  7108                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  7109                                  ;		||||||`-- bus is Micro Channel instead of ISA
  7110                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  7111                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  7112                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  7113                                  ;		||`-- real time clock installed
  7114                                  ;		|`-- 2nd interrupt controller installed
  7115                                  ;		`-- DMA channel 3 used by hard disk BIOS
  7116                                  	db	00h			; byte 6: feature byte 2
  7117                                  	db	00h			; byte 7: feature byte 3
  7118                                  	db	00h			; byte 8: feature byte 4
  7119                                  	db	00h			; byte 9: feature byte 5
  7120                                  %endif ; AT_COMPAT
  7121                                  .size	equ	$-.bytes
  7122                                  
  7123                                  ;=========================================================================
  7124                                  ; Includes with fixed entry points (for IBM compatibility)
  7125                                  ;-------------------------------------------------------------------------
  7126                                  
  7127                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  7128                              <1> ;========================================================================
  7129                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  7130                              <1> ;       INT 14h, function AH=00h
  7131                              <1> ;       INT 14h, function AH=03h
  7132                              <1> ;       INT 14h, function AH=04h
  7133                              <1> ;       INT 14h, function AH=05h
  7134                              <1> ;	- see serial1.inc for other INT 14h functions
  7135                              <1> ;-------------------------------------------------------------------------
  7136                              <1> ;
  7137                              <1> ; Compiles with NASM 2.07, might work with other versions
  7138                              <1> ;
  7139                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  7140                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7141                              <1> ;
  7142                              <1> ; This program is free software: you can redistribute it and/or modify
  7143                              <1> ; it under the terms of the GNU General Public License as published by
  7144                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7145                              <1> ; (at your option) any later version.
  7146                              <1> ;
  7147                              <1> ; This program is distributed in the hope that it will be useful,
  7148                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7149                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7150                              <1> ; GNU General Public License for more details.
  7151                              <1> ;
  7152                              <1> ; You should have received a copy of the GNU General Public License
  7153                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7154                              <1> ;
  7155                              <1> ;=========================================================================
  7156                              <1> 
  7157                              <1> ;=========================================================================
  7158                              <1> ; int_14 - BIOS Serial Port Communication Services
  7159                              <1> ;-------------------------------------------------------------------------
  7160 000066FF FF<rept>            <1> 	setloc	0E729h			; INT 14 Entry Point
  7161          ******************  <1>  warning: (setloc:7) Inserting 42 bytes
  7162                              <1> int_14:
  7163 00006729 FB                  <1> 	sti
  7164 0000672A 51                  <1> 	push	cx
  7165 0000672B 52                  <1> 	push	dx
  7166 0000672C 56                  <1> 	push	si
  7167 0000672D 1E                  <1> 	push	ds
  7168 0000672E 53                  <1> 	push	bx
  7169 0000672F BB4000              <1> 	mov	bx,biosdseg
  7170 00006732 8EDB                <1> 	mov	ds,bx
  7171 00006734 80FC06              <1> 	cmp	ah,.max/2
  7172 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
  7173 00006739 83FA04              <1> 	cmp	dx,num_serial
  7174 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
  7175 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  7176 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  7177 00006743 89D3                <1> 	mov	bx,dx
  7178 00006745 D1E3                <1> 	shl	bx,1
  7179 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  7180 00006749 09D2                <1> 	or	dx,dx
  7181 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
  7182 0000674D B700                <1> 	mov	bh,0
  7183 0000674F 88E3                <1> 	mov	bl,ah
  7184 00006751 D1E3                <1> 	shl	bx,1
  7185 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
  7186                              <1> .dispatch:
  7187 00006758 [6C67]              <1> 	dw	int_14_fn00
  7188 0000675A [911E]              <1> 	dw	int_14_fn01
  7189 0000675C [AC1E]              <1> 	dw	int_14_fn02
  7190 0000675E [A167]              <1> 	dw	int_14_fn03
  7191 00006760 [AB67]              <1> 	dw	int_14_fn04
  7192 00006762 [0568]              <1> 	dw	int_14_fn05
  7193                              <1> .max	equ	$-.dispatch
  7194                              <1> 
  7195                              <1> int_14_error:
  7196 00006764 31C0                <1> 	xor	ax,ax
  7197                              <1> 
  7198                              <1> int_14_exit:
  7199 00006766 5B                  <1> 	pop	bx
  7200 00006767 1F                  <1> 	pop	ds
  7201 00006768 5E                  <1> 	pop	si
  7202 00006769 5A                  <1> 	pop	dx
  7203 0000676A 59                  <1> 	pop	cx
  7204 0000676B CF                  <1> 	iret
  7205                              <1> 
  7206                              <1> ;=========================================================================
  7207                              <1> ; int_14_fn00 - Initialize serial port
  7208                              <1> ; Input:
  7209                              <1> ;	AH = 0 - function 00h - initialize serial port
  7210                              <1> ;	AL - initialization parameters
  7211                              <1> ;		bit 1,0	= 10	- 7 data bits
  7212                              <1> ;			= 11	- 8 data bits
  7213                              <1> ;		bit 2	= 0	- 1 stop bit
  7214                              <1> ;			= 1	- 2 stop bits
  7215                              <1> ;		bit 3	= 0	- parity disable
  7216                              <1> ;			= 1	- parity enable
  7217                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  7218                              <1> ;			= 1	- even parity (if parity enabled)
  7219                              <1> ;		bit 7-5 = 000	- 110 bps
  7220                              <1> ;			= 001	- 150 bps
  7221                              <1> ;			= 010	- 300 bps
  7222                              <1> ;			= 011	- 600 bps
  7223                              <1> ;			= 100	- 1200 bps
  7224                              <1> ;			= 101	- 2400 bps
  7225                              <1> ;			= 110	- 4800 bps
  7226                              <1> ;			= 111	- 9600 bps
  7227                              <1> ;	DX = serial port number (0-3)
  7228                              <1> ; Output:
  7229                              <1> ;	AL = modem status
  7230                              <1> ;		bit 0	= 1	- delta clear to send
  7231                              <1> ;		bit 1	= 1	- delta data set ready
  7232                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  7233                              <1> ;		bit 3	= 1	- delta data carrier detect
  7234                              <1> ;		bit 4	= 1	- clear to send
  7235                              <1> ;		bit 5	= 1	- data set ready
  7236                              <1> ;		bit 6	= 1	- ring indicator
  7237                              <1> ;		bit 7	= 1	- data carrier detect
  7238                              <1> ;	AH = line status
  7239                              <1> ;		bit 0	= 1	- data ready
  7240                              <1> ;		bit 1	= 1	- overrun error
  7241                              <1> ;		bit 2	= 1	- parity error
  7242                              <1> ;		bit 3	= 1	- framing error
  7243                              <1> ;		bit 4	= 1	- break interrupt
  7244                              <1> ;		bit 5	= 1	- transmitter holding register
  7245                              <1> ;		bit 6	= 1	- transmitter empty
  7246                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  7247                              <1> ;-------------------------------------------------------------------------
  7248                              <1> int_14_fn00:
  7249 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  7250 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7251 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7252 00006773 EE                  <1> 	out	dx,al
  7253 00006774 31DB                <1> 	xor	bx,bx
  7254 00006776 88E3                <1> 	mov	bl,ah
  7255 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  7256 0000677B D0EB                <1> 	shr	bl,1
  7257 0000677D D0EB                <1> 	shr	bl,1
  7258 0000677F D0EB                <1> 	shr	bl,1
  7259 00006781 D0EB                <1> 	shr	bl,1
  7260 00006783 2E8B9F[941F]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7261 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7262 0000678B 88D8                <1> 	mov	al,bl
  7263 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  7264 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  7265 0000678F 88F8                <1> 	mov	al,bh
  7266 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  7267 00006792 42                  <1> 	inc	dx
  7268 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  7269 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  7270 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  7271                              <1> 					; get control bits
  7272 00006798 EE                  <1> 	out	dx,al			; set LCR
  7273 00006799 4A                  <1> 	dec	dx
  7274 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  7275                              <1> 					; OPTIMIZATION:
  7276                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7277 0000679B B000                <1> 	mov	al,0
  7278 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  7279 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  7280                              <1> 					; OPTIMIZATION:
  7281                              <1> 					; uart_base = uart_ier_reg - 1
  7282 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7283                              <1> 
  7284                              <1> ;=========================================================================
  7285                              <1> ; int_14_fn03 - Return serial port status
  7286                              <1> ; Input:
  7287                              <1> ;	AH = 03h - function 03h - return serial port status
  7288                              <1> ;	DX = serial port number (0-3)
  7289                              <1> ; Output:
  7290                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7291                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7292                              <1> ;-------------------------------------------------------------------------
  7293                              <1> int_14_fn03:
  7294 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  7295 000067A4 EC                  <1> 	in	al,dx
  7296 000067A5 88C4                <1> 	mov	ah,al
  7297 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  7298 000067A8 EC                  <1> 	in	al,dx
  7299 000067A9 EBBB                <1> 	jmp	int_14_exit
  7300                              <1> 
  7301                              <1> ;=========================================================================
  7302                              <1> ; int_14_fn04 - Extended initialize serial port
  7303                              <1> ; Input:
  7304                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  7305                              <1> ;	AL - break status:
  7306                              <1> ;		00h = no break
  7307                              <1> ;		01h = break
  7308                              <1> ;	BH - parity:
  7309                              <1> ;		00h = no parity
  7310                              <1> ;		01h = odd parity
  7311                              <1> ;		02h = even parity
  7312                              <1> ;		03h = stick parity odd
  7313                              <1> ;		04h = stick parity even
  7314                              <1> ;	BL - stop bits:
  7315                              <1> ;		00h = 1 stop bit
  7316                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  7317                              <1> ;	CH - word length:
  7318                              <1> ;		00h = 5 bits
  7319                              <1> ;		01h = 6 bits
  7320                              <1> ;		02h = 7 bits
  7321                              <1> ;		03h = 8 bits
  7322                              <1> ;	CL - bps rate:
  7323                              <1> ;		00h = 110 bps
  7324                              <1> ;		01h = 150 bps
  7325                              <1> ;		02h = 300 bps
  7326                              <1> ;		03h = 600 bps
  7327                              <1> ;		04h = 1200 bps
  7328                              <1> ;		05h = 2400 bps
  7329                              <1> ;		06h = 6000 bps
  7330                              <1> ;		07h = 9600 bps
  7331                              <1> ;		08h = 19200 bps
  7332                              <1> ;		09h = 38400 bps
  7333                              <1> ;		0Ah = 57600 bps
  7334                              <1> ;		0Bh = 115200 bps
  7335                              <1> ;	DX = serial port number (0-3)
  7336                              <1> ; Output:
  7337                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  7338                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  7339                              <1> ;-------------------------------------------------------------------------
  7340                              <1> int_14_fn04:
  7341 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  7342 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  7343 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  7344                              <1> 					; exit returning modem and line status
  7345 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  7346 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  7347 000067B7 EE                  <1> 	out	dx,al
  7348 000067B8 31DB                <1> 	xor	bx,bx
  7349 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  7350 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  7351 000067BE 2E8B9F[941F]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  7352 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7353 000067C6 88D8                <1> 	mov	al,bl
  7354 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  7355 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  7356 000067CA 88F8                <1> 	mov	al,bh
  7357 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  7358 000067CD 42                  <1> 	inc	dx
  7359 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  7360                              <1> 
  7361 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  7362 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  7363                              <1> 
  7364 000067D4 D0E0                <1> 	shl	al,1
  7365 000067D6 D0E0                <1> 	shl	al,1
  7366 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  7367                              <1> 	
  7368 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  7369 000067DB 53                  <1> 	push	bx			; push it back to the stack
  7370                              <1> 
  7371 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  7372 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  7373 000067E1 FECF                <1> 	dec	bh
  7374 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  7375 000067E6 D0E7                <1> 	shl	bh,1
  7376 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  7377                              <1> 
  7378                              <1> .set_parity:
  7379 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  7380                              <1> 
  7381 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  7382                              <1> 	
  7383 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  7384 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  7385                              <1> 
  7386 000067F3 D0E0                <1> 	shl	al,1
  7387 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  7388                              <1> 
  7389 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  7390 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  7391                              <1> 
  7392 000067FC EE                  <1> 	out	dx,al			; set LCR
  7393 000067FD 4A                  <1> 	dec	dx
  7394 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  7395                              <1> 					; OPTIMIZATION:
  7396                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  7397 000067FF B000                <1> 	mov	al,0
  7398 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  7399 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  7400                              <1> 					; OPTIMIZATION:
  7401                              <1> 					; uart_base = uart_ier_reg - 1
  7402 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7403                              <1> 
  7404                              <1> ;=========================================================================
  7405                              <1> ; int_14_fn05 - Extended serial port control
  7406                              <1> ; Input:
  7407                              <1> ;	AH = 05h - function 05h - extended serial port control
  7408                              <1> ;	AL - sub-function:
  7409                              <1> ;		00h = read modem control register
  7410                              <1> ;		01h = write modem control register
  7411                              <1> ;			BL = modem control register
  7412                              <1> ;	DX = serial port number (0-3)
  7413                              <1> ; Output:
  7414                              <1> ;	AX = status	
  7415                              <1> ;	sub-function AL = 00h:
  7416                              <1> ;		BL = modem control register
  7417                              <1> ;-------------------------------------------------------------------------
  7418                              <1> int_14_fn05:
  7419 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  7420 00006807 750D                <1> 	jnz	int_14_fn05_01
  7421                              <1> 
  7422                              <1> ;-------------------------------------------------------------------------
  7423                              <1> ; sub-function 00h - read modem control register
  7424                              <1> ; int_14_fn05_00:
  7425 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7426 0000680C EC                  <1> 	in	al,dx
  7427 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  7428 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  7429 00006810 53                  <1> 	push	bx			; put BX back to the stack
  7430 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7431 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7432                              <1> 
  7433                              <1> ;-------------------------------------------------------------------------
  7434                              <1> ; sub-function 01h - write modem control register
  7435                              <1> int_14_fn05_01:
  7436 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  7437 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  7438 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  7439 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  7440 0000681D EE                  <1> 	out	dx,al
  7441 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  7442 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  7443                                  %include	"atkbd.inc"		; INT 16, INT 09
  7444                              <1> ;=========================================================================
  7445                              <1> ; atkbd.inc - AT keyboard support
  7446                              <1> ;       INT 16h - BIOS Keyboard Services
  7447                              <1> ;		- function AH=02h
  7448                              <1> ;		- function AH=03h
  7449                              <1> ;		- function AH=05h
  7450                              <1> ;		- function AH=12h
  7451                              <1> ;		- see scancode.inc for other (scancode related)
  7452                              <1> ;                 INT 16h functions
  7453                              <1> ;       INT 09h - IRQ1 interrupt handler
  7454                              <1> ;-------------------------------------------------------------------------
  7455                              <1> ;
  7456                              <1> ; Compiles with NASM 2.07, might work with other versions
  7457                              <1> ;
  7458                              <1> ; Copyright (C) 2011 - 2014 Sergey Kiselev.
  7459                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  7460                              <1> ;
  7461                              <1> ; This program is free software: you can redistribute it and/or modify
  7462                              <1> ; it under the terms of the GNU General Public License as published by
  7463                              <1> ; the Free Software Foundation, either version 3 of the License, or
  7464                              <1> ; (at your option) any later version.
  7465                              <1> ;
  7466                              <1> ; This program is distributed in the hope that it will be useful,
  7467                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7468                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7469                              <1> ; GNU General Public License for more details.
  7470                              <1> ;
  7471                              <1> ; You should have received a copy of the GNU General Public License
  7472                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  7473                              <1> ;
  7474                              <1> ;=========================================================================
  7475                              <1> 
  7476                              <1> ;=========================================================================
  7477                              <1> ; Scan codes and keyboard flags
  7478                              <1> ;-------------------------------------------------------------------------
  7479                              <1> 
  7480                              <1> ; scancodes for special keys
  7481                              <1> 
  7482                              <1> kbd_num_code	equ	45h
  7483                              <1> kbd_scroll_code	equ	46h
  7484                              <1> kbd_caps_code	equ	3ah
  7485                              <1> kbd_ctrl_code	equ	1dh
  7486                              <1> kbd_alt_code	equ	38h
  7487                              <1> kbd_rshift_code	equ	36h
  7488                              <1> kbd_prtsc_code	equ	37h
  7489                              <1> kbd_lshift_code	equ	2ah
  7490                              <1> kbd_ins_code	equ	52h
  7491                              <1> kbd_del_code	equ	53h
  7492                              <1> 
  7493                              <1> ; Bits for the various modifier keys
  7494                              <1> 
  7495                              <1> kbd_rshft_bit	equ	1
  7496                              <1> kbd_lshft_bit	equ	2
  7497                              <1> kbd_ctrl_bit	equ	4
  7498                              <1> kbd_alt_bit	equ	8
  7499                              <1> kbd_scroll_bit	equ	10h
  7500                              <1> kbd_num_bit	equ	20h
  7501                              <1> kbd_caps_bit	equ	40h
  7502                              <1> kbd_ins_bit	equ	80h
  7503                              <1> 
  7504                              <1> ;=========================================================================
  7505                              <1> ; int_16 - BIOS keyboard functions
  7506                              <1> ; XXX: critical regions - it appears that INT 16h modifies buffer head,
  7507                              <1> ;	while INT 09h modifies buffer tail, so we shouldn't have any race
  7508                              <1> ;	conditions
  7509                              <1> ;-------------------------------------------------------------------------
  7510 00006824 FF<rept>            <1> 	setloc	0E82Eh
  7511          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  7512                              <1> int_16:
  7513 0000682E 53                  <1> 	push	bx
  7514 0000682F 1E                  <1> 	push	ds
  7515 00006830 BB4000              <1> 	mov	bx,biosdseg
  7516 00006833 8EDB                <1> 	mov	ds,bx
  7517 00006835 80FC13              <1> 	cmp	ah,.num_func
  7518 00006838 7331                <1> 	jae	int_16_exit
  7519 0000683A B700                <1> 	mov	bh,0
  7520 0000683C 88E3                <1> 	mov	bl,ah
  7521 0000683E D1E3                <1> 	shl	bx,1
  7522 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
  7523                              <1> 
  7524                              <1> .dispatch:
  7525 00006845 [A61D]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  7526 00006847 [FB1D]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  7527 00006849 [7468]              <1> 	dw	int_16_fn02		; get shift status
  7528 0000684B [7968]              <1> 	dw	int_16_fn03		; set delays
  7529 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
  7530 0000684F [A668]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  7531 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
  7532 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
  7533 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
  7534 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
  7535 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
  7536 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  7537 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  7538 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  7539 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  7540 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  7541 00006865 [531E]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  7542 00006867 [7A1E]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  7543 00006869 [CF68]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  7544                              <1> .num_func	equ	($-.dispatch)/2
  7545                              <1> 
  7546                              <1> int_16_exit:
  7547 0000686B 1F                  <1> 	pop	ds
  7548 0000686C 5B                  <1> 	pop	bx
  7549 0000686D CF                  <1> 	iret
  7550                              <1> 
  7551                              <1> int_16_exitf:
  7552 0000686E 1F                  <1> 	pop	ds
  7553 0000686F 5B                  <1> 	pop	bx
  7554 00006870 FB                  <1> 	sti
  7555 00006871 CA0200              <1> 	retf	2
  7556                              <1> 
  7557                              <1> ;=========================================================================
  7558                              <1> ; int_16_fn02 - get shift flags
  7559                              <1> ; Input:
  7560                              <1> ;	AH = 02h
  7561                              <1> ; Output:
  7562                              <1> ;	AL - shift flags
  7563                              <1> ;            AL bits:
  7564                              <1> ;		7 - Insert active
  7565                              <1> ;		6 - Caps Lock active
  7566                              <1> ;		5 - Num Lock active
  7567                              <1> ;		4 - Scroll Lock active
  7568                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  7569                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  7570                              <1> ;		1 - left shift key pressed
  7571                              <1> ;		0 - right shift key pressed
  7572                              <1> ;-------------------------------------------------------------------------
  7573                              <1> int_16_fn02:
  7574 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7575 00006877 EBF2                <1> 	jmp	int_16_exit
  7576                              <1> 
  7577                              <1> ;=========================================================================
  7578                              <1> ; int_16_fn03 - set keyboard typematic rate
  7579                              <1> ; Input:
  7580                              <1> ;	AH = 03
  7581                              <1> ;	AL - subfunction
  7582                              <1> ;	     00 - set typematic rate to default
  7583                              <1> ;	     01 - increase initial delay
  7584                              <1> ;	     02 - slow typematic rate by 1/2
  7585                              <1> ;	     04 - turn off typematic chars
  7586                              <1> ;	     05 - set typematic rate/delay
  7587                              <1> ;	BH - repeat delay (AL=5)
  7588                              <1> ;		0 - 250ms	2 - 750ms
  7589                              <1> ;		1 - 500ms	3 - 1000ms
  7590                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  7591                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  7592                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  7593                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  7594                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  7595                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  7596                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  7597                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  7598                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  7599                              <1> ; Output:
  7600                              <1> ;	none
  7601                              <1> ;-------------------------------------------------------------------------
  7602                              <1> int_16_fn03:
  7603 00006879 3C05                <1> 	cmp	al,05
  7604 0000687B 7527                <1> 	jne	.exit			; only AL = 5 implemented
  7605 0000687D 53                  <1> 	push	bx
  7606 0000687E 51                  <1> 	push	cx
  7607 0000687F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7608 00006881 E824B0              <1> 	call	kbc_send_cmd_byte
  7609 00006884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
  7610 00006887 B105                <1> 	mov	cl,5
  7611 00006889 D2E7                <1> 	shl	bh,cl
  7612 0000688B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  7613 0000688E B0F3                <1> 	mov	al,0F3h
  7614 00006890 E8B1AF              <1> 	call	kbc_kb_send
  7615 00006893 88F8                <1> 	mov	al,bh
  7616 00006895 E8ACAF              <1> 	call	kbc_kb_send
  7617 00006898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7618 0000689A E80BB0              <1> 	call	kbc_send_cmd_byte
  7619 0000689D B004                <1> 	mov	al,04h
  7620 0000689F E8A2AF              <1> 	call	kbc_kb_send
  7621 000068A2 59                  <1> 	pop	cx
  7622 000068A3 5B                  <1> 	pop	bx
  7623                              <1> .exit:
  7624 000068A4 EBC5                <1> 	jmp	int_16_exit
  7625                              <1> 
  7626                              <1> ;=========================================================================
  7627                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  7628                              <1> ; Input:
  7629                              <1> ;	AH = 05h
  7630                              <1> ;	CH = BIOS scan code
  7631                              <1> ;	CL = ACII character
  7632                              <1> ; Output:
  7633                              <1> ;	AL - status
  7634                              <1> ;	     00h - success
  7635                              <1> ;	     01h - keyboard buffer full
  7636                              <1> ;-------------------------------------------------------------------------
  7637                              <1> int_16_fn05:
  7638 000068A6 56                  <1> 	push	si
  7639 000068A7 B001                <1> 	mov	al,1			; assume no space
  7640 000068A9 FA                  <1> 	cli				; critical section
  7641 000068AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7642 000068AE 89DE                <1> 	mov	si,bx
  7643 000068B0 83C302              <1> 	add	bx,2
  7644 000068B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7645 000068B7 7504                <1> 	jne	.1
  7646 000068B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7647                              <1> .1:
  7648 000068BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7649 000068C1 7408                <1> 	je	.no_space		; no space in buffer
  7650 000068C3 890C                <1> 	mov	word [si],cx
  7651 000068C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7652 000068C9 B000                <1> 	mov	al,0			; stored successfully
  7653                              <1> .no_space:
  7654 000068CB FB                  <1> 	sti
  7655 000068CC 5E                  <1> 	pop	si
  7656 000068CD EB9C                <1> 	jmp	int_16_exit
  7657                              <1> 
  7658                              <1> ;=========================================================================
  7659                              <1> ; int_16_fn12 - get extended shift flags
  7660                              <1> ; Input:
  7661                              <1> ;	AH = 12h
  7662                              <1> ; Output:
  7663                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  7664                              <1> ;	AH - shift flags 2
  7665                              <1> ;            AH bits:
  7666                              <1> ;		7 - SysRq key pressed
  7667                              <1> ;		6 - Caps Lock pressed
  7668                              <1> ;		5 - Num Lock pressed
  7669                              <1> ;		4 - Scroll Lock pressed
  7670                              <1> ;		3 - right Alt key pressed
  7671                              <1> ;		2 - right Ctrl key pressed
  7672                              <1> ;		1 - left Alt key pressed
  7673                              <1> ;		0 - left Ctrl key pressed
  7674                              <1> ;-------------------------------------------------------------------------
  7675                              <1> int_16_fn12:
  7676 000068CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  7677 000068D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  7678 000068D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  7679 000068D9 7403                <1> 	je	.1
  7680 000068DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  7681                              <1> .1:
  7682 000068DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  7683 000068E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
  7684 000068E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  7685 000068E6 08C4                <1> 	or	ah,al			; copy to AH
  7686 000068E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7687 000068EB E97DFF              <1> 	jmp	int_16_exit
  7688                              <1> 
  7689                              <1> ;=========================================================================
  7690                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  7691                              <1> ;-------------------------------------------------------------------------
  7692 000068EE FF<rept>            <1> 	setloc	0E987h			; INT 09 Entry Point
  7693          ******************  <1>  warning: (setloc:7) Inserting 153 bytes
  7694                              <1> int_09:
  7695 00006987 50                  <1> 	push	ax
  7696 00006988 53                  <1> 	push	bx
  7697 00006989 1E                  <1> 	push	ds
  7698                              <1> 
  7699 0000698A B84000              <1> 	mov	ax,biosdseg
  7700 0000698D 8ED8                <1> 	mov	ds,ax
  7701                              <1> 
  7702                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7703                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  7704                              <1> 	call    kbc_send_cmd_byte
  7705                              <1> %endif
  7706 0000698F E460                <1> 	in	al,kbc_input_reg	; get keyboard data
  7707 00006991 FB                  <1> 	sti
  7708 00006992 B44F                <1> 	mov	ah,4Fh
  7709 00006994 F9                  <1> 	stc
  7710 00006995 CD15                <1> 	int	15h			; keyboard intercept
  7711 00006997 7203E9CB01          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  7712                              <1> 
  7713                              <1> ; check for KBC response codes
  7714                              <1> 
  7715 0000699C 3CEE                <1> 	cmp	al,0EEh			; echo response?
  7716 0000699E 7503E9C401          <1> 	je      keyboard_int_exit
  7717 000069A3 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  7718 000069A5 7508                <1> 	jne     .2
  7719 000069A7 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  7720 000069AC E9B801              <1> 	jmp	keyboard_int_exit
  7721                              <1> .2:
  7722 000069AF 3CFE                <1> 	cmp	al,0FEh			; resend command?
  7723 000069B1 7508                <1> 	jne	.3
  7724 000069B3 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  7725 000069B8 E9AC01              <1> 	jmp	keyboard_int_exit
  7726                              <1> 
  7727                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  7728                              <1> 
  7729                              <1> .3:
  7730                              <1> 
  7731                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  7732                              <1> 
  7733 000069BB 3CE0                <1> 	cmp	al,0E0h
  7734 000069BD 750D                <1> 	jne	.4
  7735 000069BF 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  7736 000069C4 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  7737 000069C9 E99B01              <1> 	jmp	keyboard_int_exit
  7738                              <1> .4:
  7739 000069CC 3CE1                <1> 	cmp	al,0E1h
  7740 000069CE 750D                <1> 	jne	.5
  7741 000069D0 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  7742 000069D5 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  7743 000069DA E98A01              <1> 	jmp	keyboard_int_exit
  7744                              <1> 
  7745                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  7746                              <1> 
  7747                              <1> .5:
  7748 000069DD 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  7749 000069E1 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  7750 000069E4 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  7751 000069E7 7529                <1> 	jne	.6
  7752 000069E9 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  7753 000069EB 750B                <1> 	jne	.check_minus
  7754 000069ED C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  7755 000069F3 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  7756                              <1> 
  7757                              <1> .check_minus:
  7758 000069F8 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  7759 000069FA 7509                <1> 	jne	.check_plus
  7760                              <1> 
  7761                              <1> .turbo_off:
  7762 000069FC E461                <1> 	in	al,port_b_reg
  7763 000069FE 24FB                <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
  7764 00006A00 E661                <1> 	out	port_b_reg,al
  7765 00006A02 E96201              <1> 	jmp	keyboard_int_exit
  7766                              <1> 
  7767                              <1> .check_plus:
  7768 00006A05 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  7769 00006A07 7509                <1> 	jne	.6
  7770                              <1> 
  7771                              <1> .turbo_on:
  7772 00006A09 E461                <1> 	in	al,port_b_reg
  7773 00006A0B 0C04                <1> 	or	al,04h			; set bit 2 (turbo enable bit)
  7774 00006A0D E661                <1> 	out	port_b_reg,al
  7775 00006A0F E95501              <1> 	jmp	keyboard_int_exit
  7776                              <1> 
  7777                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  7778                              <1> ; in the keyboard flags variables.
  7779                              <1> 
  7780                              <1> .6:
  7781 00006A12 3C52                <1> 	cmp	al,kbd_ins_code
  7782 00006A14 7508                <1> 	jne	.7
  7783 00006A16 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  7784 00006A1B E90A01              <1> 	jmp	.translate	   	; pass on INS key
  7785                              <1> 
  7786                              <1> .7:
  7787 00006A1E 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  7788 00006A20 750D                <1> 	jne     .8
  7789 00006A22 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  7790 00006A27 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  7791 00006A2C E93301              <1> 	jmp     .no_buffer
  7792                              <1> 
  7793                              <1> ; handle the left and right Shift keys
  7794                              <1> 
  7795                              <1> .8:
  7796 00006A2F 3C2A                <1> 	cmp	al,kbd_lshift_code
  7797 00006A31 7508                <1> 	jne	.9
  7798 00006A33 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  7799 00006A38 E92701              <1> 	jmp	.no_buffer
  7800                              <1> .9:
  7801 00006A3B 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  7802 00006A3D 7508                <1> 	jne     .10
  7803 00006A3F 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  7804 00006A44 E91B01              <1> 	jmp     .no_buffer
  7805                              <1> .10:
  7806 00006A47 3C36                <1> 	cmp	al,kbd_rshift_code
  7807 00006A49 7508                <1> 	jne	.11
  7808 00006A4B 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  7809 00006A50 E90F01              <1> 	jmp	.no_buffer
  7810                              <1> .11:
  7811 00006A53 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  7812 00006A55 7508                <1> 	jne     .12
  7813 00006A57 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  7814 00006A5C E90301              <1> 	jmp	.no_buffer
  7815                              <1> 
  7816                              <1> ; handle the Alt key
  7817                              <1> 
  7818                              <1> .12:
  7819 00006A5F 3C38                <1> 	cmp	al,kbd_alt_code
  7820 00006A61 7508                <1> 	jne	.13
  7821 00006A63 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  7822 00006A68 E9F700              <1> 	jmp	.no_buffer
  7823                              <1> .13:
  7824 00006A6B 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  7825 00006A6D 751C                <1> 	jne	.14
  7826 00006A6F 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  7827 00006A74 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  7828 00006A79 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  7829 00006A7E A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  7830 00006A81 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  7831 00006A86 B400                <1> 	mov	ah,0
  7832 00006A88 E9B600              <1> 	jmp	.put_in_buffer
  7833                              <1> 
  7834                              <1> ; handle the Ctrl key
  7835                              <1> 
  7836                              <1> .14:
  7837 00006A8B 3C1D                <1> 	cmp	al,kbd_ctrl_code
  7838 00006A8D 7508                <1> 	jne	.15
  7839 00006A8F 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  7840 00006A94 E9CB00              <1> 	jmp	.no_buffer
  7841                              <1> .15:
  7842 00006A97 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  7843 00006A99 7508                <1> 	jne	.16
  7844 00006A9B 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  7845 00006AA0 E9BF00              <1> 	jmp	.no_buffer
  7846                              <1> 
  7847                              <1> ; handle the Caps Lock key
  7848                              <1> 
  7849                              <1> .16:
  7850 00006AA3 3C3A                <1> 	cmp	al,kbd_caps_code
  7851 00006AA5 750D                <1> 	jne	.17
  7852 00006AA7 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  7853 00006AAC 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  7854 00006AB1 E9AE00              <1> 	jmp	.no_buffer
  7855                              <1> .17:
  7856 00006AB4 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  7857 00006AB6 7508                <1> 	jne	.18
  7858 00006AB8 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  7859 00006ABD E9D000              <1> 	jmp	set_LEDs
  7860                              <1> 
  7861                              <1> ; check if print screen key was pressed
  7862                              <1> 
  7863                              <1> .18:
  7864 00006AC0 3C37                <1> 	cmp	al,kbd_prtsc_code
  7865 00006AC2 750A                <1> 	jne	.test_scroll_loc
  7866 00006AC4 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7867 00006AC9 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  7868 00006ACB E9B500              <1> 	jmp	print_screen
  7869                              <1> 
  7870                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  7871                              <1> 
  7872                              <1> .test_scroll_loc:
  7873 00006ACE 3C46                <1> 	cmp	al,kbd_scroll_code
  7874 00006AD0 7528                <1> 	jne	.19
  7875 00006AD2 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  7876 00006AD7 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  7877                              <1> 
  7878                              <1> ; handle Ctrl-Break
  7879                              <1> 
  7880 00006AD9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  7881 00006ADD 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  7882 00006AE1 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7883 00006AE5 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  7884 00006AEA CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  7885 00006AEC EB74                <1> 	jmp	.no_buffer
  7886                              <1> 
  7887                              <1> ; handle Scroll Lock
  7888                              <1> 
  7889                              <1> .scroll_lock:
  7890 00006AEE 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  7891 00006AF3 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  7892 00006AF8 EB68                <1> 	jmp	.no_buffer
  7893                              <1> .19:
  7894 00006AFA 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  7895 00006AFC 7508                <1> 	jne	.20
  7896 00006AFE 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  7897 00006B03 E98A00              <1> 	jmp	set_LEDs
  7898                              <1> 
  7899                              <1> ; handle the Num Lock
  7900                              <1> 
  7901                              <1> .20:
  7902 00006B06 3C45                <1> 	cmp	al,kbd_num_code
  7903 00006B08 7513                <1> 	jne	.21
  7904 00006B0A F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  7905 00006B0F 755E                <1> 	jnz	pause			; jump if pause
  7906 00006B11 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  7907 00006B16 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  7908 00006B1B EB45                <1> 	jmp	.no_buffer
  7909                              <1> .21:
  7910 00006B1D 3CC5                <1> 	cmp	al,kbd_num_code+80h
  7911 00006B1F 7507                <1> 	jne	.translate
  7912 00006B21 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  7913 00006B26 EB68                <1> 	jmp	set_LEDs
  7914                              <1> 
  7915                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  7916                              <1> 
  7917                              <1> .translate:
  7918 00006B28 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  7919 00006B2D 7407                <1> 	jz	.check_release
  7920 00006B2F 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  7921 00006B34 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  7922                              <1> .check_release:
  7923 00006B36 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  7924 00006B38 7528                <1> 	jnz	.no_buffer
  7925                              <1> 
  7926 00006B3A E8B0B1              <1> 	call	scan_xlat
  7927 00006B3D 85C0                <1> 	test	ax,ax		 	; check for bad code
  7928 00006B3F 7421                <1> 	je	.no_buffer
  7929                              <1> 
  7930                              <1> .put_in_buffer:
  7931 00006B41 56                  <1> 	push	si			; XXX - use Int 16h/05?
  7932 00006B42 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  7933 00006B46 89DE                <1> 	mov	si,bx
  7934 00006B48 83C302              <1> 	add	bx,2
  7935 00006B4B 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  7936 00006B4F 7504                <1> 	jne	.1
  7937 00006B51 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  7938                              <1> .1:
  7939 00006B55 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  7940 00006B59 7406                <1> 	je	.no_space		; no space in buffer
  7941 00006B5B 8904                <1> 	mov	word [si],ax
  7942 00006B5D 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  7943                              <1> 
  7944                              <1> .no_space:
  7945 00006B61 5E                  <1> 	pop	si
  7946                              <1> 
  7947                              <1> .no_buffer:
  7948 00006B62 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  7949                              <1> 
  7950                              <1> keyboard_int_exit:
  7951                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7952                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7953                              <1> 	call	kbc_send_cmd_byte
  7954                              <1> %endif
  7955 00006B67 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7956 00006B69 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  7957                              <1> 
  7958                              <1> keyboard_int_exit1:
  7959 00006B6B 1F                  <1> 	pop	ds
  7960 00006B6C 5B                  <1> 	pop	bx
  7961 00006B6D 58                  <1> 	pop	ax
  7962 00006B6E CF                  <1> 	iret
  7963                              <1> 
  7964                              <1> pause:
  7965 00006B6F 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  7966 00006B74 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  7967                              <1> 
  7968 00006B76 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7969 00006B78 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7970                              <1> 
  7971                              <1> .pause_loop:
  7972 00006B7A F606180008          <1> 	test	byte [kbd_flags_2],08h
  7973 00006B7F 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  7974 00006B81 EBE8                <1> 	jmp	keyboard_int_exit1
  7975                              <1> 
  7976                              <1> print_screen:
  7977 00006B83 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7978 00006B85 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7979 00006B87 CD05                <1> 	int	5h			; INT 5 - print screen
  7980 00006B89 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  7981 00006B8E EBDB                <1> 	jmp	keyboard_int_exit1
  7982                              <1> 
  7983                              <1> ;=========================================================================
  7984                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  7985                              <1> ; 	     variable and update LEDs on the keyboard
  7986                              <1> ;-------------------------------------------------------------------------
  7987                              <1> set_LEDs:
  7988                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  7989                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  7990                              <1> 	call	kbc_send_cmd_byte
  7991                              <1> %endif
  7992                              <1> 
  7993 00006B90 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  7994 00006B92 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  7995                              <1> 
  7996 00006B94 A01700              <1> 	mov	al,byte [kbd_flags_1]
  7997 00006B97 D0E8                <1> 	shr	al,1
  7998 00006B99 D0E8                <1> 	shr	al,1
  7999 00006B9B D0E8                <1> 	shr	al,1
  8000 00006B9D D0E8                <1> 	shr	al,1
  8001 00006B9F 2407                <1> 	and	al,111b
  8002 00006BA1 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  8003 00006BA6 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  8004 00006BAA 88C4                <1> 	mov	ah,al			; save LED bits
  8005                              <1> 
  8006 00006BAC B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  8007 00006BAE E8F7AC              <1> 	call	kbc_send_cmd_byte
  8008                              <1> 
  8009 00006BB1 B0ED                <1> 	mov	al,0EDh			; set LEDs cmd
  8010 00006BB3 E88EAC              <1> 	call	kbc_kb_send		; send the command to the keyboard
  8011 00006BB6 88E0                <1> 	mov	al,ah			; get parameter byte
  8012 00006BB8 E889AC              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  8013                              <1> 
  8014 00006BBB B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  8015 00006BBD E8E8AC              <1> 	call	kbc_send_cmd_byte
  8016 00006BC0 B0F4                <1> 	mov	al,0F4h			; restart keyboard scanning
  8017 00006BC2 E87FAC              <1> 	call	kbc_kb_send
  8018 00006BC5 EBA4                <1> 	jmp	keyboard_int_exit1
  8019                              <1> 
  8020                                  %include	"floppy2.inc"		; INT 13
  8021                              <1> ;=========================================================================
  8022                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  8023                              <1> ;       INT 13h, function AH=02h
  8024                              <1> ;       INT 13h, function AH=03h
  8025                              <1> ;       INT 13h, function AH=04h
  8026                              <1> ;       INT 13h, function AH=05h
  8027                              <1> ;	- see floppy1.inc for other INT 13h functions
  8028                              <1> ;-------------------------------------------------------------------------
  8029                              <1> ;
  8030                              <1> ; Compiles with NASM 2.07, might work with other versions
  8031                              <1> ;
  8032                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8033                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8034                              <1> ;
  8035                              <1> ; This program is free software: you can redistribute it and/or modify
  8036                              <1> ; it under the terms of the GNU General Public License as published by
  8037                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8038                              <1> ; (at your option) any later version.
  8039                              <1> ;
  8040                              <1> ; This program is distributed in the hope that it will be useful,
  8041                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8042                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8043                              <1> ; GNU General Public License for more details.
  8044                              <1> ;
  8045                              <1> ; You should have received a copy of the GNU General Public License
  8046                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8047                              <1> ;
  8048                              <1> ;=========================================================================
  8049                              <1> 
  8050                              <1> ;-------------------------------------------------------------------------
  8051                              <1> ; offsets for registers on stack
  8052                              <1> int_13_bp	equ	0
  8053                              <1> int_13_ds	equ	int_13_bp+2
  8054                              <1> int_13_di	equ	int_13_ds+2
  8055                              <1> int_13_si	equ	int_13_di+2
  8056                              <1> int_13_dx	equ	int_13_si+2
  8057                              <1> int_13_dl	equ	int_13_dx
  8058                              <1> int_13_dh	equ	int_13_dx+1
  8059                              <1> int_13_cx	equ	int_13_dx+2
  8060                              <1> int_13_cl	equ	int_13_cx
  8061                              <1> int_13_ch	equ	int_13_cx+1
  8062                              <1> int_13_bx	equ	int_13_cx+2
  8063                              <1> int_13_bl	equ	int_13_bx
  8064                              <1> int_13_bh	equ	int_13_bx+1
  8065                              <1> int_13_ax	equ	int_13_bx+2
  8066                              <1> int_13_al	equ	int_13_ax
  8067                              <1> int_13_ah	equ	int_13_ax+1
  8068                              <1> int_13_ip	equ	int_13_ax+2
  8069                              <1> int_13_cs	equ	int_13_ip+2
  8070                              <1> int_13_flags	equ	int_13_cs+2
  8071                              <1> int_13_flags_l	equ	int_13_flags
  8072                              <1> 
  8073                              <1> ;=========================================================================
  8074                              <1> ; int_13 - BIOS floppy disk services
  8075                              <1> ; Input:
  8076                              <1> ;	AH = function
  8077                              <1> ;		00h - Reset disk system
  8078                              <1> ;		01h - Get status of last operation
  8079                              <1> ;		02h - Read disk sectors
  8080                              <1> ;		03h - Write disk sectors
  8081                              <1> ;		04h - Verify disk sectors
  8082                              <1> ;		05h - Format track
  8083                              <1> ;		08h - Get drive parameters
  8084                              <1> ;		15h - Get disk type
  8085                              <1> ;		16h - Detect disk change
  8086                              <1> ;		17h - Set disk type for format
  8087                              <1> ;		18h - Set media type for format
  8088                              <1> ; Output:
  8089                              <1> ;	- depends on function
  8090                              <1> ;	- for most functions:
  8091                              <1> ;		CF clear if successful
  8092                              <1> ;			AH = 00h - successful completion
  8093                              <1> ;		CF set on error
  8094                              <1> ;			AH = error code
  8095                              <1> ;-------------------------------------------------------------------------
  8096 00006BC7 FF<rept>            <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  8097          ******************  <1>  warning: (setloc:7) Inserting 146 bytes
  8098                              <1> int_13:
  8099 00006C59 FB                  <1> 	sti
  8100 00006C5A 50                  <1> 	push	ax
  8101 00006C5B 53                  <1> 	push	bx
  8102 00006C5C 51                  <1> 	push	cx
  8103 00006C5D 52                  <1> 	push	dx
  8104 00006C5E 56                  <1> 	push	si
  8105 00006C5F 57                  <1> 	push	di
  8106 00006C60 1E                  <1> 	push	ds
  8107 00006C61 55                  <1> 	push	bp
  8108 00006C62 89E5                <1> 	mov	bp,sp
  8109 00006C64 80FC19              <1> 	cmp	ah,.num_func
  8110 00006C67 7743                <1> 	ja	.invalid_function
  8111 00006C69 88E0                <1> 	mov	al,ah
  8112 00006C6B 98                  <1> 	cbw
  8113 00006C6C 89C7                <1> 	mov	di,ax
  8114 00006C6E D1E7                <1> 	shl	di,1
  8115 00006C70 B84000              <1> 	mov	ax,biosdseg
  8116 00006C73 8ED8                <1> 	mov	ds,ax
  8117 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  8118                              <1> 
  8119                              <1> .dispatch:
  8120 00006C7A [3410]              <1> 	dw	int_13_fn00		; Reset disk system
  8121 00006C7C [A310]              <1> 	dw	int_13_fn01		; Get status of last operation
  8122 00006C7E [EF6C]              <1> 	dw	int_13_fn02		; Read disk sectors
  8123 00006C80 [EF6C]              <1> 	dw	int_13_fn03		; Write disk sectors
  8124 00006C82 [EF6C]              <1> 	dw	int_13_fn04		; Verify disk sectors
  8125 00006C84 [5D6E]              <1> 	dw	int_13_fn05		; Format track
  8126 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  8127 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  8128 00006C8A [AF10]              <1> 	dw	int_13_fn08		; Get drive parameters
  8129 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  8130 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  8131 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  8132 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  8133 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  8134 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  8135 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  8136 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  8137 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  8138 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  8139 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  8140 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  8141 00006CA4 [5C11]              <1> 	dw	int_13_fn15		; Get disk type
  8142 00006CA6 [7D11]              <1> 	dw	int_13_fn16		; Detect disk change
  8143 00006CA8 [C911]              <1> 	dw	int_13_fn17		; Set disk type for format
  8144 00006CAA [3412]              <1> 	dw	int_13_fn18		; Set media type for format
  8145                              <1> .num_func	equ ($-.dispatch)/2
  8146                              <1> 
  8147                              <1> .invalid_function:
  8148 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  8149 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  8150 00006CB2 F9                  <1> 	stc				; error condition
  8151 00006CB3 EB21                <1> 	jmp	int_13_exit
  8152                              <1> 
  8153                              <1> ;-------------------------------------------------------------------------
  8154                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  8155                              <1> 
  8156                              <1> int_13_upd_exit:
  8157 00006CB5 9C                  <1> 	pushf
  8158 00006CB6 50                  <1> 	push	ax
  8159 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  8160 00006CBA 3C01                <1> 	cmp	al,1
  8161 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  8162 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  8163 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  8164 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  8165 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  8166 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  8167 00006CCA 08C0                <1> 	or	al,al
  8168 00006CCC 7402                <1> 	jz	.drive_0
  8169 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  8170                              <1> 
  8171                              <1> .drive_0:
  8172 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  8173                              <1> 
  8174                              <1> .no_update:
  8175 00006CD4 58                  <1> 	pop	ax
  8176 00006CD5 9D                  <1> 	popf
  8177                              <1> 
  8178                              <1> int_13_exit:
  8179 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  8180 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  8181 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  8182 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  8183 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  8184                              <1> 
  8185                              <1> .set_error:
  8186 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  8187 00006CE6 5D                  <1> 	pop	bp
  8188 00006CE7 1F                  <1> 	pop	ds
  8189 00006CE8 5F                  <1> 	pop	di
  8190 00006CE9 5E                  <1> 	pop	si
  8191 00006CEA 5A                  <1> 	pop	dx
  8192 00006CEB 59                  <1> 	pop	cx
  8193 00006CEC 5B                  <1> 	pop	bx
  8194 00006CED 58                  <1> 	pop	ax
  8195 00006CEE CF                  <1> 	iret
  8196                              <1> 
  8197                              <1> ;=========================================================================
  8198                              <1> ; int_13_fn02 - Read disk sectors
  8199                              <1> ; int_13_fn03 - Write disk sectors
  8200                              <1> ; int_13_fn04 - Verify disk sectors
  8201                              <1> ; Input:
  8202                              <1> ;	AH = function
  8203                              <1> ;		02h - read
  8204                              <1> ;		03h - write
  8205                              <1> ;		04h - verify
  8206                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  8207                              <1> ;	CH = cylinder number
  8208                              <1> ;	CL = sector number
  8209                              <1> ;	DH = head number (0 or 1)
  8210                              <1> ;	DL = drive number (0 or 1)
  8211                              <1> ;	ES:BX -> data buffer
  8212                              <1> ; Output:
  8213                              <1> ;	CF clear if successful
  8214                              <1> ;		AH = 00h - successful completion
  8215                              <1> ;		AL = number of sectors transferred or verified
  8216                              <1> ;	CF set on error
  8217                              <1> ;		AH = error code
  8218                              <1> ;-------------------------------------------------------------------------
  8219                              <1> int_13_fn02:
  8220                              <1> int_13_fn03:
  8221                              <1> int_13_fn04:
  8222 00006CEF 80FA01              <1> 	cmp	dl,1
  8223 00006CF2 7603E94801          <1> 	ja	.invalid_drive
  8224 00006CF7 BE9000              <1> 	mov	si,fdc_media_state
  8225 00006CFA 52                  <1> 	push	dx
  8226 00006CFB B600                <1> 	mov	dh,00h
  8227 00006CFD 01D6                <1> 	add	si,dx			; SI -> drive media state
  8228 00006CFF 5A                  <1> 	pop	dx
  8229                              <1> 
  8230 00006D00 E881A9              <1> 	call	read_cmos_type		; get drive type in AL
  8231 00006D03 7303E93701          <1> 	jc	.invalid_drive
  8232                              <1> 
  8233 00006D08 BF3F00              <1> 	mov	di,fdc_motor_state
  8234 00006D0B 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  8235 00006D0E 80FC03              <1> 	cmp	ah,03h			; write function
  8236 00006D11 7503                <1> 	jne	.motor_on		; jump if not write function
  8237 00006D13 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  8238                              <1> 
  8239                              <1> .motor_on:
  8240 00006D16 E8DCA6              <1> 	call	fdc_motor_on
  8241 00006D19 3C01                <1> 	cmp	al,cmos_360
  8242 00006D1B 7503E92401          <1> 	je	.set_media_360		; set media type for 360K drive
  8243 00006D20 3C03                <1> 	cmp	al,cmos_720
  8244 00006D22 7503E92101          <1> 	je	.set_media_720		; set media type for 720K drive
  8245                              <1> 
  8246 00006D27 E885A7              <1> 	call	fdc_disk_change
  8247 00006D2A 7303E90C01          <1> 	jc	.error_end_io		; jump if disk change check failed
  8248                              <1> 
  8249 00006D2F F60410              <1> 	test	byte [si],fdc_m_established
  8250 00006D32 7503E91E01          <1> 	jz	.establish_media	; jump if media type is not established
  8251                              <1> 
  8252 00006D37 E83AAA              <1> 	call	fdc_select_rate		; select transfer rate
  8253                              <1> 	
  8254                              <1> .fdc_send_specify:
  8255 00006D3A B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  8256                              <1> 					; 0BFh - specify byte 0 for 1.44M
  8257 00006D3D 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  8258 00006D40 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  8259 00006D42 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  8260 00006D44 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  8261 00006D47 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  8262 00006D49 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  8263                              <1> 
  8264                              <1> .fdc_send_specify_cmd:
  8265 00006D4B BE0200              <1> 	mov	si,2			; specify byte 1
  8266 00006D4E B103                <1> 	mov	cl,3			; 3 bytes command
  8267 00006D50 E802A8              <1> 	call	fdc_send_cmd
  8268 00006D53 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  8269 00006D58 1E                  <1> 	push	ds
  8270 00006D59 31F6                <1> 	xor	si,si
  8271 00006D5B 8EDE                <1> 	mov	ds,si
  8272 00006D5D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8273 00006D61 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  8274 00006D64 B400                <1> 	mov	ah,00h
  8275 00006D66 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  8276 00006D68 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  8277 00006D6B FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  8278 00006D6D 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  8279 00006D70 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  8280 00006D72 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  8281                              <1> 
  8282                              <1> .calc_dma_count:
  8283 00006D75 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  8284 00006D78 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  8285 00006D7B D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  8286 00006D7D 1F                  <1> 	pop	ds
  8287 00006D7E 48                  <1> 	dec	ax			; minus one byte
  8288 00006D7F 89C1                <1> 	mov	cx,ax			; ...count for DMA
  8289                              <1> 
  8290 00006D81 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  8291 00006D84 B046                <1> 	mov	al,46h			; DMA mode byte for read
  8292 00006D86 80FC02              <1> 	cmp	ah,02h			; read function?
  8293 00006D89 7409                <1> 	je	.configure_dma		; jump if read function
  8294 00006D8B B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8295 00006D8D 80FC03              <1> 	cmp	ah,03h			; write function?
  8296 00006D90 7402                <1> 	je	.configure_dma		; jump if write function
  8297 00006D92 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  8298                              <1> 
  8299                              <1> .configure_dma:
  8300 00006D94 E860A7              <1> 	call	fdc_configure_dma
  8301 00006D97 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  8302 00006D9A 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  8303                              <1> 
  8304 00006D9F E89CA5              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8305 00006DA2 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8306                              <1> 
  8307 00006DA7 1E                  <1> 	push	ds
  8308 00006DA8 31C0                <1> 	xor	ax,ax
  8309 00006DAA 8ED8                <1> 	mov	ds,ax
  8310 00006DAC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8311 00006DB0 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  8312 00006DB3 88C8                <1> 	mov	al,cl			; AL = first sector number
  8313 00006DB5 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  8314 00006DB7 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  8315 00006DBA 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  8316 00006DBD 1F                  <1> 	pop	ds
  8317                              <1> 
  8318 00006DBE BE9000              <1> 	mov	si,fdc_media_state
  8319 00006DC1 B600                <1> 	mov	dh,00h
  8320 00006DC3 01D6                <1> 	add	si,dx
  8321 00006DC5 8A14                <1> 	mov	dl,byte [si]		; drive media state
  8322 00006DC7 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  8323 00006DC9 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  8324 00006DCC 7413                <1> 	je	.gap_set		; jump if 1.44M media
  8325 00006DCE 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  8326 00006DD1 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  8327 00006DD3 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  8328 00006DD6 7409                <1> 	je	.gap_set		; jump if 2.88M media
  8329 00006DD8 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  8330 00006DDA 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  8331 00006DDD 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  8332 00006DDF B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  8333                              <1> 	
  8334                              <1> .gap_set:
  8335 00006DE1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  8336 00006DE4 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  8337 00006DE7 88F4                <1> 	mov	ah,dh			; head
  8338 00006DE9 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  8339 00006DEB D0E4                <1> 	shl	ah,1
  8340 00006DED D0E4                <1> 	shl	ah,1
  8341 00006DEF 08D4                <1> 	or	ah,dl			; FDC command byte 1
  8342 00006DF1 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  8343 00006DF3 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  8344 00006DF7 7502                <1> 	jne	.send_command		; jump if not write 
  8345 00006DF9 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  8346                              <1> 
  8347                              <1> .send_command:
  8348 00006DFB B109                <1> 	mov	cl,9			; 9 bytes command
  8349 00006DFD 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8350 00006E02 E850A7              <1> 	call	fdc_send_cmd
  8351 00006E05 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  8352 00006E07 E89CA9              <1> 	call	fdc_wait_irq
  8353 00006E0A 7228                <1> 	jc	.error_fdc_get_result
  8354 00006E0C B107                <1> 	mov	cl,7
  8355 00006E0E E8A9A7              <1> 	call	fdc_get_result		; read result bytes
  8356 00006E11 7228                <1> 	jc	.error_end_io
  8357                              <1> 
  8358 00006E13 E8F9A7              <1> 	call	fdc_get_error
  8359                              <1> 
  8360                              <1> .exit_end_io:
  8361 00006E16 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  8362                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  8363 00006E19 E868A6              <1> 	call	fdc_end_io		; return number of last sector in BL
  8364 00006E1C 08C0                <1> 	or	al,al
  8365 00006E1E 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  8366 00006E20 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  8367 00006E22 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  8368                              <1> 
  8369                              <1> .zero_sectors:
  8370 00006E25 08E4                <1> 	or	ah,ah
  8371 00006E27 7401                <1> 	jz	.exit			; jump if no errors
  8372                              <1> 
  8373                              <1> .error:
  8374 00006E29 F9                  <1> 	stc				; indicate error
  8375                              <1> 
  8376                              <1> .exit:
  8377 00006E2A 88264100            <1> 	mov	byte [fdc_last_error],ah
  8378 00006E2E 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  8379 00006E31 E981FE              <1> 	jmp	int_13_upd_exit
  8380                              <1> 
  8381                              <1> .error_fdc_get_result:
  8382 00006E34 B107                <1> 	mov	cl,7
  8383 00006E36 50                  <1> 	push	ax
  8384 00006E37 E880A7              <1> 	call	fdc_get_result		; read result bytes
  8385 00006E3A 58                  <1> 	pop	ax
  8386                              <1> 
  8387                              <1> .error_end_io:
  8388 00006E3B B000                <1> 	mov	al,00h			; failure, no sectors transferred
  8389 00006E3D EBD7                <1> 	jmp	.exit_end_io
  8390                              <1> 
  8391                              <1> .invalid_drive:
  8392 00006E3F B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  8393 00006E42 EBE5                <1> 	jmp	.error
  8394                              <1> 
  8395                              <1> ; 360K and 720K drives don't support change line, and only support
  8396                              <1> ; one media type - set it here
  8397                              <1> 
  8398                              <1> .set_media_360:
  8399 00006E44 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  8400 00006E46 EB02                <1> 	jmp	.set_media
  8401                              <1> 
  8402                              <1> .set_media_720:
  8403 00006E48 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  8404                              <1> 
  8405                              <1> .set_media:
  8406 00006E4A 8804                <1> 	mov	byte [si],al		; save media state
  8407 00006E4C E84CA9              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  8408 00006E4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  8409 00006E52 E9E5FE              <1> 	jmp	.fdc_send_specify
  8410                              <1> 
  8411                              <1> ; establish media type
  8412                              <1> 
  8413                              <1> .establish_media:
  8414 00006E55 E84FA8              <1> 	call	fdc_detect_media
  8415 00006E58 72E1                <1> 	jc	.error_end_io
  8416 00006E5A E9DDFE              <1> 	jmp	.fdc_send_specify
  8417                              <1> 	
  8418                              <1> 
  8419                              <1> ;=========================================================================
  8420                              <1> ; int_13_fn05 - Format track
  8421                              <1> ; Input:
  8422                              <1> ;	AH = 05h
  8423                              <1> ;	CH = track number
  8424                              <1> ;	DH = head number (0 or 1)
  8425                              <1> ;	DL = drive number (0 or 1)
  8426                              <1> ;	ES:BX -> address field buffer
  8427                              <1> ; Output:
  8428                              <1> ;	CF clear if successful
  8429                              <1> ;		AH = 00h - successful completion
  8430                              <1> ;	CF set on error
  8431                              <1> ;		AH = error code 
  8432                              <1> ;-------------------------------------------------------------------------
  8433                              <1> int_13_fn05:
  8434 00006E5D 80FA01              <1> 	cmp	dl,1
  8435 00006E60 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  8436 00006E65 E81CA8              <1> 	call	read_cmos_type		; get drive type in AL
  8437 00006E68 7303E99500          <1> 	jc	.invalid_drive
  8438 00006E6D BE9000              <1> 	mov	si,fdc_media_state
  8439 00006E70 52                  <1> 	push	dx
  8440 00006E71 B600                <1> 	mov	dh,00h
  8441 00006E73 01D6                <1> 	add	si,dx			; SI -> drive media state
  8442 00006E75 5A                  <1> 	pop	dx
  8443 00006E76 803C00              <1> 	cmp	byte [si],0
  8444 00006E79 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  8445 00006E7E 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  8446 00006E83 E86FA5              <1> 	call	fdc_motor_on
  8447 00006E86 E826A6              <1> 	call	fdc_disk_change		; read disk change line
  8448 00006E89 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  8449 00006E8B E8E6A8              <1> 	call	fdc_select_rate		; select transfer rate
  8450 00006E8E E8F3A1              <1> 	call	fdc_send_specify	; send FDC Specify command
  8451 00006E91 1E                  <1> 	push	ds
  8452 00006E92 31F6                <1> 	xor	si,si
  8453 00006E94 8EDE                <1> 	mov	ds,si
  8454 00006E96 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  8455 00006E9A 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  8456 00006E9D 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  8457 00006EA0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  8458 00006EA3 1F                  <1> 	pop	ds
  8459 00006EA4 B500                <1> 	mov	ch,00h			; CX = sectors per track
  8460 00006EA6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  8461 00006EA8 D1E1                <1> 	shl	cx,1
  8462 00006EAA 49                  <1> 	dec	cx	 		; minus one byte...
  8463 00006EAB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  8464 00006EAD E847A6              <1> 	call	fdc_configure_dma
  8465 00006EB0 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  8466 00006EB2 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  8467 00006EB5 56                  <1> 	push	si
  8468 00006EB6 E885A4              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  8469 00006EB9 5E                  <1> 	pop	si
  8470 00006EBA 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  8471                              <1> 
  8472 00006EBC 88F4                <1> 	mov	ah,dh
  8473 00006EBE D0E4                <1> 	shl	ah,1
  8474 00006EC0 D0E4                <1> 	shl	ah,1
  8475 00006EC2 08D4                <1> 	or	ah,dl
  8476 00006EC4 B04D                <1> 	mov	al,4Dh			; FDC Format command
  8477                              <1> 
  8478 00006EC6 B106                <1> 	mov	cl,6			; 6 byte command
  8479 00006EC8 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  8480 00006ECD E885A6              <1> 	call	fdc_send_cmd
  8481 00006ED0 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  8482 00006ED2 E8D1A8              <1> 	call	fdc_wait_irq
  8483 00006ED5 720A                <1> 	jc	.exit_end_io
  8484 00006ED7 B107                <1> 	mov	cl,7
  8485 00006ED9 E8DEA6              <1> 	call	fdc_get_result		; read result bytes
  8486 00006EDC 7203                <1> 	jc	.exit_end_io
  8487 00006EDE E82EA7              <1> 	call	fdc_get_error		; get error code
  8488                              <1> 
  8489                              <1> .exit_end_io:
  8490 00006EE1 E8A0A5              <1> 	call	fdc_end_io
  8491 00006EE4 08E4                <1> 	or	ah,ah
  8492 00006EE6 7401                <1> 	jz	.exit			; jump if no errors
  8493                              <1> 
  8494                              <1> .error:
  8495 00006EE8 F9                  <1> 	stc				; indicate error
  8496                              <1> 
  8497                              <1> .exit:
  8498 00006EE9 88264100            <1> 	mov	byte [fdc_last_error],ah
  8499 00006EED E9C5FD              <1> 	jmp	int_13_upd_exit
  8500                              <1> 
  8501                              <1> .error_fdc_get_result:
  8502 00006EF0 B107                <1> 	mov	cl,7
  8503 00006EF2 50                  <1> 	push	ax
  8504 00006EF3 E8C4A6              <1> 	call	fdc_get_result		; read result bytes
  8505 00006EF6 58                  <1> 	pop	ax
  8506 00006EF7 EBE8                <1> 	jmp	.exit_end_io
  8507                              <1> 
  8508                              <1> .error_end_io:
  8509 00006EF9 E888A5              <1> 	call	fdc_end_io
  8510 00006EFC EBEA                <1> 	jmp	.error
  8511                              <1> 
  8512                              <1> .timeout:
  8513 00006EFE B480                <1> 	mov	ah,fdc_e_timeout
  8514 00006F00 EBE6                <1> 	jmp	.error
  8515                              <1> 
  8516                              <1> .invalid_drive:
  8517 00006F02 B401                <1> 	mov	ah,fdc_e_invalid
  8518 00006F04 EBE2                <1> 	jmp	.error
  8519                              <1> 
  8520                              <1> ;=========================================================================
  8521                              <1> ; int_0E - IRQ6 (FDC) service routine
  8522                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  8523                              <1> ;-------------------------------------------------------------------------
  8524 00006F06 FF<rept>            <1> 	setloc	0EF57h
  8525          ******************  <1>  warning: (setloc:7) Inserting 81 bytes
  8526                              <1> 
  8527                              <1> int_0E:
  8528 00006F57 50                  <1> 	push	ax
  8529 00006F58 1E                  <1> 	push	ds
  8530 00006F59 B84000              <1> 	mov	ax,biosdseg
  8531 00006F5C 8ED8                <1> 	mov	ds,ax
  8532 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  8533 00006F63 1F                  <1> 	pop	ds
  8534 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  8535 00006F66 E620                <1> 	out	pic1_reg0,al
  8536 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  8537 00006F6B CD15                <1> 	int	15h
  8538 00006F6D 58                  <1> 	pop	ax
  8539 00006F6E CF                  <1> 	iret
  8540                              <1> 
  8541                              <1> ;=========================================================================
  8542                              <1> ; Disk parameter tables in INT 1Eh format
  8543                              <1> ; Byte 0: First byte for specify command:
  8544                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  8545                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  8546                              <1> ; Byte 1: Second byte for specify command:
  8547                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  8548                              <1> ;	bit 0: non-DMA mode (always 0)
  8549                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  8550                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  8551                              <1> ; Byte 4: sectors per track
  8552                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  8553                              <1> ; Byte 6: special sector size (0FFh - not used)
  8554                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  8555                              <1> ; Byte 8: format filler byte (default 0F6h)
  8556                              <1> ; Byte 9: head settle time in milliseconds
  8557                              <1> ; Byte A: motor start time, in 1/8 seconds
  8558                              <1> ; Byte B: number of cylinders minus one
  8559                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  8560                              <1> ;-------------------------------------------------------------------------
  8561                              <1> media_360_in_360:
  8562 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8563 00006F78 0F08                <1>
  8564 00006F7A 2780                <1> 	db	27h, 80h
  8565                              <1> media_1200:
  8566 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  8567 00006F85 0F08                <1>
  8568 00006F87 4F00                <1> 	db	4Fh, 00h
  8569                              <1> media_720:
  8570 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  8571 00006F92 0F08                <1>
  8572 00006F94 4F80                <1> 	db	4Fh, 80h
  8573                              <1> media_1440:
  8574 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  8575 00006F9F 0F08                <1>
  8576 00006FA1 4F00                <1> 	db	4Fh, 00h
  8577                              <1> media_360_in_1200:
  8578 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  8579 00006FAC 0F08                <1>
  8580 00006FAE 2740                <1> 	db	27h, 40h
  8581                              <1> media_2880:
  8582 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8583 00006FB9 0F08                <1>
  8584 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  8585                              <1> 
  8586                              <1> ;=========================================================================
  8587                              <1> ; Disk parameter table for IBM compatibility
  8588                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  8589                              <1> ;-------------------------------------------------------------------------
  8590 00006FBD FF<rept>            <1> 	setloc	0EFC7h
  8591          ******************  <1>  warning: (setloc:7) Inserting 10 bytes
  8592                              <1> int_1E:
  8593 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  8594 00006FD0 0F08                <1>
  8595                                  %include	"printer2.inc"		; INT 17
  8596                              <1> ;=========================================================================
  8597                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  8598                              <1> ;       INT 17h, function AH=00h
  8599                              <1> ;	INT 17h, function AH=02h
  8600                              <1> ;	- see printer1.inc for other INT 17h functions
  8601                              <1> ;-------------------------------------------------------------------------
  8602                              <1> ;
  8603                              <1> ; Compiles with NASM 2.07, might work with other versions
  8604                              <1> ;
  8605                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
  8606                              <1> ; Provided for hobbyist use on the Xi 8088 board.
  8607                              <1> ;
  8608                              <1> ; This program is free software: you can redistribute it and/or modify
  8609                              <1> ; it under the terms of the GNU General Public License as published by
  8610                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8611                              <1> ; (at your option) any later version.
  8612                              <1> ;
  8613                              <1> ; This program is distributed in the hope that it will be useful,
  8614                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8615                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8616                              <1> ; GNU General Public License for more details.
  8617                              <1> ;
  8618                              <1> ; You should have received a copy of the GNU General Public License
  8619                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8620                              <1> ;
  8621                              <1> ;=========================================================================
  8622                              <1> 
  8623                              <1> ;=========================================================================
  8624                              <1> ; int_17  - BIOS Printer Services
  8625                              <1> ;-------------------------------------------------------------------------
  8626                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  8627                              <1> int_17:
  8628 00006FD2 FB                  <1> 	sti
  8629 00006FD3 53                  <1> 	push	bx
  8630 00006FD4 52                  <1> 	push	dx
  8631 00006FD5 56                  <1> 	push	si
  8632 00006FD6 1E                  <1> 	push	ds
  8633 00006FD7 BB4000              <1> 	mov	bx,biosdseg
  8634 00006FDA 8EDB                <1> 	mov	ds,bx
  8635 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
  8636 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  8637 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  8638 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  8639 00006FE6 89D3                <1> 	mov	bx,dx
  8640 00006FE8 D1E3                <1> 	shl	bx,1
  8641 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  8642 00006FED 09D2                <1> 	or	dx,dx
  8643 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  8644                              <1> 
  8645 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  8646                              <1> 
  8647 00006FF3 08E4                <1> 	or	ah,ah
  8648 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  8649 00006FF7 FECC                <1> 	dec	ah
  8650 00006FF9 7503E9AEAF          <1> 	jz	int_17_fn01		; AH = 01h
  8651 00006FFE FECC                <1> 	dec	ah
  8652 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  8653                              <1> 
  8654                              <1> int_17_exit:
  8655 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  8656 00007005 88D8                <1> 	mov	al,bl			; restore AL
  8657                              <1> 
  8658                              <1> int_17_error:
  8659 00007007 1F                  <1> 	pop	ds
  8660 00007008 5E                  <1> 	pop	si
  8661 00007009 5A                  <1> 	pop	dx
  8662 0000700A 5B                  <1> 	pop	bx
  8663 0000700B CF                  <1> 	iret
  8664                              <1> 
  8665                              <1> ;=========================================================================
  8666                              <1> ; int_17_fn00 - Print character
  8667                              <1> ; Input:
  8668                              <1> ;	AH = 0 - function 00h - print character
  8669                              <1> ;	AL = character to print
  8670                              <1> ;	DX = printer port number (0-2)
  8671                              <1> ; Output:
  8672                              <1> ;	AH = printer status:
  8673                              <1> ;		bit 0	= 1	- timeout error
  8674                              <1> ;		bit 1,2		- reserved
  8675                              <1> ;		bit 3	= 1	- I/O error
  8676                              <1> ;		bit 4	= 1	- printed selected
  8677                              <1> ;		bit 5	= 1	- out of paper
  8678                              <1> ;		bit 6	= 1	- acknowledge from printer
  8679                              <1> ;		bit 7	= 1	- printer not busy
  8680                              <1> ;-------------------------------------------------------------------------
  8681                              <1> int_17_fn00:
  8682 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  8683 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8684                              <1> 					; OPTIMIZATION:
  8685                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8686 0000700E EC                  <1> 	in	al,dx			; read status
  8687 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  8688 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  8689 00007014 750C                <1>         jnz     .not_busy
  8690                              <1> 
  8691 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  8692 00007019 CD15                <1> 	int	15h			; call OS hook
  8693                              <1> 
  8694 0000701B B780                <1> 	mov	bh,prn_stat_busy
  8695 0000701D E8B1AE              <1> 	call	wait_for_port		; wait for printer to be ready
  8696 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  8697                              <1> 
  8698                              <1> .not_busy:
  8699 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  8700                              <1> 					; OPTIMIZATION:
  8701                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  8702 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  8703 00007025 EE                  <1> 	out	dx,al			; activate strobe
  8704 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  8705 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  8706 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  8707 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  8708 0000702E EBD2                <1> 	jmp	int_17_exit
  8709                              <1> 
  8710                              <1> .timeout:
  8711 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  8712 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  8713 00007036 EBCA                <1> 	jmp	int_17_exit
  8714                              <1> 
  8715                              <1> ;=========================================================================
  8716                              <1> ; int_17_fn02 - Return printer status
  8717                              <1> ; Input:
  8718                              <1> ;	AH = 2 - function 02h - return printer status
  8719                              <1> ;	DX = printer port number (0-2)
  8720                              <1> ; Output:
  8721                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  8722                              <1> ;-------------------------------------------------------------------------
  8723                              <1> int_17_fn02:
  8724 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  8725                              <1> 					; OPTIMIZATION:
  8726                              <1> 					; prn_stat_reg = prn_data_reg + 1
  8727                              <1> int_17_status:
  8728 00007039 EC                  <1> 	in	al,dx			; read the status
  8729 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  8730 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  8731 0000703F EBC1                <1> 	jmp	int_17_exit
  8732                                  %include	"video.inc"		; INT 10
  8733                              <1> ;=========================================================================
  8734                              <1> ; video.inc - BIOS video services
  8735                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  8736                              <1> ;-------------------------------------------------------------------------
  8737                              <1> ;
  8738                              <1> ; Compiles with NASM 2.07, might work with other versions
  8739                              <1> ;
  8740                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  8741                              <1> ;
  8742                              <1> ; This program is free software: you can redistribute it and/or modify
  8743                              <1> ; it under the terms of the GNU General Public License as published by
  8744                              <1> ; the Free Software Foundation, either version 3 of the License, or
  8745                              <1> ; (at your option) any later version.
  8746                              <1> ;
  8747                              <1> ; This program is distributed in the hope that it will be useful,
  8748                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8749                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8750                              <1> ; GNU General Public License for more details.
  8751                              <1> ;
  8752                              <1> ; You should have received a copy of the GNU General Public License
  8753                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  8754                              <1> ;
  8755                              <1> ;=========================================================================
  8756                              <1> 
  8757                              <1> ;-------------------------------------------------------------------------
  8758                              <1> ; CRTC registers
  8759                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  8760                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  8761                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  8762                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  8763                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  8764                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  8765                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  8766                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  8767                              <1> 
  8768                              <1> ;-------------------------------------------------------------------------
  8769                              <1> ; control characters
  8770                              <1> bel	equ	07h
  8771                              <1> bs	equ	08h
  8772                              <1> lf	equ	0Ah
  8773                              <1> cr	equ	0Dh
  8774                              <1> 
  8775 00007041 FF<rept>            <1> 	setloc	0F045h			; int 10 functions table
  8776          ******************  <1>  warning: (setloc:7) Inserting 4 bytes
  8777                              <1> 
  8778                              <1> int_10_dispatch:
  8779 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
  8780 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  8781 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
  8782 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  8783 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
  8784 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
  8785 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
  8786 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
  8787 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
  8788 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
  8789 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
  8790 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
  8791 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  8792 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  8793 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
  8794 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
  8795                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  8796                              <1> 
  8797                              <1> 
  8798                              <1> ;-------------------------------------------------------------------------
  8799                              <1> ; offsets for registers on stack
  8800                              <1> 
  8801                              <1> int_10_ax	equ	0
  8802                              <1> int_10_al	equ	int_10_ax
  8803                              <1> int_10_ah	equ	int_10_ax+1
  8804                              <1> int_10_bx	equ	int_10_ax+2
  8805                              <1> int_10_bl	equ	int_10_bx
  8806                              <1> int_10_bh	equ	int_10_bx+1
  8807                              <1> int_10_cx	equ	int_10_bx+2
  8808                              <1> int_10_ch	equ	int_10_cx+1
  8809                              <1> int_10_dx	equ	int_10_cx+2
  8810                              <1> 
  8811                              <1> ;=========================================================================
  8812                              <1> ; int_10 - BIOS video services
  8813                              <1> ; Input:
  8814                              <1> ;	AH - Function
  8815                              <1> ;		00h - Set video mode
  8816                              <1> ;		01h - Set text mode cursor shape
  8817                              <1> ;		02h - Set cursor position
  8818                              <1> ;		03h - Get cursor position and shape
  8819                              <1> ;		04h - Read light pen position
  8820                              <1> ;		05h - Select active display page
  8821                              <1> ;		06h - Scroll up window
  8822                              <1> ;		07h - Scroll down window
  8823                              <1> ;		08h - Read character and attribute at cursor position
  8824                              <1> ;		09h - Write character and attribute at cursor position
  8825                              <1> ;		0Ah - Write character only at cursor position
  8826                              <1> ;		0Bh -
  8827                              <1> ;			BH = 00h - Set background/border color
  8828                              <1> ;			BH = 01h - Set palette
  8829                              <1> ;		0Ch - Write graphics pixel
  8830                              <1> ;		0Dh - Read graphics pixel
  8831                              <1> ;		0Eh - Teletype output
  8832                              <1> ;		0Fh - Get current video mode
  8833                              <1> ;-------------------------------------------------------------------------
  8834                              <1> 	setloc	0F065h			; int 10 Entry Point
  8835                              <1> int_10:
  8836 00007065 FB                  <1> 	sti
  8837 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  8838 00007067 55                  <1> 	push	bp
  8839 00007068 06                  <1> 	push	es
  8840 00007069 1E                  <1> 	push	ds
  8841 0000706A 56                  <1> 	push	si
  8842 0000706B 57                  <1> 	push	di
  8843 0000706C 52                  <1> 	push	dx
  8844 0000706D 51                  <1> 	push	cx
  8845 0000706E 53                  <1> 	push	bx
  8846 0000706F 50                  <1> 	push	ax
  8847 00007070 BB4000              <1> 	mov	bx,biosdseg
  8848 00007073 8EDB                <1> 	mov	ds,bx
  8849 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  8850 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  8851 0000707C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  8852 0000707F 7202                <1> 	jb	.color			; it is CGA
  8853 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  8854                              <1> 
  8855                              <1> .color:
  8856 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  8857 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  8858 00007087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  8859 0000708A 730B                <1> 	jae	.exit			; invalid function
  8860 0000708C B700                <1> 	mov	bh,0
  8861 0000708E 88E3                <1> 	mov	bl,ah
  8862 00007090 D1E3                <1> 	shl	bx,1
  8863 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  8864                              <1> 
  8865                              <1> .exit:
  8866 00007097 58                  <1> 	pop	ax
  8867 00007098 5B                  <1> 	pop	bx
  8868 00007099 59                  <1> 	pop	cx
  8869 0000709A 5A                  <1> 	pop	dx
  8870 0000709B 5F                  <1> 	pop	di
  8871 0000709C 5E                  <1> 	pop	si
  8872 0000709D 1F                  <1> 	pop	ds
  8873 0000709E 07                  <1> 	pop	es
  8874 0000709F 5D                  <1> 	pop	bp
  8875 000070A0 CF                  <1> 	iret
  8876                              <1> 
  8877                              <1> 
  8878                              <1> ;=========================================================================
  8879                              <1> ; int_1D - Video parameters tables
  8880                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  8881                              <1> ; video mode initialization
  8882                              <1> ;-------------------------------------------------------------------------
  8883 000070A1 FF<rept>            <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  8884          ******************  <1>  warning: (setloc:7) Inserting 3 bytes
  8885                              <1> int_1D:
  8886                              <1> 	; CGA test 40x25 modes
  8887 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  8888 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8889                              <1> 
  8890                              <1> 	; CGA text 80x25 modes
  8891 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  8892 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  8893                              <1> 
  8894                              <1> 	; CGA graphics modes
  8895 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  8896 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  8897                              <1> 
  8898                              <1> 	; MDA text 80x25 mode
  8899 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  8900 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  8901                              <1> 
  8902                              <1> page_size:
  8903 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  8904 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  8905 000070E8 0040                <1> 	dw	4000h			; graphics modes
  8906 000070EA 0040                <1> 	dw	4000h
  8907                              <1> 
  8908                              <1> columns:
  8909 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  8910 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  8911 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  8912 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  8913                              <1> 
  8914 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  8915                              <1> 
  8916 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  8917                              <1> 
  8918                              <1> ;=========================================================================
  8919                              <1> ; int_10_fn00 - Set video mode
  8920                              <1> ; Input:
  8921                              <1> ;	AH = 00h
  8922                              <1> ;	AL = video mode
  8923                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  8924                              <1> ;		01h - CGA - text 40x25, 16 colors
  8925                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  8926                              <1> ;		03h - CGA - text 80x25, 16 colors
  8927                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  8928                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  8929                              <1> ;		06h - CGA - graphics 640x200, monochrome
  8930                              <1> ;		07h - MDA - text 80x25, monochrome
  8931                              <1> ;-------------------------------------------------------------------------
  8932                              <1> int_10_fn00:
  8933 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  8934 00007107 B900B8              <1> 	mov	cx,0B800h		; video memory segment for CGA
  8935 0000710A BAD403              <1> 	mov	dx,3D4h			; assume CGA mode
  8936 0000710D B000                <1> 	mov	al,0
  8937 0000710F 80FB07              <1> 	cmp	bl,07h
  8938 00007112 7206                <1> 	jb	.color			; jump if monochrome mode
  8939 00007114 B5B0                <1> 	mov	ch,0B0h			; video memory segment for MDA
  8940 00007116 B2B4                <1> 	mov	dl,0B4h 		; 3B4h - monochrome port XXX
  8941 00007118 FEC0                <1> 	inc	al
  8942                              <1> 
  8943                              <1> .color:
  8944 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  8945 0000711C 89166300            <1> 	mov	word [video_port],dx	; Save cur. CRTC display port
  8946 00007120 80C204              <1> 	add	dl,4
  8947 00007123 EE                  <1> 	out	dx,al			; Reset the video
  8948 00007124 881E4900            <1> 	mov	byte [video_mode],bl	;  ...save cur. CRTC mode
  8949 00007128 B700                <1> 	mov	bh,0
  8950 0000712A 53                  <1> 	push	bx
  8951 0000712B 06                  <1> 	push	es
  8952 0000712C 31C0                <1> 	xor	ax,ax
  8953 0000712E 8EC0                <1> 	mov	es,ax			; load interrupt table segment to ES
  8954 00007130 26C4367400          <1>     es	les	si,[1Dh*4]		; load INT 1Dh vector to ES:SI
  8955 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get bl for index into int_1D
  8956 0000713A 01DE                <1> 	add	si,bx
  8957                              <1> 
  8958 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  8959 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  8960 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  8961                              <1> 
  8962 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  8963                              <1> 
  8964                              <1> .setup_crt_loop:
  8965 00007149 268A04              <1>     es	mov	al,byte [si]		; Value to send in si
  8966 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  8967 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  8968 00007151 46                  <1> 	inc	si			;  ...point to next
  8969 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  8970 00007154 07                  <1> 	pop	es
  8971 00007155 31FF                <1> 	xor	di,di
  8972 00007157 B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  8973 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  8974 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  8975 0000715F 7208                <1> 	jb	.clear_screen		; jump if graphics mode
  8976 00007161 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  8977 00007163 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  8978                              <1> 
  8979                              <1> .text_fill:
  8980 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  8981                              <1> 
  8982                              <1> .clear_screen:
  8983 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  8984                              <1> 
  8985 0000716B 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  8986 0000716F 80C204              <1> 	add	dl,4
  8987 00007172 5B                  <1> 	pop	bx
  8988 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  8989 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  8990 00007179 A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  8991 0000717C 42                  <1> 	inc	dx
  8992 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  8993 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  8994 00007182 7502                <1> 	jnz	.set_palette
  8995 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  8996                              <1> 
  8997                              <1> .set_palette:
  8998 00007186 A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  8999 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  9000                              <1> 
  9001 0000718A 8CD8                <1> 	mov	ax,ds
  9002 0000718C 8EC0                <1> 	mov	es,ax
  9003 0000718E 31C0                <1> 	xor	ax,ax
  9004 00007190 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  9005 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  9006 00007196 BF4E00              <1> 	mov	di,video_page_offt
  9007 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  9008                              <1> 
  9009 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  9010 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  9011 000071A3 80E3FE              <1> 	and	bl,0FEh			; XXX: this cleans up LSB
  9012                              <1> 					; but it means that for mode 7
  9013                              <1> 					; we'll get graphics page size?!
  9014 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  9015 000071AB A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  9016 000071AE C3                  <1> 	ret
  9017                              <1> 
  9018                              <1> ;=========================================================================
  9019                              <1> ; int_10_fn01 - Set text-mode cursor shape
  9020                              <1> ; Input:
  9021                              <1> ;	AH = 01h
  9022                              <1> ;	CH = cursor scan line start
  9023                              <1> ;	CL = cursor scan line end
  9024                              <1> ; Output:
  9025                              <1> ;	none
  9026                              <1> ;-------------------------------------------------------------------------
  9027                              <1> int_10_fn01:
  9028 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  9029 000071B3 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  9030 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  9031 000071B8 C3                  <1> 	ret
  9032                              <1> 
  9033                              <1> ;=========================================================================
  9034                              <1> ; int_10_fn02 - Set cursor position
  9035                              <1> ; Input:
  9036                              <1> ;	AH = 02h
  9037                              <1> ;	BH = page number
  9038                              <1> ;	DH = cursor row (00h is top)
  9039                              <1> ;	DL = cursor column (00h is left)
  9040                              <1> ; Output:
  9041                              <1> ;	none
  9042                              <1> ;-------------------------------------------------------------------------
  9043                              <1> int_10_fn02:
  9044 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9045 000071BC 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  9046 000071C0 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  9047                              <1> 
  9048                              <1> ;=========================================================================
  9049                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  9050                              <1> ;	BL = page
  9051                              <1> ;	DH = cursor row (00h is top)
  9052                              <1> ;	DL = cursor column (00h is left)
  9053                              <1> ;-------------------------------------------------------------------------
  9054                              <1> set_cur_pos:
  9055 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  9056 000071C4 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  9057 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  9058 000071CB D1E8                <1> 	shr	ax,1
  9059 000071CD 89C1                <1> 	mov	cx,ax
  9060 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9061 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9062                              <1> bios_set_cur_pos:
  9063 000071D4 B700                <1> 	mov	bh,0
  9064 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  9065 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  9066 000071DB C3                  <1> 	ret
  9067                              <1> 
  9068                              <1> ;=========================================================================
  9069                              <1> ; int_10_fn03 - Get cursor position and shape
  9070                              <1> ; Input:
  9071                              <1> ;	AH = 03h
  9072                              <1> ;	BH = page number
  9073                              <1> ; Output:
  9074                              <1> ;	CH = cursor start scan line
  9075                              <1> ;	CL = cursor end scan line
  9076                              <1> ;	DH = cursor row (00h is top)
  9077                              <1> ;	DL = cursor column (00h is left)
  9078                              <1> ;-------------------------------------------------------------------------
  9079                              <1> int_10_fn03:
  9080 000071DC B700                <1> 	mov	bh,0
  9081 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9082 000071E1 D0E3                <1> 	shl	bl,1
  9083 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  9084 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  9085 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  9086 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  9087 000071EF C3                  <1> 	ret
  9088                              <1> 
  9089                              <1> ;=========================================================================
  9090                              <1> ; int_10_fn04 - Read light pen position
  9091                              <1> ; Input:
  9092                              <1> ;	AH = 04h
  9093                              <1> ; Output:
  9094                              <1> ;	AH - light pen trigger flag
  9095                              <1> ;		00h not down/triggered
  9096                              <1> ;		01h down/triggered
  9097                              <1> ;	If light pen is triggered:
  9098                              <1> ;		DH = character row
  9099                              <1> ;		DL = character column
  9100                              <1> ;		CH = pixel row
  9101                              <1> ;		BX = pixel column
  9102                              <1> ;-------------------------------------------------------------------------
  9103                              <1> int_10_fn04:
  9104 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  9105 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  9106 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  9107 000071FB EC                  <1> 	in	al,dx			; read it
  9108 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  9109 000071FE 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  9110 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  9111 00007202 7501                <1> 	jnz	.read_pen		; continue if triggered
  9112 00007204 C3                  <1> 	ret				; not triggered - return
  9113                              <1> 
  9114                              <1> .read_pen:
  9115 00007205 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  9116 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  9117 0000720B EE                  <1> 	out	dx,al			; select it
  9118 0000720C 42                  <1> 	inc	dx			; CRTC data register
  9119 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  9120 0000720E 88C4                <1> 	mov	ah,al
  9121 00007210 4A                  <1> 	dec	dx			; CRTC index register
  9122 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  9123 00007213 EE                  <1> 	out	dx,al			; select it
  9124 00007214 42                  <1> 	inc	dx			; CRTC data register
  9125 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  9126                              <1> 
  9127 00007216 B700                <1> 	mov	bh,0
  9128 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  9129 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  9130 00007221 29D8                <1> 	sub	ax,bx
  9131 00007223 7902                <1> 	jns	.1
  9132 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  9133                              <1> 
  9134                              <1> .1:
  9135 00007227 E8ED04              <1> 	call	vid_check_mode			; check video mode
  9136 0000722A 7325                <1> 	jnb	.text			; calculate character position if text
  9137 0000722C B228                <1> 	mov	dl,40			; divide by 40
  9138 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  9139 00007230 B700                <1> 	mov	bh,0
  9140 00007232 88E3                <1> 	mov	bl,ah
  9141 00007234 B103                <1> 	mov	cl,3
  9142 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  9143 00007238 88C5                <1> 	mov	ch,al
  9144 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  9145 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  9146 0000723E 88C6                <1> 	mov	dh,al
  9147 00007240 D0EE                <1> 	shr	dh,1
  9148 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  9149 00007244 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  9150 00007249 751A                <1> 	jnz	.exit
  9151 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  9152 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  9153 0000724F EB14                <1> 	jmp	.exit
  9154                              <1> 
  9155                              <1> .text:
  9156 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  9157 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  9158 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  9159 00007259 B103                <1> 	mov	cl,3
  9160 0000725B D2E4                <1> 	shl	ah,cl
  9161 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  9162 0000725F B700                <1> 	mov	bh,0
  9163 00007261 88C3                <1> 	mov	bl,al
  9164 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  9165                              <1> 
  9166                              <1> .exit:
  9167 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  9168 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  9169 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  9170 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  9171                              <1> 
  9172                              <1> .reset_pen:
  9173 00007272 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  9174 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  9175 00007279 EE                  <1> 	out	dx,al			; reset it
  9176 0000727A C3                  <1> 	ret
  9177                              <1> 
  9178                              <1> .correction:
  9179 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  9180                              <1> 
  9181                              <1> ;=========================================================================
  9182                              <1> ; int_10_fn05 - Select active display page
  9183                              <1> ; Input:
  9184                              <1> ;	AH = 05h
  9185                              <1> ;	AL - new page number (00h is the first page)
  9186                              <1> ; Output:
  9187                              <1> ;	none
  9188                              <1> ;-------------------------------------------------------------------------
  9189                              <1> int_10_fn05:
  9190 00007283 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  9191 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  9192 00007288 B400                <1> 	mov	ah,0
  9193 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  9194 0000728E A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  9195 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  9196 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  9197 00007295 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  9198 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  9199                              <1> 
  9200 0000729A B700                <1> 	mov	bh,0
  9201 0000729C D1E3                <1> 	shl	bx,1
  9202 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  9203 000072A1 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  9204 000072A4 D1E8                <1> 	shr	ax,1
  9205 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  9206 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  9207 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  9208 000072AD C3                  <1> 	ret
  9209                              <1> 
  9210                              <1> ;=========================================================================
  9211                              <1> ; int_10_fn06 - scroll up window
  9212                              <1> ; int_10_fn07 - scroll down window
  9213                              <1> ; Input:
  9214                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  9215                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  9216                              <1> ;	BH = attribute used to write blank rows at bottom of window
  9217                              <1> ;	CH,CL = row,column of window's upper left corner
  9218                              <1> ;	DH,DL = row,column of window's lower right corner
  9219                              <1> ; Output:
  9220                              <1> ;	none
  9221                              <1> ; TODO:
  9222                              <1> ;	optimize graphics fill
  9223                              <1> ;-------------------------------------------------------------------------
  9224                              <1> int_10_fn06:
  9225                              <1> int_10_fn07:
  9226 000072AE E86604              <1> 	call	vid_check_mode
  9227 000072B1 7303E9D900          <1> 	jb	.graphics_scroll
  9228                              <1> 
  9229 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  9230 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  9231 000072BD 720A                <1> 	jb	.no_snow
  9232 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  9233 000072C4 7703                <1> 	ja	.no_snow
  9234 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  9235                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  9236                              <1> .no_snow:
  9237 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9238 000072CC 50                  <1> 	push	ax
  9239 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  9240 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  9241 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9242                              <1> 
  9243                              <1> .1:
  9244 000072D6 E89804              <1> 	call	vid_position_to_offset
  9245 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  9246 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9247                              <1> 
  9248                              <1> ; calculate scroll window size (DX)
  9249                              <1> 
  9250 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9251 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  9252 000072E3 81C20101            <1> 	add	dx,101h 		; add 1x1
  9253                              <1> 
  9254                              <1> ; calculate offset between the source and the destination (AX)
  9255                              <1> 
  9256 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  9257 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  9258 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  9259 000072F0 52                  <1> 	push    dx
  9260 000072F1 B400                <1>         mov     ah,0
  9261 000072F3 F7E3                <1>         mul     bx
  9262 000072F5 5A                  <1>         pop     dx
  9263                              <1> 
  9264 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  9265 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  9266 000072FA 1E                  <1> 	push	ds
  9267 000072FB 8CC1                <1> 	mov	cx,es
  9268 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9269 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9270 00007303 7405                <1> 	jz	.2			; jump if scroll up
  9271 00007305 F7D8                <1> 	neg	ax			; negate offset
  9272 00007307 F7DB                <1> 	neg	bx			; negate distance
  9273 00007309 FD                  <1> 	std				; copy backwards
  9274                              <1> 
  9275                              <1> .2:
  9276 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  9277 0000730D 08C9                <1> 	or	cl,cl
  9278 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  9279 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  9280 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  9281 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  9282                              <1> 
  9283 00007316 09DB                <1> 	or	bx,bx
  9284 00007318 7434                <1> 	jz	.text_full_row_scroll
  9285                              <1> 
  9286                              <1> .text_scroll_loop:
  9287 0000731A B500                <1> 	mov	ch,0
  9288 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  9289                              <1> 
  9290 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  9291 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  9292 00007322 E85800              <1> 	call	.retrace_wait
  9293                              <1> 
  9294                              <1> .text_scroll_no_retrace:
  9295 00007325 F3A5                <1> 	repz	movsw			; copy one row
  9296                              <1> 
  9297                              <1> ;.text_scroll_next_row:
  9298 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  9299 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  9300 0000732B FECE                <1> 	dec	dh			; decrement row counter
  9301 0000732D 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  9302                              <1> 
  9303                              <1> .text_fill:
  9304 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  9305 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  9306                              <1> 
  9307                              <1> .text_fill_only:
  9308 00007334 B500                <1> 	mov	ch,0
  9309 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  9310 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  9311                              <1> 
  9312                              <1> .text_fill_loop:
  9313 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  9314 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  9315 0000733F 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  9316 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  9317                              <1> 
  9318                              <1> .text_fill_no_retrace:
  9319 00007344 F3AB                <1> 	repz	stosw			; fill one row
  9320 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  9321 00007348 FECE                <1> 	dec	dh			; decrement row counter
  9322 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  9323                              <1> 
  9324 0000734C 1F                  <1> 	pop	ds
  9325 0000734D C3                  <1> 	ret
  9326                              <1> 
  9327                              <1> .text_full_row_scroll:
  9328 0000734E 09C0                <1> 	or	ax,ax
  9329 00007350 741F                <1> 	jz	.text_full_row_no_snow
  9330 00007352 50                  <1> 	push	ax
  9331 00007353 88D0                <1> 	mov	al,dl
  9332 00007355 F6E6                <1> 	mul	dh
  9333                              <1> 
  9334                              <1> .text_full_row_loop:
  9335 00007357 B9F000              <1> 	mov	cx,240
  9336 0000735A 39C8                <1> 	cmp	ax,cx
  9337 0000735C 7705                <1> 	ja	.copy_chunk
  9338 0000735E 91                  <1> 	xchg	ax,cx
  9339 0000735F 31C0                <1> 	xor	ax,ax
  9340 00007361 EB02                <1> 	jmp	.do_copy
  9341                              <1> 
  9342                              <1> .copy_chunk:
  9343 00007363 29C8                <1> 	sub	ax,cx
  9344                              <1> 
  9345                              <1> .do_copy:
  9346 00007365 E81500              <1> 	call	.retrace_wait
  9347 00007368 F3A5                <1> 	rep	movsw
  9348 0000736A 09C0                <1> 	or	ax,ax
  9349 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  9350 0000736E 58                  <1> 	pop	ax
  9351 0000736F EBBE                <1> 	jmp	.text_fill
  9352                              <1> 
  9353                              <1> .text_full_row_no_snow:
  9354 00007371 50                  <1> 	push	ax
  9355 00007372 88D0                <1> 	mov	al,dl
  9356 00007374 F6E6                <1> 	mul	dh
  9357 00007376 89C1                <1> 	mov	cx,ax
  9358 00007378 F3A5                <1> 	rep	movsw
  9359 0000737A 58                  <1> 	pop	ax
  9360 0000737B EBB2                <1> 	jmp	.text_fill
  9361                              <1> 
  9362                              <1> ;-------------------------------------------------------------------------
  9363                              <1> ; .retrace_wait - next till the next vertical retrace
  9364                              <1> 
  9365                              <1> .retrace_wait:
  9366 0000737D 50                  <1> 	push	ax
  9367 0000737E 52                  <1> 	push	dx
  9368 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  9369                              <1> 
  9370                              <1> .retrace_wait_not_set:
  9371 00007382 EC                  <1> 	in	al,dx
  9372 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9373 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  9374                              <1> 
  9375                              <1> .retrace_wait_set:
  9376 00007387 EC                  <1> 	in	al,dx
  9377 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9378 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  9379 0000738C 5A                  <1> 	pop	dx
  9380 0000738D 58                  <1> 	pop	ax
  9381                              <1> 
  9382                              <1> .retrace_exit:
  9383 0000738E C3                  <1> 	ret
  9384                              <1> 
  9385                              <1> ;-------------------------------------------------------------------------
  9386                              <1> ; .graphics_scroll - scroll for graphics modes
  9387                              <1> 
  9388                              <1> .graphics_scroll:
  9389 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  9390 00007392 50                  <1> 	push	ax
  9391 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  9392 00007397 7403                <1> 	jz	.3			; jump if scroll down
  9393 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  9394                              <1> 
  9395                              <1> .3:
  9396 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  9397 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  9398                              <1> 
  9399                              <1> ; calculate scroll windows size (DX)
  9400                              <1> 
  9401 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  9402 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  9403 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  9404 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  9405 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  9406 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9407 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  9408 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  9409 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  9410 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  9411 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9412 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  9413 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  9414                              <1> 
  9415                              <1> .4:
  9416 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  9417 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  9418 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  9419                              <1> 					;   for copying backwards
  9420                              <1> 
  9421                              <1> .5:
  9422 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  9423 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  9424 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  9425 000073CF 53                  <1> 	push	bx
  9426 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  9427 000073D2 B050                <1> 	mov	al,50h
  9428 000073D4 F6E3                <1> 	mul	bl
  9429 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  9430 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  9431 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  9432 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  9433 000073E1 BB5020              <1> 	mov	bx,2050h
  9434 000073E4 FD                  <1> 	std				; copy backwards
  9435                              <1> 
  9436                              <1> .6:
  9437 000073E5 89FE                <1> 	mov	si,di
  9438 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  9439 000073E9 58                  <1> 	pop	ax
  9440 000073EA 8CC1                <1> 	mov	cx,es
  9441 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  9442 000073EE 08C0                <1> 	or	al,al
  9443 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  9444 000073F2 50                  <1> 	push	ax
  9445                              <1> 
  9446                              <1> .graphics_scroll_loop:
  9447 000073F3 B500                <1> 	mov	ch,0
  9448 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9449 000073F7 56                  <1> 	push	si
  9450 000073F8 57                  <1> 	push	di
  9451 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  9452 000073FB 5F                  <1> 	pop	di
  9453 000073FC 5E                  <1> 	pop	si
  9454 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  9455 00007401 81C70020            <1> 	add	di,2000h
  9456 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  9457 00007407 56                  <1> 	push	si
  9458 00007408 57                  <1> 	push	di
  9459 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  9460 0000740B 5F                  <1> 	pop	di
  9461 0000740C 5E                  <1> 	pop	si
  9462 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  9463 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  9464 00007411 FECE                <1> 	dec	dh			; decrement row counter
  9465 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  9466                              <1> 
  9467 00007415 58                  <1> 	pop	ax
  9468 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  9469                              <1> 
  9470                              <1> .graphics_fill:
  9471 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  9472 0000741B B500                <1> 	mov	ch,0
  9473                              <1> 
  9474                              <1> .graphics_fill_loop:
  9475 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9476 0000741F 57                  <1> 	push	di
  9477 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  9478 00007422 5F                  <1> 	pop	di
  9479 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  9480 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  9481 00007429 57                  <1> 	push	di
  9482 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  9483 0000742C 5F                  <1> 	pop	di
  9484 0000742D 29DF                <1> 	sub	di,bx
  9485 0000742F FECE                <1> 	dec	dh			; decrement row counter
  9486 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  9487 00007433 C3                  <1> 	ret
  9488                              <1> 
  9489                              <1> ;=========================================================================
  9490                              <1> ; int_10_fn08 - Read character and attribute
  9491                              <1> ; Input:
  9492                              <1> ;	AH = 08h
  9493                              <1> ; Output:
  9494                              <1> ;	AL - character read
  9495                              <1> ;	BH - video attribute (text modes only)
  9496                              <1> ; int_10_fn09 - Write character and attribute
  9497                              <1> ; Input:
  9498                              <1> ;	AH = 09h
  9499                              <1> ;	AL - character to write
  9500                              <1> ;	BH - page number
  9501                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  9502                              <1> ;	CX - number of times to write character
  9503                              <1> ; Output:
  9504                              <1> ;	none
  9505                              <1> ; int_10_fn0A - Write character only
  9506                              <1> ; Input:
  9507                              <1> ;	AH = 0Ah
  9508                              <1> ;	AL - character to write
  9509                              <1> ;	BH - page number
  9510                              <1> ;	CX - repeat count
  9511                              <1> ; Output:
  9512                              <1> ;	none
  9513                              <1> ;-------------------------------------------------------------------------
  9514                              <1> int_10_fn08:
  9515                              <1> int_10_fn09:
  9516                              <1> int_10_fn0A:
  9517 00007434 E8E002              <1> 	call	vid_check_mode
  9518 00007437 7277                <1> 	jb	.graphics		; jump if graphics mode
  9519 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  9520 0000743C B700                <1> 	mov	bh,0
  9521 0000743E 53                  <1> 	push	bx
  9522 0000743F E82803              <1> 	call	vid_current_offset
  9523 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  9524 00007444 58                  <1> 	pop	ax			; AX = page number
  9525 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  9526 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  9527 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  9528 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  9529 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  9530 00007454 1E                  <1> 	push	ds
  9531 00007455 8CC3                <1> 	mov	bx,es
  9532 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  9533 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  9534 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  9535 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  9536                              <1> 
  9537                              <1> .read_retrace_wait:
  9538 00007460 EC                  <1> 	in	al,dx
  9539 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9540 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  9541 00007465 FA                  <1> 	cli
  9542                              <1> 
  9543                              <1> .read_no_retrace_wait:
  9544 00007466 EC                  <1> 	in	al,dx
  9545 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9546 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  9547                              <1> 
  9548 0000746B AD                  <1> 	lodsw				; read character and attribute
  9549 0000746C FB                  <1> 	sti
  9550 0000746D 1F                  <1> 	pop	ds
  9551 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  9552 00007471 C3                  <1> 	ret
  9553                              <1> 
  9554                              <1> .text_write:
  9555 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  9556 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  9557 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  9558 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  9559 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  9560                              <1> 
  9561                              <1> .write_char_retrace:
  9562 0000747F EC                  <1> 	in	al,dx
  9563 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9564 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  9565                              <1> 
  9566                              <1> .write_retrace_wait1:
  9567 00007484 EC                  <1> 	in	al,dx
  9568 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9569 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  9570 00007489 FA                  <1> 	cli
  9571                              <1> 
  9572                              <1> .write_no_retrace_wait1:
  9573 0000748A EC                  <1> 	in	al,dx
  9574 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9575 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  9576                              <1> 
  9577                              <1> .do_write_char_attr:
  9578 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  9579 00007491 AB                  <1> 	stosw				; write it to video memory
  9580 00007492 FB                  <1> 	sti
  9581 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  9582 00007495 1F                  <1> 	pop	ds
  9583 00007496 C3                  <1> 	ret
  9584                              <1> 
  9585                              <1> .text_write_char_only:
  9586 00007497 EC                  <1> 	in	al,dx
  9587 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  9588 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  9589                              <1> 
  9590                              <1> .write_retrace_wait2:
  9591 0000749C EC                  <1> 	in	al,dx
  9592 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9593 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  9594 000074A1 FA                  <1> 	cli
  9595                              <1> 
  9596                              <1> .write_no_retrace_wait2:
  9597 000074A2 EC                  <1> 	in	al,dx
  9598 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  9599 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  9600                              <1> 
  9601                              <1> .do_write_char_only:
  9602 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  9603 000074A9 AA                  <1> 	stosb				; write it to video memory
  9604 000074AA FB                  <1> 	sti
  9605 000074AB 47                  <1> 	inc	di			; skip attribute
  9606 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  9607 000074AE 1F                  <1> 	pop	ds
  9608 000074AF C3                  <1> 	ret
  9609                              <1> 
  9610                              <1> .graphics:
  9611 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  9612 000074B4 7503E9B300          <1> 	jz	.graphics_read
  9613                              <1> 
  9614 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  9615 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  9616 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  9617 000074C1 1E                  <1> 	push	ds
  9618 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  9619 000074C5 B400                <1> 	mov	ah,0
  9620 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  9621 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  9622 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  9623 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  9624 000074D0 EB0C                <1> 	jmp	.CG9_03
  9625                              <1> 
  9626                              <1> .CG9_02:
  9627 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  9628 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  9629 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  9630 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  9631 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  9632                              <1> 
  9633                              <1> .CG9_03:
  9634 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  9635 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  9636 000074E1 D3E0                <1> 	shl	ax,cl
  9637 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  9638 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  9639 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  9640 000074ED 1E                  <1> 	push	ds
  9641 000074EE 8EDA                <1> 	mov	ds,dx
  9642 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  9643 000074F2 D1E7                <1> 	shl	di,1
  9644 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get char. attribute
  9645 000074F7 83E003              <1> 	and	ax,3
  9646 000074FA BB5555              <1> 	mov	bx,5555h
  9647 000074FD F7E3                <1> 	mul	bx
  9648 000074FF 89C2                <1> 	mov	dx,ax
  9649 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; XXXX - why again
  9650                              <1> 
  9651                              <1> .CG9_04:
  9652 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  9653 00007506 57                  <1> 	push	di
  9654 00007507 56                  <1> 	push	si
  9655                              <1> 
  9656                              <1> .CG9_05:
  9657 00007508 AC                  <1> 	lodsb				; Read the screen
  9658 00007509 51                  <1> 	push	cx
  9659 0000750A 53                  <1> 	push	bx
  9660 0000750B 31DB                <1> 	xor	bx,bx
  9661 0000750D B90800              <1> 	mov	cx,8
  9662                              <1> 
  9663                              <1> .CG9_06:
  9664 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  9665 00007512 D1DB                <1> 	rcr	bx,1
  9666 00007514 D1FB                <1> 	sar	bx,1
  9667 00007516 E2F8                <1> 	loop	.CG9_06
  9668                              <1> 
  9669 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  9670 0000751A 5B                  <1> 	pop	bx
  9671 0000751B 59                  <1> 	pop	cx
  9672 0000751C 21D0                <1> 	and	ax,dx
  9673 0000751E 86E0                <1> 	xchg	ah,al
  9674 00007520 08DB                <1> 	or	bl,bl
  9675 00007522 7903                <1> 	jns	.CG9_07
  9676 00007524 263305              <1>     es	xor	ax,word [di]
  9677                              <1> 
  9678                              <1> .CG9_07:
  9679 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  9680 0000752A 81F70020            <1> 	xor	di,2000h
  9681 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  9682 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  9683 00007534 83C750              <1> 	add	di,50h			; Else advance character
  9684                              <1> 
  9685                              <1> .CG9_08:
  9686 00007537 FECF                <1> 	dec	bh			; Show another char written
  9687 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  9688 0000753B 5E                  <1> 	pop	si
  9689 0000753C 5F                  <1> 	pop	di
  9690 0000753D 47                  <1> 	inc	di
  9691 0000753E 47                  <1> 	inc	di
  9692 0000753F E2C3                <1> 	loop	.CG9_04
  9693 00007541 1F                  <1> 	pop	ds
  9694 00007542 C3                  <1> 	ret
  9695                              <1> 
  9696                              <1> .CG8_02:
  9697 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  9698 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  9699                              <1> 
  9700                              <1> .CG8_03:
  9701 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  9702 0000754B 57                  <1> 	push	di
  9703 0000754C 56                  <1> 	push	si
  9704                              <1> 
  9705                              <1> .CG8_04:
  9706 0000754D AC                  <1> 	lodsb				; Read from one plane
  9707 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  9708 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  9709 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  9710                              <1> 
  9711                              <1> .CG8_05:
  9712 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  9713 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  9714 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  9715 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  9716 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  9717                              <1> 
  9718                              <1> .CG8_06:
  9719 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  9720 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  9721 00007565 5E                  <1> 	pop	si
  9722 00007566 5F                  <1> 	pop	di
  9723 00007567 47                  <1> 	inc	di
  9724 00007568 E2DF                <1> 	loop	.CG8_03
  9725 0000756A 1F                  <1> 	pop	ds
  9726 0000756B C3                  <1> 	ret
  9727                              <1> 
  9728                              <1> .graphics_read:
  9729 0000756C FC                  <1> 	cld				; Increment upwards
  9730 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  9731 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  9732 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  9733 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  9734 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  9735 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  9736 0000757F 8CC0                <1> 	mov	ax,es
  9737 00007581 1E                  <1> 	push	ds
  9738 00007582 57                  <1> 	push	di
  9739 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  9740 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  9741 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  9742 00007589 D1E6                <1> 	shl	si,1
  9743 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  9744                              <1> 
  9745                              <1> CGR_02:
  9746 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  9747 00007590 86E0                <1> 	xchg	ah,al
  9748 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  9749 00007595 B200                <1> 	mov	dl,0
  9750                              <1> 
  9751                              <1> CGR_03:
  9752 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  9753 00007599 F8                  <1> 	clc
  9754 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  9755 0000759C F9                  <1> 	stc				; Else show not set
  9756                              <1> 
  9757                              <1> CGR_04:
  9758 0000759D D0D2                <1> 	rcl	dl,1
  9759 0000759F D1E9                <1> 	shr	cx,1
  9760 000075A1 D1E9                <1> 	shr	cx,1
  9761 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  9762 000075A5 368815              <1>     ss	mov	byte [di],dl
  9763 000075A8 47                  <1> 	inc	di
  9764 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  9765 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  9766 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  9767 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  9768                              <1> 
  9769                              <1> CGR_05:
  9770 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  9771 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  9772 000075B6 EB17                <1> 	jmp	short	CGR_08
  9773                              <1> 
  9774                              <1> CGR_06:
  9775 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  9776                              <1> 
  9777                              <1> CGR_07:
  9778 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  9779 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  9780 000075BF 47                  <1> 	inc	di			;  ...advance
  9781 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  9782 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  9783 000075C7 47                  <1> 	inc	di			;  ...advance
  9784 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  9785 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  9786 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  9787                              <1> 
  9788                              <1> CGR_08:
  9789 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  9790 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  9791 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  9792 000075D6 8CD2                <1> 	mov	dx,ss
  9793 000075D8 8EDA                <1> 	mov	ds,dx
  9794 000075DA 5E                  <1> 	pop	si
  9795 000075DB B000                <1> 	mov	al,0
  9796                              <1> 
  9797                              <1> CGR_09:
  9798 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  9799                              <1> 
  9800                              <1> CGR_10:
  9801 000075E0 56                  <1> 	push	si
  9802 000075E1 57                  <1> 	push	di
  9803 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  9804 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  9805 000075E7 5F                  <1> 	pop	di
  9806 000075E8 5E                  <1> 	pop	si
  9807 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  9808 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  9809 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  9810 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  9811 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  9812                              <1> 
  9813 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  9814 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  9815 000075F7 31DB                <1> 	xor	bx,bx
  9816 000075F9 8EDB                <1> 	mov	ds,bx			; XXX - where ES is going
  9817 000075FB C43E7C00            <1> 	les	di,[7Ch]		; Else load user graphics char
  9818 000075FF 8CC3                <1> 	mov	bx,es
  9819 00007601 09FB                <1> 	or	bx,di
  9820 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  9821 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  9822                              <1> 
  9823                              <1> CGR_11:
  9824 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  9825 0000760A 1F                  <1> 	pop	ds
  9826 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  9827 0000760E C3                  <1> 	ret
  9828                              <1> 
  9829                              <1> ;=========================================================================
  9830                              <1> ; int_10_fn0B - Set background color or palette
  9831                              <1> ; Input:
  9832                              <1> ; 	AH - 0Bh
  9833                              <1> ;	BH = 00h - set background / border color
  9834                              <1> ;		BL - background (graphics modes) or border (text modes)
  9835                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  9836                              <1> ;		BL - palette ID:
  9837                              <1> ;			00h - background, green, red, and yellow (brown)
  9838                              <1> ;			01h - background, cyan, magenta, and white
  9839                              <1> ; Output:
  9840                              <1> ;	none
  9841                              <1> ;-------------------------------------------------------------------------
  9842                              <1> int_10_fn0B:
  9843 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  9844 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  9845 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  9846 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  9847                              <1> 
  9848 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  9849 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  9850 00007620 08E0                <1> 	or	al,ah			; apply new color
  9851 00007622 EB09                <1> 	jmp	.write_palet_reg
  9852                              <1> 
  9853                              <1> .set_palette:
  9854 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  9855 00007626 F6C401              <1> 	test	ah,01h
  9856 00007629 7402                <1> 	jz	.write_palet_reg
  9857 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  9858                              <1> 
  9859                              <1> .write_palet_reg:
  9860 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  9861 00007630 8B166300            <1> 	mov	dx,word [video_port]
  9862 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  9863 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  9864 00007638 C3                  <1> 	ret
  9865                              <1> 
  9866                              <1> ;=========================================================================
  9867                              <1> ; int_10_fn0C - Write graphics pixel
  9868                              <1> ; Input:
  9869                              <1> ;	AH = 0Ch
  9870                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  9871                              <1> ;	CX = column
  9872                              <1> ;	DX = row
  9873                              <1> ; Output:
  9874                              <1> ;	none
  9875                              <1> ;-------------------------------------------------------------------------
  9876                              <1> int_10_fn0C:
  9877 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  9878 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9879 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9880 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  9881 00007643 2401                <1> 	and	al,1			; one bit per pixel
  9882 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9883 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  9884 00007649 EB0F                <1> 	jmp	.prepare_mask
  9885                              <1> 
  9886                              <1> .mode_320x200:
  9887 0000764B D0E1                <1> 	shl	cl,1
  9888 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  9889 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  9890 00007652 2403                <1> 	and	al,3			; two bit per pixel
  9891 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  9892 00007656 D0C8                <1> 	ror	al,1
  9893 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  9894                              <1> 
  9895                              <1> .prepare_mask:
  9896 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  9897 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  9898 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  9899 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  9900 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  9901 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  9902 00007667 EB04                <1> 	jmp	.write_pixel
  9903                              <1> 
  9904                              <1> .set_color:
  9905 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  9906 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  9907                              <1> 
  9908                              <1> .write_pixel:
  9909 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  9910 00007670 C3                  <1> 	ret
  9911                              <1> 
  9912                              <1> ;=========================================================================
  9913                              <1> ; int_10_fn0D - Read graphics pixel
  9914                              <1> ; Input:
  9915                              <1> ;	AH = 0Dh
  9916                              <1> ;	CX = column
  9917                              <1> ;	DX = row
  9918                              <1> ; Output:
  9919                              <1> ;	AL = pixel color 
  9920                              <1> ;-------------------------------------------------------------------------
  9921                              <1> int_10_fn0D:
  9922 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  9923 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  9924 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  9925 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  9926 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  9927 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  9928 0000767F EB0A                <1> 	jmp	.exit
  9929                              <1> 
  9930                              <1> .mode_320x200:
  9931 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  9932 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  9933 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  9934 00007687 D0C0                <1> 	rol	al,1
  9935 00007689 2403                <1> 	and	al,3			; two bits per pixel
  9936                              <1> 
  9937                              <1> .exit:
  9938 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  9939 0000768E C3                  <1> 	ret
  9940                              <1> 
  9941                              <1> ;=========================================================================
  9942                              <1> ; int_10_fn0E - Teletype output
  9943                              <1> ; Input:
  9944                              <1> ;	AH = 0Eh
  9945                              <1> ;	AL = character to write
  9946                              <1> ;	BL = foreground color (graphics modes only)
  9947                              <1> ; Output:
  9948                              <1> ;	none
  9949                              <1> ; Notes:
  9950                              <1> ;	- writes character to the active video page
  9951                              <1> ;	- support following control characters: BEL, BS, LF, CR
  9952                              <1> ;-------------------------------------------------------------------------
  9953                              <1> int_10_fn0E:
  9954 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9955 00007693 B700                <1> 	mov	bh,0
  9956 00007695 D0E3                <1> 	shl	bl,1			; word index
  9957 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  9958                              <1> 
  9959 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  9960 0000769D 3C08                <1> 	cmp	al,bs
  9961 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  9962 000076A1 3C0A                <1> 	cmp	al,lf
  9963 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  9964 000076A5 3C07                <1> 	cmp	al,bel
  9965 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  9966 000076A9 3C0D                <1> 	cmp	al,cr
  9967 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  9968 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  9969 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  9970 000076B2 B90100              <1> 	mov	cx,1			; one character
  9971 000076B5 CD10                <1> 	int	10h			; write character
  9972 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  9973 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  9974 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  9975 000076BF B200                <1> 	mov	dl,0			; move to the first position
  9976                              <1> 
  9977                              <1> .lf:
  9978 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  9979 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  9980 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  9981 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  9982                              <1> 
  9983                              <1> .bs:
  9984 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  9985 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  9986 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
  9987 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  9988                              <1> 
  9989                              <1> .cr:
  9990 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  9991                              <1> 
  9992                              <1> .set_cursor_pos:
  9993 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  9994 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  9995                              <1> 
  9996                              <1> .bel:
  9997 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
  9998 000076DE E806AC              <1> 	call	beep
  9999 000076E1 C3                  <1> 	ret
 10000                              <1> 
 10001                              <1> .scroll:
 10002 000076E2 B402                <1> 	mov	ah,02h
 10003 000076E4 CD10                <1> 	int	10h			; set new cursor position
 10004 000076E6 E82E00              <1> 	call	vid_check_mode
 10005 000076E9 B700                <1> 	mov	bh,0
 10006 000076EB 7206                <1> 	jb	.do_scroll		; jump if text mode - do scroll
 10007 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
 10008 000076EF CD10                <1> 	int	10h			; read attirbute at current position
 10009 000076F1 88E7                <1> 	mov	bh,ah
 10010                              <1> 
 10011                              <1> .do_scroll:
 10012 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
 10013 000076F5 B001                <1> 	mov	al,1			; scroll one line
 10014 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
 10015 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
 10016 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
 10017 000076FF FECA                <1> 	dec	dl
 10018 00007701 CD10                <1> 	int	10h			; scroll page up
 10019 00007703 C3                  <1> 	ret
 10020                              <1> 
 10021                              <1> ;=========================================================================
 10022                              <1> ; int_10_fn0F - Get current video mode
 10023                              <1> ; Input:
 10024                              <1> ;	AH = 0Fh
 10025                              <1> ; Output:
 10026                              <1> ;	AL = video mode
 10027                              <1> ;	AH = characters per column
 10028                              <1> ;	BH = active video page
 10029                              <1> ;-------------------------------------------------------------------------
 10030                              <1> int_10_fn0F:
 10031 00007704 A04A00              <1> 	mov	al,byte [video_columns]
 10032 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
 10033 0000770A A04900              <1> 	mov	al,byte [video_mode]
 10034 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
 10035 00007710 A06200              <1> 	mov	al,byte [video_page]
 10036 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
 10037 00007716 C3                  <1> 	ret
 10038                              <1> 
 10039                              <1> ;=========================================================================
 10040                              <1> ; vid_check_mode - Check current video mode
 10041                              <1> ; Input:
 10042                              <1> ;	none
 10043                              <1> ; Output:
 10044                              <1> ;	ZF set if monochrome mode (mode 07h)
 10045                              <1> ;	CF set if graphics modes (modes 04h - 06h)
 10046                              <1> ;-------------------------------------------------------------------------
 10047                              <1> vid_check_mode:
 10048 00007717 50                  <1> 	push	ax
 10049 00007718 A04900              <1> 	mov	al,byte [video_mode]
 10050 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
 10051 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
 10052 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
 10053 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
 10054 00007722 7303                <1> 	jnb	.exit			; jump if not graphics
 10055 00007724 18C0                <1> 	sbb	al,al			; XXX - what for? clear ZF?
 10056 00007726 F9                  <1> 	stc				; XXX
 10057                              <1> 
 10058                              <1> .exit:
 10059 00007727 58                  <1> 	pop	ax
 10060 00007728 C3                  <1> 	ret
 10061                              <1> 
 10062                              <1> ;=========================================================================
 10063                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10064                              <1> ; Input:
 10065                              <1> ;	AH = register number
 10066                              <1> ;	CX = word to write
 10067                              <1> ; Output:
 10068                              <1> ;	AX trashed
 10069                              <1> ; Note:
 10070                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
 10071                              <1> ;-------------------------------------------------------------------------
 10072                              <1> vid_crtc_writew:
 10073 00007729 88E8                <1> 	mov	al,ch
 10074 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
 10075 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
 10076 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
 10077                              <1> 
 10078                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
 10079                              <1> 
 10080                              <1> ;=========================================================================
 10081                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
 10082                              <1> ; Input:
 10083                              <1> ;	AH = register number
 10084                              <1> ;	AL = byte to write
 10085                              <1> ; Output:
 10086                              <1> ;	none
 10087                              <1> ;-------------------------------------------------------------------------
 10088                              <1> vid_crtc_writeb:
 10089 00007732 52                  <1> 	push	dx
 10090 00007733 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
 10091 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
 10092 00007739 EE                  <1> 	out	dx,al			; write register number
 10093 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
 10094 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
 10095 0000773E EE                  <1> 	out	dx,al			; write byte
 10096 0000773F 5A                  <1> 	pop	dx
 10097 00007740 C3                  <1> 	ret
 10098                              <1> 
 10099                              <1> ;=========================================================================
 10100                              <1> ; vid_pixel_address - calculate pixel address and mask
 10101                              <1> ; Input:
 10102                              <1> ;	CX - column
 10103                              <1> ;	DX - row
 10104                              <1> ; Output:
 10105                              <1> ;	SI - pixel address
 10106                              <1> ;	CH - pixel mask
 10107                              <1> ;	CL - pixel position in the byte
 10108                              <1> ;	ZF - mode
 10109                              <1> ;		0 = 320x200
 10110                              <1> ;		1 = 640x200
 10111                              <1> ;-------------------------------------------------------------------------
 10112                              <1> vid_pixel_address:
 10113 00007741 31F6                <1> 	xor	si,si			; SI = 0
 10114 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
 10115 00007745 7303                <1> 	jnb	.even			; jump if on even row 
 10116 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
 10117                              <1> 
 10118                              <1> .even:
 10119 0000774A B050                <1> 	mov	al,50h			; bytes in each row
 10120 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
 10121                              <1> 
 10122 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
 10123 00007750 89CA                <1> 	mov	dx,cx			; DX - column
 10124 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
 10125 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
 10126 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
 10127 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
 10128 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
 10129                              <1> 
 10130                              <1> .1:
 10131 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
 10132 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
 10133 00007764 01D6                <1> 	add	si,dx			; add column address to SI
 10134 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
 10135 00007768 9D                  <1> 	popf
 10136 00007769 C3                  <1> 	ret
 10137                              <1> 
 10138                              <1> ;=========================================================================
 10139                              <1> ; vid_current_offset - convert current cursor position to offset
 10140                              <1> ;		       relative to page starting address
 10141                              <1> ; Input:
 10142                              <1> ;	BL = page
 10143                              <1> ; Output:
 10144                              <1> ;	AX = offset
 10145                              <1> ;-------------------------------------------------------------------------
 10146                              <1> vid_current_offset:
 10147 0000776A B700                <1> 	mov	bh,0
 10148 0000776C D1E3                <1> 	shl	bx,1				; word index
 10149 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
 10150                              <1> 
 10151                              <1> ; fall through to vid_position_to_offset
 10152                              <1> 
 10153                              <1> ;=========================================================================
 10154                              <1> ; vid_position_to_offset - convert position (row and column) to offset
 10155                              <1> ;			   relative to page starting address
 10156                              <1> ; Input:
 10157                              <1> ;	AH = row
 10158                              <1> ;	AL = column
 10159                              <1> ; Output:
 10160                              <1> ;	AX = offset
 10161                              <1> ;-------------------------------------------------------------------------
 10162                              <1> vid_position_to_offset:
 10163 00007771 53                  <1> 	push	bx
 10164 00007772 88C3                <1> 	mov	bl,al			; BL = column
 10165 00007774 88E0                <1> 	mov	al,ah			; AL = row
 10166 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10167 0000777A B700                <1> 	mov	bh,0			;
 10168 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
 10169 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
 10170 00007780 5B                  <1> 	pop	bx
 10171 00007781 C3                  <1> 	ret
 10172                              <1> 
 10173                              <1> ;=========================================================================
 10174                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
 10175                              <1> ; Input:
 10176                              <1> ;	AH = row
 10177                              <1> ;	AL = column
 10178                              <1> ; Output:
 10179                              <1> ;	AX = offset
 10180                              <1> ;-------------------------------------------------------------------------
 10181                              <1> vid_gfx_pos_to_offset:
 10182 00007782 53                  <1> 	push	bx
 10183 00007783 88C3                <1> 	mov	bl,al			; BL = column
 10184 00007785 88E0                <1> 	mov	al,ah			; AL = row
 10185 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
 10186 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
 10187 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
 10188 0000778F B700                <1> 	mov	bh,0
 10189 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
 10190 00007793 5B                  <1> 	pop	bx
 10191 00007794 C3                  <1> 	ret
 10192                                  
 10193                                  ;=========================================================================
 10194                                  ; int_12 - Get memory size
 10195                                  ; Input:
 10196                                  ;	none
 10197                                  ; Output:
 10198                                  ;	AX = memory size
 10199                                  ;-------------------------------------------------------------------------
 10200 00007795 FF<rept>                	setloc	0F841h			; INT 12 Entry Point
 10201          ******************       warning: (setloc:7) Inserting 172 bytes
 10202                                  int_12:
 10203 00007841 FB                      	sti
 10204 00007842 1E                      	push	ds
 10205 00007843 B84000                  	mov	ax,biosdseg
 10206 00007846 8ED8                    	mov	ds,ax
 10207 00007848 A11300                  	mov	ax,word [memory_size]
 10208 0000784B 1F                      	pop	ds
 10209 0000784C CF                      	iret
 10210                                  
 10211                                  ;=========================================================================
 10212                                  ; int_11 - Get equipment list
 10213                                  ; Input:
 10214                                  ;	none
 10215                                  ; Output:
 10216                                  ;	AX = equipment list
 10217                                  ;-------------------------------------------------------------------------
 10218                                  	setloc	0F84Dh			; INT 11 Entry Point
 10219                                  int_11:
 10220 0000784D FB                      	sti
 10221 0000784E 1E                      	push	ds
 10222 0000784F B84000                  	mov	ax,biosdseg
 10223 00007852 8ED8                    	mov	ds,ax
 10224 00007854 A11000                  	mov	ax,word [equipment_list]
 10225 00007857 1F                      	pop	ds
 10226 00007858 CF                      	iret
 10227                                  
 10228                                  ;=========================================================================
 10229                                  ; Includes with fixed entry points (for IBM compatibility)
 10230                                  ;-------------------------------------------------------------------------
 10231                                  
 10232                                  %include	"misc.inc"
 10233                              <1> ;=========================================================================
 10234                              <1> ; misc.inc - Miscellaneous BIOS Services
 10235                              <1> ;       INT 15h, functions:
 10236                              <1> ;       	4Fh	- OS hook keyboard intercept
 10237                              <1> ;		90h	- Device busy loop
 10238                              <1> ;		91h	- Interrupt completed
 10239                              <1> ;		0C0h	- Get system configruation
 10240                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
 10241                              <1> ;		
 10242                              <1> ;-------------------------------------------------------------------------
 10243                              <1> ;
 10244                              <1> ; Compiles with NASM 2.07, might work with other versions
 10245                              <1> ;
 10246                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10247                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10248                              <1> ;
 10249                              <1> ; This program is free software: you can redistribute it and/or modify
 10250                              <1> ; it under the terms of the GNU General Public License as published by
 10251                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10252                              <1> ; (at your option) any later version.
 10253                              <1> ;
 10254                              <1> ; This program is distributed in the hope that it will be useful,
 10255                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10256                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10257                              <1> ; GNU General Public License for more details.
 10258                              <1> ;
 10259                              <1> ; You should have received a copy of the GNU General Public License
 10260                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10261                              <1> ;
 10262                              <1> ;=========================================================================
 10263                              <1> 
 10264                              <1> ;-------------------------------------------------------------------------
 10265                              <1> ; offsets for registers on stack
 10266                              <1> int_15_bp	equ	0
 10267                              <1> int_15_ip	equ	int_15_bp+2
 10268                              <1> int_15_cs	equ	int_15_ip+2
 10269                              <1> int_15_flags	equ	int_15_cs+2
 10270                              <1> 
 10271                              <1> ;=========================================================================
 10272                              <1> ; int_15 - Miscellaneous BIOS services
 10273                              <1> ; Input:
 10274                              <1> ;	AH = 4Fh - OS hook keyboard intercept
 10275                              <1> ;		- Does nothing
 10276                              <1> ;	AH = 0C2h - PS/2 mouse services
 10277                              <1> ;		- Implemented in ps2aux.inc
 10278                              <1> ;-------------------------------------------------------------------------
 10279                              <1> 	setloc	0F859h			; INT 15 Entry Point
 10280                              <1> int_15:
 10281 00007859 FB                  <1> 	sti
 10282 0000785A 80FC4F              <1> 	cmp	ah,4Fh
 10283 0000785D 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
 10284 0000785F 80FCC0              <1> 	cmp	ah,0C0h
 10285 00007862 742E                <1> 	je	int_15_fnC0
 10286 00007864 3D0190              <1> 	cmp	ax,9001h
 10287 00007867 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
 10288 00007869 3DFD90              <1> 	cmp	ax,90FDh
 10289 0000786C 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
 10290 0000786E 3D0191              <1> 	cmp	ax,9101h
 10291 00007871 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
 10292                              <1> 
 10293                              <1> %ifdef PS2_MOUSE
 10294 00007873 80FCC2              <1> 	cmp	ah,0C2h
 10295 00007876 7503                <1> 	jne	.1
 10296 00007878 E9EFA7              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
 10297                              <1> .1:
 10298                              <1> %endif
 10299                              <1> 
 10300 0000787B B486                <1> 	mov	ah,86h			; no cassete present
 10301                              <1> 
 10302                              <1> int_15_err:
 10303 0000787D 55                  <1> 	push	bp
 10304 0000787E 89E5                <1> 	mov	bp,sp
 10305 00007880 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
 10306 00007884 5D                  <1> 	pop	bp
 10307 00007885 CF                  <1> 	iret
 10308                              <1> 
 10309                              <1> int_15_ok:
 10310 00007886 55                  <1> 	push	bp
 10311 00007887 89E5                <1> 	mov	bp,sp
 10312 00007889 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
 10313 0000788D 5D                  <1> 	pop	bp
 10314 0000788E CF                  <1> 	iret
 10315                              <1> 
 10316                              <1> int_15_os_hook:
 10317 0000788F B400                <1> 	mov	ah,00h
 10318                              <1> 
 10319                              <1> int_15_exit:
 10320 00007891 CF                  <1> 	iret
 10321                              <1> 
 10322                              <1> ;=========================================================================
 10323                              <1> ; int_15_fnC0 - Get configuration
 10324                              <1> ; Input:
 10325                              <1> ;	AH = 0C0h - get configuration
 10326                              <1> ; Output:
 10327                              <1> ;	AH = 00h - function supported
 10328                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
 10329                              <1> ;	CF = 0 (success)
 10330                              <1> ;-------------------------------------------------------------------------
 10331                              <1> int_15_fnC0:
 10332 00007892 B400                <1> 	mov	ah,00h
 10333 00007894 BB00F0              <1> 	mov	bx,bioscseg
 10334 00007897 8EC3                <1> 	mov	es,bx
 10335 00007899 BB[F566]            <1> 	mov	bx,config_table
 10336 0000789C EBE8                <1> 	jmp	int_15_ok
 10337                                  %include	"fnt00-7F.inc"
 10338                              <1> ;=========================================================================
 10339                              <1> ; fnt00-7F.inc - Font for graphics modes
 10340                              <1> ;       Characters from 00h to 7Fh
 10341                              <1> ;-------------------------------------------------------------------------
 10342                              <1> ;
 10343                              <1> ; Compiles with NASM 2.07, might work with other versions
 10344                              <1> ;
 10345                              <1> ; This font is borrowed from kbd package (alt-8x8)
 10346                              <1> ;
 10347                              <1> ; This program is free software: you can redistribute it and/or modify
 10348                              <1> ; it under the terms of the GNU General Public License as published by
 10349                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10350                              <1> ; (at your option) any later version.
 10351                              <1> ;
 10352                              <1> ; This program is distributed in the hope that it will be useful,
 10353                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10354                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10355                              <1> ; GNU General Public License for more details.
 10356                              <1> ;
 10357                              <1> ; You should have received a copy of the GNU General Public License
 10358                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10359                              <1> ;
 10360                              <1> ;=========================================================================
 10361 0000789E FF<rept>            <1> 	setloc	0FA6Eh				; IBM graphics char set entry
 10362          ******************  <1>  warning: (setloc:7) Inserting 464 bytes
 10363                              <1> gfx_font:
 10364 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
 10365 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
 10366 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
 10367 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
 10368 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
 10369 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
 10370 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
 10371 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
 10372 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
 10373 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
 10374 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
 10375 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
 10376 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
 10377 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
 10378 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
 10379 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
 10380 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
 10381 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
 10382 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
 10383 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
 10384 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
 10385 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
 10386 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
 10387 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
 10388 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
 10389 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
 10390 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
 10391 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
 10392 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
 10393 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
 10394 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
 10395 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
 10396 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
 10397 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
 10398 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
 10399 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
 10400 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
 10401 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
 10402 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
 10403 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
 10404 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
 10405 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
 10406 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
 10407 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
 10408 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
 10409 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
 10410 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
 10411 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
 10412 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
 10413 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
 10414 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
 10415 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
 10416 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
 10417 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
 10418 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
 10419 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
 10420 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
 10421 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
 10422 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
 10423 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
 10424 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
 10425 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
 10426 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
 10427 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
 10428 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
 10429 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
 10430 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
 10431 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
 10432 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
 10433 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
 10434 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
 10435 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
 10436 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
 10437 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10438 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
 10439 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
 10440 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
 10441 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
 10442 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
 10443 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
 10444 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
 10445 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
 10446 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
 10447 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
 10448 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
 10449 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
 10450 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10451 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
 10452 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
 10453 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
 10454 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
 10455 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
 10456 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
 10457 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
 10458 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
 10459 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
 10460 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
 10461 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
 10462 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
 10463 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
 10464 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
 10465 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
 10466 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
 10467 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10468 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
 10469 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
 10470 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
 10471 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
 10472 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
 10473 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
 10474 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
 10475 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
 10476 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
 10477 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
 10478 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
 10479 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
 10480 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
 10481 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
 10482 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
 10483 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
 10484 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
 10485 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
 10486 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
 10487 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
 10488 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
 10489 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
 10490 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
 10491 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
 10492                                  %include	"time2.inc"
 10493                              <1> ;=========================================================================
 10494                              <1> ; time2.int - BIOS Time Services
 10495                              <1> ;       INT 1Ah - BIOS Time Serivces
 10496                              <1> ;		dispatcher
 10497                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
 10498                              <1> ;-------------------------------------------------------------------------
 10499                              <1> ;
 10500                              <1> ; Compiles with NASM 2.07, might work with other versions
 10501                              <1> ;
 10502                              <1> ; Copyright (C) 2011 - 2012 Sergey Kiselev.
 10503                              <1> ; Provided for hobbyist use on the Xi 8088 board.
 10504                              <1> ;
 10505                              <1> ; This program is free software: you can redistribute it and/or modify
 10506                              <1> ; it under the terms of the GNU General Public License as published by
 10507                              <1> ; the Free Software Foundation, either version 3 of the License, or
 10508                              <1> ; (at your option) any later version.
 10509                              <1> ;
 10510                              <1> ; This program is distributed in the hope that it will be useful,
 10511                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10512                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10513                              <1> ; GNU General Public License for more details.
 10514                              <1> ;
 10515                              <1> ; You should have received a copy of the GNU General Public License
 10516                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
 10517                              <1> ;
 10518                              <1> ;=========================================================================
 10519                              <1> 
 10520                              <1> ;=========================================================================
 10521                              <1> ; int_1A - BIOS Time Services
 10522                              <1> ; Note: see time1.inc for functions implementation
 10523                              <1> ;-------------------------------------------------------------------------
 10524                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
 10525                              <1> int_1A:
 10526 00007E6E 53                  <1> 	push	bx
 10527 00007E6F 1E                  <1> 	push	ds
 10528 00007E70 BB4000              <1> 	mov	bx,biosdseg
 10529 00007E73 8EDB                <1> 	mov	ds,bx
 10530 00007E75 80FC08              <1> 	cmp	ah,.max/2
 10531 00007E78 731B                <1> 	jae	int_1A_exit
 10532 00007E7A B700                <1> 	mov	bh,0
 10533 00007E7C 88E3                <1> 	mov	bl,ah
 10534 00007E7E D1E3                <1> 	shl	bx,1
 10535 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
 10536                              <1> .dispatch:
 10537 00007E85 [B30E]              <1> 	dw	int_1A_fn00
 10538 00007E87 [C50E]              <1> 	dw	int_1A_fn01
 10539 00007E89 [D50E]              <1> 	dw	int_1A_fn02
 10540 00007E8B [070F]              <1> 	dw	int_1A_fn03
 10541 00007E8D [4C0F]              <1> 	dw	int_1A_fn04
 10542 00007E8F [7C0F]              <1> 	dw	int_1A_fn05
 10543 00007E91 [BB0F]              <1> 	dw	int_1A_fn06
 10544 00007E93 [0C10]              <1> 	dw	int_1A_fn07
 10545                              <1> .max	equ	$-.dispatch
 10546                              <1> int_1A_exit:
 10547 00007E95 1F                  <1> 	pop	ds
 10548 00007E96 5B                  <1> 	pop	bx
 10549 00007E97 CF                  <1> 	iret
 10550                              <1> int_1A_exitf:
 10551 00007E98 1F                  <1> 	pop	ds
 10552 00007E99 5B                  <1> 	pop	bx
 10553 00007E9A CA0200              <1> 	retf	2
 10554                              <1> 
 10555                              <1> ;=========================================================================
 10556                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
 10557                              <1> ;-------------------------------------------------------------------------
 10558 00007E9D FF<rept>            <1> 	setloc	0FEA5h			; INT 08 Entry Point
 10559          ******************  <1>  warning: (setloc:7) Inserting 8 bytes
 10560                              <1> int_08:
 10561 00007EA5 50                  <1> 	push	ax
 10562 00007EA6 1E                  <1> 	push	ds
 10563 00007EA7 B84000              <1> 	mov	ax,biosdseg
 10564 00007EAA 8ED8                <1> 	mov	ds,ax
 10565 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
 10566 00007EB1 7413                <1> 	jz	.1
 10567 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
 10568 00007EB7 750D                <1> 	jnz	.1
 10569 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
 10570 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
 10571 00007EC0 52                  <1> 	push	dx
 10572 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
 10573 00007EC4 EE                  <1> 	out	dx,al
 10574 00007EC5 5A                  <1> 	pop	dx
 10575                              <1> .1:
 10576 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
 10577 00007ECA 7504                <1> 	jnz	.2
 10578 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
 10579                              <1> .2:
 10580 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
 10581 00007ED5 751A                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
 10582 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
 10583 00007EDD 7512                <1> 	jnz	.3
 10584 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
 10585 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
 10586 00007EEB C70670000100        <1> 	mov	word [new_day],1
 10587                              <1> .3:
 10588 00007EF1 CD1C                <1> 	int	1Ch			; User timer interrupt
 10589 00007EF3 B020                <1> 	mov	al,20h
 10590 00007EF5 E620                <1> 	out	pic1_reg0,al
 10591 00007EF7 1F                  <1> 	pop	ds
 10592 00007EF8 58                  <1> 	pop	ax
 10593 00007EF9 CF                  <1> 	iret
 10594                                  
 10595                                  ;=========================================================================
 10596                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
 10597                                  ;-------------------------------------------------------------------------
 10598 00007EFA FF<rept>                	setloc	0FF23h			; Spurious IRQ Handler Entry Point
 10599          ******************       warning: (setloc:7) Inserting 41 bytes
 10600                                  int_ignore:
 10601 00007F23 50                      	push	ax
 10602 00007F24 1E                      	push	ds
 10603 00007F25 B84000                  	mov	ax,biosdseg
 10604 00007F28 8ED8                    	mov	ds,ax
 10605 00007F2A B00B                    	mov	al,0Bh			; XXX - check PIC manual?
 10606 00007F2C E620                    	out	pic1_reg0,al
 10607 00007F2E 90                      	nop
 10608 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
 10609 00007F31 88C4                    	mov	ah,al
 10610 00007F33 08C0                    	or	al,al
 10611 00007F35 7504                    	jnz	.1
 10612 00007F37 B4FF                    	mov	ah,0FFh
 10613 00007F39 EB0A                    	jmp	.2
 10614                                  .1:
 10615 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
 10616 00007F3D 08E0                    	or	al,ah
 10617 00007F3F E621                    	out	pic1_reg1,al
 10618 00007F41 B020                    	mov	al,20h			; end of interrupt
 10619 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
 10620                                  .2:
 10621 00007F45 88266B00                	mov	byte [last_irq],ah
 10622 00007F49 1F                      	pop	ds
 10623 00007F4A 58                      	pop	ax
 10624 00007F4B CF                      	iret
 10625                                  
 10626                                  ;=========================================================================
 10627                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
 10628                                  ;-------------------------------------------------------------------------
 10629 00007F4C FF<rept>                	setloc	0FF53h			; Dummy Interrupt Handler
 10630          ******************       warning: (setloc:7) Inserting 7 bytes
 10631                                  int_dummy:
 10632 00007F53 CF                      	iret
 10633                                  
 10634                                  ;=========================================================================
 10635                                  ; int_05 - BIOS Print Screen
 10636                                  ;-------------------------------------------------------------------------
 10637                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
 10638                                  int_05:
 10639 00007F54 FB                      	sti
 10640 00007F55 50                      	push	ax
 10641 00007F56 53                      	push	bx
 10642 00007F57 51                      	push	cx
 10643 00007F58 52                      	push	dx
 10644 00007F59 1E                      	push	ds
 10645 00007F5A B84000                  	mov	ax,biosdseg
 10646 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
 10647 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
 10648 00007F64 746A                    	je	.exit			; print screen is already in progress
 10649 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
 10650                                  					; signal that print screen is running
 10651                                  
 10652 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
 10653 00007F6D CD10                    	int	10h			; returns number of columns in AH
 10654                                  					; and active display page in BH
 10655 00007F6F 88E1                    	mov	cl,ah			; store number columns
 10656                                  
 10657 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
 10658 00007F75 08ED                    	or	ch,ch
 10659 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
 10660                                  
 10661 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
 10662 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
 10663 00007F7E 7602                    	jbe	.get_cursor_pos
 10664                                  
 10665                                  .wrong_num_rows:
 10666 00007F80 B519                    	mov	ch,25			; assume 25 rows
 10667                                  
 10668                                  .get_cursor_pos:
 10669 00007F82 B403                    	mov	ah,03h			; get cursor position and size
 10670 00007F84 CD10                    	int	10h			; returns cursor position in DX
 10671 00007F86 52                      	push	dx			; save original position / DX in stack
 10672                                  
 10673                                  	
 10674 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
 10675 00007F89 E85100                  	call	.print_char
 10676 00007F8C 7548                    	jnz	.error
 10677 00007F8E B40A                    	mov	ah,0Ah
 10678 00007F90 E84A00                  	call	.print_char
 10679 00007F93 7541                    	jnz	.error
 10680                                  
 10681 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
 10682                                  
 10683                                  .row_loop:
 10684 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
 10685                                  
 10686                                  .column_loop:
 10687 00007F99 B402                    	mov	ah,02h
 10688 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
 10689                                  
 10690 00007F9D B408                    	mov	ah,08h
 10691 00007F9F CD10                    	int	10h			; read character at cursor position
 10692                                  
 10693 00007FA1 3C20                    	cmp	al,20h			; control character?
 10694 00007FA3 7302                    	jae	.continue		; no, print it
 10695 00007FA5 B020                    	mov	al,20h			; print space instead
 10696                                  
 10697                                  .continue:
 10698 00007FA7 E83300                  	call	.print_char
 10699 00007FAA 752A                    	jnz	.error
 10700 00007FAC FEC2                    	inc	dl
 10701 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
 10702 00007FB0 72E7                    	jb	.column_loop		; print next column
 10703                                  
 10704 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
 10705 00007FB4 E82600                  	call	.print_char
 10706 00007FB7 751D                    	jnz	.error
 10707 00007FB9 B40A                    	mov	ah,0Ah
 10708 00007FBB E81F00                  	call	.print_char
 10709 00007FBE 7516                    	jnz	.error
 10710                                  
 10711 00007FC0 FEC6                    	inc	dh
 10712 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
 10713 00007FC4 72D1                    	jb	.row_loop		; print next row
 10714                                  
 10715 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
 10716                                  					; ready for the next call
 10717                                  
 10718                                  .restore_cursor:
 10719 00007FCB 5A                      	pop	dx			; DX = original cursor position
 10720 00007FCC B402                    	mov	ah,02h
 10721 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
 10722                                  
 10723                                  .exit:
 10724 00007FD0 1F                      	pop	ds
 10725 00007FD1 5A                      	pop	dx
 10726 00007FD2 59                      	pop	cx
 10727 00007FD3 5B                      	pop	bx
 10728 00007FD4 58                      	pop	ax
 10729 00007FD5 CF                      	iret
 10730                                  
 10731                                  .error:
 10732 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
 10733                                  					; signal failure
 10734 00007FDB EBEE                    	jmp	.restore_cursor
 10735                                  	
 10736                                  
 10737                                  .print_char:
 10738 00007FDD 52                      	push	dx
 10739 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
 10740 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
 10741 00007FE2 CD17                    	int	17h
 10742 00007FE4 5A                      	pop	dx
 10743 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
 10744 00007FE8 C3                      	ret
 10745                                  
 10746                                  ;=========================================================================
 10747                                  ; start - at power up or reset execution starts here (F000:FFF0)
 10748                                  ;-------------------------------------------------------------------------
 10749 00007FE9 FF<rept>                        setloc	0FFF0h			; Power-On Entry Point
 10750          ******************       warning: (setloc:7) Inserting 7 bytes
 10751                                  start:
 10752 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
 10753                                  
 10754                                  	setloc	0FFF5h			; ROM Date in ASCII
 10755 00007FF5 31302F32342F3136        	db	DATE			; BIOS release date MM/DD/YY
 10756 00007FFD 20                      	db	20h
 10757                                  
 10758                                  	setloc	0FFFEh			; System Model
 10759                                  %ifdef AT_COMPAT
 10760 00007FFE FC                      	db	0fch			; system is an IBM AT compatible
 10761                                  %else
 10762                                  	db	0feh			; system is an IBM PC/XT compatible
 10763                                  %endif ; AT_COMPAT
 10764 00007FFF FF                      	db	0ffh
